<?xml version="1.0" encoding="utf-8"?><testsuites name="pytest tests"><testsuite name="pytest" errors="0" failures="1" skipped="0" tests="38" time="748.843" timestamp="2025-08-15T19:53:06.327882+08:00" hostname="Mac-Studio.local"><testcase classname="test.test_AnalogCramerRao" name="test_HCRB_NHB" time="0.105" /><testcase classname="test.test_AnalogCramerRao" name="test_HCRB_NHB_invalid_input" time="0.000" /><testcase classname="test.test_AnalogCramerRao" name="test_HCRB_print" time="0.002" /><testcase classname="test.test_BayesCramerRao" name="test_bayesian_bound" time="135.818" /><testcase classname="test.test_BayesCramerRao" name="test_bcfim_bqcfim_multiparameter" time="202.074"><failure message="juliacall.JuliaError: MethodError: no method matching pyjliter_next(::Nothing)&#10;The function `pyjliter_next` exists, but no method is defined for this combination of argument types.&#10;&#10;Closest candidates are:&#10;  pyjliter_next(!Matched::PythonCall.JlWrap.Iterator)&#10;   @ PythonCall ~/.julia/packages/PythonCall/avYrV/src/JlWrap/iter.jl:10&#10;&#10;Stacktrace:&#10; [1] _pyjl_callmethod(f::Any, self_::Ptr{PythonCall.C.PyObject}, args_::Ptr{PythonCall.C.PyObject}, nargs::Int64)&#10;   @ PythonCall.JlWrap ~/.julia/packages/PythonCall/avYrV/src/JlWrap/base.jl:62&#10; [2] _pyjl_callmethod(o::Ptr{PythonCall.C.PyObject}, args::Ptr{PythonCall.C.PyObject})&#10;   @ PythonCall.JlWrap.Cjl ~/.julia/packages/PythonCall/avYrV/src/JlWrap/C.jl:63">def test_bcfim_bqcfim_multiparameter() -&gt; None:
        """
        Test function for BCFIM and BQFIM.
    
        This function tests:
        - Bayesian classical Fisher information in multiparameter scenario
        - Bayesian quantum Fisher information in multiparameter scenario
        """
        # Initial state
        rho0 = 0.5 * np.array([[1.0, 1.0], [1.0, 1.0]])
    
        # Free Hamiltonian parameters
        b_val = 0.5 * np.pi
        sigma_x = np.array([[0.0, 1.0], [1.0, 0.0]])
        sigma_z = np.array([[1.0, 0.0], [0.0, -1.0]])
    
        # Hamiltonian function
        hamiltonian_func = lambda omega0, x: 0.5 * b_val * omega0 * (
            sigma_x * np.cos(x) + sigma_z * np.sin(x)
        )
    
        # Derivative of Hamiltonian (return 2x2 matrices, not 1x2x2 arrays)
        d_hamiltonian_func = lambda omega0, x: [
            0.5 * b_val * (sigma_x * np.cos(x) + sigma_z * np.sin(x)),
            0.5 * b_val * omega0 * (-sigma_x * np.sin(x) + sigma_z * np.cos(x))
        ]
    
        # Prior distribution parameters
        x_values = np.linspace(-0.5 * np.pi, 0.5 * np.pi, 100)
        omega0_values = np.linspace(1, 2, 100)
        all_parameter_values = [omega0_values, x_values]
    
        # Joint probability density function (Gaussian for both parameters)
        mu_omega0, mu_x = 1.5, 0.0
        eta_omega0, eta_x = 0.2, 0.2
        prob_density = lambda omega0, x: (
            np.exp(-(omega0 - mu_omega0)**2 / (2 * eta_omega0**2)) / (eta_omega0 * np.sqrt(2 * np.pi))
            * np.exp(-(x - mu_x)**2 / (2 * eta_x**2)) / (eta_x * np.sqrt(2 * np.pi))
        )
    
        # Generate probability values
        prob_values_unnormalized = np.zeros((len(omega0_values), len(x_values)))
        for i in range(len(omega0_values)):
            for j in range(len(x_values)):
                prob_values_unnormalized[i, j] = prob_density(omega0_values[i], x_values[j])
    
        # Normalize the distribution
        integral_x = np.zeros(len(omega0_values))
        for i in range(len(omega0_values)):
            integral_x[i] = simpson(prob_values_unnormalized[i, :], x_values)
        norm_factor = simpson(integral_x, omega0_values)
        prob_normalized = prob_values_unnormalized / norm_factor
    
        # Time evolution parameters
        time_span = np.linspace(0.0, 1.0, 50)
    
        # Prepare arrays for states and derivatives
        final_states = []
        d_final_states = []
    
        # Evolve the system for each parameter combination
        for i in range(len(omega0_values)):
            row_rho = []
            row_drho = []
    
            for j in range(len(x_values)):
                hamiltonian = hamiltonian_func(omega0_values[i], x_values[j])
                d_hamiltonian = d_hamiltonian_func(omega0_values[i], x_values[j])
    
                dynamics = Lindblad(time_span, rho0, hamiltonian, d_hamiltonian)
&gt;               states, d_states = dynamics.expm()
                                   ^^^^^^^^^^^^^^^

test/test_BayesCramerRao.py:206: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
quanestimation/Parameterization/GeneralDynamics.py:149: in expm
    drho = [[np.array(drho_ij) for drho_ij in drho_i] for drho_i in drho]
                                              ^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Julia: nothing

    def __next__(self):
&gt;       return self._jl_callmethod($(pyjl_methodnum(pyjliter_next)))
               ^^^^^^^^^^^^^^^^^^^^^^^
E       juliacall.JuliaError: MethodError: no method matching pyjliter_next(::Nothing)
E       The function `pyjliter_next` exists, but no method is defined for this combination of argument types.
E       
E       Closest candidates are:
E         pyjliter_next(!Matched::PythonCall.JlWrap.Iterator)
E          @ PythonCall ~/.julia/packages/PythonCall/avYrV/src/JlWrap/iter.jl:10
E       
E       Stacktrace:
E        [1] _pyjl_callmethod(f::Any, self_::Ptr{PythonCall.C.PyObject}, args_::Ptr{PythonCall.C.PyObject}, nargs::Int64)
E          @ PythonCall.JlWrap ~/.julia/packages/PythonCall/avYrV/src/JlWrap/base.jl:62
E        [2] _pyjl_callmethod(o::Ptr{PythonCall.C.PyObject}, args::Ptr{PythonCall.C.PyObject})
E          @ PythonCall.JlWrap.Cjl ~/.julia/packages/PythonCall/avYrV/src/JlWrap/C.jl:63

/Users/liujing/.julia/packages/PythonCall/avYrV/src/JlWrap/iter.jl:39: JuliaError</failure></testcase><testcase classname="test.test_BayesEstimation" name="test_Bayes" time="251.420" /><testcase classname="test.test_Common" name="test_basis" time="0.000" /><testcase classname="test.test_Common" name="test_gramschmidt" time="0.000" /><testcase classname="test.test_Common" name="test_suN_generator" time="0.005" /><testcase classname="test.test_Common" name="test_mat_vec_convert" time="0.000" /><testcase classname="test.test_Common" name="test_SIC" time="0.001" /><testcase classname="test.test_Common" name="test_annihilation" time="0.000" /><testcase classname="test.test_Common" name="test_brgd" time="0.000" /><testcase classname="test.test_Common" name="test_BayesInput" time="0.000" /><testcase classname="test.test_Common" name="test_extract_ele" time="0.000" /><testcase classname="test.test_Common" name="test_fidelity" time="0.000" /><testcase classname="test.test_CramerRao" name="test_CramerRao_SLD" time="0.000" /><testcase classname="test.test_CramerRao" name="test_CFIM_singleparameter" time="0.000" /><testcase classname="test.test_CramerRao" name="test_QFIM_Kraus" time="0.001" /><testcase classname="test.test_CramerRao" name="test_QFIM_Bloch" time="0.002" /><testcase classname="test.test_CramerRao" name="test_QFIM_Bloch_pure" time="0.001" /><testcase classname="test.test_CramerRao" name="test_QFIM_Bloch_highdimension" time="0.003" /><testcase classname="test.test_CramerRao" name="test_QFIM_Gauss_multiparameter" time="0.001" /><testcase classname="test.test_CramerRao" name="test_QFIM_Gauss_singleparameter" time="0.001" /><testcase classname="test.test_CramerRao" name="test_QFIM_LLD_singleparameter" time="0.000" /><testcase classname="test.test_CramerRao" name="test_QFIM_RLD_singleparameter" time="0.000" /><testcase classname="test.test_CramerRao" name="test_FIM_singleparameter" time="0.000" /><testcase classname="test.test_CramerRao" name="test_FIM_multiparameter" time="0.000" /><testcase classname="test.test_CramerRao" name="test_FI_Expt" time="0.120" /><testcase classname="test.test_CramerRao" name="test_invalid_input" time="0.000" /><testcase classname="test.test_Parameterization" name="test_Kraus" time="0.000" /><testcase classname="test.test_Parameterization" name="test_Lindblad" time="8.392" /><testcase classname="test.test_Resource" name="test_SpinSqueezing_Dicke" time="0.000" /><testcase classname="test.test_Resource" name="test_SpinSqueezing_Pauli" time="0.000" /><testcase classname="test.test_Resource" name="test_SpinSqueezing_nomean" time="0.000" /><testcase classname="test.test_Resource" name="test_TargetTime" time="5.633" /><testcase classname="test.test_Resource" name="test_TargetTime_no_crossing" time="0.002" /><testcase classname="test.test_ZivZakai" name="test_ZivZakai" time="129.405" /></testsuite></testsuites>