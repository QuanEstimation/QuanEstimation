{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the QuanEstimation \u00b6 QuanEstimation is a Python-Julia based open-source toolkit for quantum parameter estimation which covers the calculation of the quantum metrological tools and quantum resources, the optimization of the probe state, control and measurement in quantum metrology. Futhermore, QuanEstimation can also perform comprehensive optimization of the probe state, control and measurement to generate optimal quantum parameter estimation schemes, and generate adaptive measurement schemes. The package structure of QuanEstimation can be seen in the following figure The package structure of QuanEstimation. The blue boxes, white boxes with blue edges, white boxes with orange boxes and gray boxes are folders, files, classes and functions in Python. The gray boxes with dotted orange boundaries represents the methods that solved in Julia. The package contains several well-used metrological tools, such as quantum (classical) Cram\u00e9r-Rao bounds, Hevolo Cram\u00e9r-Rao bound and Bayesian versions of quantum (classical) Cram\u00e9r-Rao bounds, quantum Ziv-Zakai bound, and Bayesian estimation. The users can use these bounds as the objective functions to optimize the probe state, control, measurement and simultaneous optimizations among them. The optimization methods include the gradient-based algorithms such as the gradient ascent pulse engineering (GRAPE), GRAPE algorithm based on the automatic differentiation (auto-GRAPE), automatic differentiation (AD) and the gradient-free algorithms such as particle swarm optimization (PSO), differential evolution (DE), deep deterministic policy gradients (DDPG) and reverse iterative (RI) algorithm. The interface of QuanEstimation is written in Python, but the most calculation processes are executed in Julia for the computational efficiency. Therefore, QuanEstimation also has a full Julia version apart from the Python-Julia version.","title":"Home"},{"location":"#welcome-to-the-quanestimation","text":"QuanEstimation is a Python-Julia based open-source toolkit for quantum parameter estimation which covers the calculation of the quantum metrological tools and quantum resources, the optimization of the probe state, control and measurement in quantum metrology. Futhermore, QuanEstimation can also perform comprehensive optimization of the probe state, control and measurement to generate optimal quantum parameter estimation schemes, and generate adaptive measurement schemes. The package structure of QuanEstimation can be seen in the following figure The package structure of QuanEstimation. The blue boxes, white boxes with blue edges, white boxes with orange boxes and gray boxes are folders, files, classes and functions in Python. The gray boxes with dotted orange boundaries represents the methods that solved in Julia. The package contains several well-used metrological tools, such as quantum (classical) Cram\u00e9r-Rao bounds, Hevolo Cram\u00e9r-Rao bound and Bayesian versions of quantum (classical) Cram\u00e9r-Rao bounds, quantum Ziv-Zakai bound, and Bayesian estimation. The users can use these bounds as the objective functions to optimize the probe state, control, measurement and simultaneous optimizations among them. The optimization methods include the gradient-based algorithms such as the gradient ascent pulse engineering (GRAPE), GRAPE algorithm based on the automatic differentiation (auto-GRAPE), automatic differentiation (AD) and the gradient-free algorithms such as particle swarm optimization (PSO), differential evolution (DE), deep deterministic policy gradients (DDPG) and reverse iterative (RI) algorithm. The interface of QuanEstimation is written in Python, but the most calculation processes are executed in Julia for the computational efficiency. Therefore, QuanEstimation also has a full Julia version apart from the Python-Julia version.","title":"Welcome to the QuanEstimation"},{"location":"citing/","text":"Citing QuanEstimation \u00b6 If you use QuanEstimation in your research, please cite the following paper: [1] M. Zhang, H.-M. Yu, H. Yuan, X. Wang, R. Demkowicz-Dobrza\u0144ski, and J. Liu, QuanEstimation: an open-source toolkit for quantum parameter estimation, arXiv:2205.15588 .","title":"Citing"},{"location":"citing/#citing-quanestimation","text":"If you use QuanEstimation in your research, please cite the following paper: [1] M. Zhang, H.-M. Yu, H. Yuan, X. Wang, R. Demkowicz-Dobrza\u0144ski, and J. Liu, QuanEstimation: an open-source toolkit for quantum parameter estimation, arXiv:2205.15588 .","title":"Citing QuanEstimation"},{"location":"developers/","text":"Developers \u00b6 Jing Liu \u00b6 Huazhong University of Science and Technology Email: liujingphys@hust.edu.cn Biography: Jing Liu is currently an associate professor in the National Precise Gravity Measurement Facility, Huazhong University of Science and Technology. His main research interests focus on the topics in quantum metrology, quantum control, quantum information theory, and foundations of quantum mechanics, especially the design of high-precision measurement schemes using the features of quantum mechanics. Rafa\u0142 Demkowicz-Dobrza\u0144ski \u00b6 University of Warsaw Email: Rafal.Demkowicz-Dobrzanski@fuw.edu.pl Biography: Rafa\u0142 Demkowicz-Dobrza\u0144ski is an associate professor at the Faculty of Physics, University of Warsaw. He is a theorist actively working in the field of quantum metrology, who developed methods to identify fundamental limits in quantum metrology in presence of decoherence. Mao Zhang \u00b6 Huazhong University of Science and Technology Email: zhangmao2018@hust.edu.cn Biography: Ms. Zhang is currently a Ph.D. student in the National Precise Gravity Measurement Facility, School of Physics, Huazhong University of Science and Technology. Her research focuses on the quantum metrology and quantum control, especially the design of control enhanced quantum metrological schemes. Huai-Ming Yu \u00b6 Huazhong University of Science and Technology Email: 2021612226@hust.edu.cn Biography: Advisors \u00b6 Haidong Yuan \u00b6 The Chinese University of Hong Kong Biography: Haidong Yuan is an associate professor at the Department of Mechanical and Automation Engineering, The Chinese University of Hong Kong. Xiaoguang Wang \u00b6 Zhejiang University Biography: Xiaoguang Wang is a professor at the Department of Physics, Zhejiang University.","title":"Developers"},{"location":"developers/#developers","text":"","title":"Developers"},{"location":"developers/#jing-liu","text":"Huazhong University of Science and Technology Email: liujingphys@hust.edu.cn Biography: Jing Liu is currently an associate professor in the National Precise Gravity Measurement Facility, Huazhong University of Science and Technology. His main research interests focus on the topics in quantum metrology, quantum control, quantum information theory, and foundations of quantum mechanics, especially the design of high-precision measurement schemes using the features of quantum mechanics.","title":"Jing Liu"},{"location":"developers/#rafa-demkowicz-dobrzanski","text":"University of Warsaw Email: Rafal.Demkowicz-Dobrzanski@fuw.edu.pl Biography: Rafa\u0142 Demkowicz-Dobrza\u0144ski is an associate professor at the Faculty of Physics, University of Warsaw. He is a theorist actively working in the field of quantum metrology, who developed methods to identify fundamental limits in quantum metrology in presence of decoherence.","title":"Rafa\u0142 Demkowicz-Dobrza\u0144ski"},{"location":"developers/#mao-zhang","text":"Huazhong University of Science and Technology Email: zhangmao2018@hust.edu.cn Biography: Ms. Zhang is currently a Ph.D. student in the National Precise Gravity Measurement Facility, School of Physics, Huazhong University of Science and Technology. Her research focuses on the quantum metrology and quantum control, especially the design of control enhanced quantum metrological schemes.","title":"Mao Zhang"},{"location":"developers/#huai-ming-yu","text":"Huazhong University of Science and Technology Email: 2021612226@hust.edu.cn Biography:","title":"Huai-Ming Yu"},{"location":"developers/#advisors","text":"","title":"Advisors"},{"location":"developers/#haidong-yuan","text":"The Chinese University of Hong Kong Biography: Haidong Yuan is an associate professor at the Department of Mechanical and Automation Engineering, The Chinese University of Hong Kong.","title":"Haidong Yuan"},{"location":"developers/#xiaoguang-wang","text":"Zhejiang University Biography: Xiaoguang Wang is a professor at the Department of Physics, Zhejiang University.","title":"Xiaoguang Wang"},{"location":"examples/","text":"Examples \u00b6 Calculation of CFI and QFI \u00b6 The example is discussed in Example 3.1 and Example 3.4 in quantum metrological tools. CramerRao_bounds.ipynb CramerRao_bounds.jl Calculation of CFIM, QFIM and HCRB \u00b6 The example is discussed in detail in Example 3.7 in quantum metrological tools. Holevo_CramerRao_bound.ipynb Holevo_CramerRao_bound.jl Calculation of Bayesian Cram\u00e9r-Rao bounds \u00b6 The example is discussed in detail in Example 3.8 in quantum metrological tools. Bayesian_CramerRao_bounds.ipynb Bayesian_CramerRao_bounds.jl Bayesian estimation \u00b6 The example is discussed in detail in Example 3.9 in quantum metrological tools. Bayesian_estimation.ipynb Bayesian_estimation.jl Control optimization in single qubit system (single parameter) \u00b6 The example is discussed in detail in Example 5.1 in control optimization. control_optimization_NV.ipynb control_optimization_NV.jl Control optimization in NV center (multiparameter) \u00b6 The example is discussed in detail in Example 5.2 in control optimization. control_optimization_qubit.ipynb control_optimization_qubit.jl State optimization in LMG model (single parameter) \u00b6 The example is discussed in detail in Example 6.1 in state optimization. state_optimization_LMG1.ipynb state_optimization_LMG1.jl State optimization in LMG model (multiparameter) \u00b6 The example is discussed in detail in Example 6.2 in state optimization. state_optimization_LMG2.ipynb state_optimization_LMG2.jl Measurement optimization in single qubit system (single parameter) \u00b6 The example is discussed in detail in Example 7.2 in measurement optimization. measurement_optimization_qubit.ipynb measurement_optimization_qubit.jl Measurement optimization in NV center (multiparameter) \u00b6 The example is discussed in detail in Example 7.3 in measurement optimization. measurement_optimization_NV.ipynb measurement_optimization_NV.jl Comprehensive optimization in single qubit system (single parameter) \u00b6 The example is discussed in detail in Example 8.1 in comprehensive optimization. comprehensive_optimization_qubit.ipynb comprehensive_optimization_qubit.jl Comprehensive optimization in NV center (multiparameter) \u00b6 The example is discussed in detail in Example 8.2 in comprehensive optimization. comprehensive_optimization_NV.ipynb comprehensive_optimization_NV.jl","title":"Examples"},{"location":"examples/#examples","text":"","title":"Examples"},{"location":"examples/#calculation-of-cfi-and-qfi","text":"The example is discussed in Example 3.1 and Example 3.4 in quantum metrological tools. CramerRao_bounds.ipynb CramerRao_bounds.jl","title":"Calculation of CFI and QFI"},{"location":"examples/#calculation-of-cfim-qfim-and-hcrb","text":"The example is discussed in detail in Example 3.7 in quantum metrological tools. Holevo_CramerRao_bound.ipynb Holevo_CramerRao_bound.jl","title":"Calculation of CFIM, QFIM and HCRB"},{"location":"examples/#calculation-of-bayesian-cramer-rao-bounds","text":"The example is discussed in detail in Example 3.8 in quantum metrological tools. Bayesian_CramerRao_bounds.ipynb Bayesian_CramerRao_bounds.jl","title":"Calculation of Bayesian Cram\u00e9r-Rao bounds"},{"location":"examples/#bayesian-estimation","text":"The example is discussed in detail in Example 3.9 in quantum metrological tools. Bayesian_estimation.ipynb Bayesian_estimation.jl","title":"Bayesian estimation"},{"location":"examples/#control-optimization-in-single-qubit-system-single-parameter","text":"The example is discussed in detail in Example 5.1 in control optimization. control_optimization_NV.ipynb control_optimization_NV.jl","title":"Control optimization in single qubit system (single parameter)"},{"location":"examples/#control-optimization-in-nv-center-multiparameter","text":"The example is discussed in detail in Example 5.2 in control optimization. control_optimization_qubit.ipynb control_optimization_qubit.jl","title":"Control optimization in NV center (multiparameter)"},{"location":"examples/#state-optimization-in-lmg-model-single-parameter","text":"The example is discussed in detail in Example 6.1 in state optimization. state_optimization_LMG1.ipynb state_optimization_LMG1.jl","title":"State optimization in LMG model (single parameter)"},{"location":"examples/#state-optimization-in-lmg-model-multiparameter","text":"The example is discussed in detail in Example 6.2 in state optimization. state_optimization_LMG2.ipynb state_optimization_LMG2.jl","title":"State optimization in LMG model (multiparameter)"},{"location":"examples/#measurement-optimization-in-single-qubit-system-single-parameter","text":"The example is discussed in detail in Example 7.2 in measurement optimization. measurement_optimization_qubit.ipynb measurement_optimization_qubit.jl","title":"Measurement optimization in single qubit system (single parameter)"},{"location":"examples/#measurement-optimization-in-nv-center-multiparameter","text":"The example is discussed in detail in Example 7.3 in measurement optimization. measurement_optimization_NV.ipynb measurement_optimization_NV.jl","title":"Measurement optimization in NV center (multiparameter)"},{"location":"examples/#comprehensive-optimization-in-single-qubit-system-single-parameter","text":"The example is discussed in detail in Example 8.1 in comprehensive optimization. comprehensive_optimization_qubit.ipynb comprehensive_optimization_qubit.jl","title":"Comprehensive optimization in single qubit system (single parameter)"},{"location":"examples/#comprehensive-optimization-in-nv-center-multiparameter","text":"The example is discussed in detail in Example 8.2 in comprehensive optimization. comprehensive_optimization_NV.ipynb comprehensive_optimization_NV.jl","title":"Comprehensive optimization in NV center (multiparameter)"},{"location":"installation/","text":"Installation \u00b6 Run the command in the terminal to install QuanEstimation: Python pip install quanestimation The users can also run git clone https://github.com/QuanEstimation/QuanEstimation.git to install the latest development version of QuanEstimation from Github. Julia import Pkg Pkg . add ( \"QuanEstimation\" ) If the users want to install the package via a Julia mirror, please click here for usage. Requirements \u00b6 QuanEstimation requires several open-source packages in Python and Julia. The versions of Python and Julia should be above 3.6 and 1.7, respectively. Python packages \u00b6 \\(~~~~~~~~~~~\\) Package \\(~~~~~~~\\) Version numpy >=1.22 sympy >=1.10 scipy >=1.8 cvxpy >=1.2 more_itertools >=8.12.0 Julia packages \u00b6 \\(~~~~~~~~~~~~~~~~\\) Package \\(~~~~~~~~~~~~\\) Version \\(~~~~~~~~~~~~~~~~\\) Package \\(~~~~~~~~~~~~\\) Version LinearAlgebra -- BoundaryValueDiffEq 2.7.2 Zygote 0.6.37 SCS 0.8.1 Convex 0.14.18 Trapz 2.0.3 ReinforcementLearning 0.10.0 Interpolations 0.13.5 IntervalSets 0.5.4 SparseArrays -- Flux 0.12.4 DelimitedFiles -- StatsBase 0.33.16 Random -- Printf -- StableRNGs -- The version information of the packages without the version number is the same with the corresponding packages in Julia 1.7. Besides, the version information of the full Julia package is also the same as the table above. All of these packages will be automatically installed when the users install QuanEstimation.","title":"Installation"},{"location":"installation/#installation","text":"Run the command in the terminal to install QuanEstimation: Python pip install quanestimation The users can also run git clone https://github.com/QuanEstimation/QuanEstimation.git to install the latest development version of QuanEstimation from Github. Julia import Pkg Pkg . add ( \"QuanEstimation\" ) If the users want to install the package via a Julia mirror, please click here for usage.","title":"Installation"},{"location":"installation/#requirements","text":"QuanEstimation requires several open-source packages in Python and Julia. The versions of Python and Julia should be above 3.6 and 1.7, respectively.","title":"Requirements"},{"location":"installation/#python-packages","text":"\\(~~~~~~~~~~~\\) Package \\(~~~~~~~\\) Version numpy >=1.22 sympy >=1.10 scipy >=1.8 cvxpy >=1.2 more_itertools >=8.12.0","title":"Python packages"},{"location":"installation/#julia-packages","text":"\\(~~~~~~~~~~~~~~~~\\) Package \\(~~~~~~~~~~~~\\) Version \\(~~~~~~~~~~~~~~~~\\) Package \\(~~~~~~~~~~~~\\) Version LinearAlgebra -- BoundaryValueDiffEq 2.7.2 Zygote 0.6.37 SCS 0.8.1 Convex 0.14.18 Trapz 2.0.3 ReinforcementLearning 0.10.0 Interpolations 0.13.5 IntervalSets 0.5.4 SparseArrays -- Flux 0.12.4 DelimitedFiles -- StatsBase 0.33.16 Random -- Printf -- StableRNGs -- The version information of the packages without the version number is the same with the corresponding packages in Julia 1.7. Besides, the version information of the full Julia package is also the same as the table above. All of these packages will be automatically installed when the users install QuanEstimation.","title":"Julia packages"},{"location":"API/julia/api/","text":"This part contains the methods and structs in Julia that are called by the Python-Julia packagea and the full Julia package. QuanEstimation.AD \u2014 Method . \u00b6 AD (; max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 , Adam :: Bool = true ) Optimization algorithm: AD. max_episode : The number of episodes. epsilon : Learning rate. beta1 : The exponential decay rate for the first moment estimates. beta2 : The exponential decay rate for the second moment estimates. Adam : Whether or not to use Adam for updating control coefficients. source QuanEstimation.CFIM_obj \u2014 Method . \u00b6 CFIM_obj (; M = missing , W = missing , eps = GLOBAL_EPS ) Choose CFI [ \\(\\mathrm{Tr}(WI^{-1})\\) ] as the objective function with \\(W\\) the weight matrix and \\(I\\) the CFIM. M : A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). W : Weight matrix. eps : Machine epsilon. source QuanEstimation.CMopt \u2014 Type . \u00b6 CMopt ( ctrl = missing , M = missing , ctrl_bound = [ - Inf , Inf ], seed = 1234 ) Control and measurement optimization. ctrl : Guessed control coefficients. M : Guessed projective measurement (a set of basis) ctrl_bound : Lower and upper bounds of the control coefficients. seed : Random seed. source QuanEstimation.ControlOpt \u2014 Method . \u00b6 ControlOpt ( ctrl = missing , ctrl_bound = [ - Inf , Inf ], seed = 1234 ) Control optimization. ctrl : Guessed control coefficients. ctrl_bound : Lower and upper bounds of the control coefficients. seed : Random seed. source QuanEstimation.DDPG \u2014 Method . \u00b6 DDPG (; max_episode :: Int = 500 , layer_num :: Int = 3 , layer_dim :: Int = 200 , seed :: Number = 1234 ) Optimization algorithm: DE. max_episode : The number of populations. layer_num : The number of layers (include the input and output layer). layer_dim : The number of neurons in the hidden layer. seed : Random seed. source QuanEstimation.DE \u2014 Method . \u00b6 DE (; max_episode :: Number = 1000 , p_num :: Number = 10 , ini_population = missing , c :: Number = 1.0 , cr :: Number = 0.5 , seed :: Number = 1234 ) Optimization algorithm: DE. max_episode : The number of populations. p_num : The number of particles. ini_population : Initial guesses of the optimization variables. c : Mutation constant. cr : Crossover constant. source QuanEstimation.GRAPE \u2014 Method . \u00b6 GRAPE (; max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 , Adam :: Bool = true ) Control optimization algorithm: GRAPE. max_episode : The number of episodes. epsilon : Learning rate. beta1 : The exponential decay rate for the first moment estimates. beta2 : The exponential decay rate for the second moment estimates. Adam : Whether or not to use Adam for updating control coefficients. source QuanEstimation.HCRB_obj \u2014 Method . \u00b6 HCRB_obj (; W = missing , eps = GLOBAL_EPS ) Choose HCRB as the objective function. W : Weight matrix. eps : Machine epsilon. source QuanEstimation.Kraus \u2014 Method . \u00b6 Kraus ( \u03c10 :: AbstractMatrix , K :: AbstractVector , dK :: AbstractVector ) The parameterization of a state is \\(\\rho=\\sum_i K_i\\rho_0K_i^{\\dagger}\\) with \\(\\rho\\) the evolved density matrix and \\(K_i\\) the Kraus operator. \u03c10 : Initial state (density matrix). K : Kraus operators. dK : Derivatives of the Kraus operators with respect to the unknown parameters to be estimated. For example, dK[0] is the derivative vector on the first parameter. source QuanEstimation.Kraus \u2014 Method . \u00b6 Kraus ( \u03c80 :: AbstractMatrix , K :: AbstractVector , dK :: AbstractVector ) The parameterization of a state is \\(\\psi\\rangle=\\sum_i K_i|\\psi_0\\rangle\\) with \\(\\psi\\) the evolved state and \\(K_i\\) the Kraus operator. \u03c80 : Initial state (ket). K : Kraus operators. dK : Derivatives of the Kraus operators with respect to the unknown parameters to be estimated. For example, dK[0] is the derivative vector on the first parameter. source QuanEstimation.Kraus \u2014 Method . \u00b6 Kraus ( opt :: AbstractMopt , \u03c1\u2080 :: AbstractMatrix , K , dK ; eps = GLOBAL_EPS ) Initialize the parameterization described by the Kraus operators for the measurement optimization. source QuanEstimation.Kraus \u2014 Method . \u00b6 Kraus ( opt :: CompOpt , K , dK ; eps = GLOBAL_EPS ) Initialize the parameterization described by the Kraus operators for the comprehensive optimization. source QuanEstimation.LLD \u2014 Method . \u00b6 LLD ( \u03c1 :: Matrix { T }, d\u03c1 :: Vector { Matrix { T }}; rep = \"original\" , eps = GLOBAL_EPS ) where { T <: Complex } Calculate the left logarrithmic derivatives (LLDs). The LLD operator is defined as \\(\\partial_{a}\\rho=\\mathcal{R}_a^{\\dagger}\\rho\\) , where \u03c1 is the parameterized density matrix. \u03c1 : Density matrix. d\u03c1 : Derivatives of the density matrix with respect to the unknown parameters to be estimated. For example, drho[1] is the derivative vector with respect to the first parameter. rep : Representation of the LLD operator. Options can be: \"original\" (default) and \"eigen\". eps : Machine epsilon. source QuanEstimation.LLD \u2014 Method . \u00b6 LLD ( \u03c1 :: Matrix { T }, d\u03c1 :: Matrix { T }; rep = \"original\" , eps = GLOBAL_EPS ) where { T <: Complex } When applied to the case of single parameter. source QuanEstimation.Lindblad \u2014 Method . \u00b6 Lindblad ( opt :: AbstractMopt , tspan , \u03c1\u2080 , H0 , dH ; Hc = missing , ctrl = missing , decay = missing , eps = GLOBAL_EPS ) Initialize the parameterization described by the Lindblad master equation governed dynamics for the measurement optimization. source QuanEstimation.Lindblad \u2014 Method . \u00b6 Lindblad ( opt :: ControlMeasurementOpt , tspan , \u03c1\u2080 , H0 , dH , Hc ; decay = missing , eps = GLOBAL_EPS ) Initialize the parameterization described by the Lindblad master equation governed dynamics for the comprehensive optimization on control and measurement. source QuanEstimation.Lindblad \u2014 Method . \u00b6 Lindblad ( opt :: ControlOpt , tspan , \u03c1\u2080 , H0 , dH , Hc ; decay = missing , eps = GLOBAL_EPS ) Initialize the parameterization described by the Lindblad master equation governed dynamics for the control optimization. source QuanEstimation.Lindblad \u2014 Method . \u00b6 Lindblad ( opt :: StateControlMeasurementOpt , tspan , H0 , dH , Hc ; decay = missing , eps = GLOBAL_EPS ) Initialize the parameterization described by the Lindblad master equation governed dynamics for the comprehensive optimization on state, control and measurement. source QuanEstimation.Lindblad \u2014 Method . \u00b6 Lindblad ( opt :: StateControlOpt , tspan , H0 , dH , Hc ; decay = missing , eps = GLOBAL_EPS ) Initialize the parameterization described by the Lindblad master equation governed dynamics for the comprehensive optimization on state and control. source QuanEstimation.Lindblad \u2014 Method . \u00b6 Lindblad ( opt :: StateMeasurementOpt , tspan , H0 , dH ; Hc = missing , ctrl = missing , decay = missing ) Initialize the parameterization described by the Lindblad master equation governed dynamics for the comprehensive optimization on state and measurement. source QuanEstimation.Lindblad \u2014 Method . \u00b6 Lindblad ( opt :: StateOpt , tspan , H0 , dH ; Hc = missing , ctrl = missing , decay = missing , eps = GLOBAL_EPS ) Initialize the parameterization described by the Lindblad master equation governed dynamics for the state optimization. source QuanEstimation.NM \u2014 Method . \u00b6 NM (; max_episode :: Int = 1000 , p_num :: Int = 10 , nelder_mead = missing , ar :: Number = 1.0 , ae :: Number = 2.0 , ac :: Number = 0.5 , as0 :: Number = 0.5 , seed :: Number = 1234 ) State optimization algorithm: NM. max_episode : The number of populations. p_num : The number of the input states. nelder_mead : Initial guesses of the optimization variables. ar : Reflection constant. ae : Expansion constant. ac : Constraction constant. as0 : Shrink constant. source QuanEstimation.PSO \u2014 Method . \u00b6 PSO (; max_episode :: Union { T , Vector { T }} where { T <: Int } = [ 1000 , 100 ], p_num :: Number = 10 , ini_particle = missing , c0 :: Number = 1.0 , c1 :: Number = 2.0 , c2 :: Number = 2.0 , seed :: Number = 1234 ) Optimization algorithm: PSO. max_episode : The number of episodes, it accepts both integer and array with two elements. p_num : The number of particles. ini_particle : Initial guesses of the optimization variables. c0 : The damping factor that assists convergence, also known as inertia weight. c1 : The exploitation weight that attracts the particle to its best previous position, also known as cognitive learning factor. c2 : The exploitation weight that attracts the particle to the best position in the neighborhood, also known as social learning factor. source QuanEstimation.QFIM_obj \u2014 Method . \u00b6 QFIM_obj (; W = missing , eps = GLOBAL_EPS , LDtype :: Symbol = :SLD ) Choose QFI [ \\(\\mathrm{Tr}(WF^{-1})\\) ] as the objective function with \\(W\\) the weight matrix and \\(F\\) the QFIM. W : Weight matrix. eps : Machine epsilon. LDtype : Types of QFI (QFIM) can be set as the objective function. Options are :SLD (default), :RLD and :LLD . source QuanEstimation.RI \u2014 Method . \u00b6 RI (; max_episode :: Int = 300 , seed :: Number = 1234 ) State optimization algorithm: reverse iterative. max_episode : The number of episodes. source QuanEstimation.RLD \u2014 Method . \u00b6 RLD ( \u03c1 :: Matrix { T }, d\u03c1 :: Vector { Matrix { T }}; rep = \"original\" , eps = GLOBAL_EPS ) where { T <: Complex } Calculate the right logarrithmic derivatives (RLDs). The RLD operator is defined as \\(\\partial_{a}\\rho=\\rho \\mathcal{R}_a\\) , where \\(\\rho\\) is the parameterized density matrix. \u03c1 : Density matrix. d\u03c1 : Derivatives of the density matrix with respect to the unknown parameters to be estimated. For example, drho[1] is the derivative vector with respect to the first parameter. rep : Representation of the RLD operator. Options can be: \"original\" (default) and \"eigen\". eps : Machine epsilon. source QuanEstimation.RLD \u2014 Method . \u00b6 RLD ( \u03c1 :: Matrix { T }, d\u03c1 :: Matrix { T }; rep = \"original\" , eps = GLOBAL_EPS ) where { T <: Complex } When applied to the case of single parameter. source QuanEstimation.SCMopt \u2014 Type . \u00b6 SCMopt ( psi = missing , ctrl = missing , M = missing , ctrl_bound = [ - Inf , Inf ], seed = 1234 ) State, control and measurement optimization. psi : Guessed probe state. ctrl : Guessed control coefficients. M : Guessed projective measurement (a set of basis). ctrl_bound : Lower and upper bounds of the control coefficients. seed : Random seed. source QuanEstimation.SCopt \u2014 Type . \u00b6 SCopt ( psi = missing , ctrl = missing , ctrl_bound = [ - Inf , Inf ], seed = 1234 ) State and control optimization. psi : Guessed probe state. ctrl : Guessed control coefficients. ctrl_bound : Lower and upper bounds of the control coefficients. seed : Random seed. source QuanEstimation.SLD \u2014 Method . \u00b6 SLD ( \u03c1 :: Matrix { T }, d\u03c1 :: Vector { Matrix { T }}; rep = \"original\" , eps = GLOBAL_EPS ) where { T <: Complex } Calculate the symmetric logarrithmic derivatives (SLDs). The SLD operator \\(L_a\\) is defined as \\(\\partial_{a}\\rho=\\frac{1}{2}(\\rho L_{a}+L_{a}\\rho)\\) , where \\(\\rho\\) is the parameterized density matrix. \u03c1 : Density matrix. d\u03c1 : Derivatives of the density matrix with respect to the unknown parameters to be estimated. For example, drho[1] is the derivative vector with respect to the first parameter. rep : Representation of the SLD operator. Options can be: \"original\" (default) and \"eigen\" . eps : Machine epsilon. source QuanEstimation.SLD \u2014 Method . \u00b6 SLD ( \u03c1 :: Matrix { T }, d\u03c1 :: Matrix { T }; rep = \"original\" , eps = GLOBAL_EPS ) where { T <: Complex } When applied to the case of single parameter. source QuanEstimation.SMopt \u2014 Type . \u00b6 SMopt ( psi = missing , M = missing , seed = 1234 ) State and control optimization. psi : Guessed probe state. M : Guessed projective measurement (a set of basis). seed : Random seed. source QuanEstimation.StateOpt \u2014 Method . \u00b6 StateOpt ( psi = missing , seed = 1234 ) State optimization. psi : Guessed probe state. seed : Random seed. source QuanEstimation.autoGRAPE \u2014 Method . \u00b6 autoGRAPE (; max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 , Adam :: Bool = true ) Control optimization algorithm: auto-GRAPE. max_episode : The number of episodes. epsilon : Learning rate. beta1 : The exponential decay rate for the first moment estimates. beta2 : The exponential decay rate for the second moment estimates. Adam : Whether or not to use Adam for updating control coefficients. source QuanEstimation.Adaptive \u2014 Method . \u00b6 Adaptive ( x :: AbstractVector , p , rho0 :: AbstractMatrix , tspan , H , dH ; savefile = false , max_episode :: Int = 1000 , eps :: Float64 = 1e-8 , Hc = missing , ctrl = missing , decay = missing , M = missing , W = missing ) In QuanEstimation, the Hamiltonian of the adaptive system should be written as \\(H(\\textbf{x}+\\textbf{u})\\) with \\(\\textbf{x}\\) the unknown parameters and \\(\\textbf{u}\\) the tunable parameters. The tunable parameters \\(\\textbf{u}\\) are used to let the Hamiltonian work at the optimal point \\(\\textbf{x}_{\\mathrm{opt}}\\) . x : The regimes of the parameters for the integral. p : The prior distribution. rho0 : Density matrix. tspan : The experimental results obtained in practice. H : Free Hamiltonian with respect to the values in x. dH : Derivatives of the free Hamiltonian with respect to the unknown parameters to be estimated. savefile : Whether or not to save all the posterior distributions. max_episode : The number of episodes. eps : Machine epsilon. Hc : Control Hamiltonians. ctrl : Control coefficients. decay : Decay operators and the corresponding decay rates. M : A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). W : Whether or not to save all the posterior distributions. source QuanEstimation.Adaptive \u2014 Method . \u00b6 Adaptive ( x :: AbstractVector , p , rho0 :: AbstractMatrix , K , dK ; savefile = false , max_episode :: Int = 1000 , eps :: Float64 = 1e-8 , M = missing , W = missing ) In QuanEstimation, the Hamiltonian of the adaptive system should be written as \\(H(\\textbf{x}+\\textbf{u})\\) with \\(\\textbf{x}\\) the unknown parameters and \\(\\textbf{u}\\) the tunable parameters. The tunable parameters \\(\\textbf{u}\\) are used to let the Hamiltonian work at the optimal point \\(\\textbf{x}_{\\mathrm{opt}}\\) . x : The regimes of the parameters for the integral. p : The prior distribution. rho0 : Density matrix. K : Kraus operator(s) with respect to the values in x. dK : Derivatives of the Kraus operator(s) with respect to the unknown parameters to be estimated. savefile : Whether or not to save all the posterior distributions. max_episode : The number of episodes. eps : Machine epsilon. M : A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). W : Whether or not to save all the posterior distributions. source QuanEstimation.BCB \u2014 Method . \u00b6 BCB ( x , p , rho ; W = missing , eps = GLOBAL_EPS ) Calculation of the minimum Bayesian cost with a quadratic cost function. x : The regimes of the parameters for the integral. p : The prior distribution. rho : Parameterized density matrix. W : Weight matrix. eps : Machine epsilon. source QuanEstimation.BCFIM \u2014 Method . \u00b6 BCFIM ( x :: AbstractVector , p , rho , drho ; M = missing , eps = GLOBAL_EPS ) Calculation of the Bayesian classical Fisher information (BCFI) and the Bayesian classical Fisher information matrix (BCFIM) of the form \\(\\mathcal{I}_{\\mathrm{Bayes}}=\\int p(\\textbf{x})\\mathcal{I}\\mathrm{d}\\textbf{x}\\) with \\(\\mathcal{I}\\) the CFIM and \\(p(\\textbf{x})\\) the prior distribution. x : The regimes of the parameters for the integral. p : The prior distribution. rho : Parameterized density matrix. drho : Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated. M : A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). eps : Machine epsilon. source QuanEstimation.BCRB \u2014 Method . \u00b6 BCRB ( x :: AbstractVector , p , dp , rho , drho ; M = missing , b = missing , db = missing , btype = 1 , eps = GLOBAL_EPS ) Calculation of the Bayesian Cramer-Rao bound (BCRB). x : The regimes of the parameters for the integral. p : The prior distribution. dp : Derivatives of the prior distribution with respect to the unknown parameters to be estimated. For example, dp[0] is the derivative vector on the first parameter. rho : Parameterized density matrix. drho : Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated. M : A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). b : Vector of biases of the form \\(\\textbf{b}=(b(x_0),b(x_1),\\dots)^{\\mathrm{T}}\\) . db : Derivatives of b on the unknown parameters to be estimated, It should be expressed as \\(\\textbf{b}'=(\\partial_0 b(x_0),\\partial_1 b(x_1),\\dots)^{\\mathrm{T}}\\) . btype : Types of the BCRB. Options are 1, 2 and 3. eps : Machine epsilon. source QuanEstimation.BQCRB \u2014 Method . \u00b6 BQCRB ( x :: AbstractVector , p , dp , rho , drho ; b = missing , db = missing , LDtype = :SLD , btype = 1 , eps = GLOBAL_EPS ) Calculation of the Bayesian quantum Cramer-Rao bound (BQCRB). x : The regimes of the parameters for the integral. p : The prior distribution. dp : Derivatives of the prior distribution with respect to the unknown parameters to be estimated. For example, dp[0] is the derivative vector on the first parameter. rho : Parameterized density matrix. drho : Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated. b : Vector of biases of the form \\(\\textbf{b}=(b(x_0),b(x_1),\\dots)^{\\mathrm{T}}\\) . db : Derivatives of b on the unknown parameters to be estimated, It should be expressed as \\(\\textbf{b}'=(\\partial_0 b(x_0),\\partial_1 b(x_1),\\dots)^{\\mathrm{T}}\\) . LDtype : Types of QFI (QFIM) can be set as the objective function. Options are \"SLD\" (default), \"RLD\" and \"LLD\". btype : Types of the BCRB. Options are 1, 2 and 3. eps : Machine epsilon. source QuanEstimation.BQFIM \u2014 Method . \u00b6 BQFIM ( x :: AbstractVector , p , rho , drho ; LDtype = :SLD , eps = GLOBAL_EPS ) Calculation of the Bayesian quantum Fisher information (BQFI) and the Bayesian quantum Fisher information matrix (BQFIM) of the form \\(\\mathcal{F}_{\\mathrm{Bayes}}=\\int p(\\textbf{x})\\mathcal{F}\\mathrm{d}\\textbf{x}\\) with \\(\\mathcal{F}\\) the QFIM of all types and \\(p(\\textbf{x})\\) the prior distribution. x : The regimes of the parameters for the integral. p : The prior distribution. rho : Parameterized density matrix. drho : Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated. LDtype : Types of QFI (QFIM) can be set as the objective function. Options are \"SLD\" (default), \"RLD\" and \"LLD\". eps : Machine epsilon. source QuanEstimation.Bayes \u2014 Method . \u00b6 Bayes ( x , p , rho , y ; M = missing , savefile = false ) Bayesian estimation. The prior distribution is updated via the posterior distribution obtained by the Bayes\u2019 rule and the estimated value of parameters obtained via the maximum a posteriori probability (MAP). x : The regimes of the parameters for the integral. p : The prior distribution. rho : Parameterized density matrix. y : The experimental results obtained in practice. M : A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). savefile : Whether or not to save all the posterior distributions. source QuanEstimation.BayesCost \u2014 Method . \u00b6 BayesCost ( x , p , xest , rho , M ; W = missing , eps = GLOBAL_EPS ) Calculation of the average Bayesian cost with a quadratic cost function. x : The regimes of the parameters for the integral. p : The prior distribution. xest : The estimators. rho : Parameterized density matrix. M : A set of POVM. W : Weight matrix. eps : Machine epsilon. source QuanEstimation.CFIM \u2014 Method . \u00b6 CFIM ( \u03c1 :: Matrix { T }, d\u03c1 :: Vector { Matrix { T }}, M ; eps = GLOBAL_EPS ) where { T <: Complex } Calculate the classical Fisher information matrix (CFIM). \u03c1 : Density matrix. d\u03c1 : Derivatives of the density matrix with respect to the unknown parameters to be estimated. For example, drho[1] is the derivative vector with respect to the first parameter. M : A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). eps : Machine epsilon. source QuanEstimation.CFIM \u2014 Method . \u00b6 CFIM ( \u03c1 :: Matrix { T }, d\u03c1 :: Vector { Matrix { T }}; M = nothing , eps = GLOBAL_EPS ) where { T <: Complex } When the set of POVM is not given. Calculate the CFIM with SIC-POVM. The SIC-POVM is generated from the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from here . source QuanEstimation.CFIM \u2014 Method . \u00b6 CFIM ( \u03c1 :: Matrix { T }, d\u03c1 :: Matrix { T }, M ; eps = GLOBAL_EPS ) where { T <: Complex } When applied to the case of single parameter. Calculate the classical Fisher information (CFI). source QuanEstimation.CFIM \u2014 Method . \u00b6 CFIM ( \u03c1 :: Matrix { T }, d\u03c1 :: Matrix { T }; eps = GLOBAL_EPS ) where { T <: Complex } When applied to the case of single parameter and the set of POVM is not given. Calculate the CFI with SIC-POVM. source QuanEstimation.FIM \u2014 Method . \u00b6 FIM ( p :: Vector { R }, dp :: Vector { R }; eps = GLOBAL_EPS ) where { R <: Real } Calculation of the classical Fisher information matrix for classical scenarios. p : The probability distribution. dp : Derivatives of the probability distribution on the unknown parameters to be estimated. For example, dp[0] is the derivative vector on the first parameter. eps : Machine epsilon. source QuanEstimation.FIM \u2014 Method . \u00b6 FIM ( p :: Vector { R }, dp :: Vector { R }; eps = GLOBAL_EPS ) where { R <: Real } When applied to the case of single parameter and the set of POVM is not given. Calculate the classical Fisher information for classical scenarios. source QuanEstimation.HCRB \u2014 Method . \u00b6 HCRB ( \u03c1 :: AbstractMatrix , d\u03c1 :: AbstractVector , C :: AbstractMatrix ; eps = GLOBAL_EPS ) Caltulate the Holevo Cramer-Rao bound (HCRB) via the semidefinite program (SDP). \u03c1 : Density matrix. d\u03c1 : Derivatives of the density matrix on the unknown parameters to be estimated. For example, drho[0] is the derivative vector on the first parameter. W : Weight matrix. eps : Machine epsilon. source QuanEstimation.MLE \u2014 Method . \u00b6 MLE ( x , rho , y ; M = missing , savefile = false ) Bayesian estimation. The estimated value of parameters obtained via the maximum likelihood estimation (MLE). x : The regimes of the parameters for the integral. rho : Parameterized density matrix. y : The experimental results obtained in practice. M : A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). savefile : Whether or not to save all the posterior distributions. source QuanEstimation.MeasurementOpt \u2014 Method . \u00b6 MeasurementOpt ( mtype = :Projection , kwargs ... ) Measurement optimization. mtype : The type of scenarios for the measurement optimization. Options are :Projection (default), :LC and :Rotation . kwargs... : keywords and the correponding default vaules. mtype=:Projection , mtype=:LC and mtype=:Rotation , the kwargs... are M=missing , B=missing, POVM_basis=missing , and s=missing, POVM_basis=missing , respectively. source QuanEstimation.OBB \u2014 Method . \u00b6 OBB ( x :: AbstractVector , p , dp , rho , drho , d2rho ; LDtype = :SLD , eps = GLOBAL_EPS ) Calculation of the Bayesian version of Cramer-Rao bound introduced by Van Trees (VTB). x : The regimes of the parameters for the integral. p : The prior distribution. dp : Derivatives of the prior distribution with respect to the unknown parameters to be estimated. For example, dp[0] is the derivative vector on the first parameter. rho : Parameterized density matrix. drho : Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated. d2rho : Second order Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated. LDtype : Types of QFI (QFIM) can be set as the objective function. Options are \"SLD\" (default), \"RLD\" and \"LLD\". eps : Machine epsilon. source QuanEstimation.QFIM \u2014 Method . \u00b6 QFIM ( \u03c1 :: Matrix { T }, d\u03c1 :: Vector { Matrix { T }}; LDtype = :SLD , exportLD :: Bool = false , eps = GLOBAL_EPS ) where { T <: Complex } When applied to the case of single parameter. Calculation of the quantum Fisher information (QFI) for all types. source QuanEstimation.QFIM \u2014 Method . \u00b6 QFIM ( \u03c1 :: Matrix { T }, d\u03c1 :: Matrix { T }; LDtype = :SLD , exportLD :: Bool = false , eps = GLOBAL_EPS ) where { T <: Complex } Calculation of the quantum Fisher information (QFI) for all types. \u03c1 : Density matrix. d\u03c1 : Derivatives of the density matrix with respect to the unknown parameters to be estimated. For example, drho[1] is the derivative vector with respect to the first parameter. LDtype : Types of QFI (QFIM) can be set as the objective function. Options are :SLD (default), :RLD and :LLD . exportLD : export logarithmic derivatives apart from F. eps : Machine epsilon. source QuanEstimation.QFIM_Gauss \u2014 Method . \u00b6 QFIM_Gauss ( R\u0304 :: V , dR\u0304 :: VV , D :: M , dD :: VM ) where { V , VV , M , VM <: AbstractVecOrMat } Calculate the SLD based quantum Fisher information matrix (QFIM) with gaussian states. R\u0304 : First-order moment. dR\u0304 : Derivatives of the first-order moment with respect to the unknown parameters to be estimated. For example, dR[1] is the derivative vector on the first parameter. D : Second-order moment. dD : Derivatives of the second-order moment with respect to the unknown parameters to be estimated. eps : Machine epsilon. source QuanEstimation.QFIM_Kraus \u2014 Method . \u00b6 QFIM_Kraus ( \u03c10 :: AbstractMatrix , K :: AbstractVector , dK :: AbstractVector ; LDtype = :SLD , exportLD :: Bool = false , eps = GLOBAL_EPS ) Calculation of the quantum Fisher information (QFI) and quantum Fisher information matrix (QFIM) with Kraus operator(s) for all types. \u03c10 : Density matrix. K : Kraus operator(s). dK : Derivatives of the Kraus operator(s) on the unknown parameters to be estimated. For example, dK[0] is the derivative vector on the first parameter. LDtype : Types of QFI (QFIM) can be set as the objective function. Options are :SLD (default), :RLD and :LLD . exportLD : Whether or not to export the values of logarithmic derivatives. If set True then the the values of logarithmic derivatives will be exported. eps : Machine epsilon. source QuanEstimation.QVTB \u2014 Method . \u00b6 QVTB ( x :: AbstractVector , p , dp , rho , drho ; LDtype = :SLD , eps = GLOBAL_EPS ) Calculation of the Bayesian version of Cramer-Rao bound in troduced by Van Trees (VTB). x : The regimes of the parameters for the integral. p : The prior distribution. dp : Derivatives of the prior distribution with respect to the unknown parameters to be estimated. For example, dp[0] is the derivative vector on the first parameter. rho : Parameterized density matrix. drho : Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated. LDtype : Types of QFI (QFIM) can be set as the objective function. Options are \"SLD\" (default), \"RLD\" and \"LLD\". eps : Machine epsilon. source QuanEstimation.QZZB \u2014 Method . \u00b6 QZZB ( x :: AbstractVector , p :: AbstractVector , rho :: AbstractVecOrMat ; eps = GLOBAL_EPS ) Calculation of the quantum Ziv-Zakai bound (QZZB). x : The regimes of the parameters for the integral. p : The prior distribution. rho : Parameterized density matrix. eps : Machine epsilon. source QuanEstimation.SIC \u2014 Method . \u00b6 SIC ( dim :: Int64 ) Generation of a set of rank-one symmetric informationally complete positive operator-valued measure (SIC-POVM). dim : The dimension of the system. Note: SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from here . source QuanEstimation.SpinSqueezing \u2014 Method . \u00b6 SpinSqueezing ( \u03c1 :: AbstractMatrix ; basis = \"Dicke\" , output = \"KU\" ) Calculate the spin squeezing parameter for the input density matrix. The basis can be \"Dicke\" for the Dicke basis, or \"Pauli\" for the Pauli basis. The output can be both \"KU\" (for spin squeezing defined by Kitagawa and Ueda) and \"WBIMH\" (for spin squeezing defined by Wineland et al.). source QuanEstimation.TargetTime \u2014 Method . \u00b6 TargetTime ( f :: Number , tspan :: AbstractVector , func :: Function , args ... ; kwargs ... ) Calculate the minimum time to reach a precision limit of given level. The func can be any objective function during the control optimization, e.g. QFIM, CFIM, HCRB, etc. source QuanEstimation.VTB \u2014 Method . \u00b6 VTB ( x :: AbstractVector , p , dp , rho , drho ; M = missing , eps = GLOBAL_EPS ) Calculation of the Bayesian version of Cramer-Rao bound introduced by Van Trees (VTB). x : The regimes of the parameters for the integral. p : The prior distribution. dp : Derivatives of the prior distribution with respect to the unknown parameters to be estimated. For example, dp[0] is the derivative vector on the first parameter. rho : Parameterized density matrix. drho : Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated. M : A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). eps : Machine epsilon. source QuanEstimation.evolve \u2014 Method . \u00b6 evolve ( dynamics :: Kraus { dm }) Evolution of density matrix under time-independent Hamiltonian without noise and controls. source QuanEstimation.evolve \u2014 Method . \u00b6 evolve ( dynamics :: Kraus { ket }) Evolution of pure states under time-independent Hamiltonian without noise and controls source QuanEstimation.expm \u2014 Function . \u00b6 expm(tspan::AbstractVector, \u03c10::AbstractMatrix, H0::AbstractMatrix, dH::AbstractVector, decay::Union{AbstractVector, Missing}=missing, Hc::Union{AbstractVector, Missing}=missing, ctrl::Union{AbstractVector, Missing}=missing) The dynamics of a density matrix is of the form \\(\\partial_t\\rho=-i[H,\\rho]+\\sum_i \\gamma_i\\left(\\Gamma_i\\rho\\Gamma^{\\dagger}_i-\\frac{1}{2}\\left\\{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\right\\}\\right)\\) , where \\(\\rho\\) is the evolved density matrix, \\(H\\) is the Hamiltonian of the system, \\(\\Gamma_i\\) and \\(\\gamma_i\\) are the \\(i\\mathrm{th}\\) decay operator and the corresponding decay rate. tspan : Time length for the evolution. \u03c10 : Initial state (density matrix). H0 : Free Hamiltonian. dH : Derivatives of the free Hamiltonian with respect to the unknown parameters to be estimated. For example, dH[0] is the derivative vector on the first parameter. decay : Decay operators and the corresponding decay rates. Its input rule is decay=[[ \\(\\Gamma_1\\) , \\(\\gamma_1\\) ], [ \\(\\Gamma_2\\) , \\(\\gamma_2\\) ],...], where \\(\\Gamma_1\\) \\((\\Gamma_2)\\) represents the decay operator and \\(\\gamma_1\\) \\((\\gamma_2)\\) is the corresponding decay rate. Hc : Control Hamiltonians. ctrl : Control coefficients. source QuanEstimation.mintime \u2014 Method . \u00b6 mintime ( f :: Number , opt :: ControlOpt , alg :: AbstractAlgorithm , obj :: AbstractObj , dynamics :: AbstractDynamics ; savefile :: Bool = false , method :: String = \"binary\" ) Search of the minimum time to reach a given value of the objective function. f : The given value of the objective function. opt : Control Optimization. alg : Optimization algorithms, options are auto-GRAPE , GRAPE , PSO , DE and DDPG . obj : Objective function, options are QFIM_obj , CFIM_obj and HCRB_obj . dynamics : Lindblad dynamics. savefile : Whether or not to save all the control coeffients. method : Methods for searching the minimum time to reach the given value of the objective function. Options are binary and forward . system : control system. source QuanEstimation.run \u2014 Method . \u00b6 run ( opt :: AbstractOpt , alg :: AbstractAlgorithm , obj :: AbstractObj , dynamics :: AbstractDynamics ; savefile :: Bool = false ) Run the optimization problem. opt : Types of optimization, options are ControlOpt , StateOpt , MeasurementOpt , SMopt , SCopt , CMopt and SCMopt . alg : Optimization algorithms, options are auto-GRAPE , GRAPE , AD , PSO , DE , 'NM' and DDPG . obj : Objective function, options are QFIM_obj , CFIM_obj and HCRB_obj . dynamics : Lindblad or Kraus parameterization process. savefile : Whether or not to save all the control coeffients. source QuanEstimation.suN_generator \u2014 Method . \u00b6 suN_generator ( n :: Int64 ) Generation of the SU( \\(N\\) ) generators with \\(N\\) the dimension of the system. N : The dimension of the system. source","title":"Julia"},{"location":"API/julia/api/#quanestimationad-method","text":"AD (; max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 , Adam :: Bool = true ) Optimization algorithm: AD. max_episode : The number of episodes. epsilon : Learning rate. beta1 : The exponential decay rate for the first moment estimates. beta2 : The exponential decay rate for the second moment estimates. Adam : Whether or not to use Adam for updating control coefficients. source","title":"QuanEstimation.AD &mdash; Method."},{"location":"API/julia/api/#quanestimationcfim_obj-method","text":"CFIM_obj (; M = missing , W = missing , eps = GLOBAL_EPS ) Choose CFI [ \\(\\mathrm{Tr}(WI^{-1})\\) ] as the objective function with \\(W\\) the weight matrix and \\(I\\) the CFIM. M : A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). W : Weight matrix. eps : Machine epsilon. source","title":"QuanEstimation.CFIM_obj &mdash; Method."},{"location":"API/julia/api/#quanestimationcmopt-type","text":"CMopt ( ctrl = missing , M = missing , ctrl_bound = [ - Inf , Inf ], seed = 1234 ) Control and measurement optimization. ctrl : Guessed control coefficients. M : Guessed projective measurement (a set of basis) ctrl_bound : Lower and upper bounds of the control coefficients. seed : Random seed. source","title":"QuanEstimation.CMopt &mdash; Type."},{"location":"API/julia/api/#quanestimationcontrolopt-method","text":"ControlOpt ( ctrl = missing , ctrl_bound = [ - Inf , Inf ], seed = 1234 ) Control optimization. ctrl : Guessed control coefficients. ctrl_bound : Lower and upper bounds of the control coefficients. seed : Random seed. source","title":"QuanEstimation.ControlOpt &mdash; Method."},{"location":"API/julia/api/#quanestimationddpg-method","text":"DDPG (; max_episode :: Int = 500 , layer_num :: Int = 3 , layer_dim :: Int = 200 , seed :: Number = 1234 ) Optimization algorithm: DE. max_episode : The number of populations. layer_num : The number of layers (include the input and output layer). layer_dim : The number of neurons in the hidden layer. seed : Random seed. source","title":"QuanEstimation.DDPG &mdash; Method."},{"location":"API/julia/api/#quanestimationde-method","text":"DE (; max_episode :: Number = 1000 , p_num :: Number = 10 , ini_population = missing , c :: Number = 1.0 , cr :: Number = 0.5 , seed :: Number = 1234 ) Optimization algorithm: DE. max_episode : The number of populations. p_num : The number of particles. ini_population : Initial guesses of the optimization variables. c : Mutation constant. cr : Crossover constant. source","title":"QuanEstimation.DE &mdash; Method."},{"location":"API/julia/api/#quanestimationgrape-method","text":"GRAPE (; max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 , Adam :: Bool = true ) Control optimization algorithm: GRAPE. max_episode : The number of episodes. epsilon : Learning rate. beta1 : The exponential decay rate for the first moment estimates. beta2 : The exponential decay rate for the second moment estimates. Adam : Whether or not to use Adam for updating control coefficients. source","title":"QuanEstimation.GRAPE &mdash; Method."},{"location":"API/julia/api/#quanestimationhcrb_obj-method","text":"HCRB_obj (; W = missing , eps = GLOBAL_EPS ) Choose HCRB as the objective function. W : Weight matrix. eps : Machine epsilon. source","title":"QuanEstimation.HCRB_obj &mdash; Method."},{"location":"API/julia/api/#quanestimationkraus-method","text":"Kraus ( \u03c10 :: AbstractMatrix , K :: AbstractVector , dK :: AbstractVector ) The parameterization of a state is \\(\\rho=\\sum_i K_i\\rho_0K_i^{\\dagger}\\) with \\(\\rho\\) the evolved density matrix and \\(K_i\\) the Kraus operator. \u03c10 : Initial state (density matrix). K : Kraus operators. dK : Derivatives of the Kraus operators with respect to the unknown parameters to be estimated. For example, dK[0] is the derivative vector on the first parameter. source","title":"QuanEstimation.Kraus &mdash; Method."},{"location":"API/julia/api/#quanestimationkraus-method_1","text":"Kraus ( \u03c80 :: AbstractMatrix , K :: AbstractVector , dK :: AbstractVector ) The parameterization of a state is \\(\\psi\\rangle=\\sum_i K_i|\\psi_0\\rangle\\) with \\(\\psi\\) the evolved state and \\(K_i\\) the Kraus operator. \u03c80 : Initial state (ket). K : Kraus operators. dK : Derivatives of the Kraus operators with respect to the unknown parameters to be estimated. For example, dK[0] is the derivative vector on the first parameter. source","title":"QuanEstimation.Kraus &mdash; Method."},{"location":"API/julia/api/#quanestimationkraus-method_2","text":"Kraus ( opt :: AbstractMopt , \u03c1\u2080 :: AbstractMatrix , K , dK ; eps = GLOBAL_EPS ) Initialize the parameterization described by the Kraus operators for the measurement optimization. source","title":"QuanEstimation.Kraus &mdash; Method."},{"location":"API/julia/api/#quanestimationkraus-method_3","text":"Kraus ( opt :: CompOpt , K , dK ; eps = GLOBAL_EPS ) Initialize the parameterization described by the Kraus operators for the comprehensive optimization. source","title":"QuanEstimation.Kraus &mdash; Method."},{"location":"API/julia/api/#quanestimationlld-method","text":"LLD ( \u03c1 :: Matrix { T }, d\u03c1 :: Vector { Matrix { T }}; rep = \"original\" , eps = GLOBAL_EPS ) where { T <: Complex } Calculate the left logarrithmic derivatives (LLDs). The LLD operator is defined as \\(\\partial_{a}\\rho=\\mathcal{R}_a^{\\dagger}\\rho\\) , where \u03c1 is the parameterized density matrix. \u03c1 : Density matrix. d\u03c1 : Derivatives of the density matrix with respect to the unknown parameters to be estimated. For example, drho[1] is the derivative vector with respect to the first parameter. rep : Representation of the LLD operator. Options can be: \"original\" (default) and \"eigen\". eps : Machine epsilon. source","title":"QuanEstimation.LLD &mdash; Method."},{"location":"API/julia/api/#quanestimationlld-method_1","text":"LLD ( \u03c1 :: Matrix { T }, d\u03c1 :: Matrix { T }; rep = \"original\" , eps = GLOBAL_EPS ) where { T <: Complex } When applied to the case of single parameter. source","title":"QuanEstimation.LLD &mdash; Method."},{"location":"API/julia/api/#quanestimationlindblad-method","text":"Lindblad ( opt :: AbstractMopt , tspan , \u03c1\u2080 , H0 , dH ; Hc = missing , ctrl = missing , decay = missing , eps = GLOBAL_EPS ) Initialize the parameterization described by the Lindblad master equation governed dynamics for the measurement optimization. source","title":"QuanEstimation.Lindblad &mdash; Method."},{"location":"API/julia/api/#quanestimationlindblad-method_1","text":"Lindblad ( opt :: ControlMeasurementOpt , tspan , \u03c1\u2080 , H0 , dH , Hc ; decay = missing , eps = GLOBAL_EPS ) Initialize the parameterization described by the Lindblad master equation governed dynamics for the comprehensive optimization on control and measurement. source","title":"QuanEstimation.Lindblad &mdash; Method."},{"location":"API/julia/api/#quanestimationlindblad-method_2","text":"Lindblad ( opt :: ControlOpt , tspan , \u03c1\u2080 , H0 , dH , Hc ; decay = missing , eps = GLOBAL_EPS ) Initialize the parameterization described by the Lindblad master equation governed dynamics for the control optimization. source","title":"QuanEstimation.Lindblad &mdash; Method."},{"location":"API/julia/api/#quanestimationlindblad-method_3","text":"Lindblad ( opt :: StateControlMeasurementOpt , tspan , H0 , dH , Hc ; decay = missing , eps = GLOBAL_EPS ) Initialize the parameterization described by the Lindblad master equation governed dynamics for the comprehensive optimization on state, control and measurement. source","title":"QuanEstimation.Lindblad &mdash; Method."},{"location":"API/julia/api/#quanestimationlindblad-method_4","text":"Lindblad ( opt :: StateControlOpt , tspan , H0 , dH , Hc ; decay = missing , eps = GLOBAL_EPS ) Initialize the parameterization described by the Lindblad master equation governed dynamics for the comprehensive optimization on state and control. source","title":"QuanEstimation.Lindblad &mdash; Method."},{"location":"API/julia/api/#quanestimationlindblad-method_5","text":"Lindblad ( opt :: StateMeasurementOpt , tspan , H0 , dH ; Hc = missing , ctrl = missing , decay = missing ) Initialize the parameterization described by the Lindblad master equation governed dynamics for the comprehensive optimization on state and measurement. source","title":"QuanEstimation.Lindblad &mdash; Method."},{"location":"API/julia/api/#quanestimationlindblad-method_6","text":"Lindblad ( opt :: StateOpt , tspan , H0 , dH ; Hc = missing , ctrl = missing , decay = missing , eps = GLOBAL_EPS ) Initialize the parameterization described by the Lindblad master equation governed dynamics for the state optimization. source","title":"QuanEstimation.Lindblad &mdash; Method."},{"location":"API/julia/api/#quanestimationnm-method","text":"NM (; max_episode :: Int = 1000 , p_num :: Int = 10 , nelder_mead = missing , ar :: Number = 1.0 , ae :: Number = 2.0 , ac :: Number = 0.5 , as0 :: Number = 0.5 , seed :: Number = 1234 ) State optimization algorithm: NM. max_episode : The number of populations. p_num : The number of the input states. nelder_mead : Initial guesses of the optimization variables. ar : Reflection constant. ae : Expansion constant. ac : Constraction constant. as0 : Shrink constant. source","title":"QuanEstimation.NM &mdash; Method."},{"location":"API/julia/api/#quanestimationpso-method","text":"PSO (; max_episode :: Union { T , Vector { T }} where { T <: Int } = [ 1000 , 100 ], p_num :: Number = 10 , ini_particle = missing , c0 :: Number = 1.0 , c1 :: Number = 2.0 , c2 :: Number = 2.0 , seed :: Number = 1234 ) Optimization algorithm: PSO. max_episode : The number of episodes, it accepts both integer and array with two elements. p_num : The number of particles. ini_particle : Initial guesses of the optimization variables. c0 : The damping factor that assists convergence, also known as inertia weight. c1 : The exploitation weight that attracts the particle to its best previous position, also known as cognitive learning factor. c2 : The exploitation weight that attracts the particle to the best position in the neighborhood, also known as social learning factor. source","title":"QuanEstimation.PSO &mdash; Method."},{"location":"API/julia/api/#quanestimationqfim_obj-method","text":"QFIM_obj (; W = missing , eps = GLOBAL_EPS , LDtype :: Symbol = :SLD ) Choose QFI [ \\(\\mathrm{Tr}(WF^{-1})\\) ] as the objective function with \\(W\\) the weight matrix and \\(F\\) the QFIM. W : Weight matrix. eps : Machine epsilon. LDtype : Types of QFI (QFIM) can be set as the objective function. Options are :SLD (default), :RLD and :LLD . source","title":"QuanEstimation.QFIM_obj &mdash; Method."},{"location":"API/julia/api/#quanestimationri-method","text":"RI (; max_episode :: Int = 300 , seed :: Number = 1234 ) State optimization algorithm: reverse iterative. max_episode : The number of episodes. source","title":"QuanEstimation.RI &mdash; Method."},{"location":"API/julia/api/#quanestimationrld-method","text":"RLD ( \u03c1 :: Matrix { T }, d\u03c1 :: Vector { Matrix { T }}; rep = \"original\" , eps = GLOBAL_EPS ) where { T <: Complex } Calculate the right logarrithmic derivatives (RLDs). The RLD operator is defined as \\(\\partial_{a}\\rho=\\rho \\mathcal{R}_a\\) , where \\(\\rho\\) is the parameterized density matrix. \u03c1 : Density matrix. d\u03c1 : Derivatives of the density matrix with respect to the unknown parameters to be estimated. For example, drho[1] is the derivative vector with respect to the first parameter. rep : Representation of the RLD operator. Options can be: \"original\" (default) and \"eigen\". eps : Machine epsilon. source","title":"QuanEstimation.RLD &mdash; Method."},{"location":"API/julia/api/#quanestimationrld-method_1","text":"RLD ( \u03c1 :: Matrix { T }, d\u03c1 :: Matrix { T }; rep = \"original\" , eps = GLOBAL_EPS ) where { T <: Complex } When applied to the case of single parameter. source","title":"QuanEstimation.RLD &mdash; Method."},{"location":"API/julia/api/#quanestimationscmopt-type","text":"SCMopt ( psi = missing , ctrl = missing , M = missing , ctrl_bound = [ - Inf , Inf ], seed = 1234 ) State, control and measurement optimization. psi : Guessed probe state. ctrl : Guessed control coefficients. M : Guessed projective measurement (a set of basis). ctrl_bound : Lower and upper bounds of the control coefficients. seed : Random seed. source","title":"QuanEstimation.SCMopt &mdash; Type."},{"location":"API/julia/api/#quanestimationscopt-type","text":"SCopt ( psi = missing , ctrl = missing , ctrl_bound = [ - Inf , Inf ], seed = 1234 ) State and control optimization. psi : Guessed probe state. ctrl : Guessed control coefficients. ctrl_bound : Lower and upper bounds of the control coefficients. seed : Random seed. source","title":"QuanEstimation.SCopt &mdash; Type."},{"location":"API/julia/api/#quanestimationsld-method","text":"SLD ( \u03c1 :: Matrix { T }, d\u03c1 :: Vector { Matrix { T }}; rep = \"original\" , eps = GLOBAL_EPS ) where { T <: Complex } Calculate the symmetric logarrithmic derivatives (SLDs). The SLD operator \\(L_a\\) is defined as \\(\\partial_{a}\\rho=\\frac{1}{2}(\\rho L_{a}+L_{a}\\rho)\\) , where \\(\\rho\\) is the parameterized density matrix. \u03c1 : Density matrix. d\u03c1 : Derivatives of the density matrix with respect to the unknown parameters to be estimated. For example, drho[1] is the derivative vector with respect to the first parameter. rep : Representation of the SLD operator. Options can be: \"original\" (default) and \"eigen\" . eps : Machine epsilon. source","title":"QuanEstimation.SLD &mdash; Method."},{"location":"API/julia/api/#quanestimationsld-method_1","text":"SLD ( \u03c1 :: Matrix { T }, d\u03c1 :: Matrix { T }; rep = \"original\" , eps = GLOBAL_EPS ) where { T <: Complex } When applied to the case of single parameter. source","title":"QuanEstimation.SLD &mdash; Method."},{"location":"API/julia/api/#quanestimationsmopt-type","text":"SMopt ( psi = missing , M = missing , seed = 1234 ) State and control optimization. psi : Guessed probe state. M : Guessed projective measurement (a set of basis). seed : Random seed. source","title":"QuanEstimation.SMopt &mdash; Type."},{"location":"API/julia/api/#quanestimationstateopt-method","text":"StateOpt ( psi = missing , seed = 1234 ) State optimization. psi : Guessed probe state. seed : Random seed. source","title":"QuanEstimation.StateOpt &mdash; Method."},{"location":"API/julia/api/#quanestimationautogrape-method","text":"autoGRAPE (; max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 , Adam :: Bool = true ) Control optimization algorithm: auto-GRAPE. max_episode : The number of episodes. epsilon : Learning rate. beta1 : The exponential decay rate for the first moment estimates. beta2 : The exponential decay rate for the second moment estimates. Adam : Whether or not to use Adam for updating control coefficients. source","title":"QuanEstimation.autoGRAPE &mdash; Method."},{"location":"API/julia/api/#quanestimationadaptive-method","text":"Adaptive ( x :: AbstractVector , p , rho0 :: AbstractMatrix , tspan , H , dH ; savefile = false , max_episode :: Int = 1000 , eps :: Float64 = 1e-8 , Hc = missing , ctrl = missing , decay = missing , M = missing , W = missing ) In QuanEstimation, the Hamiltonian of the adaptive system should be written as \\(H(\\textbf{x}+\\textbf{u})\\) with \\(\\textbf{x}\\) the unknown parameters and \\(\\textbf{u}\\) the tunable parameters. The tunable parameters \\(\\textbf{u}\\) are used to let the Hamiltonian work at the optimal point \\(\\textbf{x}_{\\mathrm{opt}}\\) . x : The regimes of the parameters for the integral. p : The prior distribution. rho0 : Density matrix. tspan : The experimental results obtained in practice. H : Free Hamiltonian with respect to the values in x. dH : Derivatives of the free Hamiltonian with respect to the unknown parameters to be estimated. savefile : Whether or not to save all the posterior distributions. max_episode : The number of episodes. eps : Machine epsilon. Hc : Control Hamiltonians. ctrl : Control coefficients. decay : Decay operators and the corresponding decay rates. M : A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). W : Whether or not to save all the posterior distributions. source","title":"QuanEstimation.Adaptive &mdash; Method."},{"location":"API/julia/api/#quanestimationadaptive-method_1","text":"Adaptive ( x :: AbstractVector , p , rho0 :: AbstractMatrix , K , dK ; savefile = false , max_episode :: Int = 1000 , eps :: Float64 = 1e-8 , M = missing , W = missing ) In QuanEstimation, the Hamiltonian of the adaptive system should be written as \\(H(\\textbf{x}+\\textbf{u})\\) with \\(\\textbf{x}\\) the unknown parameters and \\(\\textbf{u}\\) the tunable parameters. The tunable parameters \\(\\textbf{u}\\) are used to let the Hamiltonian work at the optimal point \\(\\textbf{x}_{\\mathrm{opt}}\\) . x : The regimes of the parameters for the integral. p : The prior distribution. rho0 : Density matrix. K : Kraus operator(s) with respect to the values in x. dK : Derivatives of the Kraus operator(s) with respect to the unknown parameters to be estimated. savefile : Whether or not to save all the posterior distributions. max_episode : The number of episodes. eps : Machine epsilon. M : A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). W : Whether or not to save all the posterior distributions. source","title":"QuanEstimation.Adaptive &mdash; Method."},{"location":"API/julia/api/#quanestimationbcb-method","text":"BCB ( x , p , rho ; W = missing , eps = GLOBAL_EPS ) Calculation of the minimum Bayesian cost with a quadratic cost function. x : The regimes of the parameters for the integral. p : The prior distribution. rho : Parameterized density matrix. W : Weight matrix. eps : Machine epsilon. source","title":"QuanEstimation.BCB &mdash; Method."},{"location":"API/julia/api/#quanestimationbcfim-method","text":"BCFIM ( x :: AbstractVector , p , rho , drho ; M = missing , eps = GLOBAL_EPS ) Calculation of the Bayesian classical Fisher information (BCFI) and the Bayesian classical Fisher information matrix (BCFIM) of the form \\(\\mathcal{I}_{\\mathrm{Bayes}}=\\int p(\\textbf{x})\\mathcal{I}\\mathrm{d}\\textbf{x}\\) with \\(\\mathcal{I}\\) the CFIM and \\(p(\\textbf{x})\\) the prior distribution. x : The regimes of the parameters for the integral. p : The prior distribution. rho : Parameterized density matrix. drho : Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated. M : A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). eps : Machine epsilon. source","title":"QuanEstimation.BCFIM &mdash; Method."},{"location":"API/julia/api/#quanestimationbcrb-method","text":"BCRB ( x :: AbstractVector , p , dp , rho , drho ; M = missing , b = missing , db = missing , btype = 1 , eps = GLOBAL_EPS ) Calculation of the Bayesian Cramer-Rao bound (BCRB). x : The regimes of the parameters for the integral. p : The prior distribution. dp : Derivatives of the prior distribution with respect to the unknown parameters to be estimated. For example, dp[0] is the derivative vector on the first parameter. rho : Parameterized density matrix. drho : Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated. M : A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). b : Vector of biases of the form \\(\\textbf{b}=(b(x_0),b(x_1),\\dots)^{\\mathrm{T}}\\) . db : Derivatives of b on the unknown parameters to be estimated, It should be expressed as \\(\\textbf{b}'=(\\partial_0 b(x_0),\\partial_1 b(x_1),\\dots)^{\\mathrm{T}}\\) . btype : Types of the BCRB. Options are 1, 2 and 3. eps : Machine epsilon. source","title":"QuanEstimation.BCRB &mdash; Method."},{"location":"API/julia/api/#quanestimationbqcrb-method","text":"BQCRB ( x :: AbstractVector , p , dp , rho , drho ; b = missing , db = missing , LDtype = :SLD , btype = 1 , eps = GLOBAL_EPS ) Calculation of the Bayesian quantum Cramer-Rao bound (BQCRB). x : The regimes of the parameters for the integral. p : The prior distribution. dp : Derivatives of the prior distribution with respect to the unknown parameters to be estimated. For example, dp[0] is the derivative vector on the first parameter. rho : Parameterized density matrix. drho : Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated. b : Vector of biases of the form \\(\\textbf{b}=(b(x_0),b(x_1),\\dots)^{\\mathrm{T}}\\) . db : Derivatives of b on the unknown parameters to be estimated, It should be expressed as \\(\\textbf{b}'=(\\partial_0 b(x_0),\\partial_1 b(x_1),\\dots)^{\\mathrm{T}}\\) . LDtype : Types of QFI (QFIM) can be set as the objective function. Options are \"SLD\" (default), \"RLD\" and \"LLD\". btype : Types of the BCRB. Options are 1, 2 and 3. eps : Machine epsilon. source","title":"QuanEstimation.BQCRB &mdash; Method."},{"location":"API/julia/api/#quanestimationbqfim-method","text":"BQFIM ( x :: AbstractVector , p , rho , drho ; LDtype = :SLD , eps = GLOBAL_EPS ) Calculation of the Bayesian quantum Fisher information (BQFI) and the Bayesian quantum Fisher information matrix (BQFIM) of the form \\(\\mathcal{F}_{\\mathrm{Bayes}}=\\int p(\\textbf{x})\\mathcal{F}\\mathrm{d}\\textbf{x}\\) with \\(\\mathcal{F}\\) the QFIM of all types and \\(p(\\textbf{x})\\) the prior distribution. x : The regimes of the parameters for the integral. p : The prior distribution. rho : Parameterized density matrix. drho : Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated. LDtype : Types of QFI (QFIM) can be set as the objective function. Options are \"SLD\" (default), \"RLD\" and \"LLD\". eps : Machine epsilon. source","title":"QuanEstimation.BQFIM &mdash; Method."},{"location":"API/julia/api/#quanestimationbayes-method","text":"Bayes ( x , p , rho , y ; M = missing , savefile = false ) Bayesian estimation. The prior distribution is updated via the posterior distribution obtained by the Bayes\u2019 rule and the estimated value of parameters obtained via the maximum a posteriori probability (MAP). x : The regimes of the parameters for the integral. p : The prior distribution. rho : Parameterized density matrix. y : The experimental results obtained in practice. M : A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). savefile : Whether or not to save all the posterior distributions. source","title":"QuanEstimation.Bayes &mdash; Method."},{"location":"API/julia/api/#quanestimationbayescost-method","text":"BayesCost ( x , p , xest , rho , M ; W = missing , eps = GLOBAL_EPS ) Calculation of the average Bayesian cost with a quadratic cost function. x : The regimes of the parameters for the integral. p : The prior distribution. xest : The estimators. rho : Parameterized density matrix. M : A set of POVM. W : Weight matrix. eps : Machine epsilon. source","title":"QuanEstimation.BayesCost &mdash; Method."},{"location":"API/julia/api/#quanestimationcfim-method","text":"CFIM ( \u03c1 :: Matrix { T }, d\u03c1 :: Vector { Matrix { T }}, M ; eps = GLOBAL_EPS ) where { T <: Complex } Calculate the classical Fisher information matrix (CFIM). \u03c1 : Density matrix. d\u03c1 : Derivatives of the density matrix with respect to the unknown parameters to be estimated. For example, drho[1] is the derivative vector with respect to the first parameter. M : A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). eps : Machine epsilon. source","title":"QuanEstimation.CFIM &mdash; Method."},{"location":"API/julia/api/#quanestimationcfim-method_1","text":"CFIM ( \u03c1 :: Matrix { T }, d\u03c1 :: Vector { Matrix { T }}; M = nothing , eps = GLOBAL_EPS ) where { T <: Complex } When the set of POVM is not given. Calculate the CFIM with SIC-POVM. The SIC-POVM is generated from the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from here . source","title":"QuanEstimation.CFIM &mdash; Method."},{"location":"API/julia/api/#quanestimationcfim-method_2","text":"CFIM ( \u03c1 :: Matrix { T }, d\u03c1 :: Matrix { T }, M ; eps = GLOBAL_EPS ) where { T <: Complex } When applied to the case of single parameter. Calculate the classical Fisher information (CFI). source","title":"QuanEstimation.CFIM &mdash; Method."},{"location":"API/julia/api/#quanestimationcfim-method_3","text":"CFIM ( \u03c1 :: Matrix { T }, d\u03c1 :: Matrix { T }; eps = GLOBAL_EPS ) where { T <: Complex } When applied to the case of single parameter and the set of POVM is not given. Calculate the CFI with SIC-POVM. source","title":"QuanEstimation.CFIM &mdash; Method."},{"location":"API/julia/api/#quanestimationfim-method","text":"FIM ( p :: Vector { R }, dp :: Vector { R }; eps = GLOBAL_EPS ) where { R <: Real } Calculation of the classical Fisher information matrix for classical scenarios. p : The probability distribution. dp : Derivatives of the probability distribution on the unknown parameters to be estimated. For example, dp[0] is the derivative vector on the first parameter. eps : Machine epsilon. source","title":"QuanEstimation.FIM &mdash; Method."},{"location":"API/julia/api/#quanestimationfim-method_1","text":"FIM ( p :: Vector { R }, dp :: Vector { R }; eps = GLOBAL_EPS ) where { R <: Real } When applied to the case of single parameter and the set of POVM is not given. Calculate the classical Fisher information for classical scenarios. source","title":"QuanEstimation.FIM &mdash; Method."},{"location":"API/julia/api/#quanestimationhcrb-method","text":"HCRB ( \u03c1 :: AbstractMatrix , d\u03c1 :: AbstractVector , C :: AbstractMatrix ; eps = GLOBAL_EPS ) Caltulate the Holevo Cramer-Rao bound (HCRB) via the semidefinite program (SDP). \u03c1 : Density matrix. d\u03c1 : Derivatives of the density matrix on the unknown parameters to be estimated. For example, drho[0] is the derivative vector on the first parameter. W : Weight matrix. eps : Machine epsilon. source","title":"QuanEstimation.HCRB &mdash; Method."},{"location":"API/julia/api/#quanestimationmle-method","text":"MLE ( x , rho , y ; M = missing , savefile = false ) Bayesian estimation. The estimated value of parameters obtained via the maximum likelihood estimation (MLE). x : The regimes of the parameters for the integral. rho : Parameterized density matrix. y : The experimental results obtained in practice. M : A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). savefile : Whether or not to save all the posterior distributions. source","title":"QuanEstimation.MLE &mdash; Method."},{"location":"API/julia/api/#quanestimationmeasurementopt-method","text":"MeasurementOpt ( mtype = :Projection , kwargs ... ) Measurement optimization. mtype : The type of scenarios for the measurement optimization. Options are :Projection (default), :LC and :Rotation . kwargs... : keywords and the correponding default vaules. mtype=:Projection , mtype=:LC and mtype=:Rotation , the kwargs... are M=missing , B=missing, POVM_basis=missing , and s=missing, POVM_basis=missing , respectively. source","title":"QuanEstimation.MeasurementOpt &mdash; Method."},{"location":"API/julia/api/#quanestimationobb-method","text":"OBB ( x :: AbstractVector , p , dp , rho , drho , d2rho ; LDtype = :SLD , eps = GLOBAL_EPS ) Calculation of the Bayesian version of Cramer-Rao bound introduced by Van Trees (VTB). x : The regimes of the parameters for the integral. p : The prior distribution. dp : Derivatives of the prior distribution with respect to the unknown parameters to be estimated. For example, dp[0] is the derivative vector on the first parameter. rho : Parameterized density matrix. drho : Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated. d2rho : Second order Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated. LDtype : Types of QFI (QFIM) can be set as the objective function. Options are \"SLD\" (default), \"RLD\" and \"LLD\". eps : Machine epsilon. source","title":"QuanEstimation.OBB &mdash; Method."},{"location":"API/julia/api/#quanestimationqfim-method","text":"QFIM ( \u03c1 :: Matrix { T }, d\u03c1 :: Vector { Matrix { T }}; LDtype = :SLD , exportLD :: Bool = false , eps = GLOBAL_EPS ) where { T <: Complex } When applied to the case of single parameter. Calculation of the quantum Fisher information (QFI) for all types. source","title":"QuanEstimation.QFIM &mdash; Method."},{"location":"API/julia/api/#quanestimationqfim-method_1","text":"QFIM ( \u03c1 :: Matrix { T }, d\u03c1 :: Matrix { T }; LDtype = :SLD , exportLD :: Bool = false , eps = GLOBAL_EPS ) where { T <: Complex } Calculation of the quantum Fisher information (QFI) for all types. \u03c1 : Density matrix. d\u03c1 : Derivatives of the density matrix with respect to the unknown parameters to be estimated. For example, drho[1] is the derivative vector with respect to the first parameter. LDtype : Types of QFI (QFIM) can be set as the objective function. Options are :SLD (default), :RLD and :LLD . exportLD : export logarithmic derivatives apart from F. eps : Machine epsilon. source","title":"QuanEstimation.QFIM &mdash; Method."},{"location":"API/julia/api/#quanestimationqfim_gauss-method","text":"QFIM_Gauss ( R\u0304 :: V , dR\u0304 :: VV , D :: M , dD :: VM ) where { V , VV , M , VM <: AbstractVecOrMat } Calculate the SLD based quantum Fisher information matrix (QFIM) with gaussian states. R\u0304 : First-order moment. dR\u0304 : Derivatives of the first-order moment with respect to the unknown parameters to be estimated. For example, dR[1] is the derivative vector on the first parameter. D : Second-order moment. dD : Derivatives of the second-order moment with respect to the unknown parameters to be estimated. eps : Machine epsilon. source","title":"QuanEstimation.QFIM_Gauss &mdash; Method."},{"location":"API/julia/api/#quanestimationqfim_kraus-method","text":"QFIM_Kraus ( \u03c10 :: AbstractMatrix , K :: AbstractVector , dK :: AbstractVector ; LDtype = :SLD , exportLD :: Bool = false , eps = GLOBAL_EPS ) Calculation of the quantum Fisher information (QFI) and quantum Fisher information matrix (QFIM) with Kraus operator(s) for all types. \u03c10 : Density matrix. K : Kraus operator(s). dK : Derivatives of the Kraus operator(s) on the unknown parameters to be estimated. For example, dK[0] is the derivative vector on the first parameter. LDtype : Types of QFI (QFIM) can be set as the objective function. Options are :SLD (default), :RLD and :LLD . exportLD : Whether or not to export the values of logarithmic derivatives. If set True then the the values of logarithmic derivatives will be exported. eps : Machine epsilon. source","title":"QuanEstimation.QFIM_Kraus &mdash; Method."},{"location":"API/julia/api/#quanestimationqvtb-method","text":"QVTB ( x :: AbstractVector , p , dp , rho , drho ; LDtype = :SLD , eps = GLOBAL_EPS ) Calculation of the Bayesian version of Cramer-Rao bound in troduced by Van Trees (VTB). x : The regimes of the parameters for the integral. p : The prior distribution. dp : Derivatives of the prior distribution with respect to the unknown parameters to be estimated. For example, dp[0] is the derivative vector on the first parameter. rho : Parameterized density matrix. drho : Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated. LDtype : Types of QFI (QFIM) can be set as the objective function. Options are \"SLD\" (default), \"RLD\" and \"LLD\". eps : Machine epsilon. source","title":"QuanEstimation.QVTB &mdash; Method."},{"location":"API/julia/api/#quanestimationqzzb-method","text":"QZZB ( x :: AbstractVector , p :: AbstractVector , rho :: AbstractVecOrMat ; eps = GLOBAL_EPS ) Calculation of the quantum Ziv-Zakai bound (QZZB). x : The regimes of the parameters for the integral. p : The prior distribution. rho : Parameterized density matrix. eps : Machine epsilon. source","title":"QuanEstimation.QZZB &mdash; Method."},{"location":"API/julia/api/#quanestimationsic-method","text":"SIC ( dim :: Int64 ) Generation of a set of rank-one symmetric informationally complete positive operator-valued measure (SIC-POVM). dim : The dimension of the system. Note: SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from here . source","title":"QuanEstimation.SIC &mdash; Method."},{"location":"API/julia/api/#quanestimationspinsqueezing-method","text":"SpinSqueezing ( \u03c1 :: AbstractMatrix ; basis = \"Dicke\" , output = \"KU\" ) Calculate the spin squeezing parameter for the input density matrix. The basis can be \"Dicke\" for the Dicke basis, or \"Pauli\" for the Pauli basis. The output can be both \"KU\" (for spin squeezing defined by Kitagawa and Ueda) and \"WBIMH\" (for spin squeezing defined by Wineland et al.). source","title":"QuanEstimation.SpinSqueezing &mdash; Method."},{"location":"API/julia/api/#quanestimationtargettime-method","text":"TargetTime ( f :: Number , tspan :: AbstractVector , func :: Function , args ... ; kwargs ... ) Calculate the minimum time to reach a precision limit of given level. The func can be any objective function during the control optimization, e.g. QFIM, CFIM, HCRB, etc. source","title":"QuanEstimation.TargetTime &mdash; Method."},{"location":"API/julia/api/#quanestimationvtb-method","text":"VTB ( x :: AbstractVector , p , dp , rho , drho ; M = missing , eps = GLOBAL_EPS ) Calculation of the Bayesian version of Cramer-Rao bound introduced by Van Trees (VTB). x : The regimes of the parameters for the integral. p : The prior distribution. dp : Derivatives of the prior distribution with respect to the unknown parameters to be estimated. For example, dp[0] is the derivative vector on the first parameter. rho : Parameterized density matrix. drho : Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated. M : A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). eps : Machine epsilon. source","title":"QuanEstimation.VTB &mdash; Method."},{"location":"API/julia/api/#quanestimationevolve-method","text":"evolve ( dynamics :: Kraus { dm }) Evolution of density matrix under time-independent Hamiltonian without noise and controls. source","title":"QuanEstimation.evolve &mdash; Method."},{"location":"API/julia/api/#quanestimationevolve-method_1","text":"evolve ( dynamics :: Kraus { ket }) Evolution of pure states under time-independent Hamiltonian without noise and controls source","title":"QuanEstimation.evolve &mdash; Method."},{"location":"API/julia/api/#quanestimationexpm-function","text":"expm(tspan::AbstractVector, \u03c10::AbstractMatrix, H0::AbstractMatrix, dH::AbstractVector, decay::Union{AbstractVector, Missing}=missing, Hc::Union{AbstractVector, Missing}=missing, ctrl::Union{AbstractVector, Missing}=missing) The dynamics of a density matrix is of the form \\(\\partial_t\\rho=-i[H,\\rho]+\\sum_i \\gamma_i\\left(\\Gamma_i\\rho\\Gamma^{\\dagger}_i-\\frac{1}{2}\\left\\{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\right\\}\\right)\\) , where \\(\\rho\\) is the evolved density matrix, \\(H\\) is the Hamiltonian of the system, \\(\\Gamma_i\\) and \\(\\gamma_i\\) are the \\(i\\mathrm{th}\\) decay operator and the corresponding decay rate. tspan : Time length for the evolution. \u03c10 : Initial state (density matrix). H0 : Free Hamiltonian. dH : Derivatives of the free Hamiltonian with respect to the unknown parameters to be estimated. For example, dH[0] is the derivative vector on the first parameter. decay : Decay operators and the corresponding decay rates. Its input rule is decay=[[ \\(\\Gamma_1\\) , \\(\\gamma_1\\) ], [ \\(\\Gamma_2\\) , \\(\\gamma_2\\) ],...], where \\(\\Gamma_1\\) \\((\\Gamma_2)\\) represents the decay operator and \\(\\gamma_1\\) \\((\\gamma_2)\\) is the corresponding decay rate. Hc : Control Hamiltonians. ctrl : Control coefficients. source","title":"QuanEstimation.expm &mdash; Function."},{"location":"API/julia/api/#quanestimationmintime-method","text":"mintime ( f :: Number , opt :: ControlOpt , alg :: AbstractAlgorithm , obj :: AbstractObj , dynamics :: AbstractDynamics ; savefile :: Bool = false , method :: String = \"binary\" ) Search of the minimum time to reach a given value of the objective function. f : The given value of the objective function. opt : Control Optimization. alg : Optimization algorithms, options are auto-GRAPE , GRAPE , PSO , DE and DDPG . obj : Objective function, options are QFIM_obj , CFIM_obj and HCRB_obj . dynamics : Lindblad dynamics. savefile : Whether or not to save all the control coeffients. method : Methods for searching the minimum time to reach the given value of the objective function. Options are binary and forward . system : control system. source","title":"QuanEstimation.mintime &mdash; Method."},{"location":"API/julia/api/#quanestimationrun-method","text":"run ( opt :: AbstractOpt , alg :: AbstractAlgorithm , obj :: AbstractObj , dynamics :: AbstractDynamics ; savefile :: Bool = false ) Run the optimization problem. opt : Types of optimization, options are ControlOpt , StateOpt , MeasurementOpt , SMopt , SCopt , CMopt and SCMopt . alg : Optimization algorithms, options are auto-GRAPE , GRAPE , AD , PSO , DE , 'NM' and DDPG . obj : Objective function, options are QFIM_obj , CFIM_obj and HCRB_obj . dynamics : Lindblad or Kraus parameterization process. savefile : Whether or not to save all the control coeffients. source","title":"QuanEstimation.run &mdash; Method."},{"location":"API/julia/api/#quanestimationsun_generator-method","text":"suN_generator ( n :: Int64 ) Generation of the SU( \\(N\\) ) generators with \\(N\\) the dimension of the system. N : The dimension of the system. source","title":"QuanEstimation.suN_generator &mdash; Method."},{"location":"API/python/classes/","text":"This part is the classes of the Python-Julia package which written in Python. Dynamics \u00b6 The dynamics of a density matrix is of the form \\[\\begin{align} \\partial_t\\rho &=\\mathcal{L}\\rho \\nonumber \\\\ &=-i[H,\\rho]+\\sum_i \\gamma_i\\left(\\Gamma_i\\rho\\Gamma^{\\dagger}_i-\\frac{1}{2} \\left\\{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\right\\}\\right), \\end{align}\\] where \\(\\rho\\) is the evolved density matrix, \\(H\\) is the Hamiltonian of the system, \\(\\Gamma_i\\) and \\(\\gamma_i\\) are the \\(i\\mathrm{th}\\) decay operator and the corresponding decay rate. Attributes \u00b6 tspan: array -- Time length for the evolution. rho0: matrix -- Initial state (density matrix). H0: matrix or list -- Free Hamiltonian. It is a matrix when the free Hamiltonian is time- independent and a list with the length equal to tspan when it is time-dependent. dH: list -- Derivatives of the free Hamiltonian with respect to the unknown parameters to be estimated. For example, dH[0] is the derivative vector on the first parameter. decay: list -- Decay operators and the corresponding decay rates. Its input rule is decay=[[ \\(\\Gamma_1\\) , \\(\\gamma_1\\) ], [ \\(\\Gamma_2\\) , \\(\\gamma_2\\) ],...], where \\(\\Gamma_1\\) \\((\\Gamma_2)\\) represents the decay operator and \\(\\gamma_1\\) \\((\\gamma_2)\\) is the corresponding decay rate. Hc: list -- Control Hamiltonians. ctrl: list of arrays -- Control coefficients. Source code in quanestimation/Parameterization/GeneralDynamics.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 class Lindblad : r \"\"\" The dynamics of a density matrix is of the form \\begin{align} \\partial_t\\rho &=\\mathcal{L}\\rho \\nonumber \\\\ &=-i[H,\\rho]+\\sum_i \\gamma_i\\left(\\Gamma_i\\rho\\Gamma^{\\dagger}_i-\\frac{1}{2} \\left\\{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\right\\}\\right), \\end{align} where $\\rho$ is the evolved density matrix, $H$ is the Hamiltonian of the system, $\\Gamma_i$ and $\\gamma_i$ are the $i\\mathrm{th}$ decay operator and the corresponding decay rate. Attributes ---------- > **tspan:** `array` -- Time length for the evolution. > **rho0:** `matrix` -- Initial state (density matrix). > **H0:** `matrix or list` -- Free Hamiltonian. It is a matrix when the free Hamiltonian is time- independent and a list with the length equal to `tspan` when it is time-dependent. > **dH:** `list` -- Derivatives of the free Hamiltonian with respect to the unknown parameters to be estimated. For example, dH[0] is the derivative vector on the first parameter. > **decay:** `list` -- Decay operators and the corresponding decay rates. Its input rule is decay=[[$\\Gamma_1$, $\\gamma_1$], [$\\Gamma_2$, $\\gamma_2$],...], where $\\Gamma_1$ $(\\Gamma_2)$ represents the decay operator and $\\gamma_1$ $(\\gamma_2)$ is the corresponding decay rate. > **Hc:** `list` -- Control Hamiltonians. > **ctrl:** `list of arrays` -- Control coefficients. \"\"\" def __init__ ( self , tspan , rho0 , H0 , dH , decay = [], Hc = [], ctrl = []): self . tspan = tspan self . rho0 = np . array ( rho0 , dtype = np . complex128 ) if type ( H0 ) == np . ndarray : self . freeHamiltonian = np . array ( H0 , dtype = np . complex128 ) else : self . freeHamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in H0 ] if type ( dH [ 0 ]) != np . ndarray : raise TypeError ( \"The derivative of Hamiltonian should be a list!\" ) if dH == []: dH = [ np . zeros (( len ( self . rho0 ), len ( self . rho0 )))] self . Hamiltonian_derivative = [ np . array ( x , dtype = np . complex128 ) for x in dH ] if decay == []: decay_opt = [ np . zeros (( len ( self . rho0 ), len ( self . rho0 )))] self . gamma = [ 0.0 ] else : decay_opt = [ decay [ i ][ 0 ] for i in range ( len ( decay ))] self . gamma = [ decay [ i ][ 1 ] for i in range ( len ( decay ))] self . decay_opt = [ np . array ( x , dtype = np . complex128 ) for x in decay_opt ] if Hc == []: Hc = [ np . zeros (( len ( self . rho0 ), len ( self . rho0 )))] ctrl = [ np . zeros ( len ( self . tspan ) - 1 )] self . control_Hamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in Hc ] self . control_coefficients = ctrl elif ctrl == []: ctrl = [ np . zeros ( len ( self . tspan ) - 1 ) for j in range ( len ( Hc ))] self . control_Hamiltonian = Hc self . control_coefficients = ctrl else : ctrl_length = len ( ctrl ) ctrlnum = len ( Hc ) if ctrlnum < ctrl_length : raise TypeError ( \"There are %d control Hamiltonians but %d coefficients sequences: \\ too many coefficients sequences\" % ( ctrlnum , ctrl_length ) ) elif ctrlnum > ctrl_length : warnings . warn ( \"Not enough coefficients sequences: there are %d control Hamiltonians \\ but %d coefficients sequences. The rest of the control sequences are \\ set to be 0.\" % ( ctrlnum , ctrl_length ), DeprecationWarning , ) number = math . ceil (( len ( self . tspan ) - 1 ) / len ( ctrl [ 0 ])) if len ( self . tspan ) - 1 % len ( ctrl [ 0 ]) != 0 : tnum = number * len ( ctrl [ 0 ]) self . tspan = np . linspace ( self . tspan [ 0 ], self . tspan [ - 1 ], tnum + 1 ) self . control_Hamiltonian = Hc self . control_coefficients = ctrl def expm ( self ): r \"\"\" Calculation of the density matrix and its derivatives on the unknown parameters. The density matrix at $j$th time interval is obtained by $\\rho_j=e^{\\Delta t\\mathcal{L}}\\rho_{j-1}$, where $\\Delta t$ is the time interval and $\\rho_{j-1}$ is the density matrix for the $(j-1)$th time interval. $\\partial_{\\textbf{x}}\\rho_j$ is calculated as \\begin{align} \\partial_{\\textbf{x}}\\rho_j =\\Delta t(\\partial_{\\textbf{x}}\\mathcal{L})\\rho_j +e^{\\Delta t \\mathcal{L}}(\\partial_{\\textbf{x}}\\rho_{j-1}). \\end{align} \"\"\" rho , drho = Main . QuanEstimation . expm_py ( self . tspan , self . rho0 , self . freeHamiltonian , self . Hamiltonian_derivative , self . decay_opt , self . gamma , self . control_Hamiltonian , self . control_coefficients , ) return rho , drho def secondorder_derivative ( self , d2H ): r \"\"\" Calculation of the density matrix and its derivatives and the second derivatives on $\\textbf{x}$. The density matrix at $j$th time interval is obtained by $\\rho_j=e^{\\Delta t\\mathcal{L}}\\rho_{j-1}$, where $\\Delta t$ is the time interval and $\\rho_{j-1}$ is the density matrix for the $(j-1)$th time interval. $\\partial_{\\textbf{x}}\\rho_j$ is calculated via \\begin{align} \\partial_{\\textbf{x}}\\rho_j =\\Delta t(\\partial_{\\textbf{x}}\\mathcal{L})\\rho_j +e^{\\Delta t \\mathcal{L}}(\\partial_{\\textbf{x}}\\rho_{j-1}). \\end{align} $\\partial_{\\textbf{x}}^2\\rho_j$ is solved as \\begin{align} \\partial_{\\textbf{x}}^2\\rho_j =\\Delta t(\\partial_{\\textbf{x}}^2\\mathcal{L})\\rho_j +\\Delta t(\\partial_{\\textbf{x}}\\mathcal{L})\\partial_{\\textbf{x}}\\rho_j +\\Delta t(\\partial_{\\textbf{x}}\\mathcal{L})e^{\\Delta t \\mathcal{L}} \\partial_{\\textbf{x}}\\rho_{j-1} +e^{\\Delta t \\mathcal{L}}(\\partial_{\\textbf{x}}^2\\rho_{j-1}). \\end{align} Parameters ---------- > **d2H:** `list` -- Second order derivatives of the free Hamiltonian on the unknown parameters to be estimated. \"\"\" d2H = [ np . array ( x , dtype = np . complex128 ) for x in d2H ] rho , drho , d2rho = Main . QuanEstimation . secondorder_derivative ( self . freeHamiltonian , self . Hamiltonian_derivative , d2H , self . rho0 , self . decay_opt , self . gamma , self . control_Hamiltonian , self . control_coefficients , self . tspan , ) return rho , drho , d2rho expm () \u00b6 Calculation of the density matrix and its derivatives on the unknown parameters. The density matrix at \\(j\\) th time interval is obtained by \\(\\rho_j=e^{\\Delta t\\mathcal{L}}\\rho_{j-1}\\) , where \\(\\Delta t\\) is the time interval and \\(\\rho_{j-1}\\) is the density matrix for the \\((j-1)\\) th time interval. \\(\\partial_{\\textbf{x}}\\rho_j\\) is calculated as \\begin{align} \\partial_{\\textbf{x}}\\rho_j =\\Delta t(\\partial_{\\textbf{x}}\\mathcal{L})\\rho_j +e^{\\Delta t \\mathcal{L}}(\\partial_{\\textbf{x}}\\rho_{j-1}). \\end{align} Source code in quanestimation/Parameterization/GeneralDynamics.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 def expm ( self ): r \"\"\" Calculation of the density matrix and its derivatives on the unknown parameters. The density matrix at $j$th time interval is obtained by $\\rho_j=e^{\\Delta t\\mathcal{L}}\\rho_{j-1}$, where $\\Delta t$ is the time interval and $\\rho_{j-1}$ is the density matrix for the $(j-1)$th time interval. $\\partial_{\\textbf{x}}\\rho_j$ is calculated as \\begin{align} \\partial_{\\textbf{x}}\\rho_j =\\Delta t(\\partial_{\\textbf{x}}\\mathcal{L})\\rho_j +e^{\\Delta t \\mathcal{L}}(\\partial_{\\textbf{x}}\\rho_{j-1}). \\end{align} \"\"\" rho , drho = Main . QuanEstimation . expm_py ( self . tspan , self . rho0 , self . freeHamiltonian , self . Hamiltonian_derivative , self . decay_opt , self . gamma , self . control_Hamiltonian , self . control_coefficients , ) return rho , drho secondorder_derivative ( d2H ) \u00b6 Calculation of the density matrix and its derivatives and the second derivatives on \\(\\textbf{x}\\) . The density matrix at \\(j\\) th time interval is obtained by \\(\\rho_j=e^{\\Delta t\\mathcal{L}}\\rho_{j-1}\\) , where \\(\\Delta t\\) is the time interval and \\(\\rho_{j-1}\\) is the density matrix for the \\((j-1)\\) th time interval. \\(\\partial_{\\textbf{x}}\\rho_j\\) is calculated via \\begin{align} \\partial_{\\textbf{x}}\\rho_j =\\Delta t(\\partial_{\\textbf{x}}\\mathcal{L})\\rho_j +e^{\\Delta t \\mathcal{L}}(\\partial_{\\textbf{x}}\\rho_{j-1}). \\end{align} \\(\\partial_{\\textbf{x}}^2\\rho_j\\) is solved as \\begin{align} \\partial_{\\textbf{x}}^2\\rho_j =\\Delta t(\\partial_{\\textbf{x}}^2\\mathcal{L})\\rho_j +\\Delta t(\\partial_{\\textbf{x}}\\mathcal{L})\\partial_{\\textbf{x}}\\rho_j +\\Delta t(\\partial_{\\textbf{x}}\\mathcal{L})e^{\\Delta t \\mathcal{L}} \\partial_{\\textbf{x}}\\rho_{j-1} +e^{\\Delta t \\mathcal{L}}(\\partial_{\\textbf{x}}^2\\rho_{j-1}). \\end{align} Parameters \u00b6 d2H: list -- Second order derivatives of the free Hamiltonian on the unknown parameters to be estimated. Source code in quanestimation/Parameterization/GeneralDynamics.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 def secondorder_derivative ( self , d2H ): r \"\"\" Calculation of the density matrix and its derivatives and the second derivatives on $\\textbf{x}$. The density matrix at $j$th time interval is obtained by $\\rho_j=e^{\\Delta t\\mathcal{L}}\\rho_{j-1}$, where $\\Delta t$ is the time interval and $\\rho_{j-1}$ is the density matrix for the $(j-1)$th time interval. $\\partial_{\\textbf{x}}\\rho_j$ is calculated via \\begin{align} \\partial_{\\textbf{x}}\\rho_j =\\Delta t(\\partial_{\\textbf{x}}\\mathcal{L})\\rho_j +e^{\\Delta t \\mathcal{L}}(\\partial_{\\textbf{x}}\\rho_{j-1}). \\end{align} $\\partial_{\\textbf{x}}^2\\rho_j$ is solved as \\begin{align} \\partial_{\\textbf{x}}^2\\rho_j =\\Delta t(\\partial_{\\textbf{x}}^2\\mathcal{L})\\rho_j +\\Delta t(\\partial_{\\textbf{x}}\\mathcal{L})\\partial_{\\textbf{x}}\\rho_j +\\Delta t(\\partial_{\\textbf{x}}\\mathcal{L})e^{\\Delta t \\mathcal{L}} \\partial_{\\textbf{x}}\\rho_{j-1} +e^{\\Delta t \\mathcal{L}}(\\partial_{\\textbf{x}}^2\\rho_{j-1}). \\end{align} Parameters ---------- > **d2H:** `list` -- Second order derivatives of the free Hamiltonian on the unknown parameters to be estimated. \"\"\" d2H = [ np . array ( x , dtype = np . complex128 ) for x in d2H ] rho , drho , d2rho = Main . QuanEstimation . secondorder_derivative ( self . freeHamiltonian , self . Hamiltonian_derivative , d2H , self . rho0 , self . decay_opt , self . gamma , self . control_Hamiltonian , self . control_coefficients , self . tspan , ) return rho , drho , d2rho Control Optimization \u00b6 The Hamiltonian of a controlled system can be written as \\begin{align} H = H_0(\\textbf{x})+\\sum_{k=1}^K u_k(t) H_k, \\end{align} where \\(H_0(\\textbf{x})\\) is the free evolution Hamiltonian with unknown parameters \\(\\textbf{x}\\) and \\(H_k\\) represents the \\(k\\) th control Hamiltonian with \\(u_k\\) the corresponding control coefficient. In QuanEstimation, different algorithms are invoked to update the optimal control coefficients. The control optimization algorithms are gradient ascent pulse engineering (GRAPE), GRAPE algorithm based on the automatic differentiation (auto-GRAPE), particle swarm optimization (PSO), differential evolution (DE) and deep deterministic policy gradients (DDPG). Base \u00b6 Attributes \u00b6 savefile: bool -- Whether or not to save all the control coeffients. If set True then the control coefficients and the values of the objective function obtained in all episodes will be saved during the training. If set False the control coefficients in the final episode and the values of the objective function in all episodes will be saved. ctrl0: list of arrays -- Initial guesses of control coefficients. eps: float -- Machine epsilon. load: bool -- Whether or not to load control coefficients in the current location. If set True then the program will load control coefficients from \"controls.csv\" file in the current location and use it as the initial control coefficients. Source code in quanestimation/ControlOpt/ControlStruct.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 class ControlSystem : \"\"\" Attributes ---------- > **savefile:** `bool` -- Whether or not to save all the control coeffients. If set `True` then the control coefficients and the values of the objective function obtained in all episodes will be saved during the training. If set `False` the control coefficients in the final episode and the values of the objective function in all episodes will be saved. > **ctrl0:** `list of arrays` -- Initial guesses of control coefficients. > **eps:** `float` -- Machine epsilon. > **load:** `bool` -- Whether or not to load control coefficients in the current location. If set `True` then the program will load control coefficients from \"controls.csv\" file in the current location and use it as the initial control coefficients. \"\"\" def __init__ ( self , savefile , ctrl0 , eps , load ): self . savefile = savefile self . ctrl0 = ctrl0 self . eps = eps self . load = load def dynamics ( self , tspan , rho0 , H0 , dH , Hc , decay = [], ctrl_bound = []): r \"\"\" The dynamics of a density matrix is of the form \\begin{align} \\partial_t\\rho &=\\mathcal{L}\\rho \\nonumber \\\\ &=-i[H,\\rho]+\\sum_i \\gamma_i\\left(\\Gamma_i\\rho\\Gamma^{\\dagger}_i-\\frac{1}{2} \\left\\{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\right\\}\\right), \\end{align} where $\\rho$ is the evolved density matrix, H is the Hamiltonian of the system, $\\Gamma_i$ and $\\gamma_i$ are the $i\\mathrm{th}$ decay operator and corresponding decay rate. Parameters ---------- > **tspan:** `array` -- Time length for the evolution. > **rho0:** `matrix` -- Initial state (density matrix). > **H0:** `matrix or list` -- Free Hamiltonian. It is a matrix when the free Hamiltonian is time- independent and a list of length equal to `tspan` when it is time-dependent. > **dH:** `list` -- Derivatives of the free Hamiltonian on the unknown parameters to be estimated. For example, dH[0] is the derivative vector on the first parameter. > **Hc:** `list` -- Control Hamiltonians. > **decay:** `list` -- Decay operators and the corresponding decay rates. Its input rule is decay=[[$\\Gamma_1$, $\\gamma_1$], [$\\Gamma_2$,$\\gamma_2$],...], where $\\Gamma_1$ $(\\Gamma_2)$ represents the decay operator and $\\gamma_1$ $(\\gamma_2)$ is the corresponding decay rate. > **ctrl_bound:** `array` -- Lower and upper bounds of the control coefficients. `ctrl_bound[0]` represents the lower bound of the control coefficients and `ctrl_bound[1]` represents the upper bound of the control coefficients. \"\"\" self . tspan = tspan self . rho0 = np . array ( rho0 , dtype = np . complex128 ) if type ( H0 ) == np . ndarray : self . freeHamiltonian = np . array ( H0 , dtype = np . complex128 ) else : self . freeHamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in H0 [: - 1 ]] if Hc == []: Hc = [ np . zeros (( len ( self . rho0 ), len ( self . rho0 )))] self . control_Hamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in Hc ] if type ( dH ) != list : raise TypeError ( \"The derivative of Hamiltonian should be a list!\" ) if dH == []: dH = [ np . zeros (( len ( self . rho0 ), len ( self . rho0 )))] self . Hamiltonian_derivative = [ np . array ( x , dtype = np . complex128 ) for x in dH ] if len ( dH ) == 1 : self . para_type = \"single_para\" else : self . para_type = \"multi_para\" if decay == []: decay_opt = [ np . zeros (( len ( self . rho0 ), len ( self . rho0 )))] self . gamma = [ 0.0 ] else : decay_opt = [ decay [ i ][ 0 ] for i in range ( len ( decay ))] self . gamma = [ decay [ i ][ 1 ] for i in range ( len ( decay ))] self . decay_opt = [ np . array ( x , dtype = np . complex128 ) for x in decay_opt ] if ctrl_bound == []: self . ctrl_bound = [ - np . inf , np . inf ] else : self . ctrl_bound = [ float ( ctrl_bound [ 0 ]), float ( ctrl_bound [ 1 ])] if self . ctrl0 == []: if ctrl_bound == []: ctrl0 = [ 2 * np . random . random ( len ( self . tspan ) - 1 ) - np . ones ( len ( self . tspan ) - 1 ) for i in range ( len ( self . control_Hamiltonian )) ] self . control_coefficients = ctrl0 self . ctrl0 = [ np . array ( ctrl0 )] else : a = ctrl_bound [ 0 ] b = ctrl_bound [ 1 ] ctrl0 = [ ( b - a ) * np . random . random ( len ( self . tspan ) - 1 ) + a * np . ones ( len ( self . tspan ) - 1 ) for i in range ( len ( self . control_Hamiltonian )) ] self . control_coefficients = ctrl0 self . ctrl0 = [ np . array ( ctrl0 )] elif len ( self . ctrl0 ) >= 1 : self . control_coefficients = [ self . ctrl0 [ 0 ][ i ] for i in range ( len ( self . control_Hamiltonian )) ] if self . load == True : if os . path . exists ( \"controls.csv\" ): data = np . genfromtxt ( \"controls.csv\" )[ - len ( self . control_Hamiltonian ) :] self . control_coefficients = [ data [ i ] for i in range ( len ( data ))] ctrl_num = len ( self . control_coefficients ) Hc_num = len ( self . control_Hamiltonian ) if Hc_num < ctrl_num : raise TypeError ( \"There are %d control Hamiltonians but %d coefficients sequences: too many coefficients sequences\" % ( Hc_num , ctrl_num ) ) elif Hc_num > ctrl_num : warnings . warn ( \"Not enough coefficients sequences: there are %d control Hamiltonians but %d coefficients sequences. The rest of the control sequences are set to be 0.\" % ( Hc_num , ctrl_num ), DeprecationWarning , ) for i in range ( Hc_num - ctrl_num ): self . control_coefficients = np . concatenate ( ( self . control_coefficients , np . zeros ( len ( self . control_coefficients [ 0 ])), ) ) else : pass if type ( H0 ) != np . ndarray : #### linear interpolation #### f = interp1d ( self . tspan , H0 , axis = 0 ) else : pass number = math . ceil (( len ( self . tspan ) - 1 ) / len ( self . control_coefficients [ 0 ])) if len ( self . tspan ) - 1 % len ( self . control_coefficients [ 0 ]) != 0 : tnum = number * len ( self . control_coefficients [ 0 ]) self . tspan = np . linspace ( self . tspan [ 0 ], self . tspan [ - 1 ], tnum + 1 ) if type ( H0 ) != np . ndarray : H0_inter = f ( self . tspan ) self . freeHamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in H0_inter [: - 1 ]] else : pass else : pass self . opt = Main . QuanEstimation . ControlOpt ( ctrl = self . control_coefficients , ctrl_bound = self . ctrl_bound , seed = self . seed ) self . dynamic = Main . QuanEstimation . Lindblad ( self . freeHamiltonian , self . Hamiltonian_derivative , self . control_Hamiltonian , self . control_coefficients , self . rho0 , self . tspan , self . decay_opt , self . gamma , ) self . output = Main . QuanEstimation . Output ( self . opt , save = self . savefile ) self . dynamics_type = \"lindblad\" def QFIM ( self , W = [], LDtype = \"SLD\" ): r \"\"\" Choose QFI or $\\mathrm{Tr}(WF^{-1})$ as the objective function. In single parameter estimation the objective function is QFI and in multiparameter estimation it will be $\\mathrm{Tr}(WF^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). \"\"\" if LDtype != \"SLD\" and LDtype != \"RLD\" and LDtype != \"LLD\" : raise ValueError ( \" {!r} is not a valid value for LDtype, supported values are 'SLD', 'RLD' and 'LLD'.\" . format ( LDtype ) ) if W == []: W = np . eye ( len ( self . Hamiltonian_derivative )) self . W = W self . obj = Main . QuanEstimation . QFIM_obj ( self . W , self . eps , self . para_type , LDtype ) system = Main . QuanEstimation . QuanEstSystem ( self . opt , self . alg , self . obj , self . dynamic , self . output ) Main . QuanEstimation . run ( system ) def CFIM ( self , M = [], W = []): r \"\"\" Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **M:** `list` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" if M == []: M = SIC ( len ( self . rho0 )) M = [ np . array ( x , dtype = np . complex128 ) for x in M ] if W == []: W = np . eye ( len ( self . Hamiltonian_derivative )) self . W = W self . obj = Main . QuanEstimation . CFIM_obj ( M , self . W , self . eps , self . para_type ) system = Main . QuanEstimation . QuanEstSystem ( self . opt , self . alg , self . obj , self . dynamic , self . output ) Main . QuanEstimation . run ( system ) def HCRB ( self , W = []): \"\"\" Choose HCRB as the objective function. **Notes:** (1) In single parameter estimation, HCRB is equivalent to QFI, please choose QFI as the objective function. (2) GRAPE and auto-GRAPE are not available when the objective function is HCRB. Supported methods are PSO, DE and DDPG. Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" if W == []: W = np . eye ( len ( self . Hamiltonian_derivative )) self . W = W if len ( self . Hamiltonian_derivative ) == 1 : print ( \"Program terminated. In the single-parameter scenario, HCRB is equivalent to QFI. Please choose QFIM as the objective function.\" ) else : if W == []: W = np . eye ( len ( self . Hamiltonian_derivative )) self . W = W self . obj = Main . QuanEstimation . HCRB_obj ( self . W , self . eps , self . para_type ) system = Main . QuanEstimation . QuanEstSystem ( self . opt , self . alg , self . obj , self . dynamic , self . output ) Main . QuanEstimation . run ( system ) def mintime ( self , f , W = [], M = [], method = \"binary\" , target = \"QFIM\" , LDtype = \"SLD\" ): \"\"\" Search of the minimum time to reach a given value of the objective function. Parameters ---------- > **f:** `float` -- The given value of the objective function. > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). > **method:** `string` -- Methods for searching the minimum time to reach the given value of the objective function. Options are: \"binary\" (default) -- Binary search (logarithmic search). \"forward\" -- Forward search from the beginning of time. > **target:** `string` -- Objective functions for searching the minimum time to reach the given value of the objective function. Options are: \"QFIM\" (default) -- Choose QFI (QFIM) as the objective function. \"CFIM\" -- Choose CFI (CFIM) as the objective function. \"HCRB\" -- Choose HCRB as the objective function. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). \"\"\" if not ( method == \"binary\" or method == \"forward\" ): raise ValueError ( \" {!r} is not a valid value for method, supported values are 'binary' and 'forward'.\" . format ( method ) ) if self . dynamics_type != \"lindblad\" : raise ValueError ( \"Supported type of dynamics is Lindblad.\" ) if self . savefile == True : warnings . warn ( \"savefile is set to be False\" , DeprecationWarning , ) self . output = Main . QuanEstimation . Output ( self . opt ) if len ( self . Hamiltonian_derivative ) > 1 : f = 1 / f if W == []: W = np . eye ( len ( self . Hamiltonian_derivative )) self . W = W if M != []: M = [ np . array ( x , dtype = np . complex128 ) for x in M ] self . obj = Main . QuanEstimation . CFIM_obj ( M , self . W , self . eps , self . para_type ) else : if target == \"HCRB\" : if self . para_type == \"single_para\" : print ( \"Program terminated. In the single-parameter scenario, the HCRB is equivalent to the QFI. Please choose 'QFIM' as the objective function.\" ) self . obj = Main . QuanEstimation . HCRB_obj ( self . W , self . eps , self . para_type ) elif target == \"QFIM\" or ( LDtype == \"SLD\" and LDtype == \"LLD\" and LDtype == \"RLD\" ): self . obj = Main . QuanEstimation . QFIM_obj ( self . W , self . eps , self . para_type , LDtype ) else : raise ValueError ( \"Please enter the correct values for target and LDtype. Supported target are 'QFIM', 'CFIM' and 'HCRB', supported LDtype are 'SLD', 'RLD' and 'LLD'.\" ) system = Main . QuanEstimation . QuanEstSystem ( self . opt , self . alg , self . obj , self . dynamic , self . output ) Main . QuanEstimation . mintime ( method , f , system ) CFIM ( M = [], W = []) \u00b6 Choose CFI or \\(\\mathrm{Tr}(WI^{-1})\\) as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be \\(\\mathrm{Tr}(WI^{-1})\\) . Parameters \u00b6 W: matrix -- Weight matrix. M: list -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). Note: SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from here . Source code in quanestimation/ControlOpt/ControlStruct.py 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 def CFIM ( self , M = [], W = []): r \"\"\" Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **M:** `list` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" if M == []: M = SIC ( len ( self . rho0 )) M = [ np . array ( x , dtype = np . complex128 ) for x in M ] if W == []: W = np . eye ( len ( self . Hamiltonian_derivative )) self . W = W self . obj = Main . QuanEstimation . CFIM_obj ( M , self . W , self . eps , self . para_type ) system = Main . QuanEstimation . QuanEstSystem ( self . opt , self . alg , self . obj , self . dynamic , self . output ) Main . QuanEstimation . run ( system ) HCRB ( W = []) \u00b6 Choose HCRB as the objective function. Notes: (1) In single parameter estimation, HCRB is equivalent to QFI, please choose QFI as the objective function. (2) GRAPE and auto-GRAPE are not available when the objective function is HCRB. Supported methods are PSO, DE and DDPG. Parameters \u00b6 W: matrix -- Weight matrix. Source code in quanestimation/ControlOpt/ControlStruct.py 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 def HCRB ( self , W = []): \"\"\" Choose HCRB as the objective function. **Notes:** (1) In single parameter estimation, HCRB is equivalent to QFI, please choose QFI as the objective function. (2) GRAPE and auto-GRAPE are not available when the objective function is HCRB. Supported methods are PSO, DE and DDPG. Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" if W == []: W = np . eye ( len ( self . Hamiltonian_derivative )) self . W = W if len ( self . Hamiltonian_derivative ) == 1 : print ( \"Program terminated. In the single-parameter scenario, HCRB is equivalent to QFI. Please choose QFIM as the objective function.\" ) else : if W == []: W = np . eye ( len ( self . Hamiltonian_derivative )) self . W = W self . obj = Main . QuanEstimation . HCRB_obj ( self . W , self . eps , self . para_type ) system = Main . QuanEstimation . QuanEstSystem ( self . opt , self . alg , self . obj , self . dynamic , self . output ) Main . QuanEstimation . run ( system ) QFIM ( W = [], LDtype = 'SLD' ) \u00b6 Choose QFI or \\(\\mathrm{Tr}(WF^{-1})\\) as the objective function. In single parameter estimation the objective function is QFI and in multiparameter estimation it will be \\(\\mathrm{Tr}(WF^{-1})\\) . Parameters \u00b6 W: matrix -- Weight matrix. LDtype: string -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). Source code in quanestimation/ControlOpt/ControlStruct.py 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 def QFIM ( self , W = [], LDtype = \"SLD\" ): r \"\"\" Choose QFI or $\\mathrm{Tr}(WF^{-1})$ as the objective function. In single parameter estimation the objective function is QFI and in multiparameter estimation it will be $\\mathrm{Tr}(WF^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). \"\"\" if LDtype != \"SLD\" and LDtype != \"RLD\" and LDtype != \"LLD\" : raise ValueError ( \" {!r} is not a valid value for LDtype, supported values are 'SLD', 'RLD' and 'LLD'.\" . format ( LDtype ) ) if W == []: W = np . eye ( len ( self . Hamiltonian_derivative )) self . W = W self . obj = Main . QuanEstimation . QFIM_obj ( self . W , self . eps , self . para_type , LDtype ) system = Main . QuanEstimation . QuanEstSystem ( self . opt , self . alg , self . obj , self . dynamic , self . output ) Main . QuanEstimation . run ( system ) dynamics ( tspan , rho0 , H0 , dH , Hc , decay = [], ctrl_bound = []) \u00b6 The dynamics of a density matrix is of the form \\[\\begin{align} \\partial_t\\rho &=\\mathcal{L}\\rho \\nonumber \\\\ &=-i[H,\\rho]+\\sum_i \\gamma_i\\left(\\Gamma_i\\rho\\Gamma^{\\dagger}_i-\\frac{1}{2} \\left\\{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\right\\}\\right), \\end{align}\\] where \\(\\rho\\) is the evolved density matrix, H is the Hamiltonian of the system, \\(\\Gamma_i\\) and \\(\\gamma_i\\) are the \\(i\\mathrm{th}\\) decay operator and corresponding decay rate. Parameters \u00b6 tspan: array -- Time length for the evolution. rho0: matrix -- Initial state (density matrix). H0: matrix or list -- Free Hamiltonian. It is a matrix when the free Hamiltonian is time- independent and a list of length equal to tspan when it is time-dependent. dH: list -- Derivatives of the free Hamiltonian on the unknown parameters to be estimated. For example, dH[0] is the derivative vector on the first parameter. Hc: list -- Control Hamiltonians. decay: list -- Decay operators and the corresponding decay rates. Its input rule is decay=[[ \\(\\Gamma_1\\) , \\(\\gamma_1\\) ], [ \\(\\Gamma_2\\) , \\(\\gamma_2\\) ],...], where \\(\\Gamma_1\\) \\((\\Gamma_2)\\) represents the decay operator and \\(\\gamma_1\\) \\((\\gamma_2)\\) is the corresponding decay rate. ctrl_bound: array -- Lower and upper bounds of the control coefficients. ctrl_bound[0] represents the lower bound of the control coefficients and ctrl_bound[1] represents the upper bound of the control coefficients. Source code in quanestimation/ControlOpt/ControlStruct.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 def dynamics ( self , tspan , rho0 , H0 , dH , Hc , decay = [], ctrl_bound = []): r \"\"\" The dynamics of a density matrix is of the form \\begin{align} \\partial_t\\rho &=\\mathcal{L}\\rho \\nonumber \\\\ &=-i[H,\\rho]+\\sum_i \\gamma_i\\left(\\Gamma_i\\rho\\Gamma^{\\dagger}_i-\\frac{1}{2} \\left\\{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\right\\}\\right), \\end{align} where $\\rho$ is the evolved density matrix, H is the Hamiltonian of the system, $\\Gamma_i$ and $\\gamma_i$ are the $i\\mathrm{th}$ decay operator and corresponding decay rate. Parameters ---------- > **tspan:** `array` -- Time length for the evolution. > **rho0:** `matrix` -- Initial state (density matrix). > **H0:** `matrix or list` -- Free Hamiltonian. It is a matrix when the free Hamiltonian is time- independent and a list of length equal to `tspan` when it is time-dependent. > **dH:** `list` -- Derivatives of the free Hamiltonian on the unknown parameters to be estimated. For example, dH[0] is the derivative vector on the first parameter. > **Hc:** `list` -- Control Hamiltonians. > **decay:** `list` -- Decay operators and the corresponding decay rates. Its input rule is decay=[[$\\Gamma_1$, $\\gamma_1$], [$\\Gamma_2$,$\\gamma_2$],...], where $\\Gamma_1$ $(\\Gamma_2)$ represents the decay operator and $\\gamma_1$ $(\\gamma_2)$ is the corresponding decay rate. > **ctrl_bound:** `array` -- Lower and upper bounds of the control coefficients. `ctrl_bound[0]` represents the lower bound of the control coefficients and `ctrl_bound[1]` represents the upper bound of the control coefficients. \"\"\" self . tspan = tspan self . rho0 = np . array ( rho0 , dtype = np . complex128 ) if type ( H0 ) == np . ndarray : self . freeHamiltonian = np . array ( H0 , dtype = np . complex128 ) else : self . freeHamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in H0 [: - 1 ]] if Hc == []: Hc = [ np . zeros (( len ( self . rho0 ), len ( self . rho0 )))] self . control_Hamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in Hc ] if type ( dH ) != list : raise TypeError ( \"The derivative of Hamiltonian should be a list!\" ) if dH == []: dH = [ np . zeros (( len ( self . rho0 ), len ( self . rho0 )))] self . Hamiltonian_derivative = [ np . array ( x , dtype = np . complex128 ) for x in dH ] if len ( dH ) == 1 : self . para_type = \"single_para\" else : self . para_type = \"multi_para\" if decay == []: decay_opt = [ np . zeros (( len ( self . rho0 ), len ( self . rho0 )))] self . gamma = [ 0.0 ] else : decay_opt = [ decay [ i ][ 0 ] for i in range ( len ( decay ))] self . gamma = [ decay [ i ][ 1 ] for i in range ( len ( decay ))] self . decay_opt = [ np . array ( x , dtype = np . complex128 ) for x in decay_opt ] if ctrl_bound == []: self . ctrl_bound = [ - np . inf , np . inf ] else : self . ctrl_bound = [ float ( ctrl_bound [ 0 ]), float ( ctrl_bound [ 1 ])] if self . ctrl0 == []: if ctrl_bound == []: ctrl0 = [ 2 * np . random . random ( len ( self . tspan ) - 1 ) - np . ones ( len ( self . tspan ) - 1 ) for i in range ( len ( self . control_Hamiltonian )) ] self . control_coefficients = ctrl0 self . ctrl0 = [ np . array ( ctrl0 )] else : a = ctrl_bound [ 0 ] b = ctrl_bound [ 1 ] ctrl0 = [ ( b - a ) * np . random . random ( len ( self . tspan ) - 1 ) + a * np . ones ( len ( self . tspan ) - 1 ) for i in range ( len ( self . control_Hamiltonian )) ] self . control_coefficients = ctrl0 self . ctrl0 = [ np . array ( ctrl0 )] elif len ( self . ctrl0 ) >= 1 : self . control_coefficients = [ self . ctrl0 [ 0 ][ i ] for i in range ( len ( self . control_Hamiltonian )) ] if self . load == True : if os . path . exists ( \"controls.csv\" ): data = np . genfromtxt ( \"controls.csv\" )[ - len ( self . control_Hamiltonian ) :] self . control_coefficients = [ data [ i ] for i in range ( len ( data ))] ctrl_num = len ( self . control_coefficients ) Hc_num = len ( self . control_Hamiltonian ) if Hc_num < ctrl_num : raise TypeError ( \"There are %d control Hamiltonians but %d coefficients sequences: too many coefficients sequences\" % ( Hc_num , ctrl_num ) ) elif Hc_num > ctrl_num : warnings . warn ( \"Not enough coefficients sequences: there are %d control Hamiltonians but %d coefficients sequences. The rest of the control sequences are set to be 0.\" % ( Hc_num , ctrl_num ), DeprecationWarning , ) for i in range ( Hc_num - ctrl_num ): self . control_coefficients = np . concatenate ( ( self . control_coefficients , np . zeros ( len ( self . control_coefficients [ 0 ])), ) ) else : pass if type ( H0 ) != np . ndarray : #### linear interpolation #### f = interp1d ( self . tspan , H0 , axis = 0 ) else : pass number = math . ceil (( len ( self . tspan ) - 1 ) / len ( self . control_coefficients [ 0 ])) if len ( self . tspan ) - 1 % len ( self . control_coefficients [ 0 ]) != 0 : tnum = number * len ( self . control_coefficients [ 0 ]) self . tspan = np . linspace ( self . tspan [ 0 ], self . tspan [ - 1 ], tnum + 1 ) if type ( H0 ) != np . ndarray : H0_inter = f ( self . tspan ) self . freeHamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in H0_inter [: - 1 ]] else : pass else : pass self . opt = Main . QuanEstimation . ControlOpt ( ctrl = self . control_coefficients , ctrl_bound = self . ctrl_bound , seed = self . seed ) self . dynamic = Main . QuanEstimation . Lindblad ( self . freeHamiltonian , self . Hamiltonian_derivative , self . control_Hamiltonian , self . control_coefficients , self . rho0 , self . tspan , self . decay_opt , self . gamma , ) self . output = Main . QuanEstimation . Output ( self . opt , save = self . savefile ) self . dynamics_type = \"lindblad\" mintime ( f , W = [], M = [], method = 'binary' , target = 'QFIM' , LDtype = 'SLD' ) \u00b6 Search of the minimum time to reach a given value of the objective function. Parameters \u00b6 f: float -- The given value of the objective function. W: matrix -- Weight matrix. M: list of matrices -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). method: string -- Methods for searching the minimum time to reach the given value of the objective function. Options are: \"binary\" (default) -- Binary search (logarithmic search). \"forward\" -- Forward search from the beginning of time. target: string -- Objective functions for searching the minimum time to reach the given value of the objective function. Options are: \"QFIM\" (default) -- Choose QFI (QFIM) as the objective function. \"CFIM\" -- Choose CFI (CFIM) as the objective function. \"HCRB\" -- Choose HCRB as the objective function. LDtype: string -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). Source code in quanestimation/ControlOpt/ControlStruct.py 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 def mintime ( self , f , W = [], M = [], method = \"binary\" , target = \"QFIM\" , LDtype = \"SLD\" ): \"\"\" Search of the minimum time to reach a given value of the objective function. Parameters ---------- > **f:** `float` -- The given value of the objective function. > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). > **method:** `string` -- Methods for searching the minimum time to reach the given value of the objective function. Options are: \"binary\" (default) -- Binary search (logarithmic search). \"forward\" -- Forward search from the beginning of time. > **target:** `string` -- Objective functions for searching the minimum time to reach the given value of the objective function. Options are: \"QFIM\" (default) -- Choose QFI (QFIM) as the objective function. \"CFIM\" -- Choose CFI (CFIM) as the objective function. \"HCRB\" -- Choose HCRB as the objective function. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). \"\"\" if not ( method == \"binary\" or method == \"forward\" ): raise ValueError ( \" {!r} is not a valid value for method, supported values are 'binary' and 'forward'.\" . format ( method ) ) if self . dynamics_type != \"lindblad\" : raise ValueError ( \"Supported type of dynamics is Lindblad.\" ) if self . savefile == True : warnings . warn ( \"savefile is set to be False\" , DeprecationWarning , ) self . output = Main . QuanEstimation . Output ( self . opt ) if len ( self . Hamiltonian_derivative ) > 1 : f = 1 / f if W == []: W = np . eye ( len ( self . Hamiltonian_derivative )) self . W = W if M != []: M = [ np . array ( x , dtype = np . complex128 ) for x in M ] self . obj = Main . QuanEstimation . CFIM_obj ( M , self . W , self . eps , self . para_type ) else : if target == \"HCRB\" : if self . para_type == \"single_para\" : print ( \"Program terminated. In the single-parameter scenario, the HCRB is equivalent to the QFI. Please choose 'QFIM' as the objective function.\" ) self . obj = Main . QuanEstimation . HCRB_obj ( self . W , self . eps , self . para_type ) elif target == \"QFIM\" or ( LDtype == \"SLD\" and LDtype == \"LLD\" and LDtype == \"RLD\" ): self . obj = Main . QuanEstimation . QFIM_obj ( self . W , self . eps , self . para_type , LDtype ) else : raise ValueError ( \"Please enter the correct values for target and LDtype. Supported target are 'QFIM', 'CFIM' and 'HCRB', supported LDtype are 'SLD', 'RLD' and 'LLD'.\" ) system = Main . QuanEstimation . QuanEstSystem ( self . opt , self . alg , self . obj , self . dynamic , self . output ) Main . QuanEstimation . mintime ( method , f , system ) Control optimization with GRAPE and auto-GRAPE \u00b6 Bases: Control . ControlSystem Attributes \u00b6 savefile: bool -- Whether or not to save all the control coeffients. If set True then the control coefficients and the values of the objective function obtained in all episodes will be saved during the training. If set False the control coefficients in the final episode and the values of the objective function in all episodes will be saved. Adam: bool -- Whether or not to use Adam for updating control coefficients. ctrl0: list of arrays -- Initial guesses of control coefficients. max_episode: int -- The number of episodes. epsilon: float -- Learning rate. beta1: float -- The exponential decay rate for the first moment estimates. beta2: float -- The exponential decay rate for the second moment estimates. eps: float -- Machine epsilon. load: bool -- Whether or not to load control coefficients in the current location. If set True then the program will load control coefficients from \"controls.csv\" file in the current location and use it as the initial control coefficients. auto: bool -- Whether or not to invoke automatic differentiation algorithm to evaluate the gradient. If set True then the gradient will be calculated with automatic differentiation algorithm otherwise it will be calculated using analytical method. Source code in quanestimation/ControlOpt/GRAPE_Copt.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 class GRAPE_Copt ( Control . ControlSystem ): \"\"\" Attributes ---------- > **savefile:** `bool` -- Whether or not to save all the control coeffients. If set `True` then the control coefficients and the values of the objective function obtained in all episodes will be saved during the training. If set `False` the control coefficients in the final episode and the values of the objective function in all episodes will be saved. > **Adam:** `bool` -- Whether or not to use Adam for updating control coefficients. > **ctrl0:** `list of arrays` -- Initial guesses of control coefficients. > **max_episode:** `int` -- The number of episodes. > **epsilon:** `float` -- Learning rate. > **beta1:** `float` -- The exponential decay rate for the first moment estimates. > **beta2:** `float` -- The exponential decay rate for the second moment estimates. > **eps:** `float` -- Machine epsilon. > **load:** `bool` -- Whether or not to load control coefficients in the current location. If set `True` then the program will load control coefficients from \"controls.csv\" file in the current location and use it as the initial control coefficients. > **auto:** `bool` -- Whether or not to invoke automatic differentiation algorithm to evaluate the gradient. If set `True` then the gradient will be calculated with automatic differentiation algorithm otherwise it will be calculated using analytical method. \"\"\" def __init__ ( self , savefile = False , Adam = True , ctrl0 = [], max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 , eps = 1e-8 , seed = 1234 , load = False , auto = True , ): Control . ControlSystem . __init__ ( self , savefile , ctrl0 , eps , load ) self . Adam = Adam self . max_episode = max_episode self . epsilon = epsilon self . beta1 = beta1 self . beta2 = beta2 self . mt = 0.0 self . vt = 0.0 self . seed = seed self . auto = auto def QFIM ( self , W = [], LDtype = \"SLD\" ): r \"\"\" Choose QFI or $\\mathrm{Tr}(WF^{-1})$ as the objective function. In single parameter estimation the objective function is QFI and in multiparameter estimation it will be $\\mathrm{Tr}(WF^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). \"\"\" if self . auto : if self . Adam : self . alg = Main . QuanEstimation . autoGRAPE ( self . max_episode , self . epsilon , self . beta1 , self . beta2 ) else : self . alg = Main . QuanEstimation . autoGRAPE ( self . max_episode , self . epsilon ) else : if ( len ( self . tspan ) - 1 ) != len ( self . control_coefficients [ 0 ]): warnings . warn ( \"GRAPE is not available when the length of each control is not \\ equal to the length of time, and is replaced by auto-GRAPE.\" , DeprecationWarning ) #### call autoGRAPE automatically #### if self . Adam : self . alg = Main . QuanEstimation . autoGRAPE ( self . max_episode , self . epsilon , self . beta1 , self . beta2 ) else : self . alg = Main . QuanEstimation . autoGRAPE ( self . max_episode , self . epsilon ) else : if LDtype == \"SLD\" : if self . Adam : self . alg = Main . QuanEstimation . GRAPE ( self . max_episode , self . epsilon , self . beta1 , self . beta2 ) else : self . alg = Main . QuanEstimation . GRAPE ( self . max_episode , self . epsilon ) else : raise ValueError ( \"GRAPE is only available when LDtype is SLD.\" ) super () . QFIM ( W , LDtype ) def CFIM ( self , M = [], W = []): r \"\"\" Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" if self . auto : if self . Adam : self . alg = Main . QuanEstimation . autoGRAPE ( self . max_episode , self . epsilon , self . beta1 , self . beta2 ) else : self . alg = Main . QuanEstimation . autoGRAPE ( self . max_episode , self . epsilon ) else : if ( len ( self . tspan ) - 1 ) != len ( self . control_coefficients [ 0 ]): warnings . warn ( \"GRAPE is not available when the length of each control is not \\ equal to the length of time, and is replaced by auto-GRAPE.\" , DeprecationWarning ) #### call autoGRAPE automatically #### if self . Adam : self . alg = Main . QuanEstimation . autoGRAPE ( self . max_episode , self . epsilon , self . beta1 , self . beta2 ) else : self . alg = Main . QuanEstimation . autoGRAPE ( self . max_episode , self . epsilon ) else : if self . Adam : self . alg = Main . QuanEstimation . GRAPE ( self . max_episode , self . epsilon , self . beta1 , self . beta2 ) else : self . alg = Main . QuanEstimation . GRAPE ( self . max_episode , self . epsilon ) super () . CFIM ( M , W ) def HCRB ( self , W = []): \"\"\" GRAPE and auto-GRAPE are not available when the objective function is HCRB. Supported methods are PSO, DE and DDPG. Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" raise ValueError ( \"GRAPE and auto-GRAPE are not available when the objective function is HCRB. Supported methods are 'PSO', 'DE' and 'DDPG'.\" , ) def mintime ( self , f , W = [], M = [], method = \"binary\" , target = \"QFIM\" , LDtype = \"SLD\" ): \"\"\" Search of the minimum time to reach a given value of the objective function. Parameters ---------- > **f:** `float` -- The given value of the objective function. > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). > **method:** `string` -- Methods for searching the minimum time to reach the given value of the objective function. Options are: \"binary\" (default) -- Binary search (logarithmic search). \"forward\" -- Forward search from the beginning of time. > **target:** `string` -- Objective functions for searching the minimum time to reach the given value of the objective function. Options are: \"QFIM\" (default) -- Choose QFI (QFIM) as the objective function. \"CFIM\" -- Choose CFI (CFIM) as the objective function. \"HCRB\" -- Choose HCRB as the objective function. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" if target == \"HCRB\" : raise ValueError ( \"GRAPE and auto-GRAPE are not available when the objective function is HCRB. Supported methods are 'PSO', 'DE' and 'DDPG'.\" , ) if self . auto : if self . Adam : self . alg = Main . QuanEstimation . autoGRAPE ( self . max_episode , self . epsilon , self . beta1 , self . beta2 ) else : self . alg = Main . QuanEstimation . autoGRAPE ( self . max_episode , self . epsilon ) else : if self . Adam : self . alg = Main . QuanEstimation . GRAPE ( self . max_episode , self . epsilon , self . beta1 , self . beta2 ) else : self . alg = Main . QuanEstimation . GRAPE ( self . max_episode , self . epsilon ) super () . mintime ( f , W , M , method , target , LDtype ) CFIM ( M = [], W = []) \u00b6 Choose CFI or \\(\\mathrm{Tr}(WI^{-1})\\) as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be \\(\\mathrm{Tr}(WI^{-1})\\) . Parameters \u00b6 W: matrix -- Weight matrix. M: list of matrices -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). Note: SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from here . Source code in quanestimation/ControlOpt/GRAPE_Copt.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 def CFIM ( self , M = [], W = []): r \"\"\" Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" if self . auto : if self . Adam : self . alg = Main . QuanEstimation . autoGRAPE ( self . max_episode , self . epsilon , self . beta1 , self . beta2 ) else : self . alg = Main . QuanEstimation . autoGRAPE ( self . max_episode , self . epsilon ) else : if ( len ( self . tspan ) - 1 ) != len ( self . control_coefficients [ 0 ]): warnings . warn ( \"GRAPE is not available when the length of each control is not \\ equal to the length of time, and is replaced by auto-GRAPE.\" , DeprecationWarning ) #### call autoGRAPE automatically #### if self . Adam : self . alg = Main . QuanEstimation . autoGRAPE ( self . max_episode , self . epsilon , self . beta1 , self . beta2 ) else : self . alg = Main . QuanEstimation . autoGRAPE ( self . max_episode , self . epsilon ) else : if self . Adam : self . alg = Main . QuanEstimation . GRAPE ( self . max_episode , self . epsilon , self . beta1 , self . beta2 ) else : self . alg = Main . QuanEstimation . GRAPE ( self . max_episode , self . epsilon ) super () . CFIM ( M , W ) HCRB ( W = []) \u00b6 GRAPE and auto-GRAPE are not available when the objective function is HCRB. Supported methods are PSO, DE and DDPG. Parameters \u00b6 W: matrix -- Weight matrix. Source code in quanestimation/ControlOpt/GRAPE_Copt.py 179 180 181 182 183 184 185 186 187 188 189 190 191 def HCRB ( self , W = []): \"\"\" GRAPE and auto-GRAPE are not available when the objective function is HCRB. Supported methods are PSO, DE and DDPG. Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" raise ValueError ( \"GRAPE and auto-GRAPE are not available when the objective function is HCRB. Supported methods are 'PSO', 'DE' and 'DDPG'.\" , ) QFIM ( W = [], LDtype = 'SLD' ) \u00b6 Choose QFI or \\(\\mathrm{Tr}(WF^{-1})\\) as the objective function. In single parameter estimation the objective function is QFI and in multiparameter estimation it will be \\(\\mathrm{Tr}(WF^{-1})\\) . Parameters \u00b6 W: matrix -- Weight matrix. LDtype: string -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). Source code in quanestimation/ControlOpt/GRAPE_Copt.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 def QFIM ( self , W = [], LDtype = \"SLD\" ): r \"\"\" Choose QFI or $\\mathrm{Tr}(WF^{-1})$ as the objective function. In single parameter estimation the objective function is QFI and in multiparameter estimation it will be $\\mathrm{Tr}(WF^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). \"\"\" if self . auto : if self . Adam : self . alg = Main . QuanEstimation . autoGRAPE ( self . max_episode , self . epsilon , self . beta1 , self . beta2 ) else : self . alg = Main . QuanEstimation . autoGRAPE ( self . max_episode , self . epsilon ) else : if ( len ( self . tspan ) - 1 ) != len ( self . control_coefficients [ 0 ]): warnings . warn ( \"GRAPE is not available when the length of each control is not \\ equal to the length of time, and is replaced by auto-GRAPE.\" , DeprecationWarning ) #### call autoGRAPE automatically #### if self . Adam : self . alg = Main . QuanEstimation . autoGRAPE ( self . max_episode , self . epsilon , self . beta1 , self . beta2 ) else : self . alg = Main . QuanEstimation . autoGRAPE ( self . max_episode , self . epsilon ) else : if LDtype == \"SLD\" : if self . Adam : self . alg = Main . QuanEstimation . GRAPE ( self . max_episode , self . epsilon , self . beta1 , self . beta2 ) else : self . alg = Main . QuanEstimation . GRAPE ( self . max_episode , self . epsilon ) else : raise ValueError ( \"GRAPE is only available when LDtype is SLD.\" ) super () . QFIM ( W , LDtype ) mintime ( f , W = [], M = [], method = 'binary' , target = 'QFIM' , LDtype = 'SLD' ) \u00b6 Search of the minimum time to reach a given value of the objective function. Parameters \u00b6 f: float -- The given value of the objective function. W: matrix -- Weight matrix. M: list of matrices -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). method: string -- Methods for searching the minimum time to reach the given value of the objective function. Options are: \"binary\" (default) -- Binary search (logarithmic search). \"forward\" -- Forward search from the beginning of time. target: string -- Objective functions for searching the minimum time to reach the given value of the objective function. Options are: \"QFIM\" (default) -- Choose QFI (QFIM) as the objective function. \"CFIM\" -- Choose CFI (CFIM) as the objective function. \"HCRB\" -- Choose HCRB as the objective function. LDtype: string -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). Note: SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from here . Source code in quanestimation/ControlOpt/GRAPE_Copt.py 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 def mintime ( self , f , W = [], M = [], method = \"binary\" , target = \"QFIM\" , LDtype = \"SLD\" ): \"\"\" Search of the minimum time to reach a given value of the objective function. Parameters ---------- > **f:** `float` -- The given value of the objective function. > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). > **method:** `string` -- Methods for searching the minimum time to reach the given value of the objective function. Options are: \"binary\" (default) -- Binary search (logarithmic search). \"forward\" -- Forward search from the beginning of time. > **target:** `string` -- Objective functions for searching the minimum time to reach the given value of the objective function. Options are: \"QFIM\" (default) -- Choose QFI (QFIM) as the objective function. \"CFIM\" -- Choose CFI (CFIM) as the objective function. \"HCRB\" -- Choose HCRB as the objective function. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" if target == \"HCRB\" : raise ValueError ( \"GRAPE and auto-GRAPE are not available when the objective function is HCRB. Supported methods are 'PSO', 'DE' and 'DDPG'.\" , ) if self . auto : if self . Adam : self . alg = Main . QuanEstimation . autoGRAPE ( self . max_episode , self . epsilon , self . beta1 , self . beta2 ) else : self . alg = Main . QuanEstimation . autoGRAPE ( self . max_episode , self . epsilon ) else : if self . Adam : self . alg = Main . QuanEstimation . GRAPE ( self . max_episode , self . epsilon , self . beta1 , self . beta2 ) else : self . alg = Main . QuanEstimation . GRAPE ( self . max_episode , self . epsilon ) super () . mintime ( f , W , M , method , target , LDtype ) Control Optimization with PSO \u00b6 Bases: Control . ControlSystem Attributes \u00b6 savefile: bool -- Whether or not to save all the control coeffients. If set True then the control coefficients and the values of the objective function obtained in all episodes will be saved during the training. If set False the control coefficients in the final episode and the values of the objective function in all episodes will be saved. p_num: int -- The number of particles. ctrl0: list of arrays -- Initial guesses of control coefficients. max_episode: int or list -- If it is an integer, for example max_episode=1000, it means the program will continuously run 1000 episodes. However, if it is an array, for example max_episode=[1000,100], the program will run 1000 episodes in total but replace control coefficients of all the particles with global best every 100 episodes. c0: float -- The damping factor that assists convergence, also known as inertia weight. c1: float -- The exploitation weight that attracts the particle to its best previous position, also known as cognitive learning factor. c2: float -- The exploitation weight that attracts the particle to the best position in the neighborhood, also known as social learning factor. seed: int -- Random seed. eps: float -- Machine epsilon. load: bool -- Whether or not to load control coefficients in the current location. If set True then the program will load control coefficients from \"controls.csv\" file in the current location and use it as the initial control coefficients. Source code in quanestimation/ControlOpt/PSO_Copt.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 class PSO_Copt ( Control . ControlSystem ): \"\"\" Attributes ---------- > **savefile:** `bool` -- Whether or not to save all the control coeffients. If set `True` then the control coefficients and the values of the objective function obtained in all episodes will be saved during the training. If set `False` the control coefficients in the final episode and the values of the objective function in all episodes will be saved. > **p_num:** `int` -- The number of particles. > **ctrl0:** `list of arrays` -- Initial guesses of control coefficients. > **max_episode:** `int or list` -- If it is an integer, for example max_episode=1000, it means the program will continuously run 1000 episodes. However, if it is an array, for example max_episode=[1000,100], the program will run 1000 episodes in total but replace control coefficients of all the particles with global best every 100 episodes. > **c0:** `float` -- The damping factor that assists convergence, also known as inertia weight. > **c1:** `float` -- The exploitation weight that attracts the particle to its best previous position, also known as cognitive learning factor. > **c2:** `float` -- The exploitation weight that attracts the particle to the best position in the neighborhood, also known as social learning factor. > **seed:** `int` -- Random seed. > **eps:** `float` -- Machine epsilon. > **load:** `bool` -- Whether or not to load control coefficients in the current location. If set `True` then the program will load control coefficients from \"controls.csv\" file in the current location and use it as the initial control coefficients. \"\"\" def __init__ ( self , savefile = False , p_num = 10 , ctrl0 = [], max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 , seed = 1234 , eps = 1e-8 , load = False , ): Control . ControlSystem . __init__ ( self , savefile , ctrl0 , eps , load ) self . max_episode = max_episode self . p_num = p_num self . c0 = c0 self . c1 = c1 self . c2 = c2 self . seed = seed def QFIM ( self , W = [], LDtype = \"SLD\" ): r \"\"\" Choose QFI or $\\mathrm{Tr}(WF^{-1})$ as the objective function. In single parameter estimation the objective function is QFI and in multiparameter estimation it will be $\\mathrm{Tr}(WF^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). \"\"\" ini_particle = ([ self . ctrl0 ],) self . alg = Main . QuanEstimation . PSO ( self . max_episode , self . p_num , ini_particle , self . c0 , self . c1 , self . c2 , ) super () . QFIM ( W , LDtype ) def CFIM ( self , M = [], W = []): r \"\"\" Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" ini_particle = ([ self . ctrl0 ],) self . alg = Main . QuanEstimation . PSO ( self . max_episode , self . p_num , ini_particle , self . c0 , self . c1 , self . c2 , ) super () . CFIM ( M , W ) def HCRB ( self , W = []): \"\"\" Choose HCRB as the objective function. **Note:** in single parameter estimation, HCRB is equivalent to QFI, please choose QFI as the objective function. Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" ini_particle = ([ self . ctrl0 ],) self . alg = Main . QuanEstimation . PSO ( self . max_episode , self . p_num , ini_particle , self . c0 , self . c1 , self . c2 , ) super () . HCRB ( W ) def mintime ( self , f , W = [], M = [], method = \"binary\" , target = \"QFIM\" , LDtype = \"SLD\" ): \"\"\" Search of the minimum time to reach a given value of the objective function. Parameters ---------- > **f:** `float` -- The given value of the objective function. > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). > **method:** `string` -- Methods for searching the minimum time to reach the given value of the objective function. Options are: \"binary\" (default) -- Binary search (logarithmic search). \"forward\" -- Forward search from the beginning of time. > **target:** `string` -- Objective functions for searching the minimum time to reach the given value of the objective function. Options are: \"QFIM\" (default) -- Choose QFI (QFIM) as the objective function. \"CFIM\" -- Choose CFI (CFIM) as the objective function. \"HCRB\" -- Choose HCRB as the objective function. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" ini_particle = ([ self . ctrl0 ],) self . alg = Main . QuanEstimation . PSO ( self . max_episode , self . p_num , ini_particle , self . c0 , self . c1 , self . c2 , ) super () . mintime ( f , W , M , method , target , LDtype ) CFIM ( M = [], W = []) \u00b6 Choose CFI or \\(\\mathrm{Tr}(WI^{-1})\\) as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be \\(\\mathrm{Tr}(WI^{-1})\\) . Parameters \u00b6 W: matrix -- Weight matrix. M: list of matrices -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). Note: SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from here . Source code in quanestimation/ControlOpt/PSO_Copt.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 def CFIM ( self , M = [], W = []): r \"\"\" Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" ini_particle = ([ self . ctrl0 ],) self . alg = Main . QuanEstimation . PSO ( self . max_episode , self . p_num , ini_particle , self . c0 , self . c1 , self . c2 , ) super () . CFIM ( M , W ) HCRB ( W = []) \u00b6 Choose HCRB as the objective function. Note: in single parameter estimation, HCRB is equivalent to QFI, please choose QFI as the objective function. Parameters \u00b6 W: matrix -- Weight matrix. Source code in quanestimation/ControlOpt/PSO_Copt.py 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 def HCRB ( self , W = []): \"\"\" Choose HCRB as the objective function. **Note:** in single parameter estimation, HCRB is equivalent to QFI, please choose QFI as the objective function. Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" ini_particle = ([ self . ctrl0 ],) self . alg = Main . QuanEstimation . PSO ( self . max_episode , self . p_num , ini_particle , self . c0 , self . c1 , self . c2 , ) super () . HCRB ( W ) QFIM ( W = [], LDtype = 'SLD' ) \u00b6 Choose QFI or \\(\\mathrm{Tr}(WF^{-1})\\) as the objective function. In single parameter estimation the objective function is QFI and in multiparameter estimation it will be \\(\\mathrm{Tr}(WF^{-1})\\) . Parameters \u00b6 W: matrix -- Weight matrix. LDtype: string -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). Source code in quanestimation/ControlOpt/PSO_Copt.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def QFIM ( self , W = [], LDtype = \"SLD\" ): r \"\"\" Choose QFI or $\\mathrm{Tr}(WF^{-1})$ as the objective function. In single parameter estimation the objective function is QFI and in multiparameter estimation it will be $\\mathrm{Tr}(WF^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). \"\"\" ini_particle = ([ self . ctrl0 ],) self . alg = Main . QuanEstimation . PSO ( self . max_episode , self . p_num , ini_particle , self . c0 , self . c1 , self . c2 , ) super () . QFIM ( W , LDtype ) mintime ( f , W = [], M = [], method = 'binary' , target = 'QFIM' , LDtype = 'SLD' ) \u00b6 Search of the minimum time to reach a given value of the objective function. Parameters \u00b6 f: float -- The given value of the objective function. W: matrix -- Weight matrix. M: list of matrices -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). method: string -- Methods for searching the minimum time to reach the given value of the objective function. Options are: \"binary\" (default) -- Binary search (logarithmic search). \"forward\" -- Forward search from the beginning of time. target: string -- Objective functions for searching the minimum time to reach the given value of the objective function. Options are: \"QFIM\" (default) -- Choose QFI (QFIM) as the objective function. \"CFIM\" -- Choose CFI (CFIM) as the objective function. \"HCRB\" -- Choose HCRB as the objective function. LDtype: string -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). Note: SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from here . Source code in quanestimation/ControlOpt/PSO_Copt.py 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 def mintime ( self , f , W = [], M = [], method = \"binary\" , target = \"QFIM\" , LDtype = \"SLD\" ): \"\"\" Search of the minimum time to reach a given value of the objective function. Parameters ---------- > **f:** `float` -- The given value of the objective function. > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). > **method:** `string` -- Methods for searching the minimum time to reach the given value of the objective function. Options are: \"binary\" (default) -- Binary search (logarithmic search). \"forward\" -- Forward search from the beginning of time. > **target:** `string` -- Objective functions for searching the minimum time to reach the given value of the objective function. Options are: \"QFIM\" (default) -- Choose QFI (QFIM) as the objective function. \"CFIM\" -- Choose CFI (CFIM) as the objective function. \"HCRB\" -- Choose HCRB as the objective function. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" ini_particle = ([ self . ctrl0 ],) self . alg = Main . QuanEstimation . PSO ( self . max_episode , self . p_num , ini_particle , self . c0 , self . c1 , self . c2 , ) super () . mintime ( f , W , M , method , target , LDtype ) Control Optimization DE \u00b6 Bases: Control . ControlSystem Attributes \u00b6 savefile: bool --Whether or not to save all the control coeffients. If set True then the control coefficients and the values of the objective function obtained in all episodes will be saved during the training. If set False the control coefficients in the final episode and the values of the objective function in all episodes will be saved. p_num: int -- The number of populations. ctrl0: list of arrays -- Initial guesses of control coefficients. max_episode: int -- The number of episodes. c: float -- Mutation constant. cr: float -- Crossover constant. seed: int -- Random seed. eps: float -- Machine epsilon. load: bool -- Whether or not to load control coefficients in the current location. If set True then the program will load control coefficients from \"controls.csv\" file in the current location and use it as the initial control coefficients. Source code in quanestimation/ControlOpt/DE_Copt.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 class DE_Copt ( Control . ControlSystem ): \"\"\" Attributes ---------- > **savefile:** `bool` --Whether or not to save all the control coeffients. If set `True` then the control coefficients and the values of the objective function obtained in all episodes will be saved during the training. If set `False` the control coefficients in the final episode and the values of the objective function in all episodes will be saved. > **p_num:** `int` -- The number of populations. > **ctrl0:** list of arrays -- Initial guesses of control coefficients. > **max_episode:** `int` -- The number of episodes. > **c:** `float` -- Mutation constant. > **cr:** `float` -- Crossover constant. > **seed:** `int` -- Random seed. > **eps:** `float` -- Machine epsilon. > **load:** `bool` -- Whether or not to load control coefficients in the current location. If set `True` then the program will load control coefficients from \"controls.csv\" file in the current location and use it as the initial control coefficients. \"\"\" def __init__ ( self , savefile = False , p_num = 10 , ctrl0 = [], max_episode = 1000 , c = 1.0 , cr = 0.5 , seed = 1234 , eps = 1e-8 , load = False , ): Control . ControlSystem . __init__ ( self , savefile , ctrl0 , eps , load ) self . p_num = p_num self . max_episode = max_episode self . c = c self . cr = cr self . seed = seed def QFIM ( self , W = [], LDtype = \"SLD\" ): r \"\"\" Choose QFI or $\\mathrm{Tr}(WF^{-1})$ as the objective function. In single parameter estimation the objective function is QFI and in multiparameter estimation it will be $\\mathrm{Tr}(WF^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). \"\"\" ini_population = ([ self . ctrl0 ],) self . alg = Main . QuanEstimation . DE ( self . max_episode , self . p_num , ini_population , self . c , self . cr , ) super () . QFIM ( W , LDtype ) def CFIM ( self , M = [], W = []): r \"\"\" Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" ini_population = ([ self . ctrl0 ],) self . alg = Main . QuanEstimation . DE ( self . max_episode , self . p_num , ini_population , self . c , self . cr , ) super () . CFIM ( M , W ) def HCRB ( self , W = []): \"\"\" Choose HCRB as the objective function. **Note:** in single parameter estimation, HCRB is equivalent to QFI, please choose QFI as the objective function. Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" ini_population = ([ self . ctrl0 ],) self . alg = Main . QuanEstimation . DE ( self . max_episode , self . p_num , ini_population , self . c , self . cr , ) super () . HCRB ( W ) def mintime ( self , f , W = [], M = [], method = \"binary\" , target = \"QFIM\" , LDtype = \"SLD\" ): \"\"\" Search of the minimum time to reach a given value of the objective function. Parameters ---------- > **f:** `float` -- The given value of the objective function. > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). > **method:** `string` -- Methods for searching the minimum time to reach the given value of the objective function. Options are: \"binary\" (default) -- Binary search (logarithmic search). \"forward\" -- Forward search from the beginning of time. > **target:** `string` -- Objective functions for searching the minimum time to reach the given value of the objective function. Options are:<br> \"QFIM\" (default) -- Choose QFI (QFIM) as the objective function.<br> \"CFIM\" -- Choose CFI (CFIM) as the objective function.<br> \"HCRB\" -- Choose HCRB as the objective function. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" ini_population = ([ self . ctrl0 ],) self . alg = Main . QuanEstimation . DE ( self . max_episode , self . p_num , ini_population , self . c , self . cr , ) super () . mintime ( f , W , M , method , target , LDtype ) CFIM ( M = [], W = []) \u00b6 Choose CFI or \\(\\mathrm{Tr}(WI^{-1})\\) as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be \\(\\mathrm{Tr}(WI^{-1})\\) . Parameters \u00b6 W: matrix -- Weight matrix. M: list of matrices -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). Note: SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from here . Source code in quanestimation/ControlOpt/DE_Copt.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 def CFIM ( self , M = [], W = []): r \"\"\" Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" ini_population = ([ self . ctrl0 ],) self . alg = Main . QuanEstimation . DE ( self . max_episode , self . p_num , ini_population , self . c , self . cr , ) super () . CFIM ( M , W ) HCRB ( W = []) \u00b6 Choose HCRB as the objective function. Note: in single parameter estimation, HCRB is equivalent to QFI, please choose QFI as the objective function. Parameters \u00b6 W: matrix -- Weight matrix. Source code in quanestimation/ControlOpt/DE_Copt.py 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 def HCRB ( self , W = []): \"\"\" Choose HCRB as the objective function. **Note:** in single parameter estimation, HCRB is equivalent to QFI, please choose QFI as the objective function. Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" ini_population = ([ self . ctrl0 ],) self . alg = Main . QuanEstimation . DE ( self . max_episode , self . p_num , ini_population , self . c , self . cr , ) super () . HCRB ( W ) QFIM ( W = [], LDtype = 'SLD' ) \u00b6 Choose QFI or \\(\\mathrm{Tr}(WF^{-1})\\) as the objective function. In single parameter estimation the objective function is QFI and in multiparameter estimation it will be \\(\\mathrm{Tr}(WF^{-1})\\) . Parameters \u00b6 W: matrix -- Weight matrix. LDtype: string -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). Source code in quanestimation/ControlOpt/DE_Copt.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 def QFIM ( self , W = [], LDtype = \"SLD\" ): r \"\"\" Choose QFI or $\\mathrm{Tr}(WF^{-1})$ as the objective function. In single parameter estimation the objective function is QFI and in multiparameter estimation it will be $\\mathrm{Tr}(WF^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). \"\"\" ini_population = ([ self . ctrl0 ],) self . alg = Main . QuanEstimation . DE ( self . max_episode , self . p_num , ini_population , self . c , self . cr , ) super () . QFIM ( W , LDtype ) mintime ( f , W = [], M = [], method = 'binary' , target = 'QFIM' , LDtype = 'SLD' ) \u00b6 Search of the minimum time to reach a given value of the objective function. Parameters \u00b6 f: float -- The given value of the objective function. W: matrix -- Weight matrix. M: list of matrices -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). method: string -- Methods for searching the minimum time to reach the given value of the objective function. Options are: \"binary\" (default) -- Binary search (logarithmic search). \"forward\" -- Forward search from the beginning of time. target: string -- Objective functions for searching the minimum time to reach the given value of the objective function. Options are: \"QFIM\" (default) -- Choose QFI (QFIM) as the objective function. \"CFIM\" -- Choose CFI (CFIM) as the objective function. \"HCRB\" -- Choose HCRB as the objective function. LDtype: string -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). Note: SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from here . Source code in quanestimation/ControlOpt/DE_Copt.py 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 def mintime ( self , f , W = [], M = [], method = \"binary\" , target = \"QFIM\" , LDtype = \"SLD\" ): \"\"\" Search of the minimum time to reach a given value of the objective function. Parameters ---------- > **f:** `float` -- The given value of the objective function. > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). > **method:** `string` -- Methods for searching the minimum time to reach the given value of the objective function. Options are: \"binary\" (default) -- Binary search (logarithmic search). \"forward\" -- Forward search from the beginning of time. > **target:** `string` -- Objective functions for searching the minimum time to reach the given value of the objective function. Options are:<br> \"QFIM\" (default) -- Choose QFI (QFIM) as the objective function.<br> \"CFIM\" -- Choose CFI (CFIM) as the objective function.<br> \"HCRB\" -- Choose HCRB as the objective function. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" ini_population = ([ self . ctrl0 ],) self . alg = Main . QuanEstimation . DE ( self . max_episode , self . p_num , ini_population , self . c , self . cr , ) super () . mintime ( f , W , M , method , target , LDtype ) Control Optimization with DDPG \u00b6 Bases: Control . ControlSystem Attributes \u00b6 savefile: bool -- Whether or not to save all the control coeffients. If set True then the control coefficients and the values of the objective function obtained in all episodes will be saved during the training. If set False the control coefficients in the final episode and the values of the objective function in all episodes will be saved. ctrl0: list of arrays -- Initial guesses of control coefficients. max_episode: int -- The number of episodes. layer_num: int -- The number of layers (include the input and output layer). layer_dim: int -- The number of neurons in the hidden layer. seed: int -- Random seed. eps: float -- Machine epsilon. load: bool -- Whether or not to load control coefficients in the current location. If set True then the program will load control coefficients from \"controls.csv\" file in the current location and use it as the initial control coefficients. Source code in quanestimation/ControlOpt/DDPG_Copt.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 class DDPG_Copt ( Control . ControlSystem ): \"\"\" Attributes ---------- > **savefile:** `bool` -- Whether or not to save all the control coeffients. If set `True` then the control coefficients and the values of the objective function obtained in all episodes will be saved during the training. If set `False` the control coefficients in the final episode and the values of the objective function in all episodes will be saved. > **ctrl0:** `list of arrays` -- Initial guesses of control coefficients. > **max_episode:** `int` -- The number of episodes. > **layer_num:** `int` -- The number of layers (include the input and output layer). > **layer_dim:** `int` -- The number of neurons in the hidden layer. > **seed:** `int` -- Random seed. > **eps:** `float` -- Machine epsilon. > **load:** `bool` -- Whether or not to load control coefficients in the current location. If set `True` then the program will load control coefficients from \"controls.csv\" file in the current location and use it as the initial control coefficients. \"\"\" def __init__ ( self , savefile = False , ctrl0 = [], max_episode = 500 , layer_num = 3 , layer_dim = 200 , seed = 1234 , eps = 1e-8 , load = False , ): Control . ControlSystem . __init__ ( self , savefile , ctrl0 , eps , load ) self . max_episode = max_episode self . layer_num = layer_num self . layer_dim = layer_dim self . seed = seed self . alg = Main . QuanEstimation . DDPG ( self . max_episode , self . layer_num , self . layer_dim , self . seed ) def QFIM ( self , W = [], LDtype = \"SLD\" ): r \"\"\" Choose QFI or $\\mathrm{Tr}(WF^{-1})$ as the objective function. In single parameter estimation the objective function is QFI and in multiparameter estimation it will be $\\mathrm{Tr}(WF^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). \"\"\" super () . QFIM ( W , LDtype ) def CFIM ( self , M = [], W = []): r \"\"\" Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" super () . CFIM ( M , W ) def HCRB ( self , W = []): \"\"\" Choose HCRB as the objective function. **Note:** in single parameter estimation, HCRB is equivalent to QFI, please choose QFI as the objective function. Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" super () . HCRB ( W ) def mintime ( self , f , W = [], M = [], method = \"binary\" , target = \"QFIM\" , LDtype = \"SLD\" ): \"\"\" Search of the minimum time to reach a given value of the objective function. Parameters ---------- > **f:** `float` -- The given value of the objective function. > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). > **method:** `string` -- Methods for searching the minimum time to reach the given value of the objective function. Options are: \"binary\" (default) -- Binary search (logarithmic search). \"forward\" -- Forward search from the beginning of time. > **target:** `string` -- Objective functions for searching the minimum time to reach the given value of the objective function. Options are: \"QFIM\" (default) -- Choose QFI (QFIM) as the objective function. \"CFIM\" -- Choose CFI (CFIM) as the objective function. \"HCRB\" -- Choose HCRB as the objective function. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" super () . mintime ( f , W , M , method , target , LDtype ) CFIM ( M = [], W = []) \u00b6 Choose CFI or \\(\\mathrm{Tr}(WI^{-1})\\) as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be \\(\\mathrm{Tr}(WI^{-1})\\) . Parameters \u00b6 W: matrix -- Weight matrix. M: list of matrices -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). Note: SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from here . Source code in quanestimation/ControlOpt/DDPG_Copt.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def CFIM ( self , M = [], W = []): r \"\"\" Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" super () . CFIM ( M , W ) HCRB ( W = []) \u00b6 Choose HCRB as the objective function. Note: in single parameter estimation, HCRB is equivalent to QFI, please choose QFI as the objective function. Parameters \u00b6 W: matrix -- Weight matrix. Source code in quanestimation/ControlOpt/DDPG_Copt.py 109 110 111 112 113 114 115 116 117 118 119 120 121 def HCRB ( self , W = []): \"\"\" Choose HCRB as the objective function. **Note:** in single parameter estimation, HCRB is equivalent to QFI, please choose QFI as the objective function. Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" super () . HCRB ( W ) QFIM ( W = [], LDtype = 'SLD' ) \u00b6 Choose QFI or \\(\\mathrm{Tr}(WF^{-1})\\) as the objective function. In single parameter estimation the objective function is QFI and in multiparameter estimation it will be \\(\\mathrm{Tr}(WF^{-1})\\) . Parameters \u00b6 W: matrix -- Weight matrix. LDtype: string -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). Source code in quanestimation/ControlOpt/DDPG_Copt.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 def QFIM ( self , W = [], LDtype = \"SLD\" ): r \"\"\" Choose QFI or $\\mathrm{Tr}(WF^{-1})$ as the objective function. In single parameter estimation the objective function is QFI and in multiparameter estimation it will be $\\mathrm{Tr}(WF^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). \"\"\" super () . QFIM ( W , LDtype ) mintime ( f , W = [], M = [], method = 'binary' , target = 'QFIM' , LDtype = 'SLD' ) \u00b6 Search of the minimum time to reach a given value of the objective function. Parameters \u00b6 f: float -- The given value of the objective function. W: matrix -- Weight matrix. M: list of matrices -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). method: string -- Methods for searching the minimum time to reach the given value of the objective function. Options are: \"binary\" (default) -- Binary search (logarithmic search). \"forward\" -- Forward search from the beginning of time. target: string -- Objective functions for searching the minimum time to reach the given value of the objective function. Options are: \"QFIM\" (default) -- Choose QFI (QFIM) as the objective function. \"CFIM\" -- Choose CFI (CFIM) as the objective function. \"HCRB\" -- Choose HCRB as the objective function. LDtype: string -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). Note: SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from here . Source code in quanestimation/ControlOpt/DDPG_Copt.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 def mintime ( self , f , W = [], M = [], method = \"binary\" , target = \"QFIM\" , LDtype = \"SLD\" ): \"\"\" Search of the minimum time to reach a given value of the objective function. Parameters ---------- > **f:** `float` -- The given value of the objective function. > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). > **method:** `string` -- Methods for searching the minimum time to reach the given value of the objective function. Options are: \"binary\" (default) -- Binary search (logarithmic search). \"forward\" -- Forward search from the beginning of time. > **target:** `string` -- Objective functions for searching the minimum time to reach the given value of the objective function. Options are: \"QFIM\" (default) -- Choose QFI (QFIM) as the objective function. \"CFIM\" -- Choose CFI (CFIM) as the objective function. \"HCRB\" -- Choose HCRB as the objective function. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" super () . mintime ( f , W , M , method , target , LDtype ) State Optimization \u00b6 The probe state is expanded as \\(|\\psi\\rangle=\\sum_i c_i|i\\rangle\\) in a specific basis, i.e., \\(\\{|i\\rangle\\}\\) . In state optimization, the search of the optimal probe states is equal to search of the normalized complex coefficients \\(\\{c_i\\}\\) . In QuanEstimation, the state optimization algorithms are automatic differentiation (AD), reverse iterative (RI) algorithm, particle swarm optimization (PSO), differential evolution (DE), deep deterministic policy gradients (DDPG) and Nelder-Mead (NM). Base \u00b6 Attributes \u00b6 savefile: bool -- Whether or not to save all the states. If set True then the states and the values of the objective function obtained in all episodes will be saved during the training. If set False the state in the final episode and the values of the objective function in all episodes will be saved. psi0: list of arrays -- Initial guesses of states. seed: int -- Random seed. eps: float -- Machine epsilon. load: bool -- Whether or not to load states in the current location. If set True then the program will load state from \"states.csv\" file in the current location and use it as the initial state. Source code in quanestimation/StateOpt/StateStruct.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 class StateSystem : \"\"\" Attributes ---------- > **savefile:** `bool` -- Whether or not to save all the states. If set `True` then the states and the values of the objective function obtained in all episodes will be saved during the training. If set `False` the state in the final episode and the values of the objective function in all episodes will be saved. > **psi0:** `list of arrays` -- Initial guesses of states. > **seed:** `int` -- Random seed. > **eps:** `float` -- Machine epsilon. > **load:** `bool` -- Whether or not to load states in the current location. If set `True` then the program will load state from \"states.csv\" file in the current location and use it as the initial state. \"\"\" def __init__ ( self , savefile , psi0 , seed , eps , load ): self . savefile = savefile self . psi0 = psi0 self . psi = psi0 self . eps = eps self . seed = seed if load == True : if os . path . exists ( \"states.csv\" ): self . psi0 = np . genfromtxt ( \"states.csv\" , dtype = np . complex128 ) def load_save ( self ): if os . path . exists ( \"states.csv\" ): file_load = open ( \"states.csv\" , \"r\" ) file_load = \"\" . join ([ i for i in file_load ]) . replace ( \"im\" , \"j\" ) file_load = \"\" . join ([ i for i in file_load ]) . replace ( \" \" , \"\" ) file_save = open ( \"states.csv\" , \"w\" ) file_save . writelines ( file_load ) file_save . close () else : pass def dynamics ( self , tspan , H0 , dH , Hc = [], ctrl = [], decay = []): r \"\"\" The dynamics of a density matrix is of the form \\begin{align} \\partial_t\\rho &=\\mathcal{L}\\rho \\nonumber \\\\ &=-i[H,\\rho]+\\sum_i \\gamma_i\\left(\\Gamma_i\\rho\\Gamma^{\\dagger}_i-\\frac{1}{2} \\left\\{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\right\\}\\right), \\end{align} where $\\rho$ is the evolved density matrix, H is the Hamiltonian of the system, $\\Gamma_i$ and $\\gamma_i$ are the $i\\mathrm{th}$ decay operator and corresponding decay rate. Parameters ---------- > **tspan:** `array` -- Time length for the evolution. > **H0:** `matrix or list` -- Free Hamiltonian. It is a matrix when the free Hamiltonian is time- independent and a list of length equal to `tspan` when it is time-dependent. > **dH:** `list` -- Derivatives of the free Hamiltonian on the unknown parameters to be estimated. For example, dH[0] is the derivative vector on the first parameter. > **Hc:** `list` -- Control Hamiltonians. > **ctrl:** `list of arrays` -- Control coefficients. > **decay:** `list` -- Decay operators and the corresponding decay rates. Its input rule is decay=[[$\\Gamma_1$, $\\gamma_1$], [$\\Gamma_2$,$\\gamma_2$],...], where $\\Gamma_1$ $(\\Gamma_2)$ represents the decay operator and $\\gamma_1$ $(\\gamma_2)$ is the corresponding decay rate. \"\"\" self . tspan = tspan if Hc == [] or ctrl == []: if type ( H0 ) == np . ndarray : self . freeHamiltonian = np . array ( H0 , dtype = np . complex128 ) self . dim = len ( self . freeHamiltonian ) else : self . freeHamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in H0 ] self . dim = len ( self . freeHamiltonian [ 0 ]) else : ctrl_num = len ( ctrl ) Hc_num = len ( Hc ) if Hc_num < ctrl_num : raise TypeError ( \"There are %d control Hamiltonians but %d coefficients sequences: \\ too many coefficients sequences.\" % ( Hc_num , ctrl_num ) ) elif Hc_num > ctrl_num : warnings . warn ( \"Not enough coefficients sequences: there are %d control Hamiltonians \\ but %d coefficients sequences. The rest of the control sequences are \\ set to be 0.\" % ( Hc_num , ctrl_num ), DeprecationWarning , ) for i in range ( Hc_num - ctrl_num ): ctrl = np . concatenate (( ctrl , np . zeros ( len ( ctrl [ 0 ])))) else : pass if len ( ctrl [ 0 ]) == 1 : if type ( H0 ) == np . ndarray : H0 = np . array ( H0 , dtype = np . complex128 ) Hc = [ np . array ( x , dtype = np . complex128 ) for x in Hc ] Htot = H0 + sum ([ Hc [ i ] * ctrl [ i ][ 0 ] for i in range ( ctrl_num )]) self . freeHamiltonian = np . array ( Htot , dtype = np . complex128 ) self . dim = len ( self . freeHamiltonian ) else : H0 = [ np . array ( x , dtype = np . complex128 ) for x in H0 ] Htot = [] for i in range ( len ( H0 )): Htot . append ( H0 [ i ] + sum ([ Hc [ i ] * ctrl [ i ][ 0 ] for i in range ( ctrl_num )]) ) self . freeHamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in Htot ] self . dim = len ( self . freeHamiltonian [ 0 ]) else : if type ( H0 ) != np . ndarray : #### linear interpolation #### f = interp1d ( self . tspan , H0 , axis = 0 ) else : pass number = math . ceil (( len ( self . tspan ) - 1 ) / len ( ctrl [ 0 ])) if len ( self . tspan ) - 1 % len ( ctrl [ 0 ]) != 0 : tnum = number * len ( ctrl [ 0 ]) self . tspan = np . linspace ( self . tspan [ 0 ], self . tspan [ - 1 ], tnum + 1 ) if type ( H0 ) != np . ndarray : H0_inter = f ( self . tspan ) H0 = [ np . array ( x , dtype = np . complex128 ) for x in H0_inter ] else : pass else : pass if type ( H0 ) == np . ndarray : H0 = np . array ( H0 , dtype = np . complex128 ) Hc = [ np . array ( x , dtype = np . complex128 ) for x in Hc ] ctrl = [ np . array ( ctrl [ i ]) . repeat ( number ) for i in range ( len ( Hc ))] Htot = [] for i in range ( len ( ctrl [ 0 ])): S_ctrl = sum ([ Hc [ j ] * ctrl [ j ][ i ] for j in range ( len ( ctrl ))]) Htot . append ( H0 + S_ctrl ) self . freeHamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in Htot ] self . dim = len ( self . freeHamiltonian ) else : H0 = [ np . array ( x , dtype = np . complex128 ) for x in H0 ] Hc = [ np . array ( x , dtype = np . complex128 ) for x in Hc ] ctrl = [ np . array ( ctrl [ i ]) . repeat ( number ) for i in range ( len ( Hc ))] Htot = [] for i in range ( len ( ctrl [ 0 ])): S_ctrl = sum ([ Hc [ j ] * ctrl [ j ][ i ] for j in range ( len ( ctrl ))]) Htot . append ( H0 [ i ] + S_ctrl ) self . freeHamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in Htot ] self . dim = len ( self . freeHamiltonian [ 0 ]) if self . psi0 == []: np . random . seed ( self . seed ) r_ini = 2 * np . random . random ( self . dim ) - np . ones ( self . dim ) r = r_ini / np . linalg . norm ( r_ini ) phi = 2 * np . pi * np . random . random ( self . dim ) psi0 = [ r [ i ] * np . exp ( 1.0 j * phi [ i ]) for i in range ( self . dim )] self . psi0 = np . array ( psi0 ) # Initial state (an array) self . psi = [ self . psi0 ] # Initial guesses of states (a list of arrays) else : self . psi0 = np . array ( self . psi0 [ 0 ], dtype = np . complex128 ) self . psi = [ np . array ( psi , dtype = np . complex128 ) for psi in self . psi ] if type ( dH ) != list : raise TypeError ( \"The derivative of Hamiltonian should be a list!\" ) if dH == []: dH = [ np . zeros (( len ( self . psi0 ), len ( self . psi0 )))] self . Hamiltonian_derivative = [ np . array ( x , dtype = np . complex128 ) for x in dH ] if decay == []: decay_opt = [ np . zeros (( len ( self . psi0 ), len ( self . psi0 )))] self . gamma = [ 0.0 ] else : decay_opt = [ decay [ i ][ 0 ] for i in range ( len ( decay ))] self . gamma = [ decay [ i ][ 1 ] for i in range ( len ( decay ))] self . decay_opt = [ np . array ( x , dtype = np . complex128 ) for x in decay_opt ] self . opt = Main . QuanEstimation . StateOpt ( psi = self . psi0 , seed = self . seed ) if any ( self . gamma ): self . dynamic = Main . QuanEstimation . Lindblad ( self . freeHamiltonian , self . Hamiltonian_derivative , self . psi0 , self . tspan , self . decay_opt , self . gamma , ) else : self . dynamic = Main . QuanEstimation . Lindblad ( self . freeHamiltonian , self . Hamiltonian_derivative , self . psi0 , self . tspan , ) self . output = Main . QuanEstimation . Output ( self . opt , save = self . savefile ) self . dynamics_type = \"dynamics\" if len ( self . Hamiltonian_derivative ) == 1 : self . para_type = \"single_para\" else : self . para_type = \"multi_para\" def Kraus ( self , K , dK ): r \"\"\" The parameterization of a state is \\begin{align} \\rho=\\sum_i K_i\\rho_0K_i^{\\dagger}, \\end{align} where $\\rho$ is the evolved density matrix, $K_i$ is the Kraus operator. Parameters ---------- > **K:** `list` -- Kraus operators. > **dK:** `list` -- Derivatives of the Kraus operators on the unknown parameters to be estimated. For example, dK[0] is the derivative vector on the first parameter. \"\"\" k_num = len ( K ) para_num = len ( dK [ 0 ]) self . para_num = para_num self . K = [ np . array ( x , dtype = np . complex128 ) for x in K ] self . dK = [ [ np . array ( dK [ i ][ j ], dtype = np . complex128 ) for j in range ( para_num )] for i in range ( k_num ) ] self . dim = len ( self . K [ 0 ]) if self . psi0 == []: np . random . seed ( self . seed ) r_ini = 2 * np . random . random ( self . dim ) - np . ones ( self . dim ) r = r_ini / np . linalg . norm ( r_ini ) phi = 2 * np . pi * np . random . random ( self . dim ) psi0 = [ r [ i ] * np . exp ( 1.0 j * phi [ i ]) for i in range ( self . dim )] self . psi0 = np . array ( psi0 ) # Initial state (an array) self . psi = [ self . psi0 ] # Initial guesses of states (a list of arrays) else : self . psi0 = np . array ( self . psi0 [ 0 ], dtype = np . complex128 ) self . psi = [ np . array ( psi , dtype = np . complex128 ) for psi in self . psi ] self . opt = Main . QuanEstimation . StateOpt ( psi = self . psi0 , seed = self . seed ) self . dynamic = Main . QuanEstimation . Kraus ( self . psi0 , self . K , self . dK ) self . output = Main . QuanEstimation . Output ( self . opt , save = self . savefile ) self . dynamics_type = \"Kraus\" if para_num == 1 : self . para_type = \"single_para\" else : self . para_type = \"multi_para\" def QFIM ( self , W = [], LDtype = \"SLD\" ): r \"\"\" Choose QFI or $\\mathrm{Tr}(WF^{-1})$ as the objective function. In single parameter estimation the objective function is QFI and in multiparameter estimation it will be $\\mathrm{Tr}(WF^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). \"\"\" if LDtype != \"SLD\" and LDtype != \"RLD\" and LDtype != \"LLD\" : raise ValueError ( \" {!r} is not a valid value for LDtype, supported values are 'SLD', 'RLD' and 'LLD'.\" . format ( LDtype ) ) if self . dynamics_type == \"dynamics\" : if W == []: W = np . eye ( len ( self . Hamiltonian_derivative )) self . W = W elif self . dynamics_type == \"Kraus\" : if W == []: W = np . eye ( self . para_num ) self . W = W else : pass self . obj = Main . QuanEstimation . QFIM_obj ( self . W , self . eps , self . para_type , LDtype ) system = Main . QuanEstimation . QuanEstSystem ( self . opt , self . alg , self . obj , self . dynamic , self . output ) Main . QuanEstimation . run ( system ) self . load_save () def CFIM ( self , M = [], W = []): r \"\"\" Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" if M == []: M = SIC ( len ( self . psi0 )) M = [ np . array ( x , dtype = np . complex128 ) for x in M ] if self . dynamics_type == \"dynamics\" : if W == []: W = np . eye ( len ( self . Hamiltonian_derivative )) self . W = W elif self . dynamics_type == \"Kraus\" : if W == []: W = np . eye ( self . para_num ) self . W = W self . obj = Main . QuanEstimation . CFIM_obj ( M , self . W , self . eps , self . para_type ) system = Main . QuanEstimation . QuanEstSystem ( self . opt , self . alg , self . obj , self . dynamic , self . output ) Main . QuanEstimation . run ( system ) self . load_save () def HCRB ( self , W = []): \"\"\" Choose HCRB as the objective function. **Notes:** (1) In single parameter estimation, HCRB is equivalent to QFI, please choose QFI as the objective function. (2) GRAPE and auto-GRAPE are not available when the objective function is HCRB. Supported methods are PSO, DE and DDPG. Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" if self . dynamics_type == \"dynamics\" : if W == []: W = np . eye ( len ( self . Hamiltonian_derivative )) self . W = W if len ( self . Hamiltonian_derivative ) == 1 : print ( \"Program terminated. In the single-parameter scenario, the HCRB is equivalent to the QFI. Please choose 'QFIM' as the objective function\" ) else : pass elif self . dynamics_type == \"Kraus\" : if W == []: W = np . eye ( self . para_num ) self . W = W if len ( self . dK ) == 1 : raise ValueError ( \"In single parameter scenario, HCRB is equivalent to QFI. Please choose QFIM as the target function for control optimization\" , ) else : pass else : raise ValueError ( \"Supported type of dynamics are Lindblad and Kraus.\" ) self . obj = Main . QuanEstimation . HCRB_obj ( self . W , self . eps , self . para_type ) system = Main . QuanEstimation . QuanEstSystem ( self . opt , self . alg , self . obj , self . dynamic , self . output ) Main . QuanEstimation . run ( system ) self . load_save () CFIM ( M = [], W = []) \u00b6 Choose CFI or \\(\\mathrm{Tr}(WI^{-1})\\) as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be \\(\\mathrm{Tr}(WI^{-1})\\) . Parameters \u00b6 W: matrix -- Weight matrix. M: list of matrices -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). Note: SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from here . Source code in quanestimation/StateOpt/StateStruct.py 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 def CFIM ( self , M = [], W = []): r \"\"\" Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" if M == []: M = SIC ( len ( self . psi0 )) M = [ np . array ( x , dtype = np . complex128 ) for x in M ] if self . dynamics_type == \"dynamics\" : if W == []: W = np . eye ( len ( self . Hamiltonian_derivative )) self . W = W elif self . dynamics_type == \"Kraus\" : if W == []: W = np . eye ( self . para_num ) self . W = W self . obj = Main . QuanEstimation . CFIM_obj ( M , self . W , self . eps , self . para_type ) system = Main . QuanEstimation . QuanEstSystem ( self . opt , self . alg , self . obj , self . dynamic , self . output ) Main . QuanEstimation . run ( system ) self . load_save () HCRB ( W = []) \u00b6 Choose HCRB as the objective function. Notes: (1) In single parameter estimation, HCRB is equivalent to QFI, please choose QFI as the objective function. (2) GRAPE and auto-GRAPE are not available when the objective function is HCRB. Supported methods are PSO, DE and DDPG. Parameters \u00b6 W: matrix -- Weight matrix. Source code in quanestimation/StateOpt/StateStruct.py 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 def HCRB ( self , W = []): \"\"\" Choose HCRB as the objective function. **Notes:** (1) In single parameter estimation, HCRB is equivalent to QFI, please choose QFI as the objective function. (2) GRAPE and auto-GRAPE are not available when the objective function is HCRB. Supported methods are PSO, DE and DDPG. Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" if self . dynamics_type == \"dynamics\" : if W == []: W = np . eye ( len ( self . Hamiltonian_derivative )) self . W = W if len ( self . Hamiltonian_derivative ) == 1 : print ( \"Program terminated. In the single-parameter scenario, the HCRB is equivalent to the QFI. Please choose 'QFIM' as the objective function\" ) else : pass elif self . dynamics_type == \"Kraus\" : if W == []: W = np . eye ( self . para_num ) self . W = W if len ( self . dK ) == 1 : raise ValueError ( \"In single parameter scenario, HCRB is equivalent to QFI. Please choose QFIM as the target function for control optimization\" , ) else : pass else : raise ValueError ( \"Supported type of dynamics are Lindblad and Kraus.\" ) self . obj = Main . QuanEstimation . HCRB_obj ( self . W , self . eps , self . para_type ) system = Main . QuanEstimation . QuanEstSystem ( self . opt , self . alg , self . obj , self . dynamic , self . output ) Main . QuanEstimation . run ( system ) self . load_save () Kraus ( K , dK ) \u00b6 The parameterization of a state is \\begin{align} \\rho=\\sum_i K_i\\rho_0K_i^{\\dagger}, \\end{align} where \\(\\rho\\) is the evolved density matrix, \\(K_i\\) is the Kraus operator. Parameters \u00b6 K: list -- Kraus operators. dK: list -- Derivatives of the Kraus operators on the unknown parameters to be estimated. For example, dK[0] is the derivative vector on the first parameter. Source code in quanestimation/StateOpt/StateStruct.py 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 def Kraus ( self , K , dK ): r \"\"\" The parameterization of a state is \\begin{align} \\rho=\\sum_i K_i\\rho_0K_i^{\\dagger}, \\end{align} where $\\rho$ is the evolved density matrix, $K_i$ is the Kraus operator. Parameters ---------- > **K:** `list` -- Kraus operators. > **dK:** `list` -- Derivatives of the Kraus operators on the unknown parameters to be estimated. For example, dK[0] is the derivative vector on the first parameter. \"\"\" k_num = len ( K ) para_num = len ( dK [ 0 ]) self . para_num = para_num self . K = [ np . array ( x , dtype = np . complex128 ) for x in K ] self . dK = [ [ np . array ( dK [ i ][ j ], dtype = np . complex128 ) for j in range ( para_num )] for i in range ( k_num ) ] self . dim = len ( self . K [ 0 ]) if self . psi0 == []: np . random . seed ( self . seed ) r_ini = 2 * np . random . random ( self . dim ) - np . ones ( self . dim ) r = r_ini / np . linalg . norm ( r_ini ) phi = 2 * np . pi * np . random . random ( self . dim ) psi0 = [ r [ i ] * np . exp ( 1.0 j * phi [ i ]) for i in range ( self . dim )] self . psi0 = np . array ( psi0 ) # Initial state (an array) self . psi = [ self . psi0 ] # Initial guesses of states (a list of arrays) else : self . psi0 = np . array ( self . psi0 [ 0 ], dtype = np . complex128 ) self . psi = [ np . array ( psi , dtype = np . complex128 ) for psi in self . psi ] self . opt = Main . QuanEstimation . StateOpt ( psi = self . psi0 , seed = self . seed ) self . dynamic = Main . QuanEstimation . Kraus ( self . psi0 , self . K , self . dK ) self . output = Main . QuanEstimation . Output ( self . opt , save = self . savefile ) self . dynamics_type = \"Kraus\" if para_num == 1 : self . para_type = \"single_para\" else : self . para_type = \"multi_para\" QFIM ( W = [], LDtype = 'SLD' ) \u00b6 Choose QFI or \\(\\mathrm{Tr}(WF^{-1})\\) as the objective function. In single parameter estimation the objective function is QFI and in multiparameter estimation it will be \\(\\mathrm{Tr}(WF^{-1})\\) . Parameters \u00b6 W: matrix -- Weight matrix. LDtype: string -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). Source code in quanestimation/StateOpt/StateStruct.py 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 def QFIM ( self , W = [], LDtype = \"SLD\" ): r \"\"\" Choose QFI or $\\mathrm{Tr}(WF^{-1})$ as the objective function. In single parameter estimation the objective function is QFI and in multiparameter estimation it will be $\\mathrm{Tr}(WF^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). \"\"\" if LDtype != \"SLD\" and LDtype != \"RLD\" and LDtype != \"LLD\" : raise ValueError ( \" {!r} is not a valid value for LDtype, supported values are 'SLD', 'RLD' and 'LLD'.\" . format ( LDtype ) ) if self . dynamics_type == \"dynamics\" : if W == []: W = np . eye ( len ( self . Hamiltonian_derivative )) self . W = W elif self . dynamics_type == \"Kraus\" : if W == []: W = np . eye ( self . para_num ) self . W = W else : pass self . obj = Main . QuanEstimation . QFIM_obj ( self . W , self . eps , self . para_type , LDtype ) system = Main . QuanEstimation . QuanEstSystem ( self . opt , self . alg , self . obj , self . dynamic , self . output ) Main . QuanEstimation . run ( system ) self . load_save () dynamics ( tspan , H0 , dH , Hc = [], ctrl = [], decay = []) \u00b6 The dynamics of a density matrix is of the form \\[\\begin{align} \\partial_t\\rho &=\\mathcal{L}\\rho \\nonumber \\\\ &=-i[H,\\rho]+\\sum_i \\gamma_i\\left(\\Gamma_i\\rho\\Gamma^{\\dagger}_i-\\frac{1}{2} \\left\\{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\right\\}\\right), \\end{align}\\] where \\(\\rho\\) is the evolved density matrix, H is the Hamiltonian of the system, \\(\\Gamma_i\\) and \\(\\gamma_i\\) are the \\(i\\mathrm{th}\\) decay operator and corresponding decay rate. Parameters \u00b6 tspan: array -- Time length for the evolution. H0: matrix or list -- Free Hamiltonian. It is a matrix when the free Hamiltonian is time- independent and a list of length equal to tspan when it is time-dependent. dH: list -- Derivatives of the free Hamiltonian on the unknown parameters to be estimated. For example, dH[0] is the derivative vector on the first parameter. Hc: list -- Control Hamiltonians. ctrl: list of arrays -- Control coefficients. decay: list -- Decay operators and the corresponding decay rates. Its input rule is decay=[[ \\(\\Gamma_1\\) , \\(\\gamma_1\\) ], [ \\(\\Gamma_2\\) , \\(\\gamma_2\\) ],...], where \\(\\Gamma_1\\) \\((\\Gamma_2)\\) represents the decay operator and \\(\\gamma_1\\) \\((\\gamma_2)\\) is the corresponding decay rate. Source code in quanestimation/StateOpt/StateStruct.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 def dynamics ( self , tspan , H0 , dH , Hc = [], ctrl = [], decay = []): r \"\"\" The dynamics of a density matrix is of the form \\begin{align} \\partial_t\\rho &=\\mathcal{L}\\rho \\nonumber \\\\ &=-i[H,\\rho]+\\sum_i \\gamma_i\\left(\\Gamma_i\\rho\\Gamma^{\\dagger}_i-\\frac{1}{2} \\left\\{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\right\\}\\right), \\end{align} where $\\rho$ is the evolved density matrix, H is the Hamiltonian of the system, $\\Gamma_i$ and $\\gamma_i$ are the $i\\mathrm{th}$ decay operator and corresponding decay rate. Parameters ---------- > **tspan:** `array` -- Time length for the evolution. > **H0:** `matrix or list` -- Free Hamiltonian. It is a matrix when the free Hamiltonian is time- independent and a list of length equal to `tspan` when it is time-dependent. > **dH:** `list` -- Derivatives of the free Hamiltonian on the unknown parameters to be estimated. For example, dH[0] is the derivative vector on the first parameter. > **Hc:** `list` -- Control Hamiltonians. > **ctrl:** `list of arrays` -- Control coefficients. > **decay:** `list` -- Decay operators and the corresponding decay rates. Its input rule is decay=[[$\\Gamma_1$, $\\gamma_1$], [$\\Gamma_2$,$\\gamma_2$],...], where $\\Gamma_1$ $(\\Gamma_2)$ represents the decay operator and $\\gamma_1$ $(\\gamma_2)$ is the corresponding decay rate. \"\"\" self . tspan = tspan if Hc == [] or ctrl == []: if type ( H0 ) == np . ndarray : self . freeHamiltonian = np . array ( H0 , dtype = np . complex128 ) self . dim = len ( self . freeHamiltonian ) else : self . freeHamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in H0 ] self . dim = len ( self . freeHamiltonian [ 0 ]) else : ctrl_num = len ( ctrl ) Hc_num = len ( Hc ) if Hc_num < ctrl_num : raise TypeError ( \"There are %d control Hamiltonians but %d coefficients sequences: \\ too many coefficients sequences.\" % ( Hc_num , ctrl_num ) ) elif Hc_num > ctrl_num : warnings . warn ( \"Not enough coefficients sequences: there are %d control Hamiltonians \\ but %d coefficients sequences. The rest of the control sequences are \\ set to be 0.\" % ( Hc_num , ctrl_num ), DeprecationWarning , ) for i in range ( Hc_num - ctrl_num ): ctrl = np . concatenate (( ctrl , np . zeros ( len ( ctrl [ 0 ])))) else : pass if len ( ctrl [ 0 ]) == 1 : if type ( H0 ) == np . ndarray : H0 = np . array ( H0 , dtype = np . complex128 ) Hc = [ np . array ( x , dtype = np . complex128 ) for x in Hc ] Htot = H0 + sum ([ Hc [ i ] * ctrl [ i ][ 0 ] for i in range ( ctrl_num )]) self . freeHamiltonian = np . array ( Htot , dtype = np . complex128 ) self . dim = len ( self . freeHamiltonian ) else : H0 = [ np . array ( x , dtype = np . complex128 ) for x in H0 ] Htot = [] for i in range ( len ( H0 )): Htot . append ( H0 [ i ] + sum ([ Hc [ i ] * ctrl [ i ][ 0 ] for i in range ( ctrl_num )]) ) self . freeHamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in Htot ] self . dim = len ( self . freeHamiltonian [ 0 ]) else : if type ( H0 ) != np . ndarray : #### linear interpolation #### f = interp1d ( self . tspan , H0 , axis = 0 ) else : pass number = math . ceil (( len ( self . tspan ) - 1 ) / len ( ctrl [ 0 ])) if len ( self . tspan ) - 1 % len ( ctrl [ 0 ]) != 0 : tnum = number * len ( ctrl [ 0 ]) self . tspan = np . linspace ( self . tspan [ 0 ], self . tspan [ - 1 ], tnum + 1 ) if type ( H0 ) != np . ndarray : H0_inter = f ( self . tspan ) H0 = [ np . array ( x , dtype = np . complex128 ) for x in H0_inter ] else : pass else : pass if type ( H0 ) == np . ndarray : H0 = np . array ( H0 , dtype = np . complex128 ) Hc = [ np . array ( x , dtype = np . complex128 ) for x in Hc ] ctrl = [ np . array ( ctrl [ i ]) . repeat ( number ) for i in range ( len ( Hc ))] Htot = [] for i in range ( len ( ctrl [ 0 ])): S_ctrl = sum ([ Hc [ j ] * ctrl [ j ][ i ] for j in range ( len ( ctrl ))]) Htot . append ( H0 + S_ctrl ) self . freeHamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in Htot ] self . dim = len ( self . freeHamiltonian ) else : H0 = [ np . array ( x , dtype = np . complex128 ) for x in H0 ] Hc = [ np . array ( x , dtype = np . complex128 ) for x in Hc ] ctrl = [ np . array ( ctrl [ i ]) . repeat ( number ) for i in range ( len ( Hc ))] Htot = [] for i in range ( len ( ctrl [ 0 ])): S_ctrl = sum ([ Hc [ j ] * ctrl [ j ][ i ] for j in range ( len ( ctrl ))]) Htot . append ( H0 [ i ] + S_ctrl ) self . freeHamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in Htot ] self . dim = len ( self . freeHamiltonian [ 0 ]) if self . psi0 == []: np . random . seed ( self . seed ) r_ini = 2 * np . random . random ( self . dim ) - np . ones ( self . dim ) r = r_ini / np . linalg . norm ( r_ini ) phi = 2 * np . pi * np . random . random ( self . dim ) psi0 = [ r [ i ] * np . exp ( 1.0 j * phi [ i ]) for i in range ( self . dim )] self . psi0 = np . array ( psi0 ) # Initial state (an array) self . psi = [ self . psi0 ] # Initial guesses of states (a list of arrays) else : self . psi0 = np . array ( self . psi0 [ 0 ], dtype = np . complex128 ) self . psi = [ np . array ( psi , dtype = np . complex128 ) for psi in self . psi ] if type ( dH ) != list : raise TypeError ( \"The derivative of Hamiltonian should be a list!\" ) if dH == []: dH = [ np . zeros (( len ( self . psi0 ), len ( self . psi0 )))] self . Hamiltonian_derivative = [ np . array ( x , dtype = np . complex128 ) for x in dH ] if decay == []: decay_opt = [ np . zeros (( len ( self . psi0 ), len ( self . psi0 )))] self . gamma = [ 0.0 ] else : decay_opt = [ decay [ i ][ 0 ] for i in range ( len ( decay ))] self . gamma = [ decay [ i ][ 1 ] for i in range ( len ( decay ))] self . decay_opt = [ np . array ( x , dtype = np . complex128 ) for x in decay_opt ] self . opt = Main . QuanEstimation . StateOpt ( psi = self . psi0 , seed = self . seed ) if any ( self . gamma ): self . dynamic = Main . QuanEstimation . Lindblad ( self . freeHamiltonian , self . Hamiltonian_derivative , self . psi0 , self . tspan , self . decay_opt , self . gamma , ) else : self . dynamic = Main . QuanEstimation . Lindblad ( self . freeHamiltonian , self . Hamiltonian_derivative , self . psi0 , self . tspan , ) self . output = Main . QuanEstimation . Output ( self . opt , save = self . savefile ) self . dynamics_type = \"dynamics\" if len ( self . Hamiltonian_derivative ) == 1 : self . para_type = \"single_para\" else : self . para_type = \"multi_para\" State optimization with AD \u00b6 Bases: State . StateSystem Attributes \u00b6 savefile: bool -- Whether or not to save all the states. If set True then the states and the values of the objective function obtained in all episodes will be saved during the training. If set False the state in the final episode and the values of the objective function in all episodes will be saved. Adam: bool -- Whether or not to use Adam for updating states. psi0: list of arrays -- Initial guesses of states. max_episode: int -- The number of episodes. epsilon: float -- Learning rate. beta1: float -- The exponential decay rate for the first moment estimates. beta2: float -- The exponential decay rate for the second moment estimates. eps: float -- Machine epsilon. load: bool -- Whether or not to load states in the current location. If set True then the program will load state from \"states.csv\" file in the current location and use it as the initial state. Source code in quanestimation/StateOpt/AD_Sopt.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 class AD_Sopt ( State . StateSystem ): \"\"\" Attributes ---------- > **savefile:** `bool` -- Whether or not to save all the states. If set `True` then the states and the values of the objective function obtained in all episodes will be saved during the training. If set `False` the state in the final episode and the values of the objective function in all episodes will be saved. > **Adam:** `bool` -- Whether or not to use Adam for updating states. > **psi0:** `list of arrays` -- Initial guesses of states. > **max_episode:** `int` -- The number of episodes. > **epsilon:** `float` -- Learning rate. > **beta1:** `float` -- The exponential decay rate for the first moment estimates. > **beta2:** `float` -- The exponential decay rate for the second moment estimates. > **eps:** `float` -- Machine epsilon. > **load:** `bool` -- Whether or not to load states in the current location. If set `True` then the program will load state from \"states.csv\" file in the current location and use it as the initial state. \"\"\" def __init__ ( self , savefile = False , Adam = False , psi0 = [], max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 , seed = 1234 , eps = 1e-8 , load = False , ): State . StateSystem . __init__ ( self , savefile , psi0 , seed , eps , load ) self . Adam = Adam self . max_episode = max_episode self . epsilon = epsilon self . beta1 = beta1 self . beta2 = beta2 self . mt = 0.0 self . vt = 0.0 if self . Adam : self . alg = Main . QuanEstimation . AD ( self . max_episode , self . epsilon , self . beta1 , self . beta2 , ) else : self . alg = Main . QuanEstimation . AD ( self . max_episode , self . epsilon ) def QFIM ( self , W = [], LDtype = \"SLD\" ): r \"\"\" Choose QFI or $\\mathrm{Tr}(WF^{-1})$ as the objective function. In single parameter estimation the objective function is QFI and in multiparameter estimation it will be $\\mathrm{Tr}(WF^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). \"\"\" super () . QFIM ( W , LDtype ) def CFIM ( self , M = [], W = []): r \"\"\" Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" super () . CFIM ( M , W ) def HCRB ( self , W = []): \"\"\" AD is not available when the objective function is HCRB. Supported methods are PSO, DE, DDPG and NM. Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" raise ValueError ( \"AD is not available when the objective function is HCRB. Supported methods are 'PSO', 'DE', 'NM' and 'DDPG'.\" ) CFIM ( M = [], W = []) \u00b6 Choose CFI or \\(\\mathrm{Tr}(WI^{-1})\\) as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be \\(\\mathrm{Tr}(WI^{-1})\\) . Parameters \u00b6 W: matrix -- Weight matrix. M: list of matrices -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). Note: SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from here . Source code in quanestimation/StateOpt/AD_Sopt.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def CFIM ( self , M = [], W = []): r \"\"\" Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" super () . CFIM ( M , W ) HCRB ( W = []) \u00b6 AD is not available when the objective function is HCRB. Supported methods are PSO, DE, DDPG and NM. Parameters \u00b6 W: matrix -- Weight matrix. Source code in quanestimation/StateOpt/AD_Sopt.py 117 118 119 120 121 122 123 124 125 126 127 128 129 def HCRB ( self , W = []): \"\"\" AD is not available when the objective function is HCRB. Supported methods are PSO, DE, DDPG and NM. Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" raise ValueError ( \"AD is not available when the objective function is HCRB. Supported methods are 'PSO', 'DE', 'NM' and 'DDPG'.\" ) QFIM ( W = [], LDtype = 'SLD' ) \u00b6 Choose QFI or \\(\\mathrm{Tr}(WF^{-1})\\) as the objective function. In single parameter estimation the objective function is QFI and in multiparameter estimation it will be \\(\\mathrm{Tr}(WF^{-1})\\) . Parameters \u00b6 W: matrix -- Weight matrix. LDtype: string -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). Source code in quanestimation/StateOpt/AD_Sopt.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 def QFIM ( self , W = [], LDtype = \"SLD\" ): r \"\"\" Choose QFI or $\\mathrm{Tr}(WF^{-1})$ as the objective function. In single parameter estimation the objective function is QFI and in multiparameter estimation it will be $\\mathrm{Tr}(WF^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). \"\"\" super () . QFIM ( W , LDtype ) State optimization with RI \u00b6 Bases: State . StateSystem Attributes \u00b6 savefile: bool -- Whether or not to save all the states. If set True then the states and the values of the objective function obtained in all episodes will be saved during the training. If set False the state in the final episode and the values of the objective function in all episodes will be saved. psi0: list of arrays -- Initial guesses of states. max_episode: int -- The number of episodes. seed: int -- Random seed. eps: float -- Machine epsilon. load: bool -- Whether or not to load states in the current location. If set True then the program will load state from \"states.csv\" file in the current location and use it as the initial state. Source code in quanestimation/StateOpt/RI_Sopt.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 class RI_Sopt ( State . StateSystem ): \"\"\" Attributes ---------- > **savefile:** `bool` -- Whether or not to save all the states. If set `True` then the states and the values of the objective function obtained in all episodes will be saved during the training. If set `False` the state in the final episode and the values of the objective function in all episodes will be saved. > **psi0:** `list of arrays` -- Initial guesses of states. > **max_episode:** `int` -- The number of episodes. > **seed:** `int` -- Random seed. > **eps:** `float` -- Machine epsilon. > **load:** `bool` -- Whether or not to load states in the current location. If set `True` then the program will load state from \"states.csv\" file in the current location and use it as the initial state. \"\"\" def __init__ ( self , savefile = False , psi0 = [], max_episode = 300 , seed = 1234 , eps = 1e-8 , load = False , ): State . StateSystem . __init__ ( self , savefile , psi0 , seed , eps , load ) self . max_episode = max_episode self . seed = seed def QFIM ( self , W = [], LDtype = \"SLD\" ): r \"\"\" Choose QFI as the objective function. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Only SLD can is available here. \"\"\" self . alg = Main . QuanEstimation . RI ( self . max_episode , ) if self . dynamics_type != \"Kraus\" : raise ValueError ( \"Only the parameterization with Kraus operators is available.\" ) if LDtype == \"SLD\" : super () . QFIM ( W , LDtype ) else : raise ValueError ( \"Only SLD is available.\" ) def CFIM ( self , M = [], W = []): \"\"\" Choose CFIM as the objective function. **Note:** CFIM is not available. Parameters ---------- > **M:** `list` -- POVM. > **W:** `matrix` -- Weight matrix. \"\"\" raise ValueError ( \"CFIM is not available.\" ) def HCRB ( self , W = []): \"\"\" Choose HCRB as the objective function. **Note:** Here HCRB is not available. Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" raise ValueError ( \"HCRB is not available.\" ) CFIM ( M = [], W = []) \u00b6 Choose CFIM as the objective function. Note: CFIM is not available. Parameters \u00b6 M: list -- POVM. W: matrix -- Weight matrix. Source code in quanestimation/StateOpt/RI_Sopt.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def CFIM ( self , M = [], W = []): \"\"\" Choose CFIM as the objective function. **Note:** CFIM is not available. Parameters ---------- > **M:** `list` -- POVM. > **W:** `matrix` -- Weight matrix. \"\"\" raise ValueError ( \"CFIM is not available.\" ) HCRB ( W = []) \u00b6 Choose HCRB as the objective function. Note: Here HCRB is not available. Parameters \u00b6 W: matrix -- Weight matrix. Source code in quanestimation/StateOpt/RI_Sopt.py 90 91 92 93 94 95 96 97 98 99 100 101 def HCRB ( self , W = []): \"\"\" Choose HCRB as the objective function. **Note:** Here HCRB is not available. Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" raise ValueError ( \"HCRB is not available.\" ) QFIM ( W = [], LDtype = 'SLD' ) \u00b6 Choose QFI as the objective function. Parameters \u00b6 W: matrix -- Weight matrix. LDtype: string -- Types of QFI (QFIM) can be set as the objective function. Only SLD can is available here. Source code in quanestimation/StateOpt/RI_Sopt.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def QFIM ( self , W = [], LDtype = \"SLD\" ): r \"\"\" Choose QFI as the objective function. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Only SLD can is available here. \"\"\" self . alg = Main . QuanEstimation . RI ( self . max_episode , ) if self . dynamics_type != \"Kraus\" : raise ValueError ( \"Only the parameterization with Kraus operators is available.\" ) if LDtype == \"SLD\" : super () . QFIM ( W , LDtype ) else : raise ValueError ( \"Only SLD is available.\" ) State Optimization with PSO \u00b6 Bases: State . StateSystem Attributes \u00b6 savefile: bool -- Whether or not to save all the states. If set True then the states and the values of the objective function obtained in all episodes will be saved during the training. If set False the state in the final episode and the values of the objective function in all episodes will be saved. p_num: int -- The number of particles. psi0: list of arrays -- Initial guesses of states. max_episode: int or list -- If it is an integer, for example max_episode=1000, it means the program will continuously run 1000 episodes. However, if it is an array, for example max_episode=[1000,100], the program will run 1000 episodes in total but replace states of all the particles with global best every 100 episodes. c0: float -- The damping factor that assists convergence, also known as inertia weight. c1: float -- The exploitation weight that attracts the particle to its best previous position, also known as cognitive learning factor. c2: float -- The exploitation weight that attracts the particle to the best position in the neighborhood, also known as social learning factor. seed: int -- Random seed. eps: float -- Machine epsilon. load: bool -- Whether or not to load states in the current location. If set True then the program will load state from \"states.csv\" file in the current location and use it as the initial state. Source code in quanestimation/StateOpt/PSO_Sopt.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 class PSO_Sopt ( State . StateSystem ): \"\"\" Attributes ---------- > **savefile:** `bool` -- Whether or not to save all the states. If set `True` then the states and the values of the objective function obtained in all episodes will be saved during the training. If set `False` the state in the final episode and the values of the objective function in all episodes will be saved. > **p_num:** `int` -- The number of particles. > **psi0:** `list of arrays` -- Initial guesses of states. > **max_episode:** `int or list` -- If it is an integer, for example max_episode=1000, it means the program will continuously run 1000 episodes. However, if it is an array, for example max_episode=[1000,100], the program will run 1000 episodes in total but replace states of all the particles with global best every 100 episodes. > **c0:** `float` -- The damping factor that assists convergence, also known as inertia weight. > **c1:** `float` -- The exploitation weight that attracts the particle to its best previous position, also known as cognitive learning factor. > **c2:** `float` -- The exploitation weight that attracts the particle to the best position in the neighborhood, also known as social learning factor. > **seed:** `int` -- Random seed. > **eps:** `float` -- Machine epsilon. > **load:** `bool` -- Whether or not to load states in the current location. If set `True` then the program will load state from \"states.csv\" file in the current location and use it as the initial state. \"\"\" def __init__ ( self , savefile = False , p_num = 10 , psi0 = [], max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 , seed = 1234 , eps = 1e-8 , load = False , ): State . StateSystem . __init__ ( self , savefile , psi0 , seed , eps , load ) \"\"\" -------- inputs -------- p_num: --description: the number of particles. --type: int psi0: --description: initial guesses of states (kets). --type: array max_episode: --description: max number of the training episodes. --type: int c0: --description: damping factor that assists convergence. --type: float c1: --description: exploitation weight that attract the particle to its best previous position. --type: float c2: --description: exploitation weight that attract the particle to the best position in the neighborhood. --type: float seed: --description: random seed. --type: int \"\"\" self . max_episode = max_episode self . p_num = p_num self . c0 = c0 self . c1 = c1 self . c2 = c2 self . seed = seed def QFIM ( self , W = [], LDtype = \"SLD\" ): r \"\"\" Choose QFI or $\\mathrm{Tr}(WF^{-1})$ as the objective function. In single parameter estimation the objective function is QFI and in multiparameter estimation it will be $\\mathrm{Tr}(WF^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). \"\"\" ini_particle = ([ self . psi ],) self . alg = Main . QuanEstimation . PSO ( self . max_episode , self . p_num , ini_particle , self . c0 , self . c1 , self . c2 , ) super () . QFIM ( W , LDtype ) def CFIM ( self , M = [], W = []): r \"\"\" Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" ini_particle = ([ self . psi ],) self . alg = Main . QuanEstimation . PSO ( self . max_episode , self . p_num , ini_particle , self . c0 , self . c1 , self . c2 , ) super () . CFIM ( M , W ) def HCRB ( self , W = []): \"\"\" Choose HCRB as the objective function. **Note:** in single parameter estimation, HCRB is equivalent to QFI, please choose QFI as the objective function. Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" ini_particle = ([ self . psi ],) self . alg = Main . QuanEstimation . PSO ( self . max_episode , self . p_num , ini_particle , self . c0 , self . c1 , self . c2 , ) super () . HCRB ( W ) CFIM ( M = [], W = []) \u00b6 Choose CFI or \\(\\mathrm{Tr}(WI^{-1})\\) as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be \\(\\mathrm{Tr}(WI^{-1})\\) . Parameters \u00b6 W: matrix -- Weight matrix. M: list of matrices -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). Note: SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from here . Source code in quanestimation/StateOpt/PSO_Sopt.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 def CFIM ( self , M = [], W = []): r \"\"\" Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" ini_particle = ([ self . psi ],) self . alg = Main . QuanEstimation . PSO ( self . max_episode , self . p_num , ini_particle , self . c0 , self . c1 , self . c2 , ) super () . CFIM ( M , W ) HCRB ( W = []) \u00b6 Choose HCRB as the objective function. Note: in single parameter estimation, HCRB is equivalent to QFI, please choose QFI as the objective function. Parameters \u00b6 W: matrix -- Weight matrix. Source code in quanestimation/StateOpt/PSO_Sopt.py 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 def HCRB ( self , W = []): \"\"\" Choose HCRB as the objective function. **Note:** in single parameter estimation, HCRB is equivalent to QFI, please choose QFI as the objective function. Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" ini_particle = ([ self . psi ],) self . alg = Main . QuanEstimation . PSO ( self . max_episode , self . p_num , ini_particle , self . c0 , self . c1 , self . c2 , ) super () . HCRB ( W ) QFIM ( W = [], LDtype = 'SLD' ) \u00b6 Choose QFI or \\(\\mathrm{Tr}(WF^{-1})\\) as the objective function. In single parameter estimation the objective function is QFI and in multiparameter estimation it will be \\(\\mathrm{Tr}(WF^{-1})\\) . Parameters \u00b6 W: matrix -- Weight matrix. LDtype: string -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). Source code in quanestimation/StateOpt/PSO_Sopt.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 def QFIM ( self , W = [], LDtype = \"SLD\" ): r \"\"\" Choose QFI or $\\mathrm{Tr}(WF^{-1})$ as the objective function. In single parameter estimation the objective function is QFI and in multiparameter estimation it will be $\\mathrm{Tr}(WF^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). \"\"\" ini_particle = ([ self . psi ],) self . alg = Main . QuanEstimation . PSO ( self . max_episode , self . p_num , ini_particle , self . c0 , self . c1 , self . c2 , ) super () . QFIM ( W , LDtype ) State Optimization DE \u00b6 Bases: State . StateSystem Attributes \u00b6 savefile: bool -- Whether or not to save all the states. If set True then the states and the values of the objective function obtained in all episodes will be saved during the training. If set False the state in the final episode and the values of the objective function in all episodes will be saved. p_num: int -- The number of populations. psi0: list of arrays -- Initial guesses of states. max_episode: int -- The number of episodes. c: float -- Mutation constant. cr: float -- Crossover constant. seed: int -- Random seed. eps: float -- Machine epsilon. load: bool -- Whether or not to load states in the current location. If set True then the program will load state from \"states.csv\" file in the current location and use it as the initial state. Source code in quanestimation/StateOpt/DE_Sopt.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 class DE_Sopt ( State . StateSystem ): \"\"\" Attributes ---------- > **savefile:** `bool` -- Whether or not to save all the states. If set `True` then the states and the values of the objective function obtained in all episodes will be saved during the training. If set `False` the state in the final episode and the values of the objective function in all episodes will be saved. > **p_num:** `int` -- The number of populations. > **psi0:** `list of arrays` -- Initial guesses of states. > **max_episode:** `int` -- The number of episodes. > **c:** `float` -- Mutation constant. > **cr:** `float` -- Crossover constant. > **seed:** `int` -- Random seed. > **eps:** `float` -- Machine epsilon. > **load:** `bool` -- Whether or not to load states in the current location. If set `True` then the program will load state from \"states.csv\" file in the current location and use it as the initial state. \"\"\" def __init__ ( self , savefile = False , p_num = 10 , psi0 = [], max_episode = 1000 , c = 1.0 , cr = 0.5 , seed = 1234 , eps = 1e-8 , load = False , ): State . StateSystem . __init__ ( self , savefile , psi0 , seed , eps , load ) self . p_num = p_num self . max_episode = max_episode self . c = c self . cr = cr self . seed = seed def QFIM ( self , W = [], LDtype = \"SLD\" ): r \"\"\" Choose QFI or $\\mathrm{Tr}(WF^{-1})$ as the objective function. In single parameter estimation the objective function is QFI and in multiparameter estimation it will be $\\mathrm{Tr}(WF^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). \"\"\" ini_population = ([ self . psi ],) self . alg = Main . QuanEstimation . DE ( self . max_episode , self . p_num , ini_population , self . c , self . cr , ) super () . QFIM ( W , LDtype ) def CFIM ( self , M = [], W = []): r \"\"\" Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" ini_population = ([ self . psi ],) self . alg = Main . QuanEstimation . DE ( self . max_episode , self . p_num , ini_population , self . c , self . cr , ) super () . CFIM ( M , W ) def HCRB ( self , W = []): \"\"\" Choose HCRB as the objective function. **Note:** in single parameter estimation, HCRB is equivalent to QFI, please choose QFI as the objective function. Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" ini_population = ([ self . psi ],) self . alg = Main . QuanEstimation . DE ( self . max_episode , self . p_num , ini_population , self . c , self . cr , ) super () . HCRB ( W ) CFIM ( M = [], W = []) \u00b6 Choose CFI or \\(\\mathrm{Tr}(WI^{-1})\\) as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be \\(\\mathrm{Tr}(WI^{-1})\\) . Parameters \u00b6 W: matrix -- Weight matrix. M: list of matrices -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). Note: SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from here . Source code in quanestimation/StateOpt/DE_Sopt.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 def CFIM ( self , M = [], W = []): r \"\"\" Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" ini_population = ([ self . psi ],) self . alg = Main . QuanEstimation . DE ( self . max_episode , self . p_num , ini_population , self . c , self . cr , ) super () . CFIM ( M , W ) HCRB ( W = []) \u00b6 Choose HCRB as the objective function. Note: in single parameter estimation, HCRB is equivalent to QFI, please choose QFI as the objective function. Parameters \u00b6 W: matrix -- Weight matrix. Source code in quanestimation/StateOpt/DE_Sopt.py 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 def HCRB ( self , W = []): \"\"\" Choose HCRB as the objective function. **Note:** in single parameter estimation, HCRB is equivalent to QFI, please choose QFI as the objective function. Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" ini_population = ([ self . psi ],) self . alg = Main . QuanEstimation . DE ( self . max_episode , self . p_num , ini_population , self . c , self . cr , ) super () . HCRB ( W ) QFIM ( W = [], LDtype = 'SLD' ) \u00b6 Choose QFI or \\(\\mathrm{Tr}(WF^{-1})\\) as the objective function. In single parameter estimation the objective function is QFI and in multiparameter estimation it will be \\(\\mathrm{Tr}(WF^{-1})\\) . Parameters \u00b6 W: matrix -- Weight matrix. LDtype: string -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). Source code in quanestimation/StateOpt/DE_Sopt.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 def QFIM ( self , W = [], LDtype = \"SLD\" ): r \"\"\" Choose QFI or $\\mathrm{Tr}(WF^{-1})$ as the objective function. In single parameter estimation the objective function is QFI and in multiparameter estimation it will be $\\mathrm{Tr}(WF^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). \"\"\" ini_population = ([ self . psi ],) self . alg = Main . QuanEstimation . DE ( self . max_episode , self . p_num , ini_population , self . c , self . cr , ) super () . QFIM ( W , LDtype ) State Optimization with DDPG \u00b6 Bases: State . StateSystem Attributes \u00b6 savefile: bool -- Whether or not to save all the states. If set True then the states and the values of the objective function obtained in all episodes will be saved during the training. If set False the state in the final episode and the values of the objective function in all episodes will be saved. psi0: list of arrays -- Initial guesses of states. max_episode: int -- The number of episodes. layer_num: int -- The number of layers (include the input and output layer). layer_dim: int -- The number of neurons in the hidden layer. seed: int -- Random seed. eps: float -- Machine epsilon. load: bool -- Whether or not to load states in the current location. If set True then the program will load state from \"states.csv\" file in the current location and use it as the initial state. Source code in quanestimation/StateOpt/DDPG_Sopt.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 class DDPG_Sopt ( State . StateSystem ): \"\"\" Attributes ---------- > **savefile:** `bool` -- Whether or not to save all the states. If set `True` then the states and the values of the objective function obtained in all episodes will be saved during the training. If set `False` the state in the final episode and the values of the objective function in all episodes will be saved. > **psi0:** `list of arrays` -- Initial guesses of states. > **max_episode:** `int` -- The number of episodes. > **layer_num:** `int` -- The number of layers (include the input and output layer). > **layer_dim:** `int` -- The number of neurons in the hidden layer. > **seed:** `int` -- Random seed. > **eps:** `float` -- Machine epsilon. > **load:** `bool` -- Whether or not to load states in the current location. If set `True` then the program will load state from \"states.csv\" file in the current location and use it as the initial state. \"\"\" def __init__ ( self , savefile = False , psi0 = [], max_episode = 500 , layer_num = 3 , layer_dim = 200 , seed = 1234 , eps = 1e-8 , load = False , ): State . StateSystem . __init__ ( self , savefile , psi0 , seed , eps , load ) self . max_episode = max_episode self . layer_num = layer_num self . layer_dim = layer_dim self . seed = seed self . alg = Main . QuanEstimation . DDPG ( self . max_episode , self . layer_num , self . layer_dim , self . seed ) def QFIM ( self , W = [], LDtype = \"SLD\" ): r \"\"\" Choose QFI or $\\mathrm{Tr}(WF^{-1})$ as the objective function. In single parameter estimation the objective function is QFI and in multiparameter estimation it will be $\\mathrm{Tr}(WF^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). \"\"\" super () . QFIM ( W , LDtype ) def CFIM ( self , M = [], W = []): r \"\"\" Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" super () . CFIM ( M , W ) def HCRB ( self , W = []): \"\"\" Choose HCRB as the objective function. **Note:** in single parameter estimation, HCRB is equivalent to QFI, please choose QFI as the objective function. Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" super () . HCRB ( W ) CFIM ( M = [], W = []) \u00b6 Choose CFI or \\(\\mathrm{Tr}(WI^{-1})\\) as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be \\(\\mathrm{Tr}(WI^{-1})\\) . Parameters \u00b6 W: matrix -- Weight matrix. M: list of matrices -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). Note: SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from here . Source code in quanestimation/StateOpt/DDPG_Sopt.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def CFIM ( self , M = [], W = []): r \"\"\" Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" super () . CFIM ( M , W ) HCRB ( W = []) \u00b6 Choose HCRB as the objective function. Note: in single parameter estimation, HCRB is equivalent to QFI, please choose QFI as the objective function. Parameters \u00b6 W: matrix -- Weight matrix. Source code in quanestimation/StateOpt/DDPG_Sopt.py 108 109 110 111 112 113 114 115 116 117 118 119 120 def HCRB ( self , W = []): \"\"\" Choose HCRB as the objective function. **Note:** in single parameter estimation, HCRB is equivalent to QFI, please choose QFI as the objective function. Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" super () . HCRB ( W ) QFIM ( W = [], LDtype = 'SLD' ) \u00b6 Choose QFI or \\(\\mathrm{Tr}(WF^{-1})\\) as the objective function. In single parameter estimation the objective function is QFI and in multiparameter estimation it will be \\(\\mathrm{Tr}(WF^{-1})\\) . Parameters \u00b6 W: matrix -- Weight matrix. LDtype: string -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). Source code in quanestimation/StateOpt/DDPG_Sopt.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def QFIM ( self , W = [], LDtype = \"SLD\" ): r \"\"\" Choose QFI or $\\mathrm{Tr}(WF^{-1})$ as the objective function. In single parameter estimation the objective function is QFI and in multiparameter estimation it will be $\\mathrm{Tr}(WF^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). \"\"\" super () . QFIM ( W , LDtype ) Measurement Optimization \u00b6 In QuanEstimation, three measurement optimization scenarios are considered. The first one is to optimize a set of rank-one projective measurement, it can be written in a specific basis \\(\\{|\\phi_i\\rangle\\}\\) with \\(|\\phi_i\\rangle=\\sum_j C_{ij}|j\\rangle\\) in the Hilbert space as \\(\\{|\\phi_i\\rangle\\langle\\phi_i|\\}\\) . In this case, the goal is to search a set of optimal coefficients \\(C_{ij}\\) . The second scenario is to find the optimal linear combination of an input measurement \\(\\{\\Pi_j\\}\\) . The third scenario is to find the optimal rotated measurement of an input measurement. After rotation, the new measurement is \\(\\{U\\Pi_i U^{\\dagger}\\}\\) , where \\(U=\\prod_k \\exp(i s_k\\lambda_k)\\) with \\(\\lambda_k\\) a SU( \\(N\\) ) generator and \\(s_k\\) a real number in the regime \\([0,2\\pi]\\) . In this scenario, the goal is to search a set of optimal coefficients \\(s_k\\) . Here different algorithms are invoked to search the optimal measurement include particle swarm optimization (PSO) [1] , differential evolution (DE) [2] , and automatic differentiation (AD) [[3]] (#Baydin2018). Base \u00b6 Attributes mtype: string -- The type of scenarios for the measurement optimization. Options are: \"projection\" (default) -- Optimization of rank-one projective measurements. \"input\" -- Find the optimal linear combination or the optimal rotated measurement of a given set of POVM. minput: list -- In the case of optimization of rank-one projective measurements, the minput should keep empty. For finding the optimal linear combination and the optimal rotated measurement of a given set of POVM, the input rule are minput=[\"LC\", [Pi1,Pi2,...], m] and minput=[\"LC\", [Pi1,Pi2,...]] respectively. Here [Pi1,Pi2,...] represents a list of input POVM and m is the number of operators of the output measurement. savefile: bool -- Whether or not to save all the measurements. If set True then the measurements and the values of the objective function obtained in all episodes will be saved during the training. If set False the measurement in the final episode and the values of the objective function in all episodes will be saved. measurement0: list of arrays -- Initial guesses of measurements. seed: int -- Random seed. eps: float -- Machine epsilon. load: bool -- Whether or not to load measurements in the current location. If set True then the program will load measurement from \"measurements.csv\" file in the current location and use it as the initial measurement. Source code in quanestimation/MeasurementOpt/MeasurementStruct.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 class MeasurementSystem : \"\"\" Attributes ---------- > **mtype:** `string` -- The type of scenarios for the measurement optimization. Options are: \"projection\" (default) -- Optimization of rank-one projective measurements. \"input\" -- Find the optimal linear combination or the optimal rotated measurement of a given set of POVM. > **minput:** `list` -- In the case of optimization of rank-one projective measurements, the `minput` should keep empty. For finding the optimal linear combination and the optimal rotated measurement of a given set of POVM, the input rule are `minput=[\"LC\", [Pi1,Pi2,...], m]` and `minput=[\"LC\", [Pi1,Pi2,...]]` respectively. Here `[Pi1,Pi2,...]` represents a list of input POVM and `m` is the number of operators of the output measurement. > **savefile:** `bool` -- Whether or not to save all the measurements. If set `True` then the measurements and the values of the objective function obtained in all episodes will be saved during the training. If set `False` the measurement in the final episode and the values of the objective function in all episodes will be saved. > **measurement0:** `list of arrays` -- Initial guesses of measurements. > **seed:** `int` -- Random seed. > **eps:** `float` -- Machine epsilon. > **load:** `bool` -- Whether or not to load measurements in the current location. If set `True` then the program will load measurement from \"measurements.csv\" file in the current location and use it as the initial measurement. \"\"\" def __init__ ( self , mtype , minput , savefile , measurement0 , seed , eps , load ): self . mtype = mtype self . minput = minput self . savefile = savefile self . eps = eps self . seed = seed self . load = load self . measurement0 = measurement0 def load_save ( self ): if os . path . exists ( \"measurements.csv\" ): file_load = open ( \"measurements.csv\" , \"r\" ) file_load = \"\" . join ([ i for i in file_load ]) . replace ( \"im\" , \"j\" ) file_load = \"\" . join ([ i for i in file_load ]) . replace ( \" \" , \"\" ) file_save = open ( \"measurements.csv\" , \"w\" ) file_save . writelines ( file_load ) file_save . close () else : pass def dynamics ( self , tspan , rho0 , H0 , dH , Hc = [], ctrl = [], decay = []): r \"\"\" The dynamics of a density matrix is of the form \\begin{align} \\partial_t\\rho &=\\mathcal{L}\\rho \\nonumber \\\\ &=-i[H,\\rho]+\\sum_i \\gamma_i\\left(\\Gamma_i\\rho\\Gamma^{\\dagger}_i-\\frac{1}{2} \\left\\{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\right\\}\\right), \\end{align} where $\\rho$ is the evolved density matrix, H is the Hamiltonian of the system, $\\Gamma_i$ and $\\gamma_i$ are the $i\\mathrm{th}$ decay operator and corresponding decay rate. Parameters ---------- > **tspan:** `array` -- Time length for the evolution. > **rho0:** `matrix` -- Initial state (density matrix). > **H0:** `matrix or list` -- Free Hamiltonian. It is a matrix when the free Hamiltonian is time- independent and a list of length equal to `tspan` when it is time-dependent. > **dH:** `list` -- Derivatives of the free Hamiltonian on the unknown parameters to be estimated. For example, dH[0] is the derivative vector on the first parameter. > **Hc:** `list` -- Control Hamiltonians. > **ctrl:** `list of arrays` -- Control coefficients. > **decay:** `list` -- Decay operators and the corresponding decay rates. Its input rule is decay=[[$\\Gamma_1$, $\\gamma_1$], [$\\Gamma_2$,$\\gamma_2$],...], where $\\Gamma_1$ $(\\Gamma_2)$ represents the decay operator and $\\gamma_1$ $(\\gamma_2)$ is the corresponding decay rate. \"\"\" self . tspan = tspan self . rho0 = np . array ( rho0 , dtype = np . complex128 ) self . dynamics_type = \"dynamics\" if len ( dH ) == 1 : self . para_type = \"single_para\" else : self . para_type = \"multi_para\" if self . mtype == \"projection\" : if self . measurement0 == []: np . random . seed ( self . seed ) M = [[] for i in range ( len ( self . rho0 ))] for i in range ( len ( self . rho0 )): r_ini = 2 * np . random . random ( len ( self . rho0 )) - np . ones ( len ( self . rho0 ) ) r = r_ini / np . linalg . norm ( r_ini ) phi = 2 * np . pi * np . random . random ( len ( self . rho0 )) M [ i ] = [ r [ j ] * np . exp ( 1.0 j * phi [ j ]) for j in range ( len ( self . rho0 ))] self . C = gramschmidt ( np . array ( M )) self . measurement0 = [ np . array ([ self . C [ i ] for i in range ( len ( self . rho0 ))]) ] else : self . C = [ self . measurement0 [ 0 ][ i ] for i in range ( len ( self . rho0 ))] self . C = [ np . array ( x , dtype = np . complex128 ) for x in self . C ] self . opt = Main . QuanEstimation . Mopt_Projection ( M = self . C , seed = self . seed ) elif self . mtype == \"input\" : if self . minput [ 0 ] == \"LC\" : ## optimize the combination of a set of SIC-POVM if self . minput [ 1 ] == []: file_path = os . path . join ( os . path . dirname ( os . path . dirname ( __file__ )), \"sic_fiducial_vectors/d %d .txt\" % ( len ( self . rho0 )), ) data = np . loadtxt ( file_path ) fiducial = data [:, 0 ] + data [:, 1 ] * 1.0 j fiducial = np . array ( fiducial ) . reshape ( len ( fiducial ), 1 ) self . povm_basis = sic_povm ( fiducial ) self . M_num = self . minput [ 2 ] else : ## optimize the combination of a set of given POVMs if type ( self . minput [ 1 ]) != list : raise TypeError ( \"The given POVMs should be a list!\" ) else : accu = len ( str ( int ( 1 / self . eps ))) - 1 for i in range ( len ( self . minput [ 1 ])): val , vec = np . linalg . eig ( self . minput [ 1 ]) if np . all ( val . round ( accu ) >= 0 ): pass else : raise TypeError ( \"The given POVMs should be semidefinite!\" ) M = np . zeros ( ( len ( self . rho0 ), len ( self . rho0 )), dtype = np . complex128 ) for i in range ( len ( self . minput [ 1 ])): M += self . minput [ 1 ][ i ] if np . all ( M . round ( accu ) - np . identity ( len ( self . rho0 )) == 0 ): pass else : raise TypeError ( \"The sum of the given POVMs should be identity matrix!\" ) self . povm_basis = [ np . array ( x , dtype = np . complex128 ) for x in self . minput [ 1 ] ] self . M_num = self . minput [ 2 ] if self . measurement0 == []: self . B = [ np . random . random ( len ( self . povm_basis )) for i in range ( self . M_num ) ] self . measurement0 = [ np . array ( self . B )] elif len ( self . measurement0 ) >= 1 : self . B = [ self . measurement0 [ 0 ][ i ] for i in range ( self . M_num )] self . opt = Main . QuanEstimation . Mopt_LinearComb ( B = self . B , POVM_basis = self . povm_basis , M_num = self . M_num , seed = self . seed ) elif self . minput [ 0 ] == \"rotation\" : ## optimize the coefficients of the rotation matrix if type ( self . minput [ 1 ]) != list : raise TypeError ( \"The given POVMs should be a list!\" ) else : if self . minput [ 1 ] == []: raise TypeError ( \"The initial POVM should not be empty!\" ) accu = len ( str ( int ( 1 / self . eps ))) - 1 for i in range ( len ( self . minput [ 1 ])): val , vec = np . linalg . eig ( self . minput [ 1 ]) if np . all ( val . round ( accu ) >= 0 ): pass else : raise TypeError ( \"The given POVMs should be semidefinite!\" ) M = np . zeros (( len ( self . rho0 ), len ( self . rho0 )), dtype = np . complex128 ) for i in range ( len ( self . minput [ 1 ])): M += self . minput [ 1 ][ i ] if np . all ( M . round ( accu ) - np . identity ( len ( self . rho0 )) == 0 ): pass else : raise TypeError ( \"The sum of the given POVMs should be identity matrix!\" ) self . povm_basis = [ np . array ( x , dtype = np . complex128 ) for x in self . minput [ 1 ] ] self . mtype = \"rotation\" if self . measurement0 == []: self . s = np . random . random ( len ( self . rho0 ) ** 2 ) self . measurement0 = [ self . s ] elif len ( self . measurement0 ) >= 1 : self . s = [ self . measurement0 [ 0 ][ i ] for i in range ( len ( self . rho0 ) * len ( self . rho0 )) ] self . opt = Main . QuanEstimation . Mopt_Rotation ( s = self . s , POVM_basis = self . povm_basis , Lambda = [], seed = self . seed ) #### Lambda=[] else : raise ValueError ( \" {!r} is not a valid value for the first input of minput, supported values are 'LC' and 'rotation'.\" . format ( self . minput [ 0 ] ) ) else : raise ValueError ( \" {!r} is not a valid value for mtype, supported values are 'projection' and 'input'.\" . format ( self . mtype ) ) if Hc == [] or ctrl == []: if type ( H0 ) == np . ndarray : self . freeHamiltonian = np . array ( H0 , dtype = np . complex128 ) else : self . freeHamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in H0 ] else : ctrl_num = len ( ctrl ) Hc_num = len ( Hc ) if Hc_num < ctrl_num : raise TypeError ( \"There are %d control Hamiltonians but %d coefficients sequences: too many coefficients sequences\" % ( Hc_num , ctrl_num ) ) elif Hc_num > ctrl_num : warnings . warn ( \"Not enough coefficients sequences: there are %d control Hamiltonians but %d coefficients sequences. The rest of the control sequences are set to be 0.\" % ( Hc_num , ctrl_num ), DeprecationWarning , ) for i in range ( Hc_num - ctrl_num ): ctrl = np . concatenate (( ctrl , np . zeros ( len ( ctrl [ 0 ])))) else : pass if len ( ctrl [ 0 ]) == 1 : if type ( H0 ) == np . ndarray : H0 = np . array ( H0 , dtype = np . complex128 ) Hc = [ np . array ( x , dtype = np . complex128 ) for x in Hc ] Htot = H0 + sum ([ Hc [ i ] * ctrl [ i ][ 0 ] for i in range ( ctrl_num )]) self . freeHamiltonian = np . array ( Htot , dtype = np . complex128 ) else : H0 = [ np . array ( x , dtype = np . complex128 ) for x in H0 ] Htot = [] for i in range ( len ( H0 )): Htot . append ( H0 [ i ] + sum ([ Hc [ i ] * ctrl [ i ][ 0 ] for i in range ( ctrl_num )]) ) self . freeHamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in Htot ] else : if type ( H0 ) != np . ndarray : #### linear interpolation #### f = interp1d ( self . tspan , H0 , axis = 0 ) else : pass number = math . ceil (( len ( self . tspan ) - 1 ) / len ( ctrl [ 0 ])) if len ( self . tspan ) - 1 % len ( ctrl [ 0 ]) != 0 : tnum = number * len ( ctrl [ 0 ]) self . tspan = np . linspace ( self . tspan [ 0 ], self . tspan [ - 1 ], tnum + 1 ) if type ( H0 ) != np . ndarray : H0_inter = f ( self . tspan ) H0 = [ np . array ( x , dtype = np . complex128 ) for x in H0_inter ] else : pass else : pass if type ( H0 ) == np . ndarray : H0 = np . array ( H0 , dtype = np . complex128 ) Hc = [ np . array ( x , dtype = np . complex128 ) for x in Hc ] ctrl = [ np . array ( ctrl [ i ]) . repeat ( number ) for i in range ( len ( Hc ))] Htot = [] for i in range ( len ( ctrl [ 0 ])): S_ctrl = sum ([ Hc [ j ] * ctrl [ j ][ i ] for j in range ( len ( ctrl ))]) Htot . append ( H0 + S_ctrl ) self . freeHamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in Htot ] else : H0 = [ np . array ( x , dtype = np . complex128 ) for x in H0 ] Hc = [ np . array ( x , dtype = np . complex128 ) for x in Hc ] ctrl = [ np . array ( ctrl [ i ]) . repeat ( number ) for i in range ( len ( Hc ))] Htot = [] for i in range ( len ( ctrl [ 0 ])): S_ctrl = sum ([ Hc [ j ] * ctrl [ j ][ i ] for j in range ( len ( ctrl ))]) Htot . append ( H0 [ i ] + S_ctrl ) self . freeHamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in Htot ] if type ( dH ) != list : raise TypeError ( \"The derivative of Hamiltonian should be a list!\" ) if dH == []: dH = [ np . zeros (( len ( self . rho0 ), len ( self . rho0 )))] self . Hamiltonian_derivative = [ np . array ( x , dtype = np . complex128 ) for x in dH ] if decay == []: decay_opt = [ np . zeros (( len ( self . rho0 ), len ( self . rho0 )))] self . gamma = [ 0.0 ] else : decay_opt = [ decay [ i ][ 0 ] for i in range ( len ( decay ))] self . gamma = [ decay [ i ][ 1 ] for i in range ( len ( decay ))] self . decay_opt = [ np . array ( x , dtype = np . complex128 ) for x in decay_opt ] if any ( self . gamma ): self . dynamic = Main . QuanEstimation . Lindblad ( self . freeHamiltonian , self . Hamiltonian_derivative , self . rho0 , self . tspan , self . decay_opt , self . gamma , ) else : self . dynamic = Main . QuanEstimation . Lindblad ( self . freeHamiltonian , self . Hamiltonian_derivative , self . rho0 , self . tspan , ) self . output = Main . QuanEstimation . Output ( self . opt , save = self . savefile ) self . dynamics_type = \"dynamics\" def Kraus ( self , rho0 , K , dK ): r \"\"\" The parameterization of a state is \\begin{align} \\rho=\\sum_i K_i\\rho_0K_i^{\\dagger}, \\end{align} where $\\rho$ is the evolved density matrix, $K_i$ is the Kraus operator. Parameters ---------- > **rho0:** `matrix` -- Initial state (density matrix). > **K:** `list` -- Kraus operators. > **dK:** `list` -- Derivatives of the Kraus operators on the unknown parameters to be estimated. For example, dK[0] is the derivative vector on the first parameter. \"\"\" k_num = len ( K ) para_num = len ( dK [ 0 ]) self . para_num = para_num self . dK = [ [ np . array ( dK [ i ][ j ], dtype = np . complex128 ) for j in range ( para_num )] for i in range ( k_num ) ] self . rho0 = np . array ( rho0 , dtype = np . complex128 ) self . K = [ np . array ( x , dtype = np . complex128 ) for x in K ] if para_num == 1 : self . para_type = \"single_para\" else : self . para_type = \"multi_para\" if self . mtype == \"projection\" : if self . measurement0 == []: np . random . seed ( self . seed ) M = [[] for i in range ( len ( self . rho0 ))] for i in range ( len ( self . rho0 )): r_ini = 2 * np . random . random ( len ( self . rho0 )) - np . ones ( len ( self . rho0 ) ) r = r_ini / np . linalg . norm ( r_ini ) phi = 2 * np . pi * np . random . random ( len ( self . rho0 )) M [ i ] = [ r [ j ] * np . exp ( 1.0 j * phi [ j ]) for j in range ( len ( self . rho0 ))] self . C = gramschmidt ( np . array ( M )) self . measurement0 = [ np . array ([ self . C [ i ] for i in range ( len ( self . rho0 ))]) ] else : self . C = [ self . measurement0 [ 0 ][ i ] for i in range ( len ( self . rho0 ))] self . C = [ np . array ( x , dtype = np . complex128 ) for x in self . C ] self . opt = Main . QuanEstimation . Mopt_Projection ( M = self . C , seed = self . seed ) elif self . mtype == \"input\" : if self . minput [ 0 ] == \"LC\" : ## optimize the combination of a set of SIC-POVM if self . minput [ 1 ] == []: file_path = os . path . join ( os . path . dirname ( os . path . dirname ( __file__ )), \"sic_fiducial_vectors/d %d .txt\" % ( len ( self . rho0 )), ) data = np . loadtxt ( file_path ) fiducial = data [:, 0 ] + data [:, 1 ] * 1.0 j fiducial = np . array ( fiducial ) . reshape ( len ( fiducial ), 1 ) self . povm_basis = sic_povm ( fiducial ) self . M_num = self . minput [ 2 ] else : ## optimize the combination of a set of given POVMs if type ( self . minput [ 1 ]) != list : raise TypeError ( \"The given POVMs should be a list!\" ) else : accu = len ( str ( int ( 1 / self . eps ))) - 1 for i in range ( len ( self . minput [ 1 ])): val , vec = np . linalg . eig ( self . minput [ 1 ]) if np . all ( val . round ( accu ) >= 0 ): pass else : raise TypeError ( \"The given POVMs should be semidefinite!\" ) M = np . zeros ( ( len ( self . rho0 ), len ( self . rho0 )), dtype = np . complex128 ) for i in range ( len ( self . minput [ 1 ])): M += self . minput [ 1 ][ i ] if np . all ( M . round ( accu ) - np . identity ( len ( self . rho0 )) == 0 ): pass else : raise TypeError ( \"The sum of the given POVMs should be identity matrix!\" ) self . povm_basis = [ np . array ( x , dtype = np . complex128 ) for x in self . minput [ 1 ] ] self . M_num = self . minput [ 2 ] if self . measurement0 == []: self . B = [ np . random . random ( len ( self . povm_basis )) for i in range ( self . M_num ) ] self . measurement0 = [ np . array ( self . B )] elif len ( self . measurement0 ) >= 1 : self . B = [ self . measurement0 [ 0 ][ i ] for i in range ( len ( self . povm_basis )) ] self . opt = Main . QuanEstimation . Mopt_LinearComb ( B = self . B , POVM_basis = self . povm_basis , M_num = self . M_num , seed = self . seed ) elif self . minput [ 0 ] == \"rotation\" : ## optimize the coefficients of the rotation matrix if type ( self . minput [ 1 ]) != list : raise TypeError ( \"The given POVMs should be a list!\" ) else : if self . minput [ 1 ] == []: raise TypeError ( \"The initial POVM should not be empty!\" ) accu = len ( str ( int ( 1 / self . eps ))) - 1 for i in range ( len ( self . minput [ 1 ])): val , vec = np . linalg . eig ( self . minput [ 1 ]) if np . all ( val . round ( accu ) >= 0 ): pass else : raise TypeError ( \"The given POVMs should be semidefinite!\" ) M = np . zeros (( len ( self . rho0 ), len ( self . rho0 )), dtype = np . complex128 ) for i in range ( len ( self . minput [ 1 ])): M += self . minput [ 1 ][ i ] if np . all ( M . round ( accu ) - np . identity ( len ( self . rho0 )) == 0 ): pass else : raise TypeError ( \"The sum of the given POVMs should be identity matrix!\" ) self . povm_basis = [ np . array ( x , dtype = np . complex128 ) for x in self . minput [ 1 ] ] self . mtype = \"rotation\" if self . measurement0 == []: self . s = np . random . random ( len ( self . rho0 ) ** 2 ) self . measurement0 = [ self . s ] elif len ( self . measurement0 ) >= 1 : self . s = [ self . measurement0 [ 0 ][ i ] for i in range ( len ( self . rho0 ) * len ( self . rho0 )) ] self . opt = Main . QuanEstimation . Mopt_Rotation ( s = self . s , POVM_basis = self . povm_basis , Lambda = [], seed = self . seed ) else : raise ValueError ( \" {!r} is not a valid value for the first input of minput, supported values are 'LC' and 'rotation'.\" . format ( self . minput [ 0 ] ) ) else : raise ValueError ( \" {!r} is not a valid value for mtype, supported values are 'projection' and 'input'.\" . format ( self . mtype ) ) self . dynamic = Main . QuanEstimation . Kraus ( self . rho0 , self . K , self . dK ) self . output = Main . QuanEstimation . Output ( self . opt , save = self . savefile ) self . dynamics_type = \"Kraus\" def CFIM ( self , W = []): r \"\"\" Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" if self . dynamics_type == \"dynamics\" : if W == []: W = np . eye ( len ( self . Hamiltonian_derivative )) self . W = W elif self . dynamics_type == \"Kraus\" : if W == []: W = np . eye ( self . para_num ) self . W = W else : raise ValueError ( \"Supported type of dynamics are Lindblad and Kraus.\" ) self . obj = Main . QuanEstimation . CFIM_obj ( [], self . W , self . eps , self . para_type ) #### m=[] system = Main . QuanEstimation . QuanEstSystem ( self . opt , self . alg , self . obj , self . dynamic , self . output ) Main . QuanEstimation . run ( system ) self . load_save () CFIM ( W = []) \u00b6 Choose CFI or \\(\\mathrm{Tr}(WI^{-1})\\) as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be \\(\\mathrm{Tr}(WI^{-1})\\) . Parameters \u00b6 W: matrix -- Weight matrix. Source code in quanestimation/MeasurementOpt/MeasurementStruct.py 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 def CFIM ( self , W = []): r \"\"\" Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" if self . dynamics_type == \"dynamics\" : if W == []: W = np . eye ( len ( self . Hamiltonian_derivative )) self . W = W elif self . dynamics_type == \"Kraus\" : if W == []: W = np . eye ( self . para_num ) self . W = W else : raise ValueError ( \"Supported type of dynamics are Lindblad and Kraus.\" ) self . obj = Main . QuanEstimation . CFIM_obj ( [], self . W , self . eps , self . para_type ) #### m=[] system = Main . QuanEstimation . QuanEstSystem ( self . opt , self . alg , self . obj , self . dynamic , self . output ) Main . QuanEstimation . run ( system ) self . load_save () Kraus ( rho0 , K , dK ) \u00b6 The parameterization of a state is \\begin{align} \\rho=\\sum_i K_i\\rho_0K_i^{\\dagger}, \\end{align} where \\(\\rho\\) is the evolved density matrix, \\(K_i\\) is the Kraus operator. Parameters \u00b6 rho0: matrix -- Initial state (density matrix). K: list -- Kraus operators. dK: list -- Derivatives of the Kraus operators on the unknown parameters to be estimated. For example, dK[0] is the derivative vector on the first parameter. Source code in quanestimation/MeasurementOpt/MeasurementStruct.py 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 def Kraus ( self , rho0 , K , dK ): r \"\"\" The parameterization of a state is \\begin{align} \\rho=\\sum_i K_i\\rho_0K_i^{\\dagger}, \\end{align} where $\\rho$ is the evolved density matrix, $K_i$ is the Kraus operator. Parameters ---------- > **rho0:** `matrix` -- Initial state (density matrix). > **K:** `list` -- Kraus operators. > **dK:** `list` -- Derivatives of the Kraus operators on the unknown parameters to be estimated. For example, dK[0] is the derivative vector on the first parameter. \"\"\" k_num = len ( K ) para_num = len ( dK [ 0 ]) self . para_num = para_num self . dK = [ [ np . array ( dK [ i ][ j ], dtype = np . complex128 ) for j in range ( para_num )] for i in range ( k_num ) ] self . rho0 = np . array ( rho0 , dtype = np . complex128 ) self . K = [ np . array ( x , dtype = np . complex128 ) for x in K ] if para_num == 1 : self . para_type = \"single_para\" else : self . para_type = \"multi_para\" if self . mtype == \"projection\" : if self . measurement0 == []: np . random . seed ( self . seed ) M = [[] for i in range ( len ( self . rho0 ))] for i in range ( len ( self . rho0 )): r_ini = 2 * np . random . random ( len ( self . rho0 )) - np . ones ( len ( self . rho0 ) ) r = r_ini / np . linalg . norm ( r_ini ) phi = 2 * np . pi * np . random . random ( len ( self . rho0 )) M [ i ] = [ r [ j ] * np . exp ( 1.0 j * phi [ j ]) for j in range ( len ( self . rho0 ))] self . C = gramschmidt ( np . array ( M )) self . measurement0 = [ np . array ([ self . C [ i ] for i in range ( len ( self . rho0 ))]) ] else : self . C = [ self . measurement0 [ 0 ][ i ] for i in range ( len ( self . rho0 ))] self . C = [ np . array ( x , dtype = np . complex128 ) for x in self . C ] self . opt = Main . QuanEstimation . Mopt_Projection ( M = self . C , seed = self . seed ) elif self . mtype == \"input\" : if self . minput [ 0 ] == \"LC\" : ## optimize the combination of a set of SIC-POVM if self . minput [ 1 ] == []: file_path = os . path . join ( os . path . dirname ( os . path . dirname ( __file__ )), \"sic_fiducial_vectors/d %d .txt\" % ( len ( self . rho0 )), ) data = np . loadtxt ( file_path ) fiducial = data [:, 0 ] + data [:, 1 ] * 1.0 j fiducial = np . array ( fiducial ) . reshape ( len ( fiducial ), 1 ) self . povm_basis = sic_povm ( fiducial ) self . M_num = self . minput [ 2 ] else : ## optimize the combination of a set of given POVMs if type ( self . minput [ 1 ]) != list : raise TypeError ( \"The given POVMs should be a list!\" ) else : accu = len ( str ( int ( 1 / self . eps ))) - 1 for i in range ( len ( self . minput [ 1 ])): val , vec = np . linalg . eig ( self . minput [ 1 ]) if np . all ( val . round ( accu ) >= 0 ): pass else : raise TypeError ( \"The given POVMs should be semidefinite!\" ) M = np . zeros ( ( len ( self . rho0 ), len ( self . rho0 )), dtype = np . complex128 ) for i in range ( len ( self . minput [ 1 ])): M += self . minput [ 1 ][ i ] if np . all ( M . round ( accu ) - np . identity ( len ( self . rho0 )) == 0 ): pass else : raise TypeError ( \"The sum of the given POVMs should be identity matrix!\" ) self . povm_basis = [ np . array ( x , dtype = np . complex128 ) for x in self . minput [ 1 ] ] self . M_num = self . minput [ 2 ] if self . measurement0 == []: self . B = [ np . random . random ( len ( self . povm_basis )) for i in range ( self . M_num ) ] self . measurement0 = [ np . array ( self . B )] elif len ( self . measurement0 ) >= 1 : self . B = [ self . measurement0 [ 0 ][ i ] for i in range ( len ( self . povm_basis )) ] self . opt = Main . QuanEstimation . Mopt_LinearComb ( B = self . B , POVM_basis = self . povm_basis , M_num = self . M_num , seed = self . seed ) elif self . minput [ 0 ] == \"rotation\" : ## optimize the coefficients of the rotation matrix if type ( self . minput [ 1 ]) != list : raise TypeError ( \"The given POVMs should be a list!\" ) else : if self . minput [ 1 ] == []: raise TypeError ( \"The initial POVM should not be empty!\" ) accu = len ( str ( int ( 1 / self . eps ))) - 1 for i in range ( len ( self . minput [ 1 ])): val , vec = np . linalg . eig ( self . minput [ 1 ]) if np . all ( val . round ( accu ) >= 0 ): pass else : raise TypeError ( \"The given POVMs should be semidefinite!\" ) M = np . zeros (( len ( self . rho0 ), len ( self . rho0 )), dtype = np . complex128 ) for i in range ( len ( self . minput [ 1 ])): M += self . minput [ 1 ][ i ] if np . all ( M . round ( accu ) - np . identity ( len ( self . rho0 )) == 0 ): pass else : raise TypeError ( \"The sum of the given POVMs should be identity matrix!\" ) self . povm_basis = [ np . array ( x , dtype = np . complex128 ) for x in self . minput [ 1 ] ] self . mtype = \"rotation\" if self . measurement0 == []: self . s = np . random . random ( len ( self . rho0 ) ** 2 ) self . measurement0 = [ self . s ] elif len ( self . measurement0 ) >= 1 : self . s = [ self . measurement0 [ 0 ][ i ] for i in range ( len ( self . rho0 ) * len ( self . rho0 )) ] self . opt = Main . QuanEstimation . Mopt_Rotation ( s = self . s , POVM_basis = self . povm_basis , Lambda = [], seed = self . seed ) else : raise ValueError ( \" {!r} is not a valid value for the first input of minput, supported values are 'LC' and 'rotation'.\" . format ( self . minput [ 0 ] ) ) else : raise ValueError ( \" {!r} is not a valid value for mtype, supported values are 'projection' and 'input'.\" . format ( self . mtype ) ) self . dynamic = Main . QuanEstimation . Kraus ( self . rho0 , self . K , self . dK ) self . output = Main . QuanEstimation . Output ( self . opt , save = self . savefile ) self . dynamics_type = \"Kraus\" dynamics ( tspan , rho0 , H0 , dH , Hc = [], ctrl = [], decay = []) \u00b6 The dynamics of a density matrix is of the form \\[\\begin{align} \\partial_t\\rho &=\\mathcal{L}\\rho \\nonumber \\\\ &=-i[H,\\rho]+\\sum_i \\gamma_i\\left(\\Gamma_i\\rho\\Gamma^{\\dagger}_i-\\frac{1}{2} \\left\\{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\right\\}\\right), \\end{align}\\] where \\(\\rho\\) is the evolved density matrix, H is the Hamiltonian of the system, \\(\\Gamma_i\\) and \\(\\gamma_i\\) are the \\(i\\mathrm{th}\\) decay operator and corresponding decay rate. Parameters \u00b6 tspan: array -- Time length for the evolution. rho0: matrix -- Initial state (density matrix). H0: matrix or list -- Free Hamiltonian. It is a matrix when the free Hamiltonian is time- independent and a list of length equal to tspan when it is time-dependent. dH: list -- Derivatives of the free Hamiltonian on the unknown parameters to be estimated. For example, dH[0] is the derivative vector on the first parameter. Hc: list -- Control Hamiltonians. ctrl: list of arrays -- Control coefficients. decay: list -- Decay operators and the corresponding decay rates. Its input rule is decay=[[ \\(\\Gamma_1\\) , \\(\\gamma_1\\) ], [ \\(\\Gamma_2\\) , \\(\\gamma_2\\) ],...], where \\(\\Gamma_1\\) \\((\\Gamma_2)\\) represents the decay operator and \\(\\gamma_1\\) \\((\\gamma_2)\\) is the corresponding decay rate. Source code in quanestimation/MeasurementOpt/MeasurementStruct.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 def dynamics ( self , tspan , rho0 , H0 , dH , Hc = [], ctrl = [], decay = []): r \"\"\" The dynamics of a density matrix is of the form \\begin{align} \\partial_t\\rho &=\\mathcal{L}\\rho \\nonumber \\\\ &=-i[H,\\rho]+\\sum_i \\gamma_i\\left(\\Gamma_i\\rho\\Gamma^{\\dagger}_i-\\frac{1}{2} \\left\\{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\right\\}\\right), \\end{align} where $\\rho$ is the evolved density matrix, H is the Hamiltonian of the system, $\\Gamma_i$ and $\\gamma_i$ are the $i\\mathrm{th}$ decay operator and corresponding decay rate. Parameters ---------- > **tspan:** `array` -- Time length for the evolution. > **rho0:** `matrix` -- Initial state (density matrix). > **H0:** `matrix or list` -- Free Hamiltonian. It is a matrix when the free Hamiltonian is time- independent and a list of length equal to `tspan` when it is time-dependent. > **dH:** `list` -- Derivatives of the free Hamiltonian on the unknown parameters to be estimated. For example, dH[0] is the derivative vector on the first parameter. > **Hc:** `list` -- Control Hamiltonians. > **ctrl:** `list of arrays` -- Control coefficients. > **decay:** `list` -- Decay operators and the corresponding decay rates. Its input rule is decay=[[$\\Gamma_1$, $\\gamma_1$], [$\\Gamma_2$,$\\gamma_2$],...], where $\\Gamma_1$ $(\\Gamma_2)$ represents the decay operator and $\\gamma_1$ $(\\gamma_2)$ is the corresponding decay rate. \"\"\" self . tspan = tspan self . rho0 = np . array ( rho0 , dtype = np . complex128 ) self . dynamics_type = \"dynamics\" if len ( dH ) == 1 : self . para_type = \"single_para\" else : self . para_type = \"multi_para\" if self . mtype == \"projection\" : if self . measurement0 == []: np . random . seed ( self . seed ) M = [[] for i in range ( len ( self . rho0 ))] for i in range ( len ( self . rho0 )): r_ini = 2 * np . random . random ( len ( self . rho0 )) - np . ones ( len ( self . rho0 ) ) r = r_ini / np . linalg . norm ( r_ini ) phi = 2 * np . pi * np . random . random ( len ( self . rho0 )) M [ i ] = [ r [ j ] * np . exp ( 1.0 j * phi [ j ]) for j in range ( len ( self . rho0 ))] self . C = gramschmidt ( np . array ( M )) self . measurement0 = [ np . array ([ self . C [ i ] for i in range ( len ( self . rho0 ))]) ] else : self . C = [ self . measurement0 [ 0 ][ i ] for i in range ( len ( self . rho0 ))] self . C = [ np . array ( x , dtype = np . complex128 ) for x in self . C ] self . opt = Main . QuanEstimation . Mopt_Projection ( M = self . C , seed = self . seed ) elif self . mtype == \"input\" : if self . minput [ 0 ] == \"LC\" : ## optimize the combination of a set of SIC-POVM if self . minput [ 1 ] == []: file_path = os . path . join ( os . path . dirname ( os . path . dirname ( __file__ )), \"sic_fiducial_vectors/d %d .txt\" % ( len ( self . rho0 )), ) data = np . loadtxt ( file_path ) fiducial = data [:, 0 ] + data [:, 1 ] * 1.0 j fiducial = np . array ( fiducial ) . reshape ( len ( fiducial ), 1 ) self . povm_basis = sic_povm ( fiducial ) self . M_num = self . minput [ 2 ] else : ## optimize the combination of a set of given POVMs if type ( self . minput [ 1 ]) != list : raise TypeError ( \"The given POVMs should be a list!\" ) else : accu = len ( str ( int ( 1 / self . eps ))) - 1 for i in range ( len ( self . minput [ 1 ])): val , vec = np . linalg . eig ( self . minput [ 1 ]) if np . all ( val . round ( accu ) >= 0 ): pass else : raise TypeError ( \"The given POVMs should be semidefinite!\" ) M = np . zeros ( ( len ( self . rho0 ), len ( self . rho0 )), dtype = np . complex128 ) for i in range ( len ( self . minput [ 1 ])): M += self . minput [ 1 ][ i ] if np . all ( M . round ( accu ) - np . identity ( len ( self . rho0 )) == 0 ): pass else : raise TypeError ( \"The sum of the given POVMs should be identity matrix!\" ) self . povm_basis = [ np . array ( x , dtype = np . complex128 ) for x in self . minput [ 1 ] ] self . M_num = self . minput [ 2 ] if self . measurement0 == []: self . B = [ np . random . random ( len ( self . povm_basis )) for i in range ( self . M_num ) ] self . measurement0 = [ np . array ( self . B )] elif len ( self . measurement0 ) >= 1 : self . B = [ self . measurement0 [ 0 ][ i ] for i in range ( self . M_num )] self . opt = Main . QuanEstimation . Mopt_LinearComb ( B = self . B , POVM_basis = self . povm_basis , M_num = self . M_num , seed = self . seed ) elif self . minput [ 0 ] == \"rotation\" : ## optimize the coefficients of the rotation matrix if type ( self . minput [ 1 ]) != list : raise TypeError ( \"The given POVMs should be a list!\" ) else : if self . minput [ 1 ] == []: raise TypeError ( \"The initial POVM should not be empty!\" ) accu = len ( str ( int ( 1 / self . eps ))) - 1 for i in range ( len ( self . minput [ 1 ])): val , vec = np . linalg . eig ( self . minput [ 1 ]) if np . all ( val . round ( accu ) >= 0 ): pass else : raise TypeError ( \"The given POVMs should be semidefinite!\" ) M = np . zeros (( len ( self . rho0 ), len ( self . rho0 )), dtype = np . complex128 ) for i in range ( len ( self . minput [ 1 ])): M += self . minput [ 1 ][ i ] if np . all ( M . round ( accu ) - np . identity ( len ( self . rho0 )) == 0 ): pass else : raise TypeError ( \"The sum of the given POVMs should be identity matrix!\" ) self . povm_basis = [ np . array ( x , dtype = np . complex128 ) for x in self . minput [ 1 ] ] self . mtype = \"rotation\" if self . measurement0 == []: self . s = np . random . random ( len ( self . rho0 ) ** 2 ) self . measurement0 = [ self . s ] elif len ( self . measurement0 ) >= 1 : self . s = [ self . measurement0 [ 0 ][ i ] for i in range ( len ( self . rho0 ) * len ( self . rho0 )) ] self . opt = Main . QuanEstimation . Mopt_Rotation ( s = self . s , POVM_basis = self . povm_basis , Lambda = [], seed = self . seed ) #### Lambda=[] else : raise ValueError ( \" {!r} is not a valid value for the first input of minput, supported values are 'LC' and 'rotation'.\" . format ( self . minput [ 0 ] ) ) else : raise ValueError ( \" {!r} is not a valid value for mtype, supported values are 'projection' and 'input'.\" . format ( self . mtype ) ) if Hc == [] or ctrl == []: if type ( H0 ) == np . ndarray : self . freeHamiltonian = np . array ( H0 , dtype = np . complex128 ) else : self . freeHamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in H0 ] else : ctrl_num = len ( ctrl ) Hc_num = len ( Hc ) if Hc_num < ctrl_num : raise TypeError ( \"There are %d control Hamiltonians but %d coefficients sequences: too many coefficients sequences\" % ( Hc_num , ctrl_num ) ) elif Hc_num > ctrl_num : warnings . warn ( \"Not enough coefficients sequences: there are %d control Hamiltonians but %d coefficients sequences. The rest of the control sequences are set to be 0.\" % ( Hc_num , ctrl_num ), DeprecationWarning , ) for i in range ( Hc_num - ctrl_num ): ctrl = np . concatenate (( ctrl , np . zeros ( len ( ctrl [ 0 ])))) else : pass if len ( ctrl [ 0 ]) == 1 : if type ( H0 ) == np . ndarray : H0 = np . array ( H0 , dtype = np . complex128 ) Hc = [ np . array ( x , dtype = np . complex128 ) for x in Hc ] Htot = H0 + sum ([ Hc [ i ] * ctrl [ i ][ 0 ] for i in range ( ctrl_num )]) self . freeHamiltonian = np . array ( Htot , dtype = np . complex128 ) else : H0 = [ np . array ( x , dtype = np . complex128 ) for x in H0 ] Htot = [] for i in range ( len ( H0 )): Htot . append ( H0 [ i ] + sum ([ Hc [ i ] * ctrl [ i ][ 0 ] for i in range ( ctrl_num )]) ) self . freeHamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in Htot ] else : if type ( H0 ) != np . ndarray : #### linear interpolation #### f = interp1d ( self . tspan , H0 , axis = 0 ) else : pass number = math . ceil (( len ( self . tspan ) - 1 ) / len ( ctrl [ 0 ])) if len ( self . tspan ) - 1 % len ( ctrl [ 0 ]) != 0 : tnum = number * len ( ctrl [ 0 ]) self . tspan = np . linspace ( self . tspan [ 0 ], self . tspan [ - 1 ], tnum + 1 ) if type ( H0 ) != np . ndarray : H0_inter = f ( self . tspan ) H0 = [ np . array ( x , dtype = np . complex128 ) for x in H0_inter ] else : pass else : pass if type ( H0 ) == np . ndarray : H0 = np . array ( H0 , dtype = np . complex128 ) Hc = [ np . array ( x , dtype = np . complex128 ) for x in Hc ] ctrl = [ np . array ( ctrl [ i ]) . repeat ( number ) for i in range ( len ( Hc ))] Htot = [] for i in range ( len ( ctrl [ 0 ])): S_ctrl = sum ([ Hc [ j ] * ctrl [ j ][ i ] for j in range ( len ( ctrl ))]) Htot . append ( H0 + S_ctrl ) self . freeHamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in Htot ] else : H0 = [ np . array ( x , dtype = np . complex128 ) for x in H0 ] Hc = [ np . array ( x , dtype = np . complex128 ) for x in Hc ] ctrl = [ np . array ( ctrl [ i ]) . repeat ( number ) for i in range ( len ( Hc ))] Htot = [] for i in range ( len ( ctrl [ 0 ])): S_ctrl = sum ([ Hc [ j ] * ctrl [ j ][ i ] for j in range ( len ( ctrl ))]) Htot . append ( H0 [ i ] + S_ctrl ) self . freeHamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in Htot ] if type ( dH ) != list : raise TypeError ( \"The derivative of Hamiltonian should be a list!\" ) if dH == []: dH = [ np . zeros (( len ( self . rho0 ), len ( self . rho0 )))] self . Hamiltonian_derivative = [ np . array ( x , dtype = np . complex128 ) for x in dH ] if decay == []: decay_opt = [ np . zeros (( len ( self . rho0 ), len ( self . rho0 )))] self . gamma = [ 0.0 ] else : decay_opt = [ decay [ i ][ 0 ] for i in range ( len ( decay ))] self . gamma = [ decay [ i ][ 1 ] for i in range ( len ( decay ))] self . decay_opt = [ np . array ( x , dtype = np . complex128 ) for x in decay_opt ] if any ( self . gamma ): self . dynamic = Main . QuanEstimation . Lindblad ( self . freeHamiltonian , self . Hamiltonian_derivative , self . rho0 , self . tspan , self . decay_opt , self . gamma , ) else : self . dynamic = Main . QuanEstimation . Lindblad ( self . freeHamiltonian , self . Hamiltonian_derivative , self . rho0 , self . tspan , ) self . output = Main . QuanEstimation . Output ( self . opt , save = self . savefile ) self . dynamics_type = \"dynamics\" Measurement optimization with AD \u00b6 Bases: Measurement . MeasurementSystem Attributes \u00b6 savefile: bool -- Whether or not to save all the measurements. If set True then the measurements and the values of the objective function obtained in all episodes will be saved during the training. If set False the measurement in the final episode and the values of the objective function in all episodes will be saved. Adam: bool -- Whether or not to use Adam for updating measurements. measurement0: list of arrays -- Initial guesses of measurements. max_episode: int -- The number of episodes. epsilon: float -- Learning rate. beta1: float -- The exponential decay rate for the first moment estimates. beta2: float -- The exponential decay rate for the second moment estimates. eps: float -- Machine epsilon. load: bool -- Whether or not to load measurements in the current location. If set True then the program will load measurement from \"measurements.csv\" file in the current location and use it as the initial measurement. Source code in quanestimation/MeasurementOpt/AD_Mopt.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 class AD_Mopt ( Measurement . MeasurementSystem ): \"\"\" Attributes ---------- > **savefile:** `bool` -- Whether or not to save all the measurements. If set `True` then the measurements and the values of the objective function obtained in all episodes will be saved during the training. If set `False` the measurement in the final episode and the values of the objective function in all episodes will be saved. > **Adam:** `bool` -- Whether or not to use Adam for updating measurements. > **measurement0:** `list of arrays` -- Initial guesses of measurements. > **max_episode:** `int` -- The number of episodes. > **epsilon:** `float` -- Learning rate. > **beta1:** `float` -- The exponential decay rate for the first moment estimates. > **beta2:** `float` -- The exponential decay rate for the second moment estimates. > **eps:** `float` -- Machine epsilon. > **load:** `bool` -- Whether or not to load measurements in the current location. If set `True` then the program will load measurement from \"measurements.csv\" file in the current location and use it as the initial measurement. \"\"\" def __init__ ( self , mtype , minput , savefile = False , Adam = False , measurement0 = [], max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 , seed = 1234 , eps = 1e-8 , load = False , ): Measurement . MeasurementSystem . __init__ ( self , mtype , minput , savefile , measurement0 , seed , eps , load ) self . Adam = Adam self . max_episode = max_episode self . epsilon = epsilon self . beta1 = beta1 self . beta2 = beta2 self . mt = 0.0 self . vt = 0.0 self . seed = seed if self . Adam : self . alg = Main . QuanEstimation . AD ( self . max_episode , self . epsilon , self . beta1 , self . beta2 ) else : self . alg = Main . QuanEstimation . AD ( self . max_episode , self . epsilon ) def CFIM ( self , W = []): r \"\"\" Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" if self . mtype == \"projection\" : raise ValueError ( \"AD is not available when mtype is projection. Supported methods are 'PSO' and 'DE'.\" , ) else : super () . CFIM ( W ) CFIM ( W = []) \u00b6 Choose CFI or \\(\\mathrm{Tr}(WI^{-1})\\) as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be \\(\\mathrm{Tr}(WI^{-1})\\) . Parameters \u00b6 W: matrix -- Weight matrix. Source code in quanestimation/MeasurementOpt/AD_Mopt.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def CFIM ( self , W = []): r \"\"\" Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" if self . mtype == \"projection\" : raise ValueError ( \"AD is not available when mtype is projection. Supported methods are 'PSO' and 'DE'.\" , ) else : super () . CFIM ( W ) Measurement Optimization with PSO \u00b6 Bases: Measurement . MeasurementSystem Attributes \u00b6 savefile: bool -- Whether or not to save all the measurements. If set True then the measurements and the values of the objective function obtained in all episodes will be saved during the training. If set False the measurement in the final episode and the values of the objective function in all episodes will be saved. p_num: int -- The number of particles. measurement0: list of arrays -- Initial guesses of measurements. max_episode: int or list -- If it is an integer, for example max_episode=1000, it means the program will continuously run 1000 episodes. However, if it is an array, for example max_episode=[1000,100], the program will run 1000 episodes in total but replace measurements of all the particles with global best every 100 episodes. c0: float -- The damping factor that assists convergence, also known as inertia weight. c1: float -- The exploitation weight that attracts the particle to its best previous position, also known as cognitive learning factor. c2: float -- The exploitation weight that attracts the particle to the best position in the neighborhood, also known as social learning factor. seed: int -- Random seed. eps: float -- Machine epsilon. load: bool -- Whether or not to load measurements in the current location. If set True then the program will load measurement from \"measurements.csv\" file in the current location and use it as the initial measurement. Source code in quanestimation/MeasurementOpt/PSO_Mopt.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 class PSO_Mopt ( Measurement . MeasurementSystem ): \"\"\" Attributes ---------- > **savefile:** `bool` -- Whether or not to save all the measurements. If set `True` then the measurements and the values of the objective function obtained in all episodes will be saved during the training. If set `False` the measurement in the final episode and the values of the objective function in all episodes will be saved. > **p_num:** `int` -- The number of particles. > **measurement0:** `list of arrays` -- Initial guesses of measurements. > **max_episode:** `int or list` -- If it is an integer, for example max_episode=1000, it means the program will continuously run 1000 episodes. However, if it is an array, for example max_episode=[1000,100], the program will run 1000 episodes in total but replace measurements of all the particles with global best every 100 episodes. > **c0:** `float` -- The damping factor that assists convergence, also known as inertia weight. > **c1:** `float` -- The exploitation weight that attracts the particle to its best previous position, also known as cognitive learning factor. > **c2:** `float` -- The exploitation weight that attracts the particle to the best position in the neighborhood, also known as social learning factor. > **seed:** `int` -- Random seed. > **eps:** `float` -- Machine epsilon. > **load:** `bool` -- Whether or not to load measurements in the current location. If set `True` then the program will load measurement from \"measurements.csv\" file in the current location and use it as the initial measurement. \"\"\" def __init__ ( self , mtype , minput , savefile = False , p_num = 10 , measurement0 = [], max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 , seed = 1234 , eps = 1e-8 , load = False , ): Measurement . MeasurementSystem . __init__ ( self , mtype , minput , savefile , measurement0 , seed , eps , load ) self . p_num = p_num self . max_episode = max_episode self . c0 = c0 self . c1 = c1 self . c2 = c2 self . seed = seed def CFIM ( self , W = []): r \"\"\" Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" ini_particle = ([ self . measurement0 ],) self . alg = Main . QuanEstimation . PSO ( self . max_episode , self . p_num , ini_particle , self . c0 , self . c1 , self . c2 , ) super () . CFIM ( W ) CFIM ( W = []) \u00b6 Choose CFI or \\(\\mathrm{Tr}(WI^{-1})\\) as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be \\(\\mathrm{Tr}(WI^{-1})\\) . Parameters \u00b6 W: matrix -- Weight matrix. Source code in quanestimation/MeasurementOpt/PSO_Mopt.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 def CFIM ( self , W = []): r \"\"\" Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" ini_particle = ([ self . measurement0 ],) self . alg = Main . QuanEstimation . PSO ( self . max_episode , self . p_num , ini_particle , self . c0 , self . c1 , self . c2 , ) super () . CFIM ( W ) Measurement Optimization with DE \u00b6 Bases: Measurement . MeasurementSystem Attributes \u00b6 savefile: bool -- Whether or not to save all the measurements. If set True then the measurements and the values of the objective function obtained in all episodes will be saved during the training. If set False the measurement in the final episode and the values of the objective function in all episodes will be saved. p_num: int -- The number of populations. measurement0: list of arrays -- Initial guesses of measurements. max_episode: int -- The number of episodes. c: float -- Mutation constant. cr: float -- Crossover constant. seed: int -- Random seed. eps: float -- Machine epsilon. load: bool -- Whether or not to load measurements in the current location. If set True then the program will load measurement from \"measurements.csv\" file in the current location and use it as the initial measurement. Source code in quanestimation/MeasurementOpt/DE_Mopt.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 class DE_Mopt ( Measurement . MeasurementSystem ): \"\"\" Attributes ---------- > **savefile:** `bool` -- Whether or not to save all the measurements. If set `True` then the measurements and the values of the objective function obtained in all episodes will be saved during the training. If set `False` the measurement in the final episode and the values of the objective function in all episodes will be saved. > **p_num:** `int` -- The number of populations. > **measurement0:** `list of arrays` -- Initial guesses of measurements. > **max_episode:** `int` -- The number of episodes. > **c:** `float` -- Mutation constant. > **cr:** `float` -- Crossover constant. > **seed:** `int` -- Random seed. > **eps:** `float` -- Machine epsilon. > **load:** `bool` -- Whether or not to load measurements in the current location. If set `True` then the program will load measurement from \"measurements.csv\" file in the current location and use it as the initial measurement. \"\"\" def __init__ ( self , mtype , minput , savefile = False , p_num = 10 , measurement0 = [], max_episode = 1000 , c = 1.0 , cr = 0.5 , seed = 1234 , eps = 1e-8 , load = False , ): Measurement . MeasurementSystem . __init__ ( self , mtype , minput , savefile , measurement0 , seed , eps , load ) self . p_num = p_num self . max_episode = max_episode self . c = c self . cr = cr def CFIM ( self , W = []): r \"\"\" Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" ini_population = ([ self . measurement0 ],) self . alg = Main . QuanEstimation . DE ( self . max_episode , self . p_num , ini_population , self . c , self . cr , ) super () . CFIM ( W ) CFIM ( W = []) \u00b6 Choose CFI or \\(\\mathrm{Tr}(WI^{-1})\\) as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be \\(\\mathrm{Tr}(WI^{-1})\\) . Parameters \u00b6 W: matrix -- Weight matrix. Source code in quanestimation/MeasurementOpt/DE_Mopt.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def CFIM ( self , W = []): r \"\"\" Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" ini_population = ([ self . measurement0 ],) self . alg = Main . QuanEstimation . DE ( self . max_episode , self . p_num , ini_population , self . c , self . cr , ) super () . CFIM ( W ) Comprehensive Optimization \u00b6 In order to obtain the optimal parameter estimation schemes, it is necessary to simultaneously optimize the probe state, control and measurement. The comprehensive optimization for the probe state and measurement (SM), the probe state and control (SC), the control and measurement (CM) and the probe state, control and measurement (SCM) are proposed for this. In QuanEstimation, the comprehensive optimization algorithms are particle swarm optimization (PSO), differential evolution (DE), and automatic differentiation (AD). Base \u00b6 Attributes \u00b6 savefile: bool -- Whether or not to save all the optimized variables (probe states, control coefficients and measurements). If set True then the optimized variables and the values of the objective function obtained in all episodes will be saved during the training. If set False the optimized variables in the final episode and the values of the objective function in all episodes will be saved. psi0: list of arrays -- Initial guesses of states. ctrl0: list of arrays -- Initial guesses of control coefficients. measurement0: list of arrays -- Initial guesses of measurements. seed: int -- Random seed. eps: float -- Machine epsilon. Source code in quanestimation/ComprehensiveOpt/ComprehensiveStruct.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 class ComprehensiveSystem : \"\"\" Attributes ---------- > **savefile:** `bool` -- Whether or not to save all the optimized variables (probe states, control coefficients and measurements). If set `True` then the optimized variables and the values of the objective function obtained in all episodes will be saved during the training. If set `False` the optimized variables in the final episode and the values of the objective function in all episodes will be saved. > **psi0:** `list of arrays` -- Initial guesses of states. > **ctrl0:** `list of arrays` -- Initial guesses of control coefficients. > **measurement0:** `list of arrays` -- Initial guesses of measurements. > **seed:** `int` -- Random seed. > **eps:** `float` -- Machine epsilon. \"\"\" def __init__ ( self , savefile , psi0 , ctrl0 , measurement0 , seed , eps ): self . savefile = savefile self . ctrl0 = ctrl0 self . psi0 = psi0 self . eps = eps self . seed = seed self . measurement0 = measurement0 def dynamics ( self , tspan , H0 , dH , Hc = [], ctrl = [], decay = [], ctrl_bound = []): r \"\"\" The dynamics of a density matrix is of the form \\begin{align} \\partial_t\\rho &=\\mathcal{L}\\rho \\nonumber \\\\ &=-i[H,\\rho]+\\sum_i \\gamma_i\\left(\\Gamma_i\\rho\\Gamma^{\\dagger}_i-\\frac{1}{2} \\left\\{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\right\\}\\right), \\end{align} where $\\rho$ is the evolved density matrix, H is the Hamiltonian of the system, $\\Gamma_i$ and $\\gamma_i$ are the $i\\mathrm{th}$ decay operator and corresponding decay rate. Parameters ---------- > **tspan:** `array` -- Time length for the evolution. > **H0:** `matrix or list` -- Free Hamiltonian. It is a matrix when the free Hamiltonian is time- independent and a list of length equal to `tspan` when it is time-dependent. > **dH:** `list` -- Derivatives of the free Hamiltonian on the unknown parameters to be estimated. For example, dH[0] is the derivative vector on the first parameter. > **Hc:** `list` -- Control Hamiltonians. > **ctrl:** `list of arrays` -- Control coefficients. > **decay:** `list` -- Decay operators and the corresponding decay rates. Its input rule is decay=[[$\\Gamma_1$, $\\gamma_1$], [$\\Gamma_2$,$\\gamma_2$],...], where $\\Gamma_1$ $(\\Gamma_2)$ represents the decay operator and $\\gamma_1$ $(\\gamma_2)$ is the corresponding decay rate. > **ctrl_bound:** `array` -- Lower and upper bounds of the control coefficients. `ctrl_bound[0]` represents the lower bound of the control coefficients and `ctrl_bound[1]` represents the upper bound of the control coefficients. \"\"\" self . tspan = tspan self . ctrl = ctrl self . Hc = Hc if type ( H0 ) == np . ndarray : self . freeHamiltonian = np . array ( H0 , dtype = np . complex128 ) self . dim = len ( self . freeHamiltonian ) else : self . freeHamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in H0 [: - 1 ]] self . dim = len ( self . freeHamiltonian [ 0 ]) if self . psi0 == []: np . random . seed ( self . seed ) r_ini = 2 * np . random . random ( self . dim ) - np . ones ( self . dim ) r = r_ini / np . linalg . norm ( r_ini ) phi = 2 * np . pi * np . random . random ( self . dim ) self . psi = np . array ([ r [ i ] * np . exp ( 1.0 j * phi [ i ]) for i in range ( self . dim )]) self . psi0 = [ self . psi ] else : self . psi = np . array ( self . psi0 [ 0 ], dtype = np . complex128 ) if Hc == []: Hc = [ np . zeros (( self . dim , self . dim ))] self . control_Hamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in Hc ] if type ( dH ) != list : raise TypeError ( \"The derivative of Hamiltonian should be a list!\" ) if dH == []: dH = [ np . zeros (( self . dim , self . dim ))] self . Hamiltonian_derivative = [ np . array ( x , dtype = np . complex128 ) for x in dH ] if len ( dH ) == 1 : self . para_type = \"single_para\" else : self . para_type = \"multi_para\" if decay == []: decay_opt = [ np . zeros (( self . dim , self . dim ))] self . gamma = [ 0.0 ] else : decay_opt = [ decay [ i ][ 0 ] for i in range ( len ( decay ))] self . gamma = [ decay [ i ][ 1 ] for i in range ( len ( decay ))] self . decay_opt = [ np . array ( x , dtype = np . complex128 ) for x in decay_opt ] if ctrl_bound == []: self . ctrl_bound = [ - np . inf , np . inf ] else : self . ctrl_bound = [ float ( ctrl_bound [ 0 ]), float ( ctrl_bound [ 1 ])] if self . ctrl0 == []: if ctrl_bound == []: ctrl0 = [ 2 * np . random . random ( len ( self . tspan ) - 1 ) - np . ones ( len ( self . tspan ) - 1 ) for i in range ( len ( self . control_Hamiltonian )) ] else : a = ctrl_bound [ 0 ] b = ctrl_bound [ 1 ] ctrl0 = [ ( b - a ) * np . random . random ( len ( self . tspan ) - 1 ) + a * np . ones ( len ( self . tspan ) - 1 ) for i in range ( len ( self . control_Hamiltonian )) ] self . control_coefficients = ctrl0 self . ctrl0 = [ np . array ( ctrl0 )] elif len ( self . ctrl0 ) >= 1 : self . control_coefficients = [ self . ctrl0 [ 0 ][ i ] for i in range ( len ( self . control_Hamiltonian )) ] ctrl_num = len ( self . control_coefficients ) Hc_num = len ( self . control_Hamiltonian ) if Hc_num < ctrl_num : raise TypeError ( \"There are %d control Hamiltonians but %d coefficients sequences: \\ too many coefficients sequences\" % ( Hc_num , ctrl_num ) ) elif Hc_num > ctrl_num : warnings . warn ( \"Not enough coefficients sequences: there are %d control Hamiltonians \\ but %d coefficients sequences. The rest of the control sequences are \\ set to be 0.\" % ( Hc_num , ctrl_num ), DeprecationWarning , ) for i in range ( Hc_num - ctrl_num ): self . control_coefficients = np . concatenate ( ( self . control_coefficients , np . zeros ( len ( self . control_coefficients [ 0 ])), ) ) else : pass if self . measurement0 == []: np . random . seed ( self . seed ) M = [[] for i in range ( self . dim )] for i in range ( self . dim ): r_ini = 2 * np . random . random ( self . dim ) - np . ones ( self . dim ) r = r_ini / np . linalg . norm ( r_ini ) phi = 2 * np . pi * np . random . random ( self . dim ) M [ i ] = [ r [ j ] * np . exp ( 1.0 j * phi [ j ]) for j in range ( self . dim )] self . C = gramschmidt ( np . array ( M )) self . measurement0 = [ np . array ([ self . C [ i ] for i in range ( self . dim )])] elif len ( self . measurement0 ) >= 1 : self . C = [ self . measurement0 [ 0 ][ i ] for i in range ( self . dim )] self . C = [ np . array ( x , dtype = np . complex128 ) for x in self . C ] if type ( H0 ) != np . ndarray : #### linear interpolation #### f = interp1d ( self . tspan , H0 , axis = 0 ) else : pass number = math . ceil (( len ( self . tspan ) - 1 ) / len ( self . control_coefficients [ 0 ])) if len ( self . tspan ) - 1 % len ( self . control_coefficients [ 0 ]) != 0 : tnum = number * len ( self . control_coefficients [ 0 ]) self . tspan = np . linspace ( self . tspan [ 0 ], self . tspan [ - 1 ], tnum + 1 ) if type ( H0 ) != np . ndarray : H0_inter = f ( self . tspan ) self . freeHamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in H0_inter [: - 1 ]] else : pass else : pass self . dynamics_type = \"dynamics\" def Kraus ( self , K , dK ): r \"\"\" The parameterization of a state is \\begin{align} \\rho=\\sum_i K_i\\rho_0K_i^{\\dagger}, \\end{align} where $\\rho$ is the evolved density matrix, $K_i$ is the Kraus operator. Parameters ---------- > **K:** `list` -- Kraus operators. > **dK:** `list` -- Derivatives of the Kraus operators on the unknown parameters to be estimated. For example, dK[0] is the derivative vector on the first parameter. \"\"\" k_num = len ( K ) para_num = len ( dK [ 0 ]) self . para_num = para_num dK_tp = [ [ np . array ( dK [ i ][ j ], dtype = np . complex128 ) for j in range ( para_num )] for i in range ( k_num ) ] self . K = [ np . array ( x , dtype = np . complex128 ) for x in K ] self . dK = dK_tp if para_num == 1 : self . para_type = \"single_para\" else : self . para_type = \"multi_para\" self . dim = len ( K [ 0 ]) if self . psi0 == []: np . random . seed ( self . seed ) r_ini = 2 * np . random . random ( self . dim ) - np . ones ( self . dim ) r = r_ini / np . linalg . norm ( r_ini ) phi = 2 * np . pi * np . random . random ( self . dim ) self . psi = np . array ([ r [ i ] * np . exp ( 1.0 j * phi [ i ]) for i in range ( self . dim )]) self . psi0 = [ self . psi ] else : self . psi = np . array ( self . psi0 [ 0 ], dtype = np . complex128 ) if self . measurement0 == []: np . random . seed ( self . seed ) M = [[] for i in range ( self . dim )] for i in range ( self . dim ): r_ini = 2 * np . random . random ( self . dim ) - np . ones ( self . dim ) r = r_ini / np . linalg . norm ( r_ini ) phi = 2 * np . pi * np . random . random ( self . dim ) M [ i ] = [ r [ i ] * np . exp ( 1.0 j * phi [ i ]) for i in range ( self . dim )] self . C = gramschmidt ( np . array ( M )) self . measurement0 = [ np . array ([ self . C [ i ] for i in range ( len ( self . psi ))])] elif len ( self . measurement0 ) >= 1 : self . C = [ self . measurement0 [ 0 ][ i ] for i in range ( len ( self . psi ))] self . C = [ np . array ( x , dtype = np . complex128 ) for x in self . C ] self . dynamic = Main . QuanEstimation . Kraus ( self . psi , self . K , self . dK ) self . dynamics_type = \"Kraus\" def SC ( self , W = [], M = [], target = \"QFIM\" , LDtype = \"SLD\" ): \"\"\" Comprehensive optimization of the probe state and control (SC). Parameters ---------- > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). > **target:** `string` -- Objective functions for comprehensive optimization. Options are: \"QFIM\" (default) -- choose QFI (QFIM) as the objective function. \"CFIM\" -- choose CFI (CFIM) as the objective function. \"HCRB\" -- choose HCRB as the objective function. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" if self . dynamics_type != \"dynamics\" : raise ValueError ( \"Supported type of dynamics is Lindblad.\" ) if W == []: W = np . eye ( len ( self . Hamiltonian_derivative )) self . W = W if M != []: M = [ np . array ( x , dtype = np . complex128 ) for x in M ] self . obj = Main . QuanEstimation . CFIM_obj ( M , self . W , self . eps , self . para_type ) else : if target == \"HCRB\" : if self . para_type == \"single_para\" : print ( \"Program terminated. In the single-parameter scenario, the HCRB is equivalent to the QFI. Please choose 'QFIM' as the objective function\" ) else : self . obj = Main . QuanEstimation . HCRB_obj ( self . W , self . eps , self . para_type ) elif target == \"QFIM\" and ( LDtype == \"SLD\" or LDtype == \"RLD\" or LDtype == \"LLD\" ): self . obj = Main . QuanEstimation . QFIM_obj ( self . W , self . eps , self . para_type , LDtype ) elif target == \"CFIM\" : M = SIC ( len ( self . psi )) self . obj = Main . QuanEstimation . CFIM_obj ( M , self . W , self . eps , self . para_type ) else : raise ValueError ( \"Please enter the correct values for target and LDtype. Supported target are 'QFIM', 'CFIM' and 'HCRB', supported LDtype are 'SLD', 'RLD' and 'LLD'.\" ) self . opt = Main . QuanEstimation . StateControlOpt ( psi = self . psi , ctrl = self . control_coefficients , ctrl_bound = self . ctrl_bound , seed = self . seed ) self . output = Main . QuanEstimation . Output ( self . opt , save = self . savefile ) self . dynamic = Main . QuanEstimation . Lindblad ( self . freeHamiltonian , self . Hamiltonian_derivative , self . control_Hamiltonian , self . control_coefficients , self . psi , self . tspan , self . decay_opt , self . gamma , ) system = Main . QuanEstimation . QuanEstSystem ( self . opt , self . alg , self . obj , self . dynamic , self . output ) Main . QuanEstimation . run ( system ) self . load_save_state () def CM ( self , rho0 , W = []): \"\"\" Comprehensive optimization of the control and measurement (CM). Parameters ---------- > **rho0:** `matrix` -- Initial state (density matrix). > **W:** `matrix` -- Weight matrix. \"\"\" if self . dynamics_type != \"dynamics\" : raise ValueError ( \"Supported type of dynamics is Lindblad.\" ) if W == []: W = np . eye ( len ( self . Hamiltonian_derivative )) self . W = W self . rho0 = np . array ( rho0 , dtype = np . complex128 ) self . obj = Main . QuanEstimation . CFIM_obj ([], self . W , self . eps , self . para_type ) self . opt = Main . QuanEstimation . ControlMeasurementOpt ( ctrl = self . control_coefficients , M = self . C , ctrl_bound = self . ctrl_bound , seed = self . seed ) self . output = Main . QuanEstimation . Output ( self . opt , save = self . savefile ) self . dynamic = Main . QuanEstimation . Lindblad ( self . freeHamiltonian , self . Hamiltonian_derivative , self . control_Hamiltonian , self . control_coefficients , rho0 , self . tspan , self . decay_opt , self . gamma , ) system = Main . QuanEstimation . QuanEstSystem ( self . opt , self . alg , self . obj , self . dynamic , self . output ) Main . QuanEstimation . run ( system ) self . load_save_meas () def SM ( self , W = []): \"\"\" Comprehensive optimization of the probe state and measurement (SM). Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" if self . dynamics_type == \"dynamics\" : if W == []: W = np . eye ( len ( self . Hamiltonian_derivative )) self . W = W if self . Hc == [] or self . ctrl == []: freeHamiltonian = self . freeHamiltonian else : ctrl_num = len ( self . ctrl ) Hc_num = len ( self . control_Hamiltonian ) if Hc_num < ctrl_num : raise TypeError ( \"There are %d control Hamiltonians but %d coefficients sequences: \\ too many coefficients sequences.\" % ( Hc_num , ctrl_num ) ) elif Hc_num > ctrl_num : warnings . warn ( \"Not enough coefficients sequences: there are %d control Hamiltonians \\ but %d coefficients sequences. The rest of the control sequences are \\ set to be 0.\" % ( Hc_num , ctrl_num ), DeprecationWarning , ) for i in range ( Hc_num - ctrl_num ): self . ctrl = np . concatenate ( ( self . ctrl , np . zeros ( len ( self . ctrl [ 0 ]))) ) else : pass if len ( self . ctrl [ 0 ]) == 1 : if type ( self . freeHamiltonian ) == np . ndarray : H0 = np . array ( self . freeHamiltonian , dtype = np . complex128 ) Hc = [ np . array ( x , dtype = np . complex128 ) for x in self . control_Hamiltonian ] Htot = H0 + sum ( [ self . control_Hamiltonian [ i ] * self . ctrl [ i ][ 0 ] for i in range ( ctrl_num ) ] ) freeHamiltonian = np . array ( Htot , dtype = np . complex128 ) else : H0 = [ np . array ( x , dtype = np . complex128 ) for x in self . freeHamiltonian ] Htot = [] for i in range ( len ( H0 )): Htot . append ( H0 [ i ] + sum ( [ self . control_Hamiltonian [ i ] * self . ctrl [ i ][ 0 ] for i in range ( ctrl_num ) ] ) ) freeHamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in Htot ] else : if type ( self . freeHamiltonian ) != np . ndarray : #### linear interpolation #### f = interp1d ( self . tspan , self . freeHamiltonian , axis = 0 ) else : pass number = math . ceil (( len ( self . tspan ) - 1 ) / len ( self . ctrl [ 0 ])) if len ( self . tspan ) - 1 % len ( self . ctrl [ 0 ]) != 0 : tnum = number * len ( self . ctrl [ 0 ]) self . tspan = np . linspace ( self . tspan [ 0 ], self . tspan [ - 1 ], tnum + 1 ) if type ( self . freeHamiltonian ) != np . ndarray : H0_inter = f ( self . tspan ) self . freeHamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in H0_inter ] else : pass else : pass if type ( self . freeHamiltonian ) == np . ndarray : H0 = np . array ( self . freeHamiltonian , dtype = np . complex128 ) Hc = [ np . array ( x , dtype = np . complex128 ) for x in self . control_Hamiltonian ] self . ctrl = [ np . array ( self . ctrl [ i ]) . repeat ( number ) for i in range ( len ( Hc ))] Htot = [] for i in range ( len ( self . ctrl [ 0 ])): S_ctrl = sum ( [ Hc [ j ] * self . ctrl [ j ][ i ] for j in range ( len ( self . ctrl ))] ) Htot . append ( H0 + S_ctrl ) freeHamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in Htot ] else : H0 = [ np . array ( x , dtype = np . complex128 ) for x in self . freeHamiltonian ] Hc = [ np . array ( x , dtype = np . complex128 ) for x in self . control_Hamiltonian ] self . ctrl = [ np . array ( self . ctrl [ i ]) . repeat ( number ) for i in range ( len ( Hc ))] Htot = [] for i in range ( len ( self . ctrl [ 0 ])): S_ctrl = sum ( [ Hc [ j ] * self . ctrl [ j ][ i ] for j in range ( len ( self . ctrl ))] ) Htot . append ( H0 [ i ] + S_ctrl ) freeHamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in Htot ] self . dynamic = Main . QuanEstimation . Lindblad ( freeHamiltonian , self . Hamiltonian_derivative , self . psi , self . tspan , self . decay_opt , self . gamma , ) elif self . dynamics_type == \"Kraus\" : if W == []: W = np . eye ( self . para_num ) self . W = W else : raise ValueError ( \"Supported type of dynamics are Lindblad and Kraus.\" ) self . obj = Main . QuanEstimation . CFIM_obj ([], self . W , self . eps , self . para_type ) self . opt = Main . QuanEstimation . StateMeasurementOpt ( psi = self . psi , M = self . C , seed = self . seed ) self . output = Main . QuanEstimation . Output ( self . opt , save = self . savefile ) system = Main . QuanEstimation . QuanEstSystem ( self . opt , self . alg , self . obj , self . dynamic , self . output ) Main . QuanEstimation . run ( system ) self . load_save_state () self . load_save_meas () def SCM ( self , W = []): \"\"\" Comprehensive optimization of the probe state, control and measurement (SCM). Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" if self . dynamics_type != \"dynamics\" : raise ValueError ( \"Supported type of dynamics is Lindblad.\" ) if W == []: W = np . eye ( len ( self . Hamiltonian_derivative )) self . W = W self . obj = Main . QuanEstimation . CFIM_obj ([], self . W , self . eps , self . para_type ) self . opt = Main . QuanEstimation . StateControlMeasurementOpt ( psi = self . psi , ctrl = self . control_coefficients , M = self . C , ctrl_bound = self . ctrl_bound , seed = self . seed ) self . output = Main . QuanEstimation . Output ( self . opt , save = self . savefile ) self . dynamic = Main . QuanEstimation . Lindblad ( self . freeHamiltonian , self . Hamiltonian_derivative , self . control_Hamiltonian , self . control_coefficients , self . psi , self . tspan , self . decay_opt , self . gamma , ) system = Main . QuanEstimation . QuanEstSystem ( self . opt , self . alg , self . obj , self . dynamic , self . output ) Main . QuanEstimation . run ( system ) self . load_save_state () self . load_save_meas () def load_save_state ( self ): if os . path . exists ( \"states.csv\" ): file_load = open ( \"states.csv\" , \"r\" ) file_load = \"\" . join ([ i for i in file_load ]) . replace ( \"im\" , \"j\" ) file_load = \"\" . join ([ i for i in file_load ]) . replace ( \" \" , \"\" ) file_save = open ( \"states.csv\" , \"w\" ) file_save . writelines ( file_load ) file_save . close () else : pass def load_save_meas ( self ): if os . path . exists ( \"measurements.csv\" ): file_load = open ( \"measurements.csv\" , \"r\" ) file_load = \"\" . join ([ i for i in file_load ]) . replace ( \"im\" , \"j\" ) file_load = \"\" . join ([ i for i in file_load ]) . replace ( \" \" , \"\" ) file_save = open ( \"measurements.csv\" , \"w\" ) file_save . writelines ( file_load ) file_save . close () else : pass CM ( rho0 , W = []) \u00b6 Comprehensive optimization of the control and measurement (CM). Parameters \u00b6 rho0: matrix -- Initial state (density matrix). W: matrix -- Weight matrix. Source code in quanestimation/ComprehensiveOpt/ComprehensiveStruct.py 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 def CM ( self , rho0 , W = []): \"\"\" Comprehensive optimization of the control and measurement (CM). Parameters ---------- > **rho0:** `matrix` -- Initial state (density matrix). > **W:** `matrix` -- Weight matrix. \"\"\" if self . dynamics_type != \"dynamics\" : raise ValueError ( \"Supported type of dynamics is Lindblad.\" ) if W == []: W = np . eye ( len ( self . Hamiltonian_derivative )) self . W = W self . rho0 = np . array ( rho0 , dtype = np . complex128 ) self . obj = Main . QuanEstimation . CFIM_obj ([], self . W , self . eps , self . para_type ) self . opt = Main . QuanEstimation . ControlMeasurementOpt ( ctrl = self . control_coefficients , M = self . C , ctrl_bound = self . ctrl_bound , seed = self . seed ) self . output = Main . QuanEstimation . Output ( self . opt , save = self . savefile ) self . dynamic = Main . QuanEstimation . Lindblad ( self . freeHamiltonian , self . Hamiltonian_derivative , self . control_Hamiltonian , self . control_coefficients , rho0 , self . tspan , self . decay_opt , self . gamma , ) system = Main . QuanEstimation . QuanEstSystem ( self . opt , self . alg , self . obj , self . dynamic , self . output ) Main . QuanEstimation . run ( system ) self . load_save_meas () Kraus ( K , dK ) \u00b6 The parameterization of a state is \\begin{align} \\rho=\\sum_i K_i\\rho_0K_i^{\\dagger}, \\end{align} where \\(\\rho\\) is the evolved density matrix, \\(K_i\\) is the Kraus operator. Parameters \u00b6 K: list -- Kraus operators. dK: list -- Derivatives of the Kraus operators on the unknown parameters to be estimated. For example, dK[0] is the derivative vector on the first parameter. Source code in quanestimation/ComprehensiveOpt/ComprehensiveStruct.py 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 def Kraus ( self , K , dK ): r \"\"\" The parameterization of a state is \\begin{align} \\rho=\\sum_i K_i\\rho_0K_i^{\\dagger}, \\end{align} where $\\rho$ is the evolved density matrix, $K_i$ is the Kraus operator. Parameters ---------- > **K:** `list` -- Kraus operators. > **dK:** `list` -- Derivatives of the Kraus operators on the unknown parameters to be estimated. For example, dK[0] is the derivative vector on the first parameter. \"\"\" k_num = len ( K ) para_num = len ( dK [ 0 ]) self . para_num = para_num dK_tp = [ [ np . array ( dK [ i ][ j ], dtype = np . complex128 ) for j in range ( para_num )] for i in range ( k_num ) ] self . K = [ np . array ( x , dtype = np . complex128 ) for x in K ] self . dK = dK_tp if para_num == 1 : self . para_type = \"single_para\" else : self . para_type = \"multi_para\" self . dim = len ( K [ 0 ]) if self . psi0 == []: np . random . seed ( self . seed ) r_ini = 2 * np . random . random ( self . dim ) - np . ones ( self . dim ) r = r_ini / np . linalg . norm ( r_ini ) phi = 2 * np . pi * np . random . random ( self . dim ) self . psi = np . array ([ r [ i ] * np . exp ( 1.0 j * phi [ i ]) for i in range ( self . dim )]) self . psi0 = [ self . psi ] else : self . psi = np . array ( self . psi0 [ 0 ], dtype = np . complex128 ) if self . measurement0 == []: np . random . seed ( self . seed ) M = [[] for i in range ( self . dim )] for i in range ( self . dim ): r_ini = 2 * np . random . random ( self . dim ) - np . ones ( self . dim ) r = r_ini / np . linalg . norm ( r_ini ) phi = 2 * np . pi * np . random . random ( self . dim ) M [ i ] = [ r [ i ] * np . exp ( 1.0 j * phi [ i ]) for i in range ( self . dim )] self . C = gramschmidt ( np . array ( M )) self . measurement0 = [ np . array ([ self . C [ i ] for i in range ( len ( self . psi ))])] elif len ( self . measurement0 ) >= 1 : self . C = [ self . measurement0 [ 0 ][ i ] for i in range ( len ( self . psi ))] self . C = [ np . array ( x , dtype = np . complex128 ) for x in self . C ] self . dynamic = Main . QuanEstimation . Kraus ( self . psi , self . K , self . dK ) self . dynamics_type = \"Kraus\" SC ( W = [], M = [], target = 'QFIM' , LDtype = 'SLD' ) \u00b6 Comprehensive optimization of the probe state and control (SC). Parameters \u00b6 W: matrix -- Weight matrix. M: list of matrices -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). target: string -- Objective functions for comprehensive optimization. Options are: \"QFIM\" (default) -- choose QFI (QFIM) as the objective function. \"CFIM\" -- choose CFI (CFIM) as the objective function. \"HCRB\" -- choose HCRB as the objective function. LDtype: string -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). Note: SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from here . Source code in quanestimation/ComprehensiveOpt/ComprehensiveStruct.py 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 def SC ( self , W = [], M = [], target = \"QFIM\" , LDtype = \"SLD\" ): \"\"\" Comprehensive optimization of the probe state and control (SC). Parameters ---------- > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). > **target:** `string` -- Objective functions for comprehensive optimization. Options are: \"QFIM\" (default) -- choose QFI (QFIM) as the objective function. \"CFIM\" -- choose CFI (CFIM) as the objective function. \"HCRB\" -- choose HCRB as the objective function. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" if self . dynamics_type != \"dynamics\" : raise ValueError ( \"Supported type of dynamics is Lindblad.\" ) if W == []: W = np . eye ( len ( self . Hamiltonian_derivative )) self . W = W if M != []: M = [ np . array ( x , dtype = np . complex128 ) for x in M ] self . obj = Main . QuanEstimation . CFIM_obj ( M , self . W , self . eps , self . para_type ) else : if target == \"HCRB\" : if self . para_type == \"single_para\" : print ( \"Program terminated. In the single-parameter scenario, the HCRB is equivalent to the QFI. Please choose 'QFIM' as the objective function\" ) else : self . obj = Main . QuanEstimation . HCRB_obj ( self . W , self . eps , self . para_type ) elif target == \"QFIM\" and ( LDtype == \"SLD\" or LDtype == \"RLD\" or LDtype == \"LLD\" ): self . obj = Main . QuanEstimation . QFIM_obj ( self . W , self . eps , self . para_type , LDtype ) elif target == \"CFIM\" : M = SIC ( len ( self . psi )) self . obj = Main . QuanEstimation . CFIM_obj ( M , self . W , self . eps , self . para_type ) else : raise ValueError ( \"Please enter the correct values for target and LDtype. Supported target are 'QFIM', 'CFIM' and 'HCRB', supported LDtype are 'SLD', 'RLD' and 'LLD'.\" ) self . opt = Main . QuanEstimation . StateControlOpt ( psi = self . psi , ctrl = self . control_coefficients , ctrl_bound = self . ctrl_bound , seed = self . seed ) self . output = Main . QuanEstimation . Output ( self . opt , save = self . savefile ) self . dynamic = Main . QuanEstimation . Lindblad ( self . freeHamiltonian , self . Hamiltonian_derivative , self . control_Hamiltonian , self . control_coefficients , self . psi , self . tspan , self . decay_opt , self . gamma , ) system = Main . QuanEstimation . QuanEstSystem ( self . opt , self . alg , self . obj , self . dynamic , self . output ) Main . QuanEstimation . run ( system ) self . load_save_state () SCM ( W = []) \u00b6 Comprehensive optimization of the probe state, control and measurement (SCM). Parameters \u00b6 W: matrix -- Weight matrix. Source code in quanestimation/ComprehensiveOpt/ComprehensiveStruct.py 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 def SCM ( self , W = []): \"\"\" Comprehensive optimization of the probe state, control and measurement (SCM). Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" if self . dynamics_type != \"dynamics\" : raise ValueError ( \"Supported type of dynamics is Lindblad.\" ) if W == []: W = np . eye ( len ( self . Hamiltonian_derivative )) self . W = W self . obj = Main . QuanEstimation . CFIM_obj ([], self . W , self . eps , self . para_type ) self . opt = Main . QuanEstimation . StateControlMeasurementOpt ( psi = self . psi , ctrl = self . control_coefficients , M = self . C , ctrl_bound = self . ctrl_bound , seed = self . seed ) self . output = Main . QuanEstimation . Output ( self . opt , save = self . savefile ) self . dynamic = Main . QuanEstimation . Lindblad ( self . freeHamiltonian , self . Hamiltonian_derivative , self . control_Hamiltonian , self . control_coefficients , self . psi , self . tspan , self . decay_opt , self . gamma , ) system = Main . QuanEstimation . QuanEstSystem ( self . opt , self . alg , self . obj , self . dynamic , self . output ) Main . QuanEstimation . run ( system ) self . load_save_state () self . load_save_meas () SM ( W = []) \u00b6 Comprehensive optimization of the probe state and measurement (SM). Parameters \u00b6 W: matrix -- Weight matrix. Source code in quanestimation/ComprehensiveOpt/ComprehensiveStruct.py 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 def SM ( self , W = []): \"\"\" Comprehensive optimization of the probe state and measurement (SM). Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" if self . dynamics_type == \"dynamics\" : if W == []: W = np . eye ( len ( self . Hamiltonian_derivative )) self . W = W if self . Hc == [] or self . ctrl == []: freeHamiltonian = self . freeHamiltonian else : ctrl_num = len ( self . ctrl ) Hc_num = len ( self . control_Hamiltonian ) if Hc_num < ctrl_num : raise TypeError ( \"There are %d control Hamiltonians but %d coefficients sequences: \\ too many coefficients sequences.\" % ( Hc_num , ctrl_num ) ) elif Hc_num > ctrl_num : warnings . warn ( \"Not enough coefficients sequences: there are %d control Hamiltonians \\ but %d coefficients sequences. The rest of the control sequences are \\ set to be 0.\" % ( Hc_num , ctrl_num ), DeprecationWarning , ) for i in range ( Hc_num - ctrl_num ): self . ctrl = np . concatenate ( ( self . ctrl , np . zeros ( len ( self . ctrl [ 0 ]))) ) else : pass if len ( self . ctrl [ 0 ]) == 1 : if type ( self . freeHamiltonian ) == np . ndarray : H0 = np . array ( self . freeHamiltonian , dtype = np . complex128 ) Hc = [ np . array ( x , dtype = np . complex128 ) for x in self . control_Hamiltonian ] Htot = H0 + sum ( [ self . control_Hamiltonian [ i ] * self . ctrl [ i ][ 0 ] for i in range ( ctrl_num ) ] ) freeHamiltonian = np . array ( Htot , dtype = np . complex128 ) else : H0 = [ np . array ( x , dtype = np . complex128 ) for x in self . freeHamiltonian ] Htot = [] for i in range ( len ( H0 )): Htot . append ( H0 [ i ] + sum ( [ self . control_Hamiltonian [ i ] * self . ctrl [ i ][ 0 ] for i in range ( ctrl_num ) ] ) ) freeHamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in Htot ] else : if type ( self . freeHamiltonian ) != np . ndarray : #### linear interpolation #### f = interp1d ( self . tspan , self . freeHamiltonian , axis = 0 ) else : pass number = math . ceil (( len ( self . tspan ) - 1 ) / len ( self . ctrl [ 0 ])) if len ( self . tspan ) - 1 % len ( self . ctrl [ 0 ]) != 0 : tnum = number * len ( self . ctrl [ 0 ]) self . tspan = np . linspace ( self . tspan [ 0 ], self . tspan [ - 1 ], tnum + 1 ) if type ( self . freeHamiltonian ) != np . ndarray : H0_inter = f ( self . tspan ) self . freeHamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in H0_inter ] else : pass else : pass if type ( self . freeHamiltonian ) == np . ndarray : H0 = np . array ( self . freeHamiltonian , dtype = np . complex128 ) Hc = [ np . array ( x , dtype = np . complex128 ) for x in self . control_Hamiltonian ] self . ctrl = [ np . array ( self . ctrl [ i ]) . repeat ( number ) for i in range ( len ( Hc ))] Htot = [] for i in range ( len ( self . ctrl [ 0 ])): S_ctrl = sum ( [ Hc [ j ] * self . ctrl [ j ][ i ] for j in range ( len ( self . ctrl ))] ) Htot . append ( H0 + S_ctrl ) freeHamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in Htot ] else : H0 = [ np . array ( x , dtype = np . complex128 ) for x in self . freeHamiltonian ] Hc = [ np . array ( x , dtype = np . complex128 ) for x in self . control_Hamiltonian ] self . ctrl = [ np . array ( self . ctrl [ i ]) . repeat ( number ) for i in range ( len ( Hc ))] Htot = [] for i in range ( len ( self . ctrl [ 0 ])): S_ctrl = sum ( [ Hc [ j ] * self . ctrl [ j ][ i ] for j in range ( len ( self . ctrl ))] ) Htot . append ( H0 [ i ] + S_ctrl ) freeHamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in Htot ] self . dynamic = Main . QuanEstimation . Lindblad ( freeHamiltonian , self . Hamiltonian_derivative , self . psi , self . tspan , self . decay_opt , self . gamma , ) elif self . dynamics_type == \"Kraus\" : if W == []: W = np . eye ( self . para_num ) self . W = W else : raise ValueError ( \"Supported type of dynamics are Lindblad and Kraus.\" ) self . obj = Main . QuanEstimation . CFIM_obj ([], self . W , self . eps , self . para_type ) self . opt = Main . QuanEstimation . StateMeasurementOpt ( psi = self . psi , M = self . C , seed = self . seed ) self . output = Main . QuanEstimation . Output ( self . opt , save = self . savefile ) system = Main . QuanEstimation . QuanEstSystem ( self . opt , self . alg , self . obj , self . dynamic , self . output ) Main . QuanEstimation . run ( system ) self . load_save_state () self . load_save_meas () dynamics ( tspan , H0 , dH , Hc = [], ctrl = [], decay = [], ctrl_bound = []) \u00b6 The dynamics of a density matrix is of the form \\[\\begin{align} \\partial_t\\rho &=\\mathcal{L}\\rho \\nonumber \\\\ &=-i[H,\\rho]+\\sum_i \\gamma_i\\left(\\Gamma_i\\rho\\Gamma^{\\dagger}_i-\\frac{1}{2} \\left\\{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\right\\}\\right), \\end{align}\\] where \\(\\rho\\) is the evolved density matrix, H is the Hamiltonian of the system, \\(\\Gamma_i\\) and \\(\\gamma_i\\) are the \\(i\\mathrm{th}\\) decay operator and corresponding decay rate. Parameters \u00b6 tspan: array -- Time length for the evolution. H0: matrix or list -- Free Hamiltonian. It is a matrix when the free Hamiltonian is time- independent and a list of length equal to tspan when it is time-dependent. dH: list -- Derivatives of the free Hamiltonian on the unknown parameters to be estimated. For example, dH[0] is the derivative vector on the first parameter. Hc: list -- Control Hamiltonians. ctrl: list of arrays -- Control coefficients. decay: list -- Decay operators and the corresponding decay rates. Its input rule is decay=[[ \\(\\Gamma_1\\) , \\(\\gamma_1\\) ], [ \\(\\Gamma_2\\) , \\(\\gamma_2\\) ],...], where \\(\\Gamma_1\\) \\((\\Gamma_2)\\) represents the decay operator and \\(\\gamma_1\\) \\((\\gamma_2)\\) is the corresponding decay rate. ctrl_bound: array -- Lower and upper bounds of the control coefficients. ctrl_bound[0] represents the lower bound of the control coefficients and ctrl_bound[1] represents the upper bound of the control coefficients. Source code in quanestimation/ComprehensiveOpt/ComprehensiveStruct.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 def dynamics ( self , tspan , H0 , dH , Hc = [], ctrl = [], decay = [], ctrl_bound = []): r \"\"\" The dynamics of a density matrix is of the form \\begin{align} \\partial_t\\rho &=\\mathcal{L}\\rho \\nonumber \\\\ &=-i[H,\\rho]+\\sum_i \\gamma_i\\left(\\Gamma_i\\rho\\Gamma^{\\dagger}_i-\\frac{1}{2} \\left\\{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\right\\}\\right), \\end{align} where $\\rho$ is the evolved density matrix, H is the Hamiltonian of the system, $\\Gamma_i$ and $\\gamma_i$ are the $i\\mathrm{th}$ decay operator and corresponding decay rate. Parameters ---------- > **tspan:** `array` -- Time length for the evolution. > **H0:** `matrix or list` -- Free Hamiltonian. It is a matrix when the free Hamiltonian is time- independent and a list of length equal to `tspan` when it is time-dependent. > **dH:** `list` -- Derivatives of the free Hamiltonian on the unknown parameters to be estimated. For example, dH[0] is the derivative vector on the first parameter. > **Hc:** `list` -- Control Hamiltonians. > **ctrl:** `list of arrays` -- Control coefficients. > **decay:** `list` -- Decay operators and the corresponding decay rates. Its input rule is decay=[[$\\Gamma_1$, $\\gamma_1$], [$\\Gamma_2$,$\\gamma_2$],...], where $\\Gamma_1$ $(\\Gamma_2)$ represents the decay operator and $\\gamma_1$ $(\\gamma_2)$ is the corresponding decay rate. > **ctrl_bound:** `array` -- Lower and upper bounds of the control coefficients. `ctrl_bound[0]` represents the lower bound of the control coefficients and `ctrl_bound[1]` represents the upper bound of the control coefficients. \"\"\" self . tspan = tspan self . ctrl = ctrl self . Hc = Hc if type ( H0 ) == np . ndarray : self . freeHamiltonian = np . array ( H0 , dtype = np . complex128 ) self . dim = len ( self . freeHamiltonian ) else : self . freeHamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in H0 [: - 1 ]] self . dim = len ( self . freeHamiltonian [ 0 ]) if self . psi0 == []: np . random . seed ( self . seed ) r_ini = 2 * np . random . random ( self . dim ) - np . ones ( self . dim ) r = r_ini / np . linalg . norm ( r_ini ) phi = 2 * np . pi * np . random . random ( self . dim ) self . psi = np . array ([ r [ i ] * np . exp ( 1.0 j * phi [ i ]) for i in range ( self . dim )]) self . psi0 = [ self . psi ] else : self . psi = np . array ( self . psi0 [ 0 ], dtype = np . complex128 ) if Hc == []: Hc = [ np . zeros (( self . dim , self . dim ))] self . control_Hamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in Hc ] if type ( dH ) != list : raise TypeError ( \"The derivative of Hamiltonian should be a list!\" ) if dH == []: dH = [ np . zeros (( self . dim , self . dim ))] self . Hamiltonian_derivative = [ np . array ( x , dtype = np . complex128 ) for x in dH ] if len ( dH ) == 1 : self . para_type = \"single_para\" else : self . para_type = \"multi_para\" if decay == []: decay_opt = [ np . zeros (( self . dim , self . dim ))] self . gamma = [ 0.0 ] else : decay_opt = [ decay [ i ][ 0 ] for i in range ( len ( decay ))] self . gamma = [ decay [ i ][ 1 ] for i in range ( len ( decay ))] self . decay_opt = [ np . array ( x , dtype = np . complex128 ) for x in decay_opt ] if ctrl_bound == []: self . ctrl_bound = [ - np . inf , np . inf ] else : self . ctrl_bound = [ float ( ctrl_bound [ 0 ]), float ( ctrl_bound [ 1 ])] if self . ctrl0 == []: if ctrl_bound == []: ctrl0 = [ 2 * np . random . random ( len ( self . tspan ) - 1 ) - np . ones ( len ( self . tspan ) - 1 ) for i in range ( len ( self . control_Hamiltonian )) ] else : a = ctrl_bound [ 0 ] b = ctrl_bound [ 1 ] ctrl0 = [ ( b - a ) * np . random . random ( len ( self . tspan ) - 1 ) + a * np . ones ( len ( self . tspan ) - 1 ) for i in range ( len ( self . control_Hamiltonian )) ] self . control_coefficients = ctrl0 self . ctrl0 = [ np . array ( ctrl0 )] elif len ( self . ctrl0 ) >= 1 : self . control_coefficients = [ self . ctrl0 [ 0 ][ i ] for i in range ( len ( self . control_Hamiltonian )) ] ctrl_num = len ( self . control_coefficients ) Hc_num = len ( self . control_Hamiltonian ) if Hc_num < ctrl_num : raise TypeError ( \"There are %d control Hamiltonians but %d coefficients sequences: \\ too many coefficients sequences\" % ( Hc_num , ctrl_num ) ) elif Hc_num > ctrl_num : warnings . warn ( \"Not enough coefficients sequences: there are %d control Hamiltonians \\ but %d coefficients sequences. The rest of the control sequences are \\ set to be 0.\" % ( Hc_num , ctrl_num ), DeprecationWarning , ) for i in range ( Hc_num - ctrl_num ): self . control_coefficients = np . concatenate ( ( self . control_coefficients , np . zeros ( len ( self . control_coefficients [ 0 ])), ) ) else : pass if self . measurement0 == []: np . random . seed ( self . seed ) M = [[] for i in range ( self . dim )] for i in range ( self . dim ): r_ini = 2 * np . random . random ( self . dim ) - np . ones ( self . dim ) r = r_ini / np . linalg . norm ( r_ini ) phi = 2 * np . pi * np . random . random ( self . dim ) M [ i ] = [ r [ j ] * np . exp ( 1.0 j * phi [ j ]) for j in range ( self . dim )] self . C = gramschmidt ( np . array ( M )) self . measurement0 = [ np . array ([ self . C [ i ] for i in range ( self . dim )])] elif len ( self . measurement0 ) >= 1 : self . C = [ self . measurement0 [ 0 ][ i ] for i in range ( self . dim )] self . C = [ np . array ( x , dtype = np . complex128 ) for x in self . C ] if type ( H0 ) != np . ndarray : #### linear interpolation #### f = interp1d ( self . tspan , H0 , axis = 0 ) else : pass number = math . ceil (( len ( self . tspan ) - 1 ) / len ( self . control_coefficients [ 0 ])) if len ( self . tspan ) - 1 % len ( self . control_coefficients [ 0 ]) != 0 : tnum = number * len ( self . control_coefficients [ 0 ]) self . tspan = np . linspace ( self . tspan [ 0 ], self . tspan [ - 1 ], tnum + 1 ) if type ( H0 ) != np . ndarray : H0_inter = f ( self . tspan ) self . freeHamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in H0_inter [: - 1 ]] else : pass else : pass self . dynamics_type = \"dynamics\" Comprehensive optimization with AD \u00b6 Bases: Comp . ComprehensiveSystem Attributes \u00b6 savefile: bool -- Whether or not to save all the optimized variables (probe states, control coefficients and measurements). If set True then the optimized variables and the values of the objective function obtained in all episodes will be saved during the training. If set False the optimized variables in the final episode and the values of the objective function in all episodes will be saved. Adam: bool -- Whether or not to use Adam for updating. psi0: list of arrays -- Initial guesses of states. ctrl0: list of arrays -- Initial guesses of control coefficients. measurement0: list of arrays -- Initial guesses of measurements. max_episode: int -- The number of episodes. epsilon: float -- Learning rate. beta1: float -- The exponential decay rate for the first moment estimates. beta2: float -- The exponential decay rate for the second moment estimates. seed: int -- Random seed. eps: float -- Machine epsilon. Source code in quanestimation/ComprehensiveOpt/AD_Compopt.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 class AD_Compopt ( Comp . ComprehensiveSystem ): \"\"\" Attributes ---------- > **savefile:** `bool` -- Whether or not to save all the optimized variables (probe states, control coefficients and measurements). If set `True` then the optimized variables and the values of the objective function obtained in all episodes will be saved during the training. If set `False` the optimized variables in the final episode and the values of the objective function in all episodes will be saved. > **Adam:** `bool` -- Whether or not to use Adam for updating. > **psi0:** `list of arrays` -- Initial guesses of states. > **ctrl0:** `list of arrays` -- Initial guesses of control coefficients. > **measurement0:** `list of arrays` -- Initial guesses of measurements. > **max_episode:** `int` -- The number of episodes. > **epsilon:** `float` -- Learning rate. > **beta1:** `float` -- The exponential decay rate for the first moment estimates. > **beta2:** `float` -- The exponential decay rate for the second moment estimates. > **seed:** `int` -- Random seed. > **eps:** `float` -- Machine epsilon. \"\"\" def __init__ ( self , savefile = False , Adam = False , psi0 = [], ctrl0 = [], measurement0 = [], max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 , seed = 1234 , eps = 1e-8 , ): Comp . ComprehensiveSystem . __init__ ( self , savefile , psi0 , ctrl0 , measurement0 , seed , eps ) self . Adam = Adam self . max_episode = max_episode self . epsilon = epsilon self . beta1 = beta1 self . beta2 = beta2 self . mt = 0.0 self . vt = 0.0 self . seed = seed def SC ( self , W = [], M = [], target = \"QFIM\" , LDtype = \"SLD\" ): \"\"\" Comprehensive optimization of the probe state and control (SC). Parameters ---------- > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). > **target:** `string` -- Objective functions for searching the minimum time to reach the given value of the objective function. Options are: \"QFIM\" (default) -- choose QFI (QFIM) as the objective function. \"CFIM\" -- choose CFI (CFIM) as the objective function. \"HCRB\" -- choose HCRB as the objective function. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). **Note:** AD is only available when target is 'QFIM'. \"\"\" if M != []: raise ValueError ( \"AD is not available when target is 'CFIM'. Supported methods are 'PSO' and 'DE'.\" , ) elif target == \"HCRB\" : raise ValueError ( \"AD is not available when the target function is HCRB. Supported methods are 'PSO' and 'DE'.\" , ) if self . Adam : self . alg = Main . QuanEstimation . AD ( self . max_episode , self . epsilon , self . beta1 , self . beta2 ) else : self . alg = Main . QuanEstimation . AD ( self . max_episode , self . epsilon ) super () . SC ( W , M , target , LDtype ) SC ( W = [], M = [], target = 'QFIM' , LDtype = 'SLD' ) \u00b6 Comprehensive optimization of the probe state and control (SC). Parameters \u00b6 W: matrix -- Weight matrix. M: list of matrices -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). target: string -- Objective functions for searching the minimum time to reach the given value of the objective function. Options are: \"QFIM\" (default) -- choose QFI (QFIM) as the objective function. \"CFIM\" -- choose CFI (CFIM) as the objective function. \"HCRB\" -- choose HCRB as the objective function. LDtype: string -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). Note: AD is only available when target is 'QFIM'. Source code in quanestimation/ComprehensiveOpt/AD_Compopt.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 def SC ( self , W = [], M = [], target = \"QFIM\" , LDtype = \"SLD\" ): \"\"\" Comprehensive optimization of the probe state and control (SC). Parameters ---------- > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). > **target:** `string` -- Objective functions for searching the minimum time to reach the given value of the objective function. Options are: \"QFIM\" (default) -- choose QFI (QFIM) as the objective function. \"CFIM\" -- choose CFI (CFIM) as the objective function. \"HCRB\" -- choose HCRB as the objective function. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). **Note:** AD is only available when target is 'QFIM'. \"\"\" if M != []: raise ValueError ( \"AD is not available when target is 'CFIM'. Supported methods are 'PSO' and 'DE'.\" , ) elif target == \"HCRB\" : raise ValueError ( \"AD is not available when the target function is HCRB. Supported methods are 'PSO' and 'DE'.\" , ) if self . Adam : self . alg = Main . QuanEstimation . AD ( self . max_episode , self . epsilon , self . beta1 , self . beta2 ) else : self . alg = Main . QuanEstimation . AD ( self . max_episode , self . epsilon ) super () . SC ( W , M , target , LDtype ) Comprehensive Optimization with PSO \u00b6 Bases: Comp . ComprehensiveSystem Attributes \u00b6 savefile: bool -- Whether or not to save all the optimized variables (probe states, control coefficients and measurements). If set True then the optimized variables and the values of the objective function obtained in all episodes will be saved during the training. If set False the optimized variables in the final episode and the values of the objective function in all episodes will be saved. p_num: int -- The number of particles. psi0: list of arrays -- Initial guesses of states. ctrl0: list of arrays -- Initial guesses of control coefficients. measurement0: list of arrays -- Initial guesses of measurements. max_episode: int or list -- If it is an integer, for example max_episode=1000, it means the program will continuously run 1000 episodes. However, if it is an array, for example max_episode=[1000,100], the program will run 1000 episodes in total but replace states of all the particles with global best every 100 episodes. c0: float -- The damping factor that assists convergence, also known as inertia weight. c1: float -- The exploitation weight that attracts the particle to its best previous position, also known as cognitive learning factor. c2: float -- The exploitation weight that attracts the particle to the best position in the neighborhood, also known as social learning factor. seed: int -- Random seed. eps: float -- Machine epsilon. Source code in quanestimation/ComprehensiveOpt/PSO_Compopt.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 class PSO_Compopt ( Comp . ComprehensiveSystem ): \"\"\" Attributes ---------- > **savefile:** `bool` -- Whether or not to save all the optimized variables (probe states, control coefficients and measurements). If set `True` then the optimized variables and the values of the objective function obtained in all episodes will be saved during the training. If set `False` the optimized variables in the final episode and the values of the objective function in all episodes will be saved. > **p_num:** `int` -- The number of particles. > **psi0:** `list of arrays` -- Initial guesses of states. > **ctrl0:** `list of arrays` -- Initial guesses of control coefficients. > **measurement0:** `list of arrays` -- Initial guesses of measurements. > **max_episode:** `int or list` -- If it is an integer, for example max_episode=1000, it means the program will continuously run 1000 episodes. However, if it is an array, for example max_episode=[1000,100], the program will run 1000 episodes in total but replace states of all the particles with global best every 100 episodes. > **c0:** `float` -- The damping factor that assists convergence, also known as inertia weight. > **c1:** `float` -- The exploitation weight that attracts the particle to its best previous position, also known as cognitive learning factor. > **c2:** `float` -- The exploitation weight that attracts the particle to the best position in the neighborhood, also known as social learning factor. > **seed:** `int` -- Random seed. > **eps:** `float` -- Machine epsilon. \"\"\" def __init__ ( self , savefile = False , p_num = 10 , psi0 = [], ctrl0 = [], measurement0 = [], max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 , seed = 1234 , eps = 1e-8 , ): Comp . ComprehensiveSystem . __init__ ( self , savefile , psi0 , ctrl0 , measurement0 , seed , eps ) self . p_num = p_num self . max_episode = max_episode self . c0 = c0 self . c1 = c1 self . c2 = c2 self . seed = seed def SC ( self , W = [], M = [], target = \"QFIM\" , LDtype = \"SLD\" ): \"\"\" Comprehensive optimization of the probe state and control (SC). Parameters ---------- > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). > **target:** `string` -- Objective functions for searching the minimum time to reach the given value of the objective function. Options are: \"QFIM\" (default) -- choose QFI (QFIM) as the objective function. \"CFIM\" -- choose CFI (CFIM) as the objective function. \"HCRB\" -- choose HCRB as the objective function. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" ini_particle = ( self . psi0 , self . ctrl0 ) self . alg = Main . QuanEstimation . PSO ( self . max_episode , self . p_num , ini_particle , self . c0 , self . c1 , self . c2 , ) super () . SC ( W , M , target , LDtype ) def CM ( self , rho0 , W = []): \"\"\" Comprehensive optimization of the control and measurement (CM). Parameters ---------- > **rho0:** `matrix` -- Initial state (density matrix). > **W:** `matrix` -- Weight matrix. \"\"\" ini_particle = ( self . ctrl0 , self . measurement0 ) self . alg = Main . QuanEstimation . PSO ( self . max_episode , self . p_num , ini_particle , self . c0 , self . c1 , self . c2 , ) super () . CM ( rho0 , W ) def SM ( self , W = []): \"\"\" Comprehensive optimization of the probe state and measurement (SM). Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" ini_particle = ( self . psi0 , self . measurement0 ) self . alg = Main . QuanEstimation . PSO ( self . max_episode , self . p_num , ini_particle , self . c0 , self . c1 , self . c2 , ) super () . SM ( W ) def SCM ( self , W = []): \"\"\" Comprehensive optimization of the probe state, the control and measurements (SCM). Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" ini_particle = ( self . psi0 , self . ctrl0 , self . measurement0 ) self . alg = Main . QuanEstimation . PSO ( self . max_episode , self . p_num , ini_particle , self . c0 , self . c1 , self . c2 , ) super () . SCM ( W ) CM ( rho0 , W = []) \u00b6 Comprehensive optimization of the control and measurement (CM). Parameters \u00b6 rho0: matrix -- Initial state (density matrix). W: matrix -- Weight matrix. Source code in quanestimation/ComprehensiveOpt/PSO_Compopt.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 def CM ( self , rho0 , W = []): \"\"\" Comprehensive optimization of the control and measurement (CM). Parameters ---------- > **rho0:** `matrix` -- Initial state (density matrix). > **W:** `matrix` -- Weight matrix. \"\"\" ini_particle = ( self . ctrl0 , self . measurement0 ) self . alg = Main . QuanEstimation . PSO ( self . max_episode , self . p_num , ini_particle , self . c0 , self . c1 , self . c2 , ) super () . CM ( rho0 , W ) SC ( W = [], M = [], target = 'QFIM' , LDtype = 'SLD' ) \u00b6 Comprehensive optimization of the probe state and control (SC). Parameters \u00b6 W: matrix -- Weight matrix. M: list of matrices -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). target: string -- Objective functions for searching the minimum time to reach the given value of the objective function. Options are: \"QFIM\" (default) -- choose QFI (QFIM) as the objective function. \"CFIM\" -- choose CFI (CFIM) as the objective function. \"HCRB\" -- choose HCRB as the objective function. LDtype: string -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). Note: SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from here . Source code in quanestimation/ComprehensiveOpt/PSO_Compopt.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 def SC ( self , W = [], M = [], target = \"QFIM\" , LDtype = \"SLD\" ): \"\"\" Comprehensive optimization of the probe state and control (SC). Parameters ---------- > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). > **target:** `string` -- Objective functions for searching the minimum time to reach the given value of the objective function. Options are: \"QFIM\" (default) -- choose QFI (QFIM) as the objective function. \"CFIM\" -- choose CFI (CFIM) as the objective function. \"HCRB\" -- choose HCRB as the objective function. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" ini_particle = ( self . psi0 , self . ctrl0 ) self . alg = Main . QuanEstimation . PSO ( self . max_episode , self . p_num , ini_particle , self . c0 , self . c1 , self . c2 , ) super () . SC ( W , M , target , LDtype ) SCM ( W = []) \u00b6 Comprehensive optimization of the probe state, the control and measurements (SCM). Parameters \u00b6 W: matrix -- Weight matrix. Source code in quanestimation/ComprehensiveOpt/PSO_Compopt.py 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 def SCM ( self , W = []): \"\"\" Comprehensive optimization of the probe state, the control and measurements (SCM). Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" ini_particle = ( self . psi0 , self . ctrl0 , self . measurement0 ) self . alg = Main . QuanEstimation . PSO ( self . max_episode , self . p_num , ini_particle , self . c0 , self . c1 , self . c2 , ) super () . SCM ( W ) SM ( W = []) \u00b6 Comprehensive optimization of the probe state and measurement (SM). Parameters \u00b6 W: matrix -- Weight matrix. Source code in quanestimation/ComprehensiveOpt/PSO_Compopt.py 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 def SM ( self , W = []): \"\"\" Comprehensive optimization of the probe state and measurement (SM). Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" ini_particle = ( self . psi0 , self . measurement0 ) self . alg = Main . QuanEstimation . PSO ( self . max_episode , self . p_num , ini_particle , self . c0 , self . c1 , self . c2 , ) super () . SM ( W ) Comprehensive Optimization with DE \u00b6 Bases: Comp . ComprehensiveSystem Attributes \u00b6 savefile: bool -- Whether or not to save all the optimized variables (probe states, control coefficients and measurements). If set True then the optimized variables and the values of the objective function obtained in all episodes will be saved during the training. If set False the optimized variables in the final episode and the values of the objective function in all episodes will be saved. p_num: int -- The number of populations. psi0: list of arrays -- Initial guesses of states. ctrl0: list of arrays -- Initial guesses of control coefficients. measurement0: list of arrays -- Initial guesses of measurements. max_episode: int -- The number of episodes. c: float -- Mutation constant. cr: float -- Crossover constant. seed: int -- Random seed. eps: float -- Machine epsilon. Source code in quanestimation/ComprehensiveOpt/DE_Compopt.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 class DE_Compopt ( Comp . ComprehensiveSystem ): \"\"\" Attributes ---------- > **savefile:** `bool` -- Whether or not to save all the optimized variables (probe states, control coefficients and measurements). If set `True` then the optimized variables and the values of the objective function obtained in all episodes will be saved during the training. If set `False` the optimized variables in the final episode and the values of the objective function in all episodes will be saved. > **p_num:** `int` -- The number of populations. > **psi0:** `list of arrays` -- Initial guesses of states. > **ctrl0:** `list of arrays` -- Initial guesses of control coefficients. > **measurement0:** `list of arrays` -- Initial guesses of measurements. > **max_episode:** `int` -- The number of episodes. > **c:** `float` -- Mutation constant. > **cr:** `float` -- Crossover constant. > **seed:** `int` -- Random seed. > **eps:** `float` -- Machine epsilon. \"\"\" def __init__ ( self , savefile = False , p_num = 10 , psi0 = [], ctrl0 = [], measurement0 = [], max_episode = 1000 , c = 1.0 , cr = 0.5 , seed = 1234 , eps = 1e-8 , ): Comp . ComprehensiveSystem . __init__ ( self , savefile , psi0 , ctrl0 , measurement0 , seed , eps ) self . p_num = p_num self . max_episode = max_episode self . c = c self . cr = cr self . seed = seed def SC ( self , W = [], M = [], target = \"QFIM\" , LDtype = \"SLD\" ): \"\"\" Comprehensive optimization of the probe state and control (SC). Parameters ---------- > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). > **target:** `string` -- Objective functions for searching the minimum time to reach the given value of the objective function. Options are: \"QFIM\" (default) -- choose QFI (QFIM) as the objective function. \"CFIM\" -- choose CFI (CFIM) as the objective function. \"HCRB\" -- choose HCRB as the objective function. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" ini_population = ( self . psi0 , self . ctrl0 ) self . alg = Main . QuanEstimation . DE ( self . max_episode , self . p_num , ini_population , self . c , self . cr , ) super () . SC ( W , M , target , LDtype ) def CM ( self , rho0 , W = []): \"\"\" Comprehensive optimization of the control and measurement (CM). Parameters ---------- > **rho0:** `matrix` -- Initial state (density matrix). > **W:** `matrix` -- Weight matrix. \"\"\" ini_population = ( self . ctrl0 , self . measurement0 ) self . alg = Main . QuanEstimation . DE ( self . max_episode , self . p_num , ini_population , self . c , self . cr , ) super () . CM ( rho0 , W ) def SM ( self , W = []): \"\"\" Comprehensive optimization of the probe state and measurement (SM). Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" ini_population = ( self . psi0 , self . measurement0 ) self . alg = Main . QuanEstimation . DE ( self . max_episode , self . p_num , ini_population , self . c , self . cr , ) super () . SM ( W ) def SCM ( self , W = []): \"\"\" Comprehensive optimization of the probe state, control and measurement (SCM). Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" ini_population = ( self . psi0 , self . ctrl0 , self . measurement0 ) self . alg = Main . QuanEstimation . DE ( self . max_episode , self . p_num , ini_population , self . c , self . cr , ) super () . SCM ( W ) CM ( rho0 , W = []) \u00b6 Comprehensive optimization of the control and measurement (CM). Parameters \u00b6 rho0: matrix -- Initial state (density matrix). W: matrix -- Weight matrix. Source code in quanestimation/ComprehensiveOpt/DE_Compopt.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 def CM ( self , rho0 , W = []): \"\"\" Comprehensive optimization of the control and measurement (CM). Parameters ---------- > **rho0:** `matrix` -- Initial state (density matrix). > **W:** `matrix` -- Weight matrix. \"\"\" ini_population = ( self . ctrl0 , self . measurement0 ) self . alg = Main . QuanEstimation . DE ( self . max_episode , self . p_num , ini_population , self . c , self . cr , ) super () . CM ( rho0 , W ) SC ( W = [], M = [], target = 'QFIM' , LDtype = 'SLD' ) \u00b6 Comprehensive optimization of the probe state and control (SC). Parameters \u00b6 W: matrix -- Weight matrix. M: list of matrices -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). target: string -- Objective functions for searching the minimum time to reach the given value of the objective function. Options are: \"QFIM\" (default) -- choose QFI (QFIM) as the objective function. \"CFIM\" -- choose CFI (CFIM) as the objective function. \"HCRB\" -- choose HCRB as the objective function. LDtype: string -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). Note: SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from here . Source code in quanestimation/ComprehensiveOpt/DE_Compopt.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 def SC ( self , W = [], M = [], target = \"QFIM\" , LDtype = \"SLD\" ): \"\"\" Comprehensive optimization of the probe state and control (SC). Parameters ---------- > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). > **target:** `string` -- Objective functions for searching the minimum time to reach the given value of the objective function. Options are: \"QFIM\" (default) -- choose QFI (QFIM) as the objective function. \"CFIM\" -- choose CFI (CFIM) as the objective function. \"HCRB\" -- choose HCRB as the objective function. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" ini_population = ( self . psi0 , self . ctrl0 ) self . alg = Main . QuanEstimation . DE ( self . max_episode , self . p_num , ini_population , self . c , self . cr , ) super () . SC ( W , M , target , LDtype ) SCM ( W = []) \u00b6 Comprehensive optimization of the probe state, control and measurement (SCM). Parameters \u00b6 W: matrix -- Weight matrix. Source code in quanestimation/ComprehensiveOpt/DE_Compopt.py 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 def SCM ( self , W = []): \"\"\" Comprehensive optimization of the probe state, control and measurement (SCM). Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" ini_population = ( self . psi0 , self . ctrl0 , self . measurement0 ) self . alg = Main . QuanEstimation . DE ( self . max_episode , self . p_num , ini_population , self . c , self . cr , ) super () . SCM ( W ) SM ( W = []) \u00b6 Comprehensive optimization of the probe state and measurement (SM). Parameters \u00b6 W: matrix -- Weight matrix. Source code in quanestimation/ComprehensiveOpt/DE_Compopt.py 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 def SM ( self , W = []): \"\"\" Comprehensive optimization of the probe state and measurement (SM). Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" ini_population = ( self . psi0 , self . measurement0 ) self . alg = Main . QuanEstimation . DE ( self . max_episode , self . p_num , ini_population , self . c , self . cr , ) super () . SM ( W ) Adaptive measurement schemes \u00b6 In QuanEstimation, the Hamiltonian of the adaptive system should be written as \\(H(\\textbf{x}+\\textbf{u})\\) with \\(\\textbf{x}\\) the unknown parameters and \\(\\textbf{u}\\) the tunable parameters. The tunable parameters \\(\\textbf{u}\\) are used to let the Hamiltonian work at the optimal point \\(\\textbf{x}_{\\mathrm{opt}}\\) . Adaptive measurement \u00b6 Attributes \u00b6 x: list -- The regimes of the parameters for the integral. p: multidimensional array -- The prior distribution. rho0: matrix -- Initial state (density matrix). savefile: bool -- Whether or not to save all the posterior distributions. If set True then three files \"pout.npy\", \"xout.npy\" and \"y.npy\" will be generated including the posterior distributions, the estimated values, and the experimental results in the iterations. If set False the posterior distribution in the final iteration, the estimated values and the experimental results in all iterations will be saved in \"pout.npy\", \"xout.npy\" and \"y.npy\". max_episode: int -- The number of episodes. eps: float -- Machine epsilon. Source code in quanestimation/AdaptiveScheme/Adaptive.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 class Adaptive : \"\"\" Attributes ---------- > **x:** `list` -- The regimes of the parameters for the integral. > **p:** `multidimensional array` -- The prior distribution. > **rho0:** `matrix` -- Initial state (density matrix). > **savefile:** `bool` -- Whether or not to save all the posterior distributions. If set `True` then three files \"pout.npy\", \"xout.npy\" and \"y.npy\" will be generated including the posterior distributions, the estimated values, and the experimental results in the iterations. If set `False` the posterior distribution in the final iteration, the estimated values and the experimental results in all iterations will be saved in \"pout.npy\", \"xout.npy\" and \"y.npy\". > **max_episode:** `int` -- The number of episodes. > **eps:** `float` -- Machine epsilon. \"\"\" def __init__ ( self , x , p , rho0 , savefile = False , max_episode = 1000 , eps = 1e-8 ): self . x = x self . p = p self . rho0 = np . array ( rho0 , dtype = np . complex128 ) self . max_episode = max_episode self . eps = eps self . para_num = len ( x ) self . savefile = savefile def dynamics ( self , tspan , H , dH , Hc = [], ctrl = [], decay = []): r \"\"\" Dynamics of the density matrix of the form \\begin{align} \\partial_t\\rho &=\\mathcal{L}\\rho \\nonumber \\\\ &=-i[H,\\rho]+\\sum_i \\gamma_i\\left(\\Gamma_i\\rho\\Gamma^{\\dagger}_i-\\frac{1}{2} \\left\\{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\right\\}\\right), \\end{align} where $\\rho$ is the evolved density matrix, H is the Hamiltonian of the system, $\\Gamma_i$ and $\\gamma_i$ are the $i\\mathrm{th}$ decay operator and decay rate. Parameters ---------- > **tspan:** `array` -- Time length for the evolution. > **H0:** `multidimensional list` -- Free Hamiltonian with respect to the values in x. > **dH:** `multidimensional list` -- Derivatives of the free Hamiltonian with respect to the unknown parameters to be estimated. > **Hc:** `list` -- Control Hamiltonians. > **ctrl:** `list` -- Control coefficients. > **decay:** `list` -- Decay operators and the corresponding decay rates. Its input rule is `decay=[[Gamma1, gamma1], [Gamma2,gamma2],...]`, where `Gamma1 (Gamma2)` represents the decay operator and `gamma1 (gamma2)` is the corresponding decay rate. \"\"\" self . tspan = tspan self . H = H self . dH = dH self . Hc = Hc self . ctrl = ctrl self . decay = decay self . dynamic_type = \"dynamics\" def Kraus ( self , K , dK ): r \"\"\" Dynamics of the density matrix of the form \\begin{align} \\rho=\\sum_i K_i\\rho_0K_i^{\\dagger} \\end{align} where $\\rho$ is the evolved density matrix, $K_i$ is the Kraus operator. Parameters ---------- > **K:** `multidimensional list` -- Kraus operator(s) with respect to the values in x. > **dK:** `multidimensional list` -- Derivatives of the Kraus operator(s) with respect to the unknown parameters to be estimated. \"\"\" self . K = K self . dK = dK self . dynamic_type = \"Kraus\" def CFIM ( self , M = [], W = []): r \"\"\" Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" if M == []: M = SIC ( len ( self . rho0 )) if W == []: W = np . eye ( len ( self . x )) self . W = W if self . dynamic_type == \"dynamics\" : adaptive_dynamics ( self . x , self . p , M , self . tspan , self . rho0 , self . H , self . dH , self . decay , self . Hc , self . ctrl , W , self . max_episode , self . eps , self . savefile , ) elif self . dynamic_type == \"Kraus\" : adaptive_Kraus ( self . x , self . p , M , self . rho0 , self . K , self . dK , W , self . max_episode , self . eps , self . savefile , ) else : raise ValueError ( \" {!r} is not a valid value for type of dynamics, supported values are 'dynamics' and 'Kraus'.\" . format ( self . dynamic_type ) ) def Mopt ( self , W = []): r \"\"\" Measurement optimization for the optimal x. Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" if W == []: W = np . identity ( self . para_num ) else : W = W if self . dynamic_type == \"dynamics\" : if self . para_num == 1 : F = [] for i in range ( len ( self . H )): dynamics = Lindblad ( self . tspan , self . rho0 , self . H [ i ], self . dH [ i ], decay = self . decay , Hc = self . Hc , ctrl = self . ctrl , ) rho_tp , drho_tp = dynamics . expm () rho , drho = rho_tp [ - 1 ], drho_tp [ - 1 ] F_tp = QFIM ( rho , drho ) F . append ( F_tp ) idx = np . argmax ( F ) H_res , dH_res = self . H [ idx ], self . dH [ idx ] else : p_ext = extract_ele ( self . p , self . para_num ) H_ext = extract_ele ( self . H , self . para_num ) dH_ext = extract_ele ( self . dH , self . para_num ) p_list , H_list , dH_list = [], [], [] for p_ele , H_ele , dH_ele in zip ( p_ext , H_ext , dH_ext ): p_list . append ( p_ele ) H_list . append ( H_ele ) dH_list . append ( dH_ele ) F = [] for i in range ( len ( p_list )): dynamics = Lindblad ( self . tspan , self . rho0 , self . H_list [ i ], self . dH_list [ i ], decay = self . decay , Hc = self . Hc , ctrl = self . ctrl , ) rho_tp , drho_tp = dynamics . expm () rho , drho = rho_tp [ - 1 ], drho_tp [ - 1 ] F_tp = QFIM ( rho , drho ) if np . linalg . det ( F_tp ) < self . eps : F . append ( self . eps ) else : F . append ( 1.0 / np . trace ( np . dot ( W , np . linalg . inv ( F_tp )))) idx = np . argmax ( F ) H_res , dH_res = self . H_list [ idx ], self . dH_list [ idx ] m = MeasurementOpt ( mtype = \"projection\" , minput = [], method = \"DE\" ) m . dynamics ( self . tspan , self . rho0 , H_res , dH_res , Hc = self . Hc , ctrl = self . ctrl , decay = self . decay , ) m . CFIM ( W = W ) elif self . dynamic_type == \"Kraus\" : if self . para_num == 1 : F = [] for hi in range ( len ( self . K )): rho_tp = sum ( [ np . dot ( Ki , np . dot ( self . rho0 , Ki . conj () . T )) for Ki in self . K [ hi ]] ) drho_tp = sum ( [ np . dot ( dKi , np . dot ( self . rho0 , Ki . conj () . T )) + np . dot ( Ki , np . dot ( self . rho0 , dKi . conj () . T )) for ( Ki , dKi ) in zip ( self . K [ hi ], self . dK [ hi ]) ] ) F_tp = QFIM ( rho_tp , drho_tp ) F . append ( F_tp ) idx = np . argmax ( F ) K_res , dK_res = self . K [ idx ], self . dK [ idx ] else : p_shape = np . shape ( self . p ) p_ext = extract_ele ( self . p , self . para_num ) K_ext = extract_ele ( self . K , self . para_num ) dK_ext = extract_ele ( self . dK , self . para_num ) p_list , K_list , dK_list = [], [], [] for K_ele , dK_ele in zip ( K_ext , dK_ext ): p_list . append ( p_ele ) K_list . append ( K_ele ) dK_list . append ( dK_ele ) F = [] for hi in range ( len ( p_list )): rho_tp = sum ( [ np . dot ( Ki , np . dot ( self . rho0 , Ki . conj () . T )) for Ki in K_list [ hi ]] ) dK_reshape = [ [ dK_list [ hi ][ i ][ j ] for i in range ( self . k_num )] for j in range ( self . para_num ) ] drho_tp = [ sum ( [ np . dot ( dKi , np . dot ( self . rho0 , Ki . conj () . T )) + np . dot ( Ki , np . dot ( self . rho0 , dKi . conj () . T )) for ( Ki , dKi ) in zip ( K_list [ hi ], dKj ) ] ) for dKj in dK_reshape ] F_tp = QFIM ( rho_tp , drho_tp ) if np . linalg . det ( F_tp ) < self . eps : F . append ( self . eps ) else : F . append ( 1.0 / np . trace ( np . dot ( W , np . linalg . inv ( F_tp )))) F = np . array ( F ) . reshape ( p_shape ) idx = np . where ( np . array ( F ) == np . max ( np . array ( F ))) K_res , dK_res = self . K_list [ idx ], self . dK_list [ idx ] m = MeasurementOpt ( mtype = \"projection\" , minput = [], method = \"DE\" ) m . Kraus ( self . rho0 , K_res , dK_res , decay = self . decay ) m . CFIM ( W = W ) else : raise ValueError ( \" {!r} is not a valid value for type of dynamics, supported values are 'dynamics' and 'Kraus'.\" . format ( self . dynamic_type ) ) CFIM ( M = [], W = []) \u00b6 Choose CFI or \\(\\mathrm{Tr}(WI^{-1})\\) as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be \\(\\mathrm{Tr}(WI^{-1})\\) . Parameters \u00b6 W: matrix -- Weight matrix. M: list of matrices -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). Note: SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from here . Source code in quanestimation/AdaptiveScheme/Adaptive.py 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 def CFIM ( self , M = [], W = []): r \"\"\" Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" if M == []: M = SIC ( len ( self . rho0 )) if W == []: W = np . eye ( len ( self . x )) self . W = W if self . dynamic_type == \"dynamics\" : adaptive_dynamics ( self . x , self . p , M , self . tspan , self . rho0 , self . H , self . dH , self . decay , self . Hc , self . ctrl , W , self . max_episode , self . eps , self . savefile , ) elif self . dynamic_type == \"Kraus\" : adaptive_Kraus ( self . x , self . p , M , self . rho0 , self . K , self . dK , W , self . max_episode , self . eps , self . savefile , ) else : raise ValueError ( \" {!r} is not a valid value for type of dynamics, supported values are 'dynamics' and 'Kraus'.\" . format ( self . dynamic_type ) ) Kraus ( K , dK ) \u00b6 Dynamics of the density matrix of the form \\begin{align} \\rho=\\sum_i K_i\\rho_0K_i^{\\dagger} \\end{align} where \\(\\rho\\) is the evolved density matrix, \\(K_i\\) is the Kraus operator. Parameters \u00b6 K: multidimensional list -- Kraus operator(s) with respect to the values in x. dK: multidimensional list -- Derivatives of the Kraus operator(s) with respect to the unknown parameters to be estimated. Source code in quanestimation/AdaptiveScheme/Adaptive.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 def Kraus ( self , K , dK ): r \"\"\" Dynamics of the density matrix of the form \\begin{align} \\rho=\\sum_i K_i\\rho_0K_i^{\\dagger} \\end{align} where $\\rho$ is the evolved density matrix, $K_i$ is the Kraus operator. Parameters ---------- > **K:** `multidimensional list` -- Kraus operator(s) with respect to the values in x. > **dK:** `multidimensional list` -- Derivatives of the Kraus operator(s) with respect to the unknown parameters to be estimated. \"\"\" self . K = K self . dK = dK self . dynamic_type = \"Kraus\" Mopt ( W = []) \u00b6 Measurement optimization for the optimal x. Parameters \u00b6 W: matrix -- Weight matrix. Source code in quanestimation/AdaptiveScheme/Adaptive.py 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 def Mopt ( self , W = []): r \"\"\" Measurement optimization for the optimal x. Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" if W == []: W = np . identity ( self . para_num ) else : W = W if self . dynamic_type == \"dynamics\" : if self . para_num == 1 : F = [] for i in range ( len ( self . H )): dynamics = Lindblad ( self . tspan , self . rho0 , self . H [ i ], self . dH [ i ], decay = self . decay , Hc = self . Hc , ctrl = self . ctrl , ) rho_tp , drho_tp = dynamics . expm () rho , drho = rho_tp [ - 1 ], drho_tp [ - 1 ] F_tp = QFIM ( rho , drho ) F . append ( F_tp ) idx = np . argmax ( F ) H_res , dH_res = self . H [ idx ], self . dH [ idx ] else : p_ext = extract_ele ( self . p , self . para_num ) H_ext = extract_ele ( self . H , self . para_num ) dH_ext = extract_ele ( self . dH , self . para_num ) p_list , H_list , dH_list = [], [], [] for p_ele , H_ele , dH_ele in zip ( p_ext , H_ext , dH_ext ): p_list . append ( p_ele ) H_list . append ( H_ele ) dH_list . append ( dH_ele ) F = [] for i in range ( len ( p_list )): dynamics = Lindblad ( self . tspan , self . rho0 , self . H_list [ i ], self . dH_list [ i ], decay = self . decay , Hc = self . Hc , ctrl = self . ctrl , ) rho_tp , drho_tp = dynamics . expm () rho , drho = rho_tp [ - 1 ], drho_tp [ - 1 ] F_tp = QFIM ( rho , drho ) if np . linalg . det ( F_tp ) < self . eps : F . append ( self . eps ) else : F . append ( 1.0 / np . trace ( np . dot ( W , np . linalg . inv ( F_tp )))) idx = np . argmax ( F ) H_res , dH_res = self . H_list [ idx ], self . dH_list [ idx ] m = MeasurementOpt ( mtype = \"projection\" , minput = [], method = \"DE\" ) m . dynamics ( self . tspan , self . rho0 , H_res , dH_res , Hc = self . Hc , ctrl = self . ctrl , decay = self . decay , ) m . CFIM ( W = W ) elif self . dynamic_type == \"Kraus\" : if self . para_num == 1 : F = [] for hi in range ( len ( self . K )): rho_tp = sum ( [ np . dot ( Ki , np . dot ( self . rho0 , Ki . conj () . T )) for Ki in self . K [ hi ]] ) drho_tp = sum ( [ np . dot ( dKi , np . dot ( self . rho0 , Ki . conj () . T )) + np . dot ( Ki , np . dot ( self . rho0 , dKi . conj () . T )) for ( Ki , dKi ) in zip ( self . K [ hi ], self . dK [ hi ]) ] ) F_tp = QFIM ( rho_tp , drho_tp ) F . append ( F_tp ) idx = np . argmax ( F ) K_res , dK_res = self . K [ idx ], self . dK [ idx ] else : p_shape = np . shape ( self . p ) p_ext = extract_ele ( self . p , self . para_num ) K_ext = extract_ele ( self . K , self . para_num ) dK_ext = extract_ele ( self . dK , self . para_num ) p_list , K_list , dK_list = [], [], [] for K_ele , dK_ele in zip ( K_ext , dK_ext ): p_list . append ( p_ele ) K_list . append ( K_ele ) dK_list . append ( dK_ele ) F = [] for hi in range ( len ( p_list )): rho_tp = sum ( [ np . dot ( Ki , np . dot ( self . rho0 , Ki . conj () . T )) for Ki in K_list [ hi ]] ) dK_reshape = [ [ dK_list [ hi ][ i ][ j ] for i in range ( self . k_num )] for j in range ( self . para_num ) ] drho_tp = [ sum ( [ np . dot ( dKi , np . dot ( self . rho0 , Ki . conj () . T )) + np . dot ( Ki , np . dot ( self . rho0 , dKi . conj () . T )) for ( Ki , dKi ) in zip ( K_list [ hi ], dKj ) ] ) for dKj in dK_reshape ] F_tp = QFIM ( rho_tp , drho_tp ) if np . linalg . det ( F_tp ) < self . eps : F . append ( self . eps ) else : F . append ( 1.0 / np . trace ( np . dot ( W , np . linalg . inv ( F_tp )))) F = np . array ( F ) . reshape ( p_shape ) idx = np . where ( np . array ( F ) == np . max ( np . array ( F ))) K_res , dK_res = self . K_list [ idx ], self . dK_list [ idx ] m = MeasurementOpt ( mtype = \"projection\" , minput = [], method = \"DE\" ) m . Kraus ( self . rho0 , K_res , dK_res , decay = self . decay ) m . CFIM ( W = W ) else : raise ValueError ( \" {!r} is not a valid value for type of dynamics, supported values are 'dynamics' and 'Kraus'.\" . format ( self . dynamic_type ) ) dynamics ( tspan , H , dH , Hc = [], ctrl = [], decay = []) \u00b6 Dynamics of the density matrix of the form \\[\\begin{align} \\partial_t\\rho &=\\mathcal{L}\\rho \\nonumber \\\\ &=-i[H,\\rho]+\\sum_i \\gamma_i\\left(\\Gamma_i\\rho\\Gamma^{\\dagger}_i-\\frac{1}{2} \\left\\{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\right\\}\\right), \\end{align}\\] where \\(\\rho\\) is the evolved density matrix, H is the Hamiltonian of the system, \\(\\Gamma_i\\) and \\(\\gamma_i\\) are the \\(i\\mathrm{th}\\) decay operator and decay rate. Parameters \u00b6 tspan: array -- Time length for the evolution. H0: multidimensional list -- Free Hamiltonian with respect to the values in x. dH: multidimensional list -- Derivatives of the free Hamiltonian with respect to the unknown parameters to be estimated. Hc: list -- Control Hamiltonians. ctrl: list -- Control coefficients. decay: list -- Decay operators and the corresponding decay rates. Its input rule is decay=[[Gamma1, gamma1], [Gamma2,gamma2],...] , where Gamma1 (Gamma2) represents the decay operator and gamma1 (gamma2) is the corresponding decay rate. Source code in quanestimation/AdaptiveScheme/Adaptive.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 def dynamics ( self , tspan , H , dH , Hc = [], ctrl = [], decay = []): r \"\"\" Dynamics of the density matrix of the form \\begin{align} \\partial_t\\rho &=\\mathcal{L}\\rho \\nonumber \\\\ &=-i[H,\\rho]+\\sum_i \\gamma_i\\left(\\Gamma_i\\rho\\Gamma^{\\dagger}_i-\\frac{1}{2} \\left\\{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\right\\}\\right), \\end{align} where $\\rho$ is the evolved density matrix, H is the Hamiltonian of the system, $\\Gamma_i$ and $\\gamma_i$ are the $i\\mathrm{th}$ decay operator and decay rate. Parameters ---------- > **tspan:** `array` -- Time length for the evolution. > **H0:** `multidimensional list` -- Free Hamiltonian with respect to the values in x. > **dH:** `multidimensional list` -- Derivatives of the free Hamiltonian with respect to the unknown parameters to be estimated. > **Hc:** `list` -- Control Hamiltonians. > **ctrl:** `list` -- Control coefficients. > **decay:** `list` -- Decay operators and the corresponding decay rates. Its input rule is `decay=[[Gamma1, gamma1], [Gamma2,gamma2],...]`, where `Gamma1 (Gamma2)` represents the decay operator and `gamma1 (gamma2)` is the corresponding decay rate. \"\"\" self . tspan = tspan self . H = H self . dH = dH self . Hc = Hc self . ctrl = ctrl self . decay = decay self . dynamic_type = \"dynamics\" Attributes \u00b6 x: list -- The regimes of the parameters for the integral. p: multidimensional array -- The prior distribution. rho0: matrix -- Initial state (density matrix). Source code in quanestimation/AdaptiveScheme/Adapt_MZI.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 class Adapt_MZI : \"\"\" Attributes ---------- > **x:** `list` -- The regimes of the parameters for the integral. > **p:** `multidimensional array` -- The prior distribution. > **rho0:** `matrix` -- Initial state (density matrix). \"\"\" def __init__ ( self , x , p , rho0 ): self . x = x self . p = p self . rho0 = rho0 self . N = int ( np . sqrt ( len ( rho0 ))) - 1 self . a = annihilation ( self . N + 1 ) def general ( self ): self . MZI_type = \"general\" def online ( self , output = \"phi\" ): \"\"\" Parameters ---------- > **output:** `string` -- The output the class. Options are: \"phi\" (default) -- The tunable phase. \"dphi\" -- Phase difference. \"\"\" phi = Main . QuanEstimation . adaptMZI_online ( self . x , self . p , self . rho0 , self . a , output ) def offline ( self , method = \"DE\" , p_num = 10 , deltaphi0 = [], c = 1.0 , cr = 0.5 , c0 = 1.0 , c1 = 2.0 , c2 = 2.0 , seed = 1234 , max_episode = 1000 , eps = 1e-8 , ): \"\"\" Parameters ---------- > **method:** `string` -- The method for the adaptive phase estimation. Options are: \"DE\" (default) -- DE algorithm for the adaptive phase estimation. \"PSO\" -- PSO algorithm for the adaptive phase estimation. If the `method=DE`, the parameters are: > **p_num:** `int` -- The number of populations. > **deltaphi0:** `list` -- Initial guesses of phase difference. > **max_episode:** `int` -- The number of episodes. > **c:** `float` -- Mutation constant. > **cr:** `float` -- Crossover constant. > **seed:** `int` -- Random seed. > **eps:** `float` -- Machine epsilon. If the `method=PSO`, the parameters are: > **deltaphi0:** `list` -- Initial guesses of phase difference. > **max_episode:** `int or list` -- If it is an integer, for example max_episode=1000, it means the program will continuously run 1000 episodes. However, if it is an array, for example max_episode=[1000,100], the program will run 1000 episodes in total but replace states of all the particles with global best every 100 episodes. > **c0:** `float` -- The damping factor that assists convergence, also known as inertia weight. > **c1:** `float` -- The exploitation weight that attracts the particle to its best previous position, also known as cognitive learning factor. > **c2:** `float` -- The exploitation weight that attracts the particle to the best position in the neighborhood, also known as social learning factor. > **eps:** `float` -- Machine epsilon. \"\"\" comb_tp = brgd ( self . N ) comb = [ np . array ([ int ( list ( comb_tp [ i ])[ j ]) for j in range ( self . N )]) for i in range ( 2 ** self . N ) ] if method == \"DE\" : Main . QuanEstimation . DE_deltaphiOpt ( self . x , self . p , self . rho0 , self . a , comb , p_num , deltaphi0 , c , cr , seed , max_episode , eps , ) elif method == \"PSO\" : Main . QuanEstimation . PSO_deltaphiOpt ( self . x , self . p , self . rho0 , self . a , comb , p_num , deltaphi0 , c0 , c1 , c2 , seed , max_episode , eps , ) else : raise ValueError ( \" {!r} is not a valid value for method, supported values are 'DE' and 'PSO'.\" . format ( method ) ) offline ( method = 'DE' , p_num = 10 , deltaphi0 = [], c = 1.0 , cr = 0.5 , c0 = 1.0 , c1 = 2.0 , c2 = 2.0 , seed = 1234 , max_episode = 1000 , eps = 1e-08 ) \u00b6 Parameters \u00b6 method: string -- The method for the adaptive phase estimation. Options are: \"DE\" (default) -- DE algorithm for the adaptive phase estimation. \"PSO\" -- PSO algorithm for the adaptive phase estimation. If the method=DE , the parameters are: p_num: int -- The number of populations. deltaphi0: list -- Initial guesses of phase difference. max_episode: int -- The number of episodes. c: float -- Mutation constant. cr: float -- Crossover constant. seed: int -- Random seed. eps: float -- Machine epsilon. If the method=PSO , the parameters are: deltaphi0: list -- Initial guesses of phase difference. max_episode: int or list -- If it is an integer, for example max_episode=1000, it means the program will continuously run 1000 episodes. However, if it is an array, for example max_episode=[1000,100], the program will run 1000 episodes in total but replace states of all the particles with global best every 100 episodes. c0: float -- The damping factor that assists convergence, also known as inertia weight. c1: float -- The exploitation weight that attracts the particle to its best previous position, also known as cognitive learning factor. c2: float -- The exploitation weight that attracts the particle to the best position in the neighborhood, also known as social learning factor. eps: float -- Machine epsilon. Source code in quanestimation/AdaptiveScheme/Adapt_MZI.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 def offline ( self , method = \"DE\" , p_num = 10 , deltaphi0 = [], c = 1.0 , cr = 0.5 , c0 = 1.0 , c1 = 2.0 , c2 = 2.0 , seed = 1234 , max_episode = 1000 , eps = 1e-8 , ): \"\"\" Parameters ---------- > **method:** `string` -- The method for the adaptive phase estimation. Options are: \"DE\" (default) -- DE algorithm for the adaptive phase estimation. \"PSO\" -- PSO algorithm for the adaptive phase estimation. If the `method=DE`, the parameters are: > **p_num:** `int` -- The number of populations. > **deltaphi0:** `list` -- Initial guesses of phase difference. > **max_episode:** `int` -- The number of episodes. > **c:** `float` -- Mutation constant. > **cr:** `float` -- Crossover constant. > **seed:** `int` -- Random seed. > **eps:** `float` -- Machine epsilon. If the `method=PSO`, the parameters are: > **deltaphi0:** `list` -- Initial guesses of phase difference. > **max_episode:** `int or list` -- If it is an integer, for example max_episode=1000, it means the program will continuously run 1000 episodes. However, if it is an array, for example max_episode=[1000,100], the program will run 1000 episodes in total but replace states of all the particles with global best every 100 episodes. > **c0:** `float` -- The damping factor that assists convergence, also known as inertia weight. > **c1:** `float` -- The exploitation weight that attracts the particle to its best previous position, also known as cognitive learning factor. > **c2:** `float` -- The exploitation weight that attracts the particle to the best position in the neighborhood, also known as social learning factor. > **eps:** `float` -- Machine epsilon. \"\"\" comb_tp = brgd ( self . N ) comb = [ np . array ([ int ( list ( comb_tp [ i ])[ j ]) for j in range ( self . N )]) for i in range ( 2 ** self . N ) ] if method == \"DE\" : Main . QuanEstimation . DE_deltaphiOpt ( self . x , self . p , self . rho0 , self . a , comb , p_num , deltaphi0 , c , cr , seed , max_episode , eps , ) elif method == \"PSO\" : Main . QuanEstimation . PSO_deltaphiOpt ( self . x , self . p , self . rho0 , self . a , comb , p_num , deltaphi0 , c0 , c1 , c2 , seed , max_episode , eps , ) else : raise ValueError ( \" {!r} is not a valid value for method, supported values are 'DE' and 'PSO'.\" . format ( method ) ) online ( output = 'phi' ) \u00b6 Parameters \u00b6 output: string -- The output the class. Options are: \"phi\" (default) -- The tunable phase. \"dphi\" -- Phase difference. Source code in quanestimation/AdaptiveScheme/Adapt_MZI.py 31 32 33 34 35 36 37 38 39 40 41 42 def online ( self , output = \"phi\" ): \"\"\" Parameters ---------- > **output:** `string` -- The output the class. Options are: \"phi\" (default) -- The tunable phase. \"dphi\" -- Phase difference. \"\"\" phi = Main . QuanEstimation . adaptMZI_online ( self . x , self . p , self . rho0 , self . a , output )","title":"Classes"},{"location":"API/python/classes/#dynamics","text":"The dynamics of a density matrix is of the form \\[\\begin{align} \\partial_t\\rho &=\\mathcal{L}\\rho \\nonumber \\\\ &=-i[H,\\rho]+\\sum_i \\gamma_i\\left(\\Gamma_i\\rho\\Gamma^{\\dagger}_i-\\frac{1}{2} \\left\\{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\right\\}\\right), \\end{align}\\] where \\(\\rho\\) is the evolved density matrix, \\(H\\) is the Hamiltonian of the system, \\(\\Gamma_i\\) and \\(\\gamma_i\\) are the \\(i\\mathrm{th}\\) decay operator and the corresponding decay rate.","title":"Dynamics"},{"location":"API/python/classes/#quanestimation.Lindblad--attributes","text":"tspan: array -- Time length for the evolution. rho0: matrix -- Initial state (density matrix). H0: matrix or list -- Free Hamiltonian. It is a matrix when the free Hamiltonian is time- independent and a list with the length equal to tspan when it is time-dependent. dH: list -- Derivatives of the free Hamiltonian with respect to the unknown parameters to be estimated. For example, dH[0] is the derivative vector on the first parameter. decay: list -- Decay operators and the corresponding decay rates. Its input rule is decay=[[ \\(\\Gamma_1\\) , \\(\\gamma_1\\) ], [ \\(\\Gamma_2\\) , \\(\\gamma_2\\) ],...], where \\(\\Gamma_1\\) \\((\\Gamma_2)\\) represents the decay operator and \\(\\gamma_1\\) \\((\\gamma_2)\\) is the corresponding decay rate. Hc: list -- Control Hamiltonians. ctrl: list of arrays -- Control coefficients. Source code in quanestimation/Parameterization/GeneralDynamics.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 class Lindblad : r \"\"\" The dynamics of a density matrix is of the form \\begin{align} \\partial_t\\rho &=\\mathcal{L}\\rho \\nonumber \\\\ &=-i[H,\\rho]+\\sum_i \\gamma_i\\left(\\Gamma_i\\rho\\Gamma^{\\dagger}_i-\\frac{1}{2} \\left\\{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\right\\}\\right), \\end{align} where $\\rho$ is the evolved density matrix, $H$ is the Hamiltonian of the system, $\\Gamma_i$ and $\\gamma_i$ are the $i\\mathrm{th}$ decay operator and the corresponding decay rate. Attributes ---------- > **tspan:** `array` -- Time length for the evolution. > **rho0:** `matrix` -- Initial state (density matrix). > **H0:** `matrix or list` -- Free Hamiltonian. It is a matrix when the free Hamiltonian is time- independent and a list with the length equal to `tspan` when it is time-dependent. > **dH:** `list` -- Derivatives of the free Hamiltonian with respect to the unknown parameters to be estimated. For example, dH[0] is the derivative vector on the first parameter. > **decay:** `list` -- Decay operators and the corresponding decay rates. Its input rule is decay=[[$\\Gamma_1$, $\\gamma_1$], [$\\Gamma_2$, $\\gamma_2$],...], where $\\Gamma_1$ $(\\Gamma_2)$ represents the decay operator and $\\gamma_1$ $(\\gamma_2)$ is the corresponding decay rate. > **Hc:** `list` -- Control Hamiltonians. > **ctrl:** `list of arrays` -- Control coefficients. \"\"\" def __init__ ( self , tspan , rho0 , H0 , dH , decay = [], Hc = [], ctrl = []): self . tspan = tspan self . rho0 = np . array ( rho0 , dtype = np . complex128 ) if type ( H0 ) == np . ndarray : self . freeHamiltonian = np . array ( H0 , dtype = np . complex128 ) else : self . freeHamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in H0 ] if type ( dH [ 0 ]) != np . ndarray : raise TypeError ( \"The derivative of Hamiltonian should be a list!\" ) if dH == []: dH = [ np . zeros (( len ( self . rho0 ), len ( self . rho0 )))] self . Hamiltonian_derivative = [ np . array ( x , dtype = np . complex128 ) for x in dH ] if decay == []: decay_opt = [ np . zeros (( len ( self . rho0 ), len ( self . rho0 )))] self . gamma = [ 0.0 ] else : decay_opt = [ decay [ i ][ 0 ] for i in range ( len ( decay ))] self . gamma = [ decay [ i ][ 1 ] for i in range ( len ( decay ))] self . decay_opt = [ np . array ( x , dtype = np . complex128 ) for x in decay_opt ] if Hc == []: Hc = [ np . zeros (( len ( self . rho0 ), len ( self . rho0 )))] ctrl = [ np . zeros ( len ( self . tspan ) - 1 )] self . control_Hamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in Hc ] self . control_coefficients = ctrl elif ctrl == []: ctrl = [ np . zeros ( len ( self . tspan ) - 1 ) for j in range ( len ( Hc ))] self . control_Hamiltonian = Hc self . control_coefficients = ctrl else : ctrl_length = len ( ctrl ) ctrlnum = len ( Hc ) if ctrlnum < ctrl_length : raise TypeError ( \"There are %d control Hamiltonians but %d coefficients sequences: \\ too many coefficients sequences\" % ( ctrlnum , ctrl_length ) ) elif ctrlnum > ctrl_length : warnings . warn ( \"Not enough coefficients sequences: there are %d control Hamiltonians \\ but %d coefficients sequences. The rest of the control sequences are \\ set to be 0.\" % ( ctrlnum , ctrl_length ), DeprecationWarning , ) number = math . ceil (( len ( self . tspan ) - 1 ) / len ( ctrl [ 0 ])) if len ( self . tspan ) - 1 % len ( ctrl [ 0 ]) != 0 : tnum = number * len ( ctrl [ 0 ]) self . tspan = np . linspace ( self . tspan [ 0 ], self . tspan [ - 1 ], tnum + 1 ) self . control_Hamiltonian = Hc self . control_coefficients = ctrl def expm ( self ): r \"\"\" Calculation of the density matrix and its derivatives on the unknown parameters. The density matrix at $j$th time interval is obtained by $\\rho_j=e^{\\Delta t\\mathcal{L}}\\rho_{j-1}$, where $\\Delta t$ is the time interval and $\\rho_{j-1}$ is the density matrix for the $(j-1)$th time interval. $\\partial_{\\textbf{x}}\\rho_j$ is calculated as \\begin{align} \\partial_{\\textbf{x}}\\rho_j =\\Delta t(\\partial_{\\textbf{x}}\\mathcal{L})\\rho_j +e^{\\Delta t \\mathcal{L}}(\\partial_{\\textbf{x}}\\rho_{j-1}). \\end{align} \"\"\" rho , drho = Main . QuanEstimation . expm_py ( self . tspan , self . rho0 , self . freeHamiltonian , self . Hamiltonian_derivative , self . decay_opt , self . gamma , self . control_Hamiltonian , self . control_coefficients , ) return rho , drho def secondorder_derivative ( self , d2H ): r \"\"\" Calculation of the density matrix and its derivatives and the second derivatives on $\\textbf{x}$. The density matrix at $j$th time interval is obtained by $\\rho_j=e^{\\Delta t\\mathcal{L}}\\rho_{j-1}$, where $\\Delta t$ is the time interval and $\\rho_{j-1}$ is the density matrix for the $(j-1)$th time interval. $\\partial_{\\textbf{x}}\\rho_j$ is calculated via \\begin{align} \\partial_{\\textbf{x}}\\rho_j =\\Delta t(\\partial_{\\textbf{x}}\\mathcal{L})\\rho_j +e^{\\Delta t \\mathcal{L}}(\\partial_{\\textbf{x}}\\rho_{j-1}). \\end{align} $\\partial_{\\textbf{x}}^2\\rho_j$ is solved as \\begin{align} \\partial_{\\textbf{x}}^2\\rho_j =\\Delta t(\\partial_{\\textbf{x}}^2\\mathcal{L})\\rho_j +\\Delta t(\\partial_{\\textbf{x}}\\mathcal{L})\\partial_{\\textbf{x}}\\rho_j +\\Delta t(\\partial_{\\textbf{x}}\\mathcal{L})e^{\\Delta t \\mathcal{L}} \\partial_{\\textbf{x}}\\rho_{j-1} +e^{\\Delta t \\mathcal{L}}(\\partial_{\\textbf{x}}^2\\rho_{j-1}). \\end{align} Parameters ---------- > **d2H:** `list` -- Second order derivatives of the free Hamiltonian on the unknown parameters to be estimated. \"\"\" d2H = [ np . array ( x , dtype = np . complex128 ) for x in d2H ] rho , drho , d2rho = Main . QuanEstimation . secondorder_derivative ( self . freeHamiltonian , self . Hamiltonian_derivative , d2H , self . rho0 , self . decay_opt , self . gamma , self . control_Hamiltonian , self . control_coefficients , self . tspan , ) return rho , drho , d2rho","title":"Attributes"},{"location":"API/python/classes/#quanestimation.Parameterization.GeneralDynamics.Lindblad.expm","text":"Calculation of the density matrix and its derivatives on the unknown parameters. The density matrix at \\(j\\) th time interval is obtained by \\(\\rho_j=e^{\\Delta t\\mathcal{L}}\\rho_{j-1}\\) , where \\(\\Delta t\\) is the time interval and \\(\\rho_{j-1}\\) is the density matrix for the \\((j-1)\\) th time interval. \\(\\partial_{\\textbf{x}}\\rho_j\\) is calculated as \\begin{align} \\partial_{\\textbf{x}}\\rho_j =\\Delta t(\\partial_{\\textbf{x}}\\mathcal{L})\\rho_j +e^{\\Delta t \\mathcal{L}}(\\partial_{\\textbf{x}}\\rho_{j-1}). \\end{align} Source code in quanestimation/Parameterization/GeneralDynamics.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 def expm ( self ): r \"\"\" Calculation of the density matrix and its derivatives on the unknown parameters. The density matrix at $j$th time interval is obtained by $\\rho_j=e^{\\Delta t\\mathcal{L}}\\rho_{j-1}$, where $\\Delta t$ is the time interval and $\\rho_{j-1}$ is the density matrix for the $(j-1)$th time interval. $\\partial_{\\textbf{x}}\\rho_j$ is calculated as \\begin{align} \\partial_{\\textbf{x}}\\rho_j =\\Delta t(\\partial_{\\textbf{x}}\\mathcal{L})\\rho_j +e^{\\Delta t \\mathcal{L}}(\\partial_{\\textbf{x}}\\rho_{j-1}). \\end{align} \"\"\" rho , drho = Main . QuanEstimation . expm_py ( self . tspan , self . rho0 , self . freeHamiltonian , self . Hamiltonian_derivative , self . decay_opt , self . gamma , self . control_Hamiltonian , self . control_coefficients , ) return rho , drho","title":"expm()"},{"location":"API/python/classes/#quanestimation.Parameterization.GeneralDynamics.Lindblad.secondorder_derivative","text":"Calculation of the density matrix and its derivatives and the second derivatives on \\(\\textbf{x}\\) . The density matrix at \\(j\\) th time interval is obtained by \\(\\rho_j=e^{\\Delta t\\mathcal{L}}\\rho_{j-1}\\) , where \\(\\Delta t\\) is the time interval and \\(\\rho_{j-1}\\) is the density matrix for the \\((j-1)\\) th time interval. \\(\\partial_{\\textbf{x}}\\rho_j\\) is calculated via \\begin{align} \\partial_{\\textbf{x}}\\rho_j =\\Delta t(\\partial_{\\textbf{x}}\\mathcal{L})\\rho_j +e^{\\Delta t \\mathcal{L}}(\\partial_{\\textbf{x}}\\rho_{j-1}). \\end{align} \\(\\partial_{\\textbf{x}}^2\\rho_j\\) is solved as \\begin{align} \\partial_{\\textbf{x}}^2\\rho_j =\\Delta t(\\partial_{\\textbf{x}}^2\\mathcal{L})\\rho_j +\\Delta t(\\partial_{\\textbf{x}}\\mathcal{L})\\partial_{\\textbf{x}}\\rho_j +\\Delta t(\\partial_{\\textbf{x}}\\mathcal{L})e^{\\Delta t \\mathcal{L}} \\partial_{\\textbf{x}}\\rho_{j-1} +e^{\\Delta t \\mathcal{L}}(\\partial_{\\textbf{x}}^2\\rho_{j-1}). \\end{align}","title":"secondorder_derivative()"},{"location":"API/python/classes/#control-optimization","text":"The Hamiltonian of a controlled system can be written as \\begin{align} H = H_0(\\textbf{x})+\\sum_{k=1}^K u_k(t) H_k, \\end{align} where \\(H_0(\\textbf{x})\\) is the free evolution Hamiltonian with unknown parameters \\(\\textbf{x}\\) and \\(H_k\\) represents the \\(k\\) th control Hamiltonian with \\(u_k\\) the corresponding control coefficient. In QuanEstimation, different algorithms are invoked to update the optimal control coefficients. The control optimization algorithms are gradient ascent pulse engineering (GRAPE), GRAPE algorithm based on the automatic differentiation (auto-GRAPE), particle swarm optimization (PSO), differential evolution (DE) and deep deterministic policy gradients (DDPG).","title":"Control Optimization"},{"location":"API/python/classes/#base","text":"","title":"Base"},{"location":"API/python/classes/#quanestimation.ControlSystem--attributes","text":"savefile: bool -- Whether or not to save all the control coeffients. If set True then the control coefficients and the values of the objective function obtained in all episodes will be saved during the training. If set False the control coefficients in the final episode and the values of the objective function in all episodes will be saved. ctrl0: list of arrays -- Initial guesses of control coefficients. eps: float -- Machine epsilon. load: bool -- Whether or not to load control coefficients in the current location. If set True then the program will load control coefficients from \"controls.csv\" file in the current location and use it as the initial control coefficients. Source code in quanestimation/ControlOpt/ControlStruct.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 class ControlSystem : \"\"\" Attributes ---------- > **savefile:** `bool` -- Whether or not to save all the control coeffients. If set `True` then the control coefficients and the values of the objective function obtained in all episodes will be saved during the training. If set `False` the control coefficients in the final episode and the values of the objective function in all episodes will be saved. > **ctrl0:** `list of arrays` -- Initial guesses of control coefficients. > **eps:** `float` -- Machine epsilon. > **load:** `bool` -- Whether or not to load control coefficients in the current location. If set `True` then the program will load control coefficients from \"controls.csv\" file in the current location and use it as the initial control coefficients. \"\"\" def __init__ ( self , savefile , ctrl0 , eps , load ): self . savefile = savefile self . ctrl0 = ctrl0 self . eps = eps self . load = load def dynamics ( self , tspan , rho0 , H0 , dH , Hc , decay = [], ctrl_bound = []): r \"\"\" The dynamics of a density matrix is of the form \\begin{align} \\partial_t\\rho &=\\mathcal{L}\\rho \\nonumber \\\\ &=-i[H,\\rho]+\\sum_i \\gamma_i\\left(\\Gamma_i\\rho\\Gamma^{\\dagger}_i-\\frac{1}{2} \\left\\{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\right\\}\\right), \\end{align} where $\\rho$ is the evolved density matrix, H is the Hamiltonian of the system, $\\Gamma_i$ and $\\gamma_i$ are the $i\\mathrm{th}$ decay operator and corresponding decay rate. Parameters ---------- > **tspan:** `array` -- Time length for the evolution. > **rho0:** `matrix` -- Initial state (density matrix). > **H0:** `matrix or list` -- Free Hamiltonian. It is a matrix when the free Hamiltonian is time- independent and a list of length equal to `tspan` when it is time-dependent. > **dH:** `list` -- Derivatives of the free Hamiltonian on the unknown parameters to be estimated. For example, dH[0] is the derivative vector on the first parameter. > **Hc:** `list` -- Control Hamiltonians. > **decay:** `list` -- Decay operators and the corresponding decay rates. Its input rule is decay=[[$\\Gamma_1$, $\\gamma_1$], [$\\Gamma_2$,$\\gamma_2$],...], where $\\Gamma_1$ $(\\Gamma_2)$ represents the decay operator and $\\gamma_1$ $(\\gamma_2)$ is the corresponding decay rate. > **ctrl_bound:** `array` -- Lower and upper bounds of the control coefficients. `ctrl_bound[0]` represents the lower bound of the control coefficients and `ctrl_bound[1]` represents the upper bound of the control coefficients. \"\"\" self . tspan = tspan self . rho0 = np . array ( rho0 , dtype = np . complex128 ) if type ( H0 ) == np . ndarray : self . freeHamiltonian = np . array ( H0 , dtype = np . complex128 ) else : self . freeHamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in H0 [: - 1 ]] if Hc == []: Hc = [ np . zeros (( len ( self . rho0 ), len ( self . rho0 )))] self . control_Hamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in Hc ] if type ( dH ) != list : raise TypeError ( \"The derivative of Hamiltonian should be a list!\" ) if dH == []: dH = [ np . zeros (( len ( self . rho0 ), len ( self . rho0 )))] self . Hamiltonian_derivative = [ np . array ( x , dtype = np . complex128 ) for x in dH ] if len ( dH ) == 1 : self . para_type = \"single_para\" else : self . para_type = \"multi_para\" if decay == []: decay_opt = [ np . zeros (( len ( self . rho0 ), len ( self . rho0 )))] self . gamma = [ 0.0 ] else : decay_opt = [ decay [ i ][ 0 ] for i in range ( len ( decay ))] self . gamma = [ decay [ i ][ 1 ] for i in range ( len ( decay ))] self . decay_opt = [ np . array ( x , dtype = np . complex128 ) for x in decay_opt ] if ctrl_bound == []: self . ctrl_bound = [ - np . inf , np . inf ] else : self . ctrl_bound = [ float ( ctrl_bound [ 0 ]), float ( ctrl_bound [ 1 ])] if self . ctrl0 == []: if ctrl_bound == []: ctrl0 = [ 2 * np . random . random ( len ( self . tspan ) - 1 ) - np . ones ( len ( self . tspan ) - 1 ) for i in range ( len ( self . control_Hamiltonian )) ] self . control_coefficients = ctrl0 self . ctrl0 = [ np . array ( ctrl0 )] else : a = ctrl_bound [ 0 ] b = ctrl_bound [ 1 ] ctrl0 = [ ( b - a ) * np . random . random ( len ( self . tspan ) - 1 ) + a * np . ones ( len ( self . tspan ) - 1 ) for i in range ( len ( self . control_Hamiltonian )) ] self . control_coefficients = ctrl0 self . ctrl0 = [ np . array ( ctrl0 )] elif len ( self . ctrl0 ) >= 1 : self . control_coefficients = [ self . ctrl0 [ 0 ][ i ] for i in range ( len ( self . control_Hamiltonian )) ] if self . load == True : if os . path . exists ( \"controls.csv\" ): data = np . genfromtxt ( \"controls.csv\" )[ - len ( self . control_Hamiltonian ) :] self . control_coefficients = [ data [ i ] for i in range ( len ( data ))] ctrl_num = len ( self . control_coefficients ) Hc_num = len ( self . control_Hamiltonian ) if Hc_num < ctrl_num : raise TypeError ( \"There are %d control Hamiltonians but %d coefficients sequences: too many coefficients sequences\" % ( Hc_num , ctrl_num ) ) elif Hc_num > ctrl_num : warnings . warn ( \"Not enough coefficients sequences: there are %d control Hamiltonians but %d coefficients sequences. The rest of the control sequences are set to be 0.\" % ( Hc_num , ctrl_num ), DeprecationWarning , ) for i in range ( Hc_num - ctrl_num ): self . control_coefficients = np . concatenate ( ( self . control_coefficients , np . zeros ( len ( self . control_coefficients [ 0 ])), ) ) else : pass if type ( H0 ) != np . ndarray : #### linear interpolation #### f = interp1d ( self . tspan , H0 , axis = 0 ) else : pass number = math . ceil (( len ( self . tspan ) - 1 ) / len ( self . control_coefficients [ 0 ])) if len ( self . tspan ) - 1 % len ( self . control_coefficients [ 0 ]) != 0 : tnum = number * len ( self . control_coefficients [ 0 ]) self . tspan = np . linspace ( self . tspan [ 0 ], self . tspan [ - 1 ], tnum + 1 ) if type ( H0 ) != np . ndarray : H0_inter = f ( self . tspan ) self . freeHamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in H0_inter [: - 1 ]] else : pass else : pass self . opt = Main . QuanEstimation . ControlOpt ( ctrl = self . control_coefficients , ctrl_bound = self . ctrl_bound , seed = self . seed ) self . dynamic = Main . QuanEstimation . Lindblad ( self . freeHamiltonian , self . Hamiltonian_derivative , self . control_Hamiltonian , self . control_coefficients , self . rho0 , self . tspan , self . decay_opt , self . gamma , ) self . output = Main . QuanEstimation . Output ( self . opt , save = self . savefile ) self . dynamics_type = \"lindblad\" def QFIM ( self , W = [], LDtype = \"SLD\" ): r \"\"\" Choose QFI or $\\mathrm{Tr}(WF^{-1})$ as the objective function. In single parameter estimation the objective function is QFI and in multiparameter estimation it will be $\\mathrm{Tr}(WF^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). \"\"\" if LDtype != \"SLD\" and LDtype != \"RLD\" and LDtype != \"LLD\" : raise ValueError ( \" {!r} is not a valid value for LDtype, supported values are 'SLD', 'RLD' and 'LLD'.\" . format ( LDtype ) ) if W == []: W = np . eye ( len ( self . Hamiltonian_derivative )) self . W = W self . obj = Main . QuanEstimation . QFIM_obj ( self . W , self . eps , self . para_type , LDtype ) system = Main . QuanEstimation . QuanEstSystem ( self . opt , self . alg , self . obj , self . dynamic , self . output ) Main . QuanEstimation . run ( system ) def CFIM ( self , M = [], W = []): r \"\"\" Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **M:** `list` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" if M == []: M = SIC ( len ( self . rho0 )) M = [ np . array ( x , dtype = np . complex128 ) for x in M ] if W == []: W = np . eye ( len ( self . Hamiltonian_derivative )) self . W = W self . obj = Main . QuanEstimation . CFIM_obj ( M , self . W , self . eps , self . para_type ) system = Main . QuanEstimation . QuanEstSystem ( self . opt , self . alg , self . obj , self . dynamic , self . output ) Main . QuanEstimation . run ( system ) def HCRB ( self , W = []): \"\"\" Choose HCRB as the objective function. **Notes:** (1) In single parameter estimation, HCRB is equivalent to QFI, please choose QFI as the objective function. (2) GRAPE and auto-GRAPE are not available when the objective function is HCRB. Supported methods are PSO, DE and DDPG. Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" if W == []: W = np . eye ( len ( self . Hamiltonian_derivative )) self . W = W if len ( self . Hamiltonian_derivative ) == 1 : print ( \"Program terminated. In the single-parameter scenario, HCRB is equivalent to QFI. Please choose QFIM as the objective function.\" ) else : if W == []: W = np . eye ( len ( self . Hamiltonian_derivative )) self . W = W self . obj = Main . QuanEstimation . HCRB_obj ( self . W , self . eps , self . para_type ) system = Main . QuanEstimation . QuanEstSystem ( self . opt , self . alg , self . obj , self . dynamic , self . output ) Main . QuanEstimation . run ( system ) def mintime ( self , f , W = [], M = [], method = \"binary\" , target = \"QFIM\" , LDtype = \"SLD\" ): \"\"\" Search of the minimum time to reach a given value of the objective function. Parameters ---------- > **f:** `float` -- The given value of the objective function. > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). > **method:** `string` -- Methods for searching the minimum time to reach the given value of the objective function. Options are: \"binary\" (default) -- Binary search (logarithmic search). \"forward\" -- Forward search from the beginning of time. > **target:** `string` -- Objective functions for searching the minimum time to reach the given value of the objective function. Options are: \"QFIM\" (default) -- Choose QFI (QFIM) as the objective function. \"CFIM\" -- Choose CFI (CFIM) as the objective function. \"HCRB\" -- Choose HCRB as the objective function. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). \"\"\" if not ( method == \"binary\" or method == \"forward\" ): raise ValueError ( \" {!r} is not a valid value for method, supported values are 'binary' and 'forward'.\" . format ( method ) ) if self . dynamics_type != \"lindblad\" : raise ValueError ( \"Supported type of dynamics is Lindblad.\" ) if self . savefile == True : warnings . warn ( \"savefile is set to be False\" , DeprecationWarning , ) self . output = Main . QuanEstimation . Output ( self . opt ) if len ( self . Hamiltonian_derivative ) > 1 : f = 1 / f if W == []: W = np . eye ( len ( self . Hamiltonian_derivative )) self . W = W if M != []: M = [ np . array ( x , dtype = np . complex128 ) for x in M ] self . obj = Main . QuanEstimation . CFIM_obj ( M , self . W , self . eps , self . para_type ) else : if target == \"HCRB\" : if self . para_type == \"single_para\" : print ( \"Program terminated. In the single-parameter scenario, the HCRB is equivalent to the QFI. Please choose 'QFIM' as the objective function.\" ) self . obj = Main . QuanEstimation . HCRB_obj ( self . W , self . eps , self . para_type ) elif target == \"QFIM\" or ( LDtype == \"SLD\" and LDtype == \"LLD\" and LDtype == \"RLD\" ): self . obj = Main . QuanEstimation . QFIM_obj ( self . W , self . eps , self . para_type , LDtype ) else : raise ValueError ( \"Please enter the correct values for target and LDtype. Supported target are 'QFIM', 'CFIM' and 'HCRB', supported LDtype are 'SLD', 'RLD' and 'LLD'.\" ) system = Main . QuanEstimation . QuanEstSystem ( self . opt , self . alg , self . obj , self . dynamic , self . output ) Main . QuanEstimation . mintime ( method , f , system )","title":"Attributes"},{"location":"API/python/classes/#quanestimation.ControlOpt.ControlStruct.ControlSystem.CFIM","text":"Choose CFI or \\(\\mathrm{Tr}(WI^{-1})\\) as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be \\(\\mathrm{Tr}(WI^{-1})\\) .","title":"CFIM()"},{"location":"API/python/classes/#quanestimation.ControlOpt.ControlStruct.ControlSystem.HCRB","text":"Choose HCRB as the objective function. Notes: (1) In single parameter estimation, HCRB is equivalent to QFI, please choose QFI as the objective function. (2) GRAPE and auto-GRAPE are not available when the objective function is HCRB. Supported methods are PSO, DE and DDPG.","title":"HCRB()"},{"location":"API/python/classes/#quanestimation.ControlOpt.ControlStruct.ControlSystem.QFIM","text":"Choose QFI or \\(\\mathrm{Tr}(WF^{-1})\\) as the objective function. In single parameter estimation the objective function is QFI and in multiparameter estimation it will be \\(\\mathrm{Tr}(WF^{-1})\\) .","title":"QFIM()"},{"location":"API/python/classes/#quanestimation.ControlOpt.ControlStruct.ControlSystem.dynamics","text":"The dynamics of a density matrix is of the form \\[\\begin{align} \\partial_t\\rho &=\\mathcal{L}\\rho \\nonumber \\\\ &=-i[H,\\rho]+\\sum_i \\gamma_i\\left(\\Gamma_i\\rho\\Gamma^{\\dagger}_i-\\frac{1}{2} \\left\\{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\right\\}\\right), \\end{align}\\] where \\(\\rho\\) is the evolved density matrix, H is the Hamiltonian of the system, \\(\\Gamma_i\\) and \\(\\gamma_i\\) are the \\(i\\mathrm{th}\\) decay operator and corresponding decay rate.","title":"dynamics()"},{"location":"API/python/classes/#quanestimation.ControlOpt.ControlStruct.ControlSystem.mintime","text":"Search of the minimum time to reach a given value of the objective function.","title":"mintime()"},{"location":"API/python/classes/#control-optimization-with-grape-and-auto-grape","text":"Bases: Control . ControlSystem","title":"Control optimization with GRAPE and auto-GRAPE"},{"location":"API/python/classes/#quanestimation.GRAPE_Copt--attributes","text":"savefile: bool -- Whether or not to save all the control coeffients. If set True then the control coefficients and the values of the objective function obtained in all episodes will be saved during the training. If set False the control coefficients in the final episode and the values of the objective function in all episodes will be saved. Adam: bool -- Whether or not to use Adam for updating control coefficients. ctrl0: list of arrays -- Initial guesses of control coefficients. max_episode: int -- The number of episodes. epsilon: float -- Learning rate. beta1: float -- The exponential decay rate for the first moment estimates. beta2: float -- The exponential decay rate for the second moment estimates. eps: float -- Machine epsilon. load: bool -- Whether or not to load control coefficients in the current location. If set True then the program will load control coefficients from \"controls.csv\" file in the current location and use it as the initial control coefficients. auto: bool -- Whether or not to invoke automatic differentiation algorithm to evaluate the gradient. If set True then the gradient will be calculated with automatic differentiation algorithm otherwise it will be calculated using analytical method. Source code in quanestimation/ControlOpt/GRAPE_Copt.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 class GRAPE_Copt ( Control . ControlSystem ): \"\"\" Attributes ---------- > **savefile:** `bool` -- Whether or not to save all the control coeffients. If set `True` then the control coefficients and the values of the objective function obtained in all episodes will be saved during the training. If set `False` the control coefficients in the final episode and the values of the objective function in all episodes will be saved. > **Adam:** `bool` -- Whether or not to use Adam for updating control coefficients. > **ctrl0:** `list of arrays` -- Initial guesses of control coefficients. > **max_episode:** `int` -- The number of episodes. > **epsilon:** `float` -- Learning rate. > **beta1:** `float` -- The exponential decay rate for the first moment estimates. > **beta2:** `float` -- The exponential decay rate for the second moment estimates. > **eps:** `float` -- Machine epsilon. > **load:** `bool` -- Whether or not to load control coefficients in the current location. If set `True` then the program will load control coefficients from \"controls.csv\" file in the current location and use it as the initial control coefficients. > **auto:** `bool` -- Whether or not to invoke automatic differentiation algorithm to evaluate the gradient. If set `True` then the gradient will be calculated with automatic differentiation algorithm otherwise it will be calculated using analytical method. \"\"\" def __init__ ( self , savefile = False , Adam = True , ctrl0 = [], max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 , eps = 1e-8 , seed = 1234 , load = False , auto = True , ): Control . ControlSystem . __init__ ( self , savefile , ctrl0 , eps , load ) self . Adam = Adam self . max_episode = max_episode self . epsilon = epsilon self . beta1 = beta1 self . beta2 = beta2 self . mt = 0.0 self . vt = 0.0 self . seed = seed self . auto = auto def QFIM ( self , W = [], LDtype = \"SLD\" ): r \"\"\" Choose QFI or $\\mathrm{Tr}(WF^{-1})$ as the objective function. In single parameter estimation the objective function is QFI and in multiparameter estimation it will be $\\mathrm{Tr}(WF^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). \"\"\" if self . auto : if self . Adam : self . alg = Main . QuanEstimation . autoGRAPE ( self . max_episode , self . epsilon , self . beta1 , self . beta2 ) else : self . alg = Main . QuanEstimation . autoGRAPE ( self . max_episode , self . epsilon ) else : if ( len ( self . tspan ) - 1 ) != len ( self . control_coefficients [ 0 ]): warnings . warn ( \"GRAPE is not available when the length of each control is not \\ equal to the length of time, and is replaced by auto-GRAPE.\" , DeprecationWarning ) #### call autoGRAPE automatically #### if self . Adam : self . alg = Main . QuanEstimation . autoGRAPE ( self . max_episode , self . epsilon , self . beta1 , self . beta2 ) else : self . alg = Main . QuanEstimation . autoGRAPE ( self . max_episode , self . epsilon ) else : if LDtype == \"SLD\" : if self . Adam : self . alg = Main . QuanEstimation . GRAPE ( self . max_episode , self . epsilon , self . beta1 , self . beta2 ) else : self . alg = Main . QuanEstimation . GRAPE ( self . max_episode , self . epsilon ) else : raise ValueError ( \"GRAPE is only available when LDtype is SLD.\" ) super () . QFIM ( W , LDtype ) def CFIM ( self , M = [], W = []): r \"\"\" Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" if self . auto : if self . Adam : self . alg = Main . QuanEstimation . autoGRAPE ( self . max_episode , self . epsilon , self . beta1 , self . beta2 ) else : self . alg = Main . QuanEstimation . autoGRAPE ( self . max_episode , self . epsilon ) else : if ( len ( self . tspan ) - 1 ) != len ( self . control_coefficients [ 0 ]): warnings . warn ( \"GRAPE is not available when the length of each control is not \\ equal to the length of time, and is replaced by auto-GRAPE.\" , DeprecationWarning ) #### call autoGRAPE automatically #### if self . Adam : self . alg = Main . QuanEstimation . autoGRAPE ( self . max_episode , self . epsilon , self . beta1 , self . beta2 ) else : self . alg = Main . QuanEstimation . autoGRAPE ( self . max_episode , self . epsilon ) else : if self . Adam : self . alg = Main . QuanEstimation . GRAPE ( self . max_episode , self . epsilon , self . beta1 , self . beta2 ) else : self . alg = Main . QuanEstimation . GRAPE ( self . max_episode , self . epsilon ) super () . CFIM ( M , W ) def HCRB ( self , W = []): \"\"\" GRAPE and auto-GRAPE are not available when the objective function is HCRB. Supported methods are PSO, DE and DDPG. Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" raise ValueError ( \"GRAPE and auto-GRAPE are not available when the objective function is HCRB. Supported methods are 'PSO', 'DE' and 'DDPG'.\" , ) def mintime ( self , f , W = [], M = [], method = \"binary\" , target = \"QFIM\" , LDtype = \"SLD\" ): \"\"\" Search of the minimum time to reach a given value of the objective function. Parameters ---------- > **f:** `float` -- The given value of the objective function. > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). > **method:** `string` -- Methods for searching the minimum time to reach the given value of the objective function. Options are: \"binary\" (default) -- Binary search (logarithmic search). \"forward\" -- Forward search from the beginning of time. > **target:** `string` -- Objective functions for searching the minimum time to reach the given value of the objective function. Options are: \"QFIM\" (default) -- Choose QFI (QFIM) as the objective function. \"CFIM\" -- Choose CFI (CFIM) as the objective function. \"HCRB\" -- Choose HCRB as the objective function. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" if target == \"HCRB\" : raise ValueError ( \"GRAPE and auto-GRAPE are not available when the objective function is HCRB. Supported methods are 'PSO', 'DE' and 'DDPG'.\" , ) if self . auto : if self . Adam : self . alg = Main . QuanEstimation . autoGRAPE ( self . max_episode , self . epsilon , self . beta1 , self . beta2 ) else : self . alg = Main . QuanEstimation . autoGRAPE ( self . max_episode , self . epsilon ) else : if self . Adam : self . alg = Main . QuanEstimation . GRAPE ( self . max_episode , self . epsilon , self . beta1 , self . beta2 ) else : self . alg = Main . QuanEstimation . GRAPE ( self . max_episode , self . epsilon ) super () . mintime ( f , W , M , method , target , LDtype )","title":"Attributes"},{"location":"API/python/classes/#quanestimation.ControlOpt.GRAPE_Copt.GRAPE_Copt.CFIM","text":"Choose CFI or \\(\\mathrm{Tr}(WI^{-1})\\) as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be \\(\\mathrm{Tr}(WI^{-1})\\) .","title":"CFIM()"},{"location":"API/python/classes/#quanestimation.ControlOpt.GRAPE_Copt.GRAPE_Copt.HCRB","text":"GRAPE and auto-GRAPE are not available when the objective function is HCRB. Supported methods are PSO, DE and DDPG.","title":"HCRB()"},{"location":"API/python/classes/#quanestimation.ControlOpt.GRAPE_Copt.GRAPE_Copt.QFIM","text":"Choose QFI or \\(\\mathrm{Tr}(WF^{-1})\\) as the objective function. In single parameter estimation the objective function is QFI and in multiparameter estimation it will be \\(\\mathrm{Tr}(WF^{-1})\\) .","title":"QFIM()"},{"location":"API/python/classes/#quanestimation.ControlOpt.GRAPE_Copt.GRAPE_Copt.mintime","text":"Search of the minimum time to reach a given value of the objective function.","title":"mintime()"},{"location":"API/python/classes/#control-optimization-with-pso","text":"Bases: Control . ControlSystem","title":"Control Optimization with PSO"},{"location":"API/python/classes/#quanestimation.PSO_Copt--attributes","text":"savefile: bool -- Whether or not to save all the control coeffients. If set True then the control coefficients and the values of the objective function obtained in all episodes will be saved during the training. If set False the control coefficients in the final episode and the values of the objective function in all episodes will be saved. p_num: int -- The number of particles. ctrl0: list of arrays -- Initial guesses of control coefficients. max_episode: int or list -- If it is an integer, for example max_episode=1000, it means the program will continuously run 1000 episodes. However, if it is an array, for example max_episode=[1000,100], the program will run 1000 episodes in total but replace control coefficients of all the particles with global best every 100 episodes. c0: float -- The damping factor that assists convergence, also known as inertia weight. c1: float -- The exploitation weight that attracts the particle to its best previous position, also known as cognitive learning factor. c2: float -- The exploitation weight that attracts the particle to the best position in the neighborhood, also known as social learning factor. seed: int -- Random seed. eps: float -- Machine epsilon. load: bool -- Whether or not to load control coefficients in the current location. If set True then the program will load control coefficients from \"controls.csv\" file in the current location and use it as the initial control coefficients. Source code in quanestimation/ControlOpt/PSO_Copt.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 class PSO_Copt ( Control . ControlSystem ): \"\"\" Attributes ---------- > **savefile:** `bool` -- Whether or not to save all the control coeffients. If set `True` then the control coefficients and the values of the objective function obtained in all episodes will be saved during the training. If set `False` the control coefficients in the final episode and the values of the objective function in all episodes will be saved. > **p_num:** `int` -- The number of particles. > **ctrl0:** `list of arrays` -- Initial guesses of control coefficients. > **max_episode:** `int or list` -- If it is an integer, for example max_episode=1000, it means the program will continuously run 1000 episodes. However, if it is an array, for example max_episode=[1000,100], the program will run 1000 episodes in total but replace control coefficients of all the particles with global best every 100 episodes. > **c0:** `float` -- The damping factor that assists convergence, also known as inertia weight. > **c1:** `float` -- The exploitation weight that attracts the particle to its best previous position, also known as cognitive learning factor. > **c2:** `float` -- The exploitation weight that attracts the particle to the best position in the neighborhood, also known as social learning factor. > **seed:** `int` -- Random seed. > **eps:** `float` -- Machine epsilon. > **load:** `bool` -- Whether or not to load control coefficients in the current location. If set `True` then the program will load control coefficients from \"controls.csv\" file in the current location and use it as the initial control coefficients. \"\"\" def __init__ ( self , savefile = False , p_num = 10 , ctrl0 = [], max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 , seed = 1234 , eps = 1e-8 , load = False , ): Control . ControlSystem . __init__ ( self , savefile , ctrl0 , eps , load ) self . max_episode = max_episode self . p_num = p_num self . c0 = c0 self . c1 = c1 self . c2 = c2 self . seed = seed def QFIM ( self , W = [], LDtype = \"SLD\" ): r \"\"\" Choose QFI or $\\mathrm{Tr}(WF^{-1})$ as the objective function. In single parameter estimation the objective function is QFI and in multiparameter estimation it will be $\\mathrm{Tr}(WF^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). \"\"\" ini_particle = ([ self . ctrl0 ],) self . alg = Main . QuanEstimation . PSO ( self . max_episode , self . p_num , ini_particle , self . c0 , self . c1 , self . c2 , ) super () . QFIM ( W , LDtype ) def CFIM ( self , M = [], W = []): r \"\"\" Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" ini_particle = ([ self . ctrl0 ],) self . alg = Main . QuanEstimation . PSO ( self . max_episode , self . p_num , ini_particle , self . c0 , self . c1 , self . c2 , ) super () . CFIM ( M , W ) def HCRB ( self , W = []): \"\"\" Choose HCRB as the objective function. **Note:** in single parameter estimation, HCRB is equivalent to QFI, please choose QFI as the objective function. Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" ini_particle = ([ self . ctrl0 ],) self . alg = Main . QuanEstimation . PSO ( self . max_episode , self . p_num , ini_particle , self . c0 , self . c1 , self . c2 , ) super () . HCRB ( W ) def mintime ( self , f , W = [], M = [], method = \"binary\" , target = \"QFIM\" , LDtype = \"SLD\" ): \"\"\" Search of the minimum time to reach a given value of the objective function. Parameters ---------- > **f:** `float` -- The given value of the objective function. > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). > **method:** `string` -- Methods for searching the minimum time to reach the given value of the objective function. Options are: \"binary\" (default) -- Binary search (logarithmic search). \"forward\" -- Forward search from the beginning of time. > **target:** `string` -- Objective functions for searching the minimum time to reach the given value of the objective function. Options are: \"QFIM\" (default) -- Choose QFI (QFIM) as the objective function. \"CFIM\" -- Choose CFI (CFIM) as the objective function. \"HCRB\" -- Choose HCRB as the objective function. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" ini_particle = ([ self . ctrl0 ],) self . alg = Main . QuanEstimation . PSO ( self . max_episode , self . p_num , ini_particle , self . c0 , self . c1 , self . c2 , ) super () . mintime ( f , W , M , method , target , LDtype )","title":"Attributes"},{"location":"API/python/classes/#quanestimation.ControlOpt.PSO_Copt.PSO_Copt.CFIM","text":"Choose CFI or \\(\\mathrm{Tr}(WI^{-1})\\) as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be \\(\\mathrm{Tr}(WI^{-1})\\) .","title":"CFIM()"},{"location":"API/python/classes/#quanestimation.ControlOpt.PSO_Copt.PSO_Copt.HCRB","text":"Choose HCRB as the objective function. Note: in single parameter estimation, HCRB is equivalent to QFI, please choose QFI as the objective function.","title":"HCRB()"},{"location":"API/python/classes/#quanestimation.ControlOpt.PSO_Copt.PSO_Copt.QFIM","text":"Choose QFI or \\(\\mathrm{Tr}(WF^{-1})\\) as the objective function. In single parameter estimation the objective function is QFI and in multiparameter estimation it will be \\(\\mathrm{Tr}(WF^{-1})\\) .","title":"QFIM()"},{"location":"API/python/classes/#quanestimation.ControlOpt.PSO_Copt.PSO_Copt.mintime","text":"Search of the minimum time to reach a given value of the objective function.","title":"mintime()"},{"location":"API/python/classes/#control-optimization-de","text":"Bases: Control . ControlSystem","title":"Control Optimization DE"},{"location":"API/python/classes/#quanestimation.DE_Copt--attributes","text":"savefile: bool --Whether or not to save all the control coeffients. If set True then the control coefficients and the values of the objective function obtained in all episodes will be saved during the training. If set False the control coefficients in the final episode and the values of the objective function in all episodes will be saved. p_num: int -- The number of populations. ctrl0: list of arrays -- Initial guesses of control coefficients. max_episode: int -- The number of episodes. c: float -- Mutation constant. cr: float -- Crossover constant. seed: int -- Random seed. eps: float -- Machine epsilon. load: bool -- Whether or not to load control coefficients in the current location. If set True then the program will load control coefficients from \"controls.csv\" file in the current location and use it as the initial control coefficients. Source code in quanestimation/ControlOpt/DE_Copt.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 class DE_Copt ( Control . ControlSystem ): \"\"\" Attributes ---------- > **savefile:** `bool` --Whether or not to save all the control coeffients. If set `True` then the control coefficients and the values of the objective function obtained in all episodes will be saved during the training. If set `False` the control coefficients in the final episode and the values of the objective function in all episodes will be saved. > **p_num:** `int` -- The number of populations. > **ctrl0:** list of arrays -- Initial guesses of control coefficients. > **max_episode:** `int` -- The number of episodes. > **c:** `float` -- Mutation constant. > **cr:** `float` -- Crossover constant. > **seed:** `int` -- Random seed. > **eps:** `float` -- Machine epsilon. > **load:** `bool` -- Whether or not to load control coefficients in the current location. If set `True` then the program will load control coefficients from \"controls.csv\" file in the current location and use it as the initial control coefficients. \"\"\" def __init__ ( self , savefile = False , p_num = 10 , ctrl0 = [], max_episode = 1000 , c = 1.0 , cr = 0.5 , seed = 1234 , eps = 1e-8 , load = False , ): Control . ControlSystem . __init__ ( self , savefile , ctrl0 , eps , load ) self . p_num = p_num self . max_episode = max_episode self . c = c self . cr = cr self . seed = seed def QFIM ( self , W = [], LDtype = \"SLD\" ): r \"\"\" Choose QFI or $\\mathrm{Tr}(WF^{-1})$ as the objective function. In single parameter estimation the objective function is QFI and in multiparameter estimation it will be $\\mathrm{Tr}(WF^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). \"\"\" ini_population = ([ self . ctrl0 ],) self . alg = Main . QuanEstimation . DE ( self . max_episode , self . p_num , ini_population , self . c , self . cr , ) super () . QFIM ( W , LDtype ) def CFIM ( self , M = [], W = []): r \"\"\" Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" ini_population = ([ self . ctrl0 ],) self . alg = Main . QuanEstimation . DE ( self . max_episode , self . p_num , ini_population , self . c , self . cr , ) super () . CFIM ( M , W ) def HCRB ( self , W = []): \"\"\" Choose HCRB as the objective function. **Note:** in single parameter estimation, HCRB is equivalent to QFI, please choose QFI as the objective function. Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" ini_population = ([ self . ctrl0 ],) self . alg = Main . QuanEstimation . DE ( self . max_episode , self . p_num , ini_population , self . c , self . cr , ) super () . HCRB ( W ) def mintime ( self , f , W = [], M = [], method = \"binary\" , target = \"QFIM\" , LDtype = \"SLD\" ): \"\"\" Search of the minimum time to reach a given value of the objective function. Parameters ---------- > **f:** `float` -- The given value of the objective function. > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). > **method:** `string` -- Methods for searching the minimum time to reach the given value of the objective function. Options are: \"binary\" (default) -- Binary search (logarithmic search). \"forward\" -- Forward search from the beginning of time. > **target:** `string` -- Objective functions for searching the minimum time to reach the given value of the objective function. Options are:<br> \"QFIM\" (default) -- Choose QFI (QFIM) as the objective function.<br> \"CFIM\" -- Choose CFI (CFIM) as the objective function.<br> \"HCRB\" -- Choose HCRB as the objective function. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" ini_population = ([ self . ctrl0 ],) self . alg = Main . QuanEstimation . DE ( self . max_episode , self . p_num , ini_population , self . c , self . cr , ) super () . mintime ( f , W , M , method , target , LDtype )","title":"Attributes"},{"location":"API/python/classes/#quanestimation.ControlOpt.DE_Copt.DE_Copt.CFIM","text":"Choose CFI or \\(\\mathrm{Tr}(WI^{-1})\\) as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be \\(\\mathrm{Tr}(WI^{-1})\\) .","title":"CFIM()"},{"location":"API/python/classes/#quanestimation.ControlOpt.DE_Copt.DE_Copt.HCRB","text":"Choose HCRB as the objective function. Note: in single parameter estimation, HCRB is equivalent to QFI, please choose QFI as the objective function.","title":"HCRB()"},{"location":"API/python/classes/#quanestimation.ControlOpt.DE_Copt.DE_Copt.QFIM","text":"Choose QFI or \\(\\mathrm{Tr}(WF^{-1})\\) as the objective function. In single parameter estimation the objective function is QFI and in multiparameter estimation it will be \\(\\mathrm{Tr}(WF^{-1})\\) .","title":"QFIM()"},{"location":"API/python/classes/#quanestimation.ControlOpt.DE_Copt.DE_Copt.mintime","text":"Search of the minimum time to reach a given value of the objective function.","title":"mintime()"},{"location":"API/python/classes/#control-optimization-with-ddpg","text":"Bases: Control . ControlSystem","title":"Control Optimization with DDPG"},{"location":"API/python/classes/#quanestimation.DDPG_Copt--attributes","text":"savefile: bool -- Whether or not to save all the control coeffients. If set True then the control coefficients and the values of the objective function obtained in all episodes will be saved during the training. If set False the control coefficients in the final episode and the values of the objective function in all episodes will be saved. ctrl0: list of arrays -- Initial guesses of control coefficients. max_episode: int -- The number of episodes. layer_num: int -- The number of layers (include the input and output layer). layer_dim: int -- The number of neurons in the hidden layer. seed: int -- Random seed. eps: float -- Machine epsilon. load: bool -- Whether or not to load control coefficients in the current location. If set True then the program will load control coefficients from \"controls.csv\" file in the current location and use it as the initial control coefficients. Source code in quanestimation/ControlOpt/DDPG_Copt.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 class DDPG_Copt ( Control . ControlSystem ): \"\"\" Attributes ---------- > **savefile:** `bool` -- Whether or not to save all the control coeffients. If set `True` then the control coefficients and the values of the objective function obtained in all episodes will be saved during the training. If set `False` the control coefficients in the final episode and the values of the objective function in all episodes will be saved. > **ctrl0:** `list of arrays` -- Initial guesses of control coefficients. > **max_episode:** `int` -- The number of episodes. > **layer_num:** `int` -- The number of layers (include the input and output layer). > **layer_dim:** `int` -- The number of neurons in the hidden layer. > **seed:** `int` -- Random seed. > **eps:** `float` -- Machine epsilon. > **load:** `bool` -- Whether or not to load control coefficients in the current location. If set `True` then the program will load control coefficients from \"controls.csv\" file in the current location and use it as the initial control coefficients. \"\"\" def __init__ ( self , savefile = False , ctrl0 = [], max_episode = 500 , layer_num = 3 , layer_dim = 200 , seed = 1234 , eps = 1e-8 , load = False , ): Control . ControlSystem . __init__ ( self , savefile , ctrl0 , eps , load ) self . max_episode = max_episode self . layer_num = layer_num self . layer_dim = layer_dim self . seed = seed self . alg = Main . QuanEstimation . DDPG ( self . max_episode , self . layer_num , self . layer_dim , self . seed ) def QFIM ( self , W = [], LDtype = \"SLD\" ): r \"\"\" Choose QFI or $\\mathrm{Tr}(WF^{-1})$ as the objective function. In single parameter estimation the objective function is QFI and in multiparameter estimation it will be $\\mathrm{Tr}(WF^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). \"\"\" super () . QFIM ( W , LDtype ) def CFIM ( self , M = [], W = []): r \"\"\" Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" super () . CFIM ( M , W ) def HCRB ( self , W = []): \"\"\" Choose HCRB as the objective function. **Note:** in single parameter estimation, HCRB is equivalent to QFI, please choose QFI as the objective function. Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" super () . HCRB ( W ) def mintime ( self , f , W = [], M = [], method = \"binary\" , target = \"QFIM\" , LDtype = \"SLD\" ): \"\"\" Search of the minimum time to reach a given value of the objective function. Parameters ---------- > **f:** `float` -- The given value of the objective function. > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). > **method:** `string` -- Methods for searching the minimum time to reach the given value of the objective function. Options are: \"binary\" (default) -- Binary search (logarithmic search). \"forward\" -- Forward search from the beginning of time. > **target:** `string` -- Objective functions for searching the minimum time to reach the given value of the objective function. Options are: \"QFIM\" (default) -- Choose QFI (QFIM) as the objective function. \"CFIM\" -- Choose CFI (CFIM) as the objective function. \"HCRB\" -- Choose HCRB as the objective function. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" super () . mintime ( f , W , M , method , target , LDtype )","title":"Attributes"},{"location":"API/python/classes/#quanestimation.ControlOpt.DDPG_Copt.DDPG_Copt.CFIM","text":"Choose CFI or \\(\\mathrm{Tr}(WI^{-1})\\) as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be \\(\\mathrm{Tr}(WI^{-1})\\) .","title":"CFIM()"},{"location":"API/python/classes/#quanestimation.ControlOpt.DDPG_Copt.DDPG_Copt.HCRB","text":"Choose HCRB as the objective function. Note: in single parameter estimation, HCRB is equivalent to QFI, please choose QFI as the objective function.","title":"HCRB()"},{"location":"API/python/classes/#quanestimation.ControlOpt.DDPG_Copt.DDPG_Copt.QFIM","text":"Choose QFI or \\(\\mathrm{Tr}(WF^{-1})\\) as the objective function. In single parameter estimation the objective function is QFI and in multiparameter estimation it will be \\(\\mathrm{Tr}(WF^{-1})\\) .","title":"QFIM()"},{"location":"API/python/classes/#quanestimation.ControlOpt.DDPG_Copt.DDPG_Copt.mintime","text":"Search of the minimum time to reach a given value of the objective function.","title":"mintime()"},{"location":"API/python/classes/#state-optimization","text":"The probe state is expanded as \\(|\\psi\\rangle=\\sum_i c_i|i\\rangle\\) in a specific basis, i.e., \\(\\{|i\\rangle\\}\\) . In state optimization, the search of the optimal probe states is equal to search of the normalized complex coefficients \\(\\{c_i\\}\\) . In QuanEstimation, the state optimization algorithms are automatic differentiation (AD), reverse iterative (RI) algorithm, particle swarm optimization (PSO), differential evolution (DE), deep deterministic policy gradients (DDPG) and Nelder-Mead (NM).","title":"State Optimization"},{"location":"API/python/classes/#base_1","text":"","title":"Base"},{"location":"API/python/classes/#quanestimation.StateSystem--attributes","text":"savefile: bool -- Whether or not to save all the states. If set True then the states and the values of the objective function obtained in all episodes will be saved during the training. If set False the state in the final episode and the values of the objective function in all episodes will be saved. psi0: list of arrays -- Initial guesses of states. seed: int -- Random seed. eps: float -- Machine epsilon. load: bool -- Whether or not to load states in the current location. If set True then the program will load state from \"states.csv\" file in the current location and use it as the initial state. Source code in quanestimation/StateOpt/StateStruct.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 class StateSystem : \"\"\" Attributes ---------- > **savefile:** `bool` -- Whether or not to save all the states. If set `True` then the states and the values of the objective function obtained in all episodes will be saved during the training. If set `False` the state in the final episode and the values of the objective function in all episodes will be saved. > **psi0:** `list of arrays` -- Initial guesses of states. > **seed:** `int` -- Random seed. > **eps:** `float` -- Machine epsilon. > **load:** `bool` -- Whether or not to load states in the current location. If set `True` then the program will load state from \"states.csv\" file in the current location and use it as the initial state. \"\"\" def __init__ ( self , savefile , psi0 , seed , eps , load ): self . savefile = savefile self . psi0 = psi0 self . psi = psi0 self . eps = eps self . seed = seed if load == True : if os . path . exists ( \"states.csv\" ): self . psi0 = np . genfromtxt ( \"states.csv\" , dtype = np . complex128 ) def load_save ( self ): if os . path . exists ( \"states.csv\" ): file_load = open ( \"states.csv\" , \"r\" ) file_load = \"\" . join ([ i for i in file_load ]) . replace ( \"im\" , \"j\" ) file_load = \"\" . join ([ i for i in file_load ]) . replace ( \" \" , \"\" ) file_save = open ( \"states.csv\" , \"w\" ) file_save . writelines ( file_load ) file_save . close () else : pass def dynamics ( self , tspan , H0 , dH , Hc = [], ctrl = [], decay = []): r \"\"\" The dynamics of a density matrix is of the form \\begin{align} \\partial_t\\rho &=\\mathcal{L}\\rho \\nonumber \\\\ &=-i[H,\\rho]+\\sum_i \\gamma_i\\left(\\Gamma_i\\rho\\Gamma^{\\dagger}_i-\\frac{1}{2} \\left\\{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\right\\}\\right), \\end{align} where $\\rho$ is the evolved density matrix, H is the Hamiltonian of the system, $\\Gamma_i$ and $\\gamma_i$ are the $i\\mathrm{th}$ decay operator and corresponding decay rate. Parameters ---------- > **tspan:** `array` -- Time length for the evolution. > **H0:** `matrix or list` -- Free Hamiltonian. It is a matrix when the free Hamiltonian is time- independent and a list of length equal to `tspan` when it is time-dependent. > **dH:** `list` -- Derivatives of the free Hamiltonian on the unknown parameters to be estimated. For example, dH[0] is the derivative vector on the first parameter. > **Hc:** `list` -- Control Hamiltonians. > **ctrl:** `list of arrays` -- Control coefficients. > **decay:** `list` -- Decay operators and the corresponding decay rates. Its input rule is decay=[[$\\Gamma_1$, $\\gamma_1$], [$\\Gamma_2$,$\\gamma_2$],...], where $\\Gamma_1$ $(\\Gamma_2)$ represents the decay operator and $\\gamma_1$ $(\\gamma_2)$ is the corresponding decay rate. \"\"\" self . tspan = tspan if Hc == [] or ctrl == []: if type ( H0 ) == np . ndarray : self . freeHamiltonian = np . array ( H0 , dtype = np . complex128 ) self . dim = len ( self . freeHamiltonian ) else : self . freeHamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in H0 ] self . dim = len ( self . freeHamiltonian [ 0 ]) else : ctrl_num = len ( ctrl ) Hc_num = len ( Hc ) if Hc_num < ctrl_num : raise TypeError ( \"There are %d control Hamiltonians but %d coefficients sequences: \\ too many coefficients sequences.\" % ( Hc_num , ctrl_num ) ) elif Hc_num > ctrl_num : warnings . warn ( \"Not enough coefficients sequences: there are %d control Hamiltonians \\ but %d coefficients sequences. The rest of the control sequences are \\ set to be 0.\" % ( Hc_num , ctrl_num ), DeprecationWarning , ) for i in range ( Hc_num - ctrl_num ): ctrl = np . concatenate (( ctrl , np . zeros ( len ( ctrl [ 0 ])))) else : pass if len ( ctrl [ 0 ]) == 1 : if type ( H0 ) == np . ndarray : H0 = np . array ( H0 , dtype = np . complex128 ) Hc = [ np . array ( x , dtype = np . complex128 ) for x in Hc ] Htot = H0 + sum ([ Hc [ i ] * ctrl [ i ][ 0 ] for i in range ( ctrl_num )]) self . freeHamiltonian = np . array ( Htot , dtype = np . complex128 ) self . dim = len ( self . freeHamiltonian ) else : H0 = [ np . array ( x , dtype = np . complex128 ) for x in H0 ] Htot = [] for i in range ( len ( H0 )): Htot . append ( H0 [ i ] + sum ([ Hc [ i ] * ctrl [ i ][ 0 ] for i in range ( ctrl_num )]) ) self . freeHamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in Htot ] self . dim = len ( self . freeHamiltonian [ 0 ]) else : if type ( H0 ) != np . ndarray : #### linear interpolation #### f = interp1d ( self . tspan , H0 , axis = 0 ) else : pass number = math . ceil (( len ( self . tspan ) - 1 ) / len ( ctrl [ 0 ])) if len ( self . tspan ) - 1 % len ( ctrl [ 0 ]) != 0 : tnum = number * len ( ctrl [ 0 ]) self . tspan = np . linspace ( self . tspan [ 0 ], self . tspan [ - 1 ], tnum + 1 ) if type ( H0 ) != np . ndarray : H0_inter = f ( self . tspan ) H0 = [ np . array ( x , dtype = np . complex128 ) for x in H0_inter ] else : pass else : pass if type ( H0 ) == np . ndarray : H0 = np . array ( H0 , dtype = np . complex128 ) Hc = [ np . array ( x , dtype = np . complex128 ) for x in Hc ] ctrl = [ np . array ( ctrl [ i ]) . repeat ( number ) for i in range ( len ( Hc ))] Htot = [] for i in range ( len ( ctrl [ 0 ])): S_ctrl = sum ([ Hc [ j ] * ctrl [ j ][ i ] for j in range ( len ( ctrl ))]) Htot . append ( H0 + S_ctrl ) self . freeHamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in Htot ] self . dim = len ( self . freeHamiltonian ) else : H0 = [ np . array ( x , dtype = np . complex128 ) for x in H0 ] Hc = [ np . array ( x , dtype = np . complex128 ) for x in Hc ] ctrl = [ np . array ( ctrl [ i ]) . repeat ( number ) for i in range ( len ( Hc ))] Htot = [] for i in range ( len ( ctrl [ 0 ])): S_ctrl = sum ([ Hc [ j ] * ctrl [ j ][ i ] for j in range ( len ( ctrl ))]) Htot . append ( H0 [ i ] + S_ctrl ) self . freeHamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in Htot ] self . dim = len ( self . freeHamiltonian [ 0 ]) if self . psi0 == []: np . random . seed ( self . seed ) r_ini = 2 * np . random . random ( self . dim ) - np . ones ( self . dim ) r = r_ini / np . linalg . norm ( r_ini ) phi = 2 * np . pi * np . random . random ( self . dim ) psi0 = [ r [ i ] * np . exp ( 1.0 j * phi [ i ]) for i in range ( self . dim )] self . psi0 = np . array ( psi0 ) # Initial state (an array) self . psi = [ self . psi0 ] # Initial guesses of states (a list of arrays) else : self . psi0 = np . array ( self . psi0 [ 0 ], dtype = np . complex128 ) self . psi = [ np . array ( psi , dtype = np . complex128 ) for psi in self . psi ] if type ( dH ) != list : raise TypeError ( \"The derivative of Hamiltonian should be a list!\" ) if dH == []: dH = [ np . zeros (( len ( self . psi0 ), len ( self . psi0 )))] self . Hamiltonian_derivative = [ np . array ( x , dtype = np . complex128 ) for x in dH ] if decay == []: decay_opt = [ np . zeros (( len ( self . psi0 ), len ( self . psi0 )))] self . gamma = [ 0.0 ] else : decay_opt = [ decay [ i ][ 0 ] for i in range ( len ( decay ))] self . gamma = [ decay [ i ][ 1 ] for i in range ( len ( decay ))] self . decay_opt = [ np . array ( x , dtype = np . complex128 ) for x in decay_opt ] self . opt = Main . QuanEstimation . StateOpt ( psi = self . psi0 , seed = self . seed ) if any ( self . gamma ): self . dynamic = Main . QuanEstimation . Lindblad ( self . freeHamiltonian , self . Hamiltonian_derivative , self . psi0 , self . tspan , self . decay_opt , self . gamma , ) else : self . dynamic = Main . QuanEstimation . Lindblad ( self . freeHamiltonian , self . Hamiltonian_derivative , self . psi0 , self . tspan , ) self . output = Main . QuanEstimation . Output ( self . opt , save = self . savefile ) self . dynamics_type = \"dynamics\" if len ( self . Hamiltonian_derivative ) == 1 : self . para_type = \"single_para\" else : self . para_type = \"multi_para\" def Kraus ( self , K , dK ): r \"\"\" The parameterization of a state is \\begin{align} \\rho=\\sum_i K_i\\rho_0K_i^{\\dagger}, \\end{align} where $\\rho$ is the evolved density matrix, $K_i$ is the Kraus operator. Parameters ---------- > **K:** `list` -- Kraus operators. > **dK:** `list` -- Derivatives of the Kraus operators on the unknown parameters to be estimated. For example, dK[0] is the derivative vector on the first parameter. \"\"\" k_num = len ( K ) para_num = len ( dK [ 0 ]) self . para_num = para_num self . K = [ np . array ( x , dtype = np . complex128 ) for x in K ] self . dK = [ [ np . array ( dK [ i ][ j ], dtype = np . complex128 ) for j in range ( para_num )] for i in range ( k_num ) ] self . dim = len ( self . K [ 0 ]) if self . psi0 == []: np . random . seed ( self . seed ) r_ini = 2 * np . random . random ( self . dim ) - np . ones ( self . dim ) r = r_ini / np . linalg . norm ( r_ini ) phi = 2 * np . pi * np . random . random ( self . dim ) psi0 = [ r [ i ] * np . exp ( 1.0 j * phi [ i ]) for i in range ( self . dim )] self . psi0 = np . array ( psi0 ) # Initial state (an array) self . psi = [ self . psi0 ] # Initial guesses of states (a list of arrays) else : self . psi0 = np . array ( self . psi0 [ 0 ], dtype = np . complex128 ) self . psi = [ np . array ( psi , dtype = np . complex128 ) for psi in self . psi ] self . opt = Main . QuanEstimation . StateOpt ( psi = self . psi0 , seed = self . seed ) self . dynamic = Main . QuanEstimation . Kraus ( self . psi0 , self . K , self . dK ) self . output = Main . QuanEstimation . Output ( self . opt , save = self . savefile ) self . dynamics_type = \"Kraus\" if para_num == 1 : self . para_type = \"single_para\" else : self . para_type = \"multi_para\" def QFIM ( self , W = [], LDtype = \"SLD\" ): r \"\"\" Choose QFI or $\\mathrm{Tr}(WF^{-1})$ as the objective function. In single parameter estimation the objective function is QFI and in multiparameter estimation it will be $\\mathrm{Tr}(WF^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). \"\"\" if LDtype != \"SLD\" and LDtype != \"RLD\" and LDtype != \"LLD\" : raise ValueError ( \" {!r} is not a valid value for LDtype, supported values are 'SLD', 'RLD' and 'LLD'.\" . format ( LDtype ) ) if self . dynamics_type == \"dynamics\" : if W == []: W = np . eye ( len ( self . Hamiltonian_derivative )) self . W = W elif self . dynamics_type == \"Kraus\" : if W == []: W = np . eye ( self . para_num ) self . W = W else : pass self . obj = Main . QuanEstimation . QFIM_obj ( self . W , self . eps , self . para_type , LDtype ) system = Main . QuanEstimation . QuanEstSystem ( self . opt , self . alg , self . obj , self . dynamic , self . output ) Main . QuanEstimation . run ( system ) self . load_save () def CFIM ( self , M = [], W = []): r \"\"\" Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" if M == []: M = SIC ( len ( self . psi0 )) M = [ np . array ( x , dtype = np . complex128 ) for x in M ] if self . dynamics_type == \"dynamics\" : if W == []: W = np . eye ( len ( self . Hamiltonian_derivative )) self . W = W elif self . dynamics_type == \"Kraus\" : if W == []: W = np . eye ( self . para_num ) self . W = W self . obj = Main . QuanEstimation . CFIM_obj ( M , self . W , self . eps , self . para_type ) system = Main . QuanEstimation . QuanEstSystem ( self . opt , self . alg , self . obj , self . dynamic , self . output ) Main . QuanEstimation . run ( system ) self . load_save () def HCRB ( self , W = []): \"\"\" Choose HCRB as the objective function. **Notes:** (1) In single parameter estimation, HCRB is equivalent to QFI, please choose QFI as the objective function. (2) GRAPE and auto-GRAPE are not available when the objective function is HCRB. Supported methods are PSO, DE and DDPG. Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" if self . dynamics_type == \"dynamics\" : if W == []: W = np . eye ( len ( self . Hamiltonian_derivative )) self . W = W if len ( self . Hamiltonian_derivative ) == 1 : print ( \"Program terminated. In the single-parameter scenario, the HCRB is equivalent to the QFI. Please choose 'QFIM' as the objective function\" ) else : pass elif self . dynamics_type == \"Kraus\" : if W == []: W = np . eye ( self . para_num ) self . W = W if len ( self . dK ) == 1 : raise ValueError ( \"In single parameter scenario, HCRB is equivalent to QFI. Please choose QFIM as the target function for control optimization\" , ) else : pass else : raise ValueError ( \"Supported type of dynamics are Lindblad and Kraus.\" ) self . obj = Main . QuanEstimation . HCRB_obj ( self . W , self . eps , self . para_type ) system = Main . QuanEstimation . QuanEstSystem ( self . opt , self . alg , self . obj , self . dynamic , self . output ) Main . QuanEstimation . run ( system ) self . load_save ()","title":"Attributes"},{"location":"API/python/classes/#quanestimation.StateOpt.StateStruct.StateSystem.CFIM","text":"Choose CFI or \\(\\mathrm{Tr}(WI^{-1})\\) as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be \\(\\mathrm{Tr}(WI^{-1})\\) .","title":"CFIM()"},{"location":"API/python/classes/#quanestimation.StateOpt.StateStruct.StateSystem.HCRB","text":"Choose HCRB as the objective function. Notes: (1) In single parameter estimation, HCRB is equivalent to QFI, please choose QFI as the objective function. (2) GRAPE and auto-GRAPE are not available when the objective function is HCRB. Supported methods are PSO, DE and DDPG.","title":"HCRB()"},{"location":"API/python/classes/#quanestimation.StateOpt.StateStruct.StateSystem.Kraus","text":"The parameterization of a state is \\begin{align} \\rho=\\sum_i K_i\\rho_0K_i^{\\dagger}, \\end{align} where \\(\\rho\\) is the evolved density matrix, \\(K_i\\) is the Kraus operator.","title":"Kraus()"},{"location":"API/python/classes/#quanestimation.StateOpt.StateStruct.StateSystem.QFIM","text":"Choose QFI or \\(\\mathrm{Tr}(WF^{-1})\\) as the objective function. In single parameter estimation the objective function is QFI and in multiparameter estimation it will be \\(\\mathrm{Tr}(WF^{-1})\\) .","title":"QFIM()"},{"location":"API/python/classes/#quanestimation.StateOpt.StateStruct.StateSystem.dynamics","text":"The dynamics of a density matrix is of the form \\[\\begin{align} \\partial_t\\rho &=\\mathcal{L}\\rho \\nonumber \\\\ &=-i[H,\\rho]+\\sum_i \\gamma_i\\left(\\Gamma_i\\rho\\Gamma^{\\dagger}_i-\\frac{1}{2} \\left\\{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\right\\}\\right), \\end{align}\\] where \\(\\rho\\) is the evolved density matrix, H is the Hamiltonian of the system, \\(\\Gamma_i\\) and \\(\\gamma_i\\) are the \\(i\\mathrm{th}\\) decay operator and corresponding decay rate.","title":"dynamics()"},{"location":"API/python/classes/#state-optimization-with-ad","text":"Bases: State . StateSystem","title":"State optimization with AD"},{"location":"API/python/classes/#quanestimation.AD_Sopt--attributes","text":"savefile: bool -- Whether or not to save all the states. If set True then the states and the values of the objective function obtained in all episodes will be saved during the training. If set False the state in the final episode and the values of the objective function in all episodes will be saved. Adam: bool -- Whether or not to use Adam for updating states. psi0: list of arrays -- Initial guesses of states. max_episode: int -- The number of episodes. epsilon: float -- Learning rate. beta1: float -- The exponential decay rate for the first moment estimates. beta2: float -- The exponential decay rate for the second moment estimates. eps: float -- Machine epsilon. load: bool -- Whether or not to load states in the current location. If set True then the program will load state from \"states.csv\" file in the current location and use it as the initial state. Source code in quanestimation/StateOpt/AD_Sopt.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 class AD_Sopt ( State . StateSystem ): \"\"\" Attributes ---------- > **savefile:** `bool` -- Whether or not to save all the states. If set `True` then the states and the values of the objective function obtained in all episodes will be saved during the training. If set `False` the state in the final episode and the values of the objective function in all episodes will be saved. > **Adam:** `bool` -- Whether or not to use Adam for updating states. > **psi0:** `list of arrays` -- Initial guesses of states. > **max_episode:** `int` -- The number of episodes. > **epsilon:** `float` -- Learning rate. > **beta1:** `float` -- The exponential decay rate for the first moment estimates. > **beta2:** `float` -- The exponential decay rate for the second moment estimates. > **eps:** `float` -- Machine epsilon. > **load:** `bool` -- Whether or not to load states in the current location. If set `True` then the program will load state from \"states.csv\" file in the current location and use it as the initial state. \"\"\" def __init__ ( self , savefile = False , Adam = False , psi0 = [], max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 , seed = 1234 , eps = 1e-8 , load = False , ): State . StateSystem . __init__ ( self , savefile , psi0 , seed , eps , load ) self . Adam = Adam self . max_episode = max_episode self . epsilon = epsilon self . beta1 = beta1 self . beta2 = beta2 self . mt = 0.0 self . vt = 0.0 if self . Adam : self . alg = Main . QuanEstimation . AD ( self . max_episode , self . epsilon , self . beta1 , self . beta2 , ) else : self . alg = Main . QuanEstimation . AD ( self . max_episode , self . epsilon ) def QFIM ( self , W = [], LDtype = \"SLD\" ): r \"\"\" Choose QFI or $\\mathrm{Tr}(WF^{-1})$ as the objective function. In single parameter estimation the objective function is QFI and in multiparameter estimation it will be $\\mathrm{Tr}(WF^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). \"\"\" super () . QFIM ( W , LDtype ) def CFIM ( self , M = [], W = []): r \"\"\" Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" super () . CFIM ( M , W ) def HCRB ( self , W = []): \"\"\" AD is not available when the objective function is HCRB. Supported methods are PSO, DE, DDPG and NM. Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" raise ValueError ( \"AD is not available when the objective function is HCRB. Supported methods are 'PSO', 'DE', 'NM' and 'DDPG'.\" )","title":"Attributes"},{"location":"API/python/classes/#quanestimation.StateOpt.AD_Sopt.AD_Sopt.CFIM","text":"Choose CFI or \\(\\mathrm{Tr}(WI^{-1})\\) as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be \\(\\mathrm{Tr}(WI^{-1})\\) .","title":"CFIM()"},{"location":"API/python/classes/#quanestimation.StateOpt.AD_Sopt.AD_Sopt.HCRB","text":"AD is not available when the objective function is HCRB. Supported methods are PSO, DE, DDPG and NM.","title":"HCRB()"},{"location":"API/python/classes/#quanestimation.StateOpt.AD_Sopt.AD_Sopt.QFIM","text":"Choose QFI or \\(\\mathrm{Tr}(WF^{-1})\\) as the objective function. In single parameter estimation the objective function is QFI and in multiparameter estimation it will be \\(\\mathrm{Tr}(WF^{-1})\\) .","title":"QFIM()"},{"location":"API/python/classes/#state-optimization-with-ri","text":"Bases: State . StateSystem","title":"State optimization with RI"},{"location":"API/python/classes/#quanestimation.RI_Sopt--attributes","text":"savefile: bool -- Whether or not to save all the states. If set True then the states and the values of the objective function obtained in all episodes will be saved during the training. If set False the state in the final episode and the values of the objective function in all episodes will be saved. psi0: list of arrays -- Initial guesses of states. max_episode: int -- The number of episodes. seed: int -- Random seed. eps: float -- Machine epsilon. load: bool -- Whether or not to load states in the current location. If set True then the program will load state from \"states.csv\" file in the current location and use it as the initial state. Source code in quanestimation/StateOpt/RI_Sopt.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 class RI_Sopt ( State . StateSystem ): \"\"\" Attributes ---------- > **savefile:** `bool` -- Whether or not to save all the states. If set `True` then the states and the values of the objective function obtained in all episodes will be saved during the training. If set `False` the state in the final episode and the values of the objective function in all episodes will be saved. > **psi0:** `list of arrays` -- Initial guesses of states. > **max_episode:** `int` -- The number of episodes. > **seed:** `int` -- Random seed. > **eps:** `float` -- Machine epsilon. > **load:** `bool` -- Whether or not to load states in the current location. If set `True` then the program will load state from \"states.csv\" file in the current location and use it as the initial state. \"\"\" def __init__ ( self , savefile = False , psi0 = [], max_episode = 300 , seed = 1234 , eps = 1e-8 , load = False , ): State . StateSystem . __init__ ( self , savefile , psi0 , seed , eps , load ) self . max_episode = max_episode self . seed = seed def QFIM ( self , W = [], LDtype = \"SLD\" ): r \"\"\" Choose QFI as the objective function. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Only SLD can is available here. \"\"\" self . alg = Main . QuanEstimation . RI ( self . max_episode , ) if self . dynamics_type != \"Kraus\" : raise ValueError ( \"Only the parameterization with Kraus operators is available.\" ) if LDtype == \"SLD\" : super () . QFIM ( W , LDtype ) else : raise ValueError ( \"Only SLD is available.\" ) def CFIM ( self , M = [], W = []): \"\"\" Choose CFIM as the objective function. **Note:** CFIM is not available. Parameters ---------- > **M:** `list` -- POVM. > **W:** `matrix` -- Weight matrix. \"\"\" raise ValueError ( \"CFIM is not available.\" ) def HCRB ( self , W = []): \"\"\" Choose HCRB as the objective function. **Note:** Here HCRB is not available. Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" raise ValueError ( \"HCRB is not available.\" )","title":"Attributes"},{"location":"API/python/classes/#quanestimation.StateOpt.RI_Sopt.RI_Sopt.CFIM","text":"Choose CFIM as the objective function. Note: CFIM is not available.","title":"CFIM()"},{"location":"API/python/classes/#quanestimation.StateOpt.RI_Sopt.RI_Sopt.HCRB","text":"Choose HCRB as the objective function. Note: Here HCRB is not available.","title":"HCRB()"},{"location":"API/python/classes/#quanestimation.StateOpt.RI_Sopt.RI_Sopt.QFIM","text":"Choose QFI as the objective function.","title":"QFIM()"},{"location":"API/python/classes/#state-optimization-with-pso","text":"Bases: State . StateSystem","title":"State Optimization with PSO"},{"location":"API/python/classes/#quanestimation.PSO_Sopt--attributes","text":"savefile: bool -- Whether or not to save all the states. If set True then the states and the values of the objective function obtained in all episodes will be saved during the training. If set False the state in the final episode and the values of the objective function in all episodes will be saved. p_num: int -- The number of particles. psi0: list of arrays -- Initial guesses of states. max_episode: int or list -- If it is an integer, for example max_episode=1000, it means the program will continuously run 1000 episodes. However, if it is an array, for example max_episode=[1000,100], the program will run 1000 episodes in total but replace states of all the particles with global best every 100 episodes. c0: float -- The damping factor that assists convergence, also known as inertia weight. c1: float -- The exploitation weight that attracts the particle to its best previous position, also known as cognitive learning factor. c2: float -- The exploitation weight that attracts the particle to the best position in the neighborhood, also known as social learning factor. seed: int -- Random seed. eps: float -- Machine epsilon. load: bool -- Whether or not to load states in the current location. If set True then the program will load state from \"states.csv\" file in the current location and use it as the initial state. Source code in quanestimation/StateOpt/PSO_Sopt.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 class PSO_Sopt ( State . StateSystem ): \"\"\" Attributes ---------- > **savefile:** `bool` -- Whether or not to save all the states. If set `True` then the states and the values of the objective function obtained in all episodes will be saved during the training. If set `False` the state in the final episode and the values of the objective function in all episodes will be saved. > **p_num:** `int` -- The number of particles. > **psi0:** `list of arrays` -- Initial guesses of states. > **max_episode:** `int or list` -- If it is an integer, for example max_episode=1000, it means the program will continuously run 1000 episodes. However, if it is an array, for example max_episode=[1000,100], the program will run 1000 episodes in total but replace states of all the particles with global best every 100 episodes. > **c0:** `float` -- The damping factor that assists convergence, also known as inertia weight. > **c1:** `float` -- The exploitation weight that attracts the particle to its best previous position, also known as cognitive learning factor. > **c2:** `float` -- The exploitation weight that attracts the particle to the best position in the neighborhood, also known as social learning factor. > **seed:** `int` -- Random seed. > **eps:** `float` -- Machine epsilon. > **load:** `bool` -- Whether or not to load states in the current location. If set `True` then the program will load state from \"states.csv\" file in the current location and use it as the initial state. \"\"\" def __init__ ( self , savefile = False , p_num = 10 , psi0 = [], max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 , seed = 1234 , eps = 1e-8 , load = False , ): State . StateSystem . __init__ ( self , savefile , psi0 , seed , eps , load ) \"\"\" -------- inputs -------- p_num: --description: the number of particles. --type: int psi0: --description: initial guesses of states (kets). --type: array max_episode: --description: max number of the training episodes. --type: int c0: --description: damping factor that assists convergence. --type: float c1: --description: exploitation weight that attract the particle to its best previous position. --type: float c2: --description: exploitation weight that attract the particle to the best position in the neighborhood. --type: float seed: --description: random seed. --type: int \"\"\" self . max_episode = max_episode self . p_num = p_num self . c0 = c0 self . c1 = c1 self . c2 = c2 self . seed = seed def QFIM ( self , W = [], LDtype = \"SLD\" ): r \"\"\" Choose QFI or $\\mathrm{Tr}(WF^{-1})$ as the objective function. In single parameter estimation the objective function is QFI and in multiparameter estimation it will be $\\mathrm{Tr}(WF^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). \"\"\" ini_particle = ([ self . psi ],) self . alg = Main . QuanEstimation . PSO ( self . max_episode , self . p_num , ini_particle , self . c0 , self . c1 , self . c2 , ) super () . QFIM ( W , LDtype ) def CFIM ( self , M = [], W = []): r \"\"\" Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" ini_particle = ([ self . psi ],) self . alg = Main . QuanEstimation . PSO ( self . max_episode , self . p_num , ini_particle , self . c0 , self . c1 , self . c2 , ) super () . CFIM ( M , W ) def HCRB ( self , W = []): \"\"\" Choose HCRB as the objective function. **Note:** in single parameter estimation, HCRB is equivalent to QFI, please choose QFI as the objective function. Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" ini_particle = ([ self . psi ],) self . alg = Main . QuanEstimation . PSO ( self . max_episode , self . p_num , ini_particle , self . c0 , self . c1 , self . c2 , ) super () . HCRB ( W )","title":"Attributes"},{"location":"API/python/classes/#quanestimation.StateOpt.PSO_Sopt.PSO_Sopt.CFIM","text":"Choose CFI or \\(\\mathrm{Tr}(WI^{-1})\\) as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be \\(\\mathrm{Tr}(WI^{-1})\\) .","title":"CFIM()"},{"location":"API/python/classes/#quanestimation.StateOpt.PSO_Sopt.PSO_Sopt.HCRB","text":"Choose HCRB as the objective function. Note: in single parameter estimation, HCRB is equivalent to QFI, please choose QFI as the objective function.","title":"HCRB()"},{"location":"API/python/classes/#quanestimation.StateOpt.PSO_Sopt.PSO_Sopt.QFIM","text":"Choose QFI or \\(\\mathrm{Tr}(WF^{-1})\\) as the objective function. In single parameter estimation the objective function is QFI and in multiparameter estimation it will be \\(\\mathrm{Tr}(WF^{-1})\\) .","title":"QFIM()"},{"location":"API/python/classes/#state-optimization-de","text":"Bases: State . StateSystem","title":"State Optimization DE"},{"location":"API/python/classes/#quanestimation.DE_Sopt--attributes","text":"savefile: bool -- Whether or not to save all the states. If set True then the states and the values of the objective function obtained in all episodes will be saved during the training. If set False the state in the final episode and the values of the objective function in all episodes will be saved. p_num: int -- The number of populations. psi0: list of arrays -- Initial guesses of states. max_episode: int -- The number of episodes. c: float -- Mutation constant. cr: float -- Crossover constant. seed: int -- Random seed. eps: float -- Machine epsilon. load: bool -- Whether or not to load states in the current location. If set True then the program will load state from \"states.csv\" file in the current location and use it as the initial state. Source code in quanestimation/StateOpt/DE_Sopt.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 class DE_Sopt ( State . StateSystem ): \"\"\" Attributes ---------- > **savefile:** `bool` -- Whether or not to save all the states. If set `True` then the states and the values of the objective function obtained in all episodes will be saved during the training. If set `False` the state in the final episode and the values of the objective function in all episodes will be saved. > **p_num:** `int` -- The number of populations. > **psi0:** `list of arrays` -- Initial guesses of states. > **max_episode:** `int` -- The number of episodes. > **c:** `float` -- Mutation constant. > **cr:** `float` -- Crossover constant. > **seed:** `int` -- Random seed. > **eps:** `float` -- Machine epsilon. > **load:** `bool` -- Whether or not to load states in the current location. If set `True` then the program will load state from \"states.csv\" file in the current location and use it as the initial state. \"\"\" def __init__ ( self , savefile = False , p_num = 10 , psi0 = [], max_episode = 1000 , c = 1.0 , cr = 0.5 , seed = 1234 , eps = 1e-8 , load = False , ): State . StateSystem . __init__ ( self , savefile , psi0 , seed , eps , load ) self . p_num = p_num self . max_episode = max_episode self . c = c self . cr = cr self . seed = seed def QFIM ( self , W = [], LDtype = \"SLD\" ): r \"\"\" Choose QFI or $\\mathrm{Tr}(WF^{-1})$ as the objective function. In single parameter estimation the objective function is QFI and in multiparameter estimation it will be $\\mathrm{Tr}(WF^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). \"\"\" ini_population = ([ self . psi ],) self . alg = Main . QuanEstimation . DE ( self . max_episode , self . p_num , ini_population , self . c , self . cr , ) super () . QFIM ( W , LDtype ) def CFIM ( self , M = [], W = []): r \"\"\" Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" ini_population = ([ self . psi ],) self . alg = Main . QuanEstimation . DE ( self . max_episode , self . p_num , ini_population , self . c , self . cr , ) super () . CFIM ( M , W ) def HCRB ( self , W = []): \"\"\" Choose HCRB as the objective function. **Note:** in single parameter estimation, HCRB is equivalent to QFI, please choose QFI as the objective function. Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" ini_population = ([ self . psi ],) self . alg = Main . QuanEstimation . DE ( self . max_episode , self . p_num , ini_population , self . c , self . cr , ) super () . HCRB ( W )","title":"Attributes"},{"location":"API/python/classes/#quanestimation.StateOpt.DE_Sopt.DE_Sopt.CFIM","text":"Choose CFI or \\(\\mathrm{Tr}(WI^{-1})\\) as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be \\(\\mathrm{Tr}(WI^{-1})\\) .","title":"CFIM()"},{"location":"API/python/classes/#quanestimation.StateOpt.DE_Sopt.DE_Sopt.HCRB","text":"Choose HCRB as the objective function. Note: in single parameter estimation, HCRB is equivalent to QFI, please choose QFI as the objective function.","title":"HCRB()"},{"location":"API/python/classes/#quanestimation.StateOpt.DE_Sopt.DE_Sopt.QFIM","text":"Choose QFI or \\(\\mathrm{Tr}(WF^{-1})\\) as the objective function. In single parameter estimation the objective function is QFI and in multiparameter estimation it will be \\(\\mathrm{Tr}(WF^{-1})\\) .","title":"QFIM()"},{"location":"API/python/classes/#state-optimization-with-ddpg","text":"Bases: State . StateSystem","title":"State Optimization with DDPG"},{"location":"API/python/classes/#quanestimation.DDPG_Sopt--attributes","text":"savefile: bool -- Whether or not to save all the states. If set True then the states and the values of the objective function obtained in all episodes will be saved during the training. If set False the state in the final episode and the values of the objective function in all episodes will be saved. psi0: list of arrays -- Initial guesses of states. max_episode: int -- The number of episodes. layer_num: int -- The number of layers (include the input and output layer). layer_dim: int -- The number of neurons in the hidden layer. seed: int -- Random seed. eps: float -- Machine epsilon. load: bool -- Whether or not to load states in the current location. If set True then the program will load state from \"states.csv\" file in the current location and use it as the initial state. Source code in quanestimation/StateOpt/DDPG_Sopt.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 class DDPG_Sopt ( State . StateSystem ): \"\"\" Attributes ---------- > **savefile:** `bool` -- Whether or not to save all the states. If set `True` then the states and the values of the objective function obtained in all episodes will be saved during the training. If set `False` the state in the final episode and the values of the objective function in all episodes will be saved. > **psi0:** `list of arrays` -- Initial guesses of states. > **max_episode:** `int` -- The number of episodes. > **layer_num:** `int` -- The number of layers (include the input and output layer). > **layer_dim:** `int` -- The number of neurons in the hidden layer. > **seed:** `int` -- Random seed. > **eps:** `float` -- Machine epsilon. > **load:** `bool` -- Whether or not to load states in the current location. If set `True` then the program will load state from \"states.csv\" file in the current location and use it as the initial state. \"\"\" def __init__ ( self , savefile = False , psi0 = [], max_episode = 500 , layer_num = 3 , layer_dim = 200 , seed = 1234 , eps = 1e-8 , load = False , ): State . StateSystem . __init__ ( self , savefile , psi0 , seed , eps , load ) self . max_episode = max_episode self . layer_num = layer_num self . layer_dim = layer_dim self . seed = seed self . alg = Main . QuanEstimation . DDPG ( self . max_episode , self . layer_num , self . layer_dim , self . seed ) def QFIM ( self , W = [], LDtype = \"SLD\" ): r \"\"\" Choose QFI or $\\mathrm{Tr}(WF^{-1})$ as the objective function. In single parameter estimation the objective function is QFI and in multiparameter estimation it will be $\\mathrm{Tr}(WF^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). \"\"\" super () . QFIM ( W , LDtype ) def CFIM ( self , M = [], W = []): r \"\"\" Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" super () . CFIM ( M , W ) def HCRB ( self , W = []): \"\"\" Choose HCRB as the objective function. **Note:** in single parameter estimation, HCRB is equivalent to QFI, please choose QFI as the objective function. Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" super () . HCRB ( W )","title":"Attributes"},{"location":"API/python/classes/#quanestimation.StateOpt.DDPG_Sopt.DDPG_Sopt.CFIM","text":"Choose CFI or \\(\\mathrm{Tr}(WI^{-1})\\) as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be \\(\\mathrm{Tr}(WI^{-1})\\) .","title":"CFIM()"},{"location":"API/python/classes/#quanestimation.StateOpt.DDPG_Sopt.DDPG_Sopt.HCRB","text":"Choose HCRB as the objective function. Note: in single parameter estimation, HCRB is equivalent to QFI, please choose QFI as the objective function.","title":"HCRB()"},{"location":"API/python/classes/#quanestimation.StateOpt.DDPG_Sopt.DDPG_Sopt.QFIM","text":"Choose QFI or \\(\\mathrm{Tr}(WF^{-1})\\) as the objective function. In single parameter estimation the objective function is QFI and in multiparameter estimation it will be \\(\\mathrm{Tr}(WF^{-1})\\) .","title":"QFIM()"},{"location":"API/python/classes/#measurement-optimization","text":"In QuanEstimation, three measurement optimization scenarios are considered. The first one is to optimize a set of rank-one projective measurement, it can be written in a specific basis \\(\\{|\\phi_i\\rangle\\}\\) with \\(|\\phi_i\\rangle=\\sum_j C_{ij}|j\\rangle\\) in the Hilbert space as \\(\\{|\\phi_i\\rangle\\langle\\phi_i|\\}\\) . In this case, the goal is to search a set of optimal coefficients \\(C_{ij}\\) . The second scenario is to find the optimal linear combination of an input measurement \\(\\{\\Pi_j\\}\\) . The third scenario is to find the optimal rotated measurement of an input measurement. After rotation, the new measurement is \\(\\{U\\Pi_i U^{\\dagger}\\}\\) , where \\(U=\\prod_k \\exp(i s_k\\lambda_k)\\) with \\(\\lambda_k\\) a SU( \\(N\\) ) generator and \\(s_k\\) a real number in the regime \\([0,2\\pi]\\) . In this scenario, the goal is to search a set of optimal coefficients \\(s_k\\) . Here different algorithms are invoked to search the optimal measurement include particle swarm optimization (PSO) [1] , differential evolution (DE) [2] , and automatic differentiation (AD) [[3]] (#Baydin2018).","title":"Measurement Optimization"},{"location":"API/python/classes/#base_2","text":"Attributes mtype: string -- The type of scenarios for the measurement optimization. Options are: \"projection\" (default) -- Optimization of rank-one projective measurements. \"input\" -- Find the optimal linear combination or the optimal rotated measurement of a given set of POVM. minput: list -- In the case of optimization of rank-one projective measurements, the minput should keep empty. For finding the optimal linear combination and the optimal rotated measurement of a given set of POVM, the input rule are minput=[\"LC\", [Pi1,Pi2,...], m] and minput=[\"LC\", [Pi1,Pi2,...]] respectively. Here [Pi1,Pi2,...] represents a list of input POVM and m is the number of operators of the output measurement. savefile: bool -- Whether or not to save all the measurements. If set True then the measurements and the values of the objective function obtained in all episodes will be saved during the training. If set False the measurement in the final episode and the values of the objective function in all episodes will be saved. measurement0: list of arrays -- Initial guesses of measurements. seed: int -- Random seed. eps: float -- Machine epsilon. load: bool -- Whether or not to load measurements in the current location. If set True then the program will load measurement from \"measurements.csv\" file in the current location and use it as the initial measurement. Source code in quanestimation/MeasurementOpt/MeasurementStruct.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 class MeasurementSystem : \"\"\" Attributes ---------- > **mtype:** `string` -- The type of scenarios for the measurement optimization. Options are: \"projection\" (default) -- Optimization of rank-one projective measurements. \"input\" -- Find the optimal linear combination or the optimal rotated measurement of a given set of POVM. > **minput:** `list` -- In the case of optimization of rank-one projective measurements, the `minput` should keep empty. For finding the optimal linear combination and the optimal rotated measurement of a given set of POVM, the input rule are `minput=[\"LC\", [Pi1,Pi2,...], m]` and `minput=[\"LC\", [Pi1,Pi2,...]]` respectively. Here `[Pi1,Pi2,...]` represents a list of input POVM and `m` is the number of operators of the output measurement. > **savefile:** `bool` -- Whether or not to save all the measurements. If set `True` then the measurements and the values of the objective function obtained in all episodes will be saved during the training. If set `False` the measurement in the final episode and the values of the objective function in all episodes will be saved. > **measurement0:** `list of arrays` -- Initial guesses of measurements. > **seed:** `int` -- Random seed. > **eps:** `float` -- Machine epsilon. > **load:** `bool` -- Whether or not to load measurements in the current location. If set `True` then the program will load measurement from \"measurements.csv\" file in the current location and use it as the initial measurement. \"\"\" def __init__ ( self , mtype , minput , savefile , measurement0 , seed , eps , load ): self . mtype = mtype self . minput = minput self . savefile = savefile self . eps = eps self . seed = seed self . load = load self . measurement0 = measurement0 def load_save ( self ): if os . path . exists ( \"measurements.csv\" ): file_load = open ( \"measurements.csv\" , \"r\" ) file_load = \"\" . join ([ i for i in file_load ]) . replace ( \"im\" , \"j\" ) file_load = \"\" . join ([ i for i in file_load ]) . replace ( \" \" , \"\" ) file_save = open ( \"measurements.csv\" , \"w\" ) file_save . writelines ( file_load ) file_save . close () else : pass def dynamics ( self , tspan , rho0 , H0 , dH , Hc = [], ctrl = [], decay = []): r \"\"\" The dynamics of a density matrix is of the form \\begin{align} \\partial_t\\rho &=\\mathcal{L}\\rho \\nonumber \\\\ &=-i[H,\\rho]+\\sum_i \\gamma_i\\left(\\Gamma_i\\rho\\Gamma^{\\dagger}_i-\\frac{1}{2} \\left\\{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\right\\}\\right), \\end{align} where $\\rho$ is the evolved density matrix, H is the Hamiltonian of the system, $\\Gamma_i$ and $\\gamma_i$ are the $i\\mathrm{th}$ decay operator and corresponding decay rate. Parameters ---------- > **tspan:** `array` -- Time length for the evolution. > **rho0:** `matrix` -- Initial state (density matrix). > **H0:** `matrix or list` -- Free Hamiltonian. It is a matrix when the free Hamiltonian is time- independent and a list of length equal to `tspan` when it is time-dependent. > **dH:** `list` -- Derivatives of the free Hamiltonian on the unknown parameters to be estimated. For example, dH[0] is the derivative vector on the first parameter. > **Hc:** `list` -- Control Hamiltonians. > **ctrl:** `list of arrays` -- Control coefficients. > **decay:** `list` -- Decay operators and the corresponding decay rates. Its input rule is decay=[[$\\Gamma_1$, $\\gamma_1$], [$\\Gamma_2$,$\\gamma_2$],...], where $\\Gamma_1$ $(\\Gamma_2)$ represents the decay operator and $\\gamma_1$ $(\\gamma_2)$ is the corresponding decay rate. \"\"\" self . tspan = tspan self . rho0 = np . array ( rho0 , dtype = np . complex128 ) self . dynamics_type = \"dynamics\" if len ( dH ) == 1 : self . para_type = \"single_para\" else : self . para_type = \"multi_para\" if self . mtype == \"projection\" : if self . measurement0 == []: np . random . seed ( self . seed ) M = [[] for i in range ( len ( self . rho0 ))] for i in range ( len ( self . rho0 )): r_ini = 2 * np . random . random ( len ( self . rho0 )) - np . ones ( len ( self . rho0 ) ) r = r_ini / np . linalg . norm ( r_ini ) phi = 2 * np . pi * np . random . random ( len ( self . rho0 )) M [ i ] = [ r [ j ] * np . exp ( 1.0 j * phi [ j ]) for j in range ( len ( self . rho0 ))] self . C = gramschmidt ( np . array ( M )) self . measurement0 = [ np . array ([ self . C [ i ] for i in range ( len ( self . rho0 ))]) ] else : self . C = [ self . measurement0 [ 0 ][ i ] for i in range ( len ( self . rho0 ))] self . C = [ np . array ( x , dtype = np . complex128 ) for x in self . C ] self . opt = Main . QuanEstimation . Mopt_Projection ( M = self . C , seed = self . seed ) elif self . mtype == \"input\" : if self . minput [ 0 ] == \"LC\" : ## optimize the combination of a set of SIC-POVM if self . minput [ 1 ] == []: file_path = os . path . join ( os . path . dirname ( os . path . dirname ( __file__ )), \"sic_fiducial_vectors/d %d .txt\" % ( len ( self . rho0 )), ) data = np . loadtxt ( file_path ) fiducial = data [:, 0 ] + data [:, 1 ] * 1.0 j fiducial = np . array ( fiducial ) . reshape ( len ( fiducial ), 1 ) self . povm_basis = sic_povm ( fiducial ) self . M_num = self . minput [ 2 ] else : ## optimize the combination of a set of given POVMs if type ( self . minput [ 1 ]) != list : raise TypeError ( \"The given POVMs should be a list!\" ) else : accu = len ( str ( int ( 1 / self . eps ))) - 1 for i in range ( len ( self . minput [ 1 ])): val , vec = np . linalg . eig ( self . minput [ 1 ]) if np . all ( val . round ( accu ) >= 0 ): pass else : raise TypeError ( \"The given POVMs should be semidefinite!\" ) M = np . zeros ( ( len ( self . rho0 ), len ( self . rho0 )), dtype = np . complex128 ) for i in range ( len ( self . minput [ 1 ])): M += self . minput [ 1 ][ i ] if np . all ( M . round ( accu ) - np . identity ( len ( self . rho0 )) == 0 ): pass else : raise TypeError ( \"The sum of the given POVMs should be identity matrix!\" ) self . povm_basis = [ np . array ( x , dtype = np . complex128 ) for x in self . minput [ 1 ] ] self . M_num = self . minput [ 2 ] if self . measurement0 == []: self . B = [ np . random . random ( len ( self . povm_basis )) for i in range ( self . M_num ) ] self . measurement0 = [ np . array ( self . B )] elif len ( self . measurement0 ) >= 1 : self . B = [ self . measurement0 [ 0 ][ i ] for i in range ( self . M_num )] self . opt = Main . QuanEstimation . Mopt_LinearComb ( B = self . B , POVM_basis = self . povm_basis , M_num = self . M_num , seed = self . seed ) elif self . minput [ 0 ] == \"rotation\" : ## optimize the coefficients of the rotation matrix if type ( self . minput [ 1 ]) != list : raise TypeError ( \"The given POVMs should be a list!\" ) else : if self . minput [ 1 ] == []: raise TypeError ( \"The initial POVM should not be empty!\" ) accu = len ( str ( int ( 1 / self . eps ))) - 1 for i in range ( len ( self . minput [ 1 ])): val , vec = np . linalg . eig ( self . minput [ 1 ]) if np . all ( val . round ( accu ) >= 0 ): pass else : raise TypeError ( \"The given POVMs should be semidefinite!\" ) M = np . zeros (( len ( self . rho0 ), len ( self . rho0 )), dtype = np . complex128 ) for i in range ( len ( self . minput [ 1 ])): M += self . minput [ 1 ][ i ] if np . all ( M . round ( accu ) - np . identity ( len ( self . rho0 )) == 0 ): pass else : raise TypeError ( \"The sum of the given POVMs should be identity matrix!\" ) self . povm_basis = [ np . array ( x , dtype = np . complex128 ) for x in self . minput [ 1 ] ] self . mtype = \"rotation\" if self . measurement0 == []: self . s = np . random . random ( len ( self . rho0 ) ** 2 ) self . measurement0 = [ self . s ] elif len ( self . measurement0 ) >= 1 : self . s = [ self . measurement0 [ 0 ][ i ] for i in range ( len ( self . rho0 ) * len ( self . rho0 )) ] self . opt = Main . QuanEstimation . Mopt_Rotation ( s = self . s , POVM_basis = self . povm_basis , Lambda = [], seed = self . seed ) #### Lambda=[] else : raise ValueError ( \" {!r} is not a valid value for the first input of minput, supported values are 'LC' and 'rotation'.\" . format ( self . minput [ 0 ] ) ) else : raise ValueError ( \" {!r} is not a valid value for mtype, supported values are 'projection' and 'input'.\" . format ( self . mtype ) ) if Hc == [] or ctrl == []: if type ( H0 ) == np . ndarray : self . freeHamiltonian = np . array ( H0 , dtype = np . complex128 ) else : self . freeHamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in H0 ] else : ctrl_num = len ( ctrl ) Hc_num = len ( Hc ) if Hc_num < ctrl_num : raise TypeError ( \"There are %d control Hamiltonians but %d coefficients sequences: too many coefficients sequences\" % ( Hc_num , ctrl_num ) ) elif Hc_num > ctrl_num : warnings . warn ( \"Not enough coefficients sequences: there are %d control Hamiltonians but %d coefficients sequences. The rest of the control sequences are set to be 0.\" % ( Hc_num , ctrl_num ), DeprecationWarning , ) for i in range ( Hc_num - ctrl_num ): ctrl = np . concatenate (( ctrl , np . zeros ( len ( ctrl [ 0 ])))) else : pass if len ( ctrl [ 0 ]) == 1 : if type ( H0 ) == np . ndarray : H0 = np . array ( H0 , dtype = np . complex128 ) Hc = [ np . array ( x , dtype = np . complex128 ) for x in Hc ] Htot = H0 + sum ([ Hc [ i ] * ctrl [ i ][ 0 ] for i in range ( ctrl_num )]) self . freeHamiltonian = np . array ( Htot , dtype = np . complex128 ) else : H0 = [ np . array ( x , dtype = np . complex128 ) for x in H0 ] Htot = [] for i in range ( len ( H0 )): Htot . append ( H0 [ i ] + sum ([ Hc [ i ] * ctrl [ i ][ 0 ] for i in range ( ctrl_num )]) ) self . freeHamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in Htot ] else : if type ( H0 ) != np . ndarray : #### linear interpolation #### f = interp1d ( self . tspan , H0 , axis = 0 ) else : pass number = math . ceil (( len ( self . tspan ) - 1 ) / len ( ctrl [ 0 ])) if len ( self . tspan ) - 1 % len ( ctrl [ 0 ]) != 0 : tnum = number * len ( ctrl [ 0 ]) self . tspan = np . linspace ( self . tspan [ 0 ], self . tspan [ - 1 ], tnum + 1 ) if type ( H0 ) != np . ndarray : H0_inter = f ( self . tspan ) H0 = [ np . array ( x , dtype = np . complex128 ) for x in H0_inter ] else : pass else : pass if type ( H0 ) == np . ndarray : H0 = np . array ( H0 , dtype = np . complex128 ) Hc = [ np . array ( x , dtype = np . complex128 ) for x in Hc ] ctrl = [ np . array ( ctrl [ i ]) . repeat ( number ) for i in range ( len ( Hc ))] Htot = [] for i in range ( len ( ctrl [ 0 ])): S_ctrl = sum ([ Hc [ j ] * ctrl [ j ][ i ] for j in range ( len ( ctrl ))]) Htot . append ( H0 + S_ctrl ) self . freeHamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in Htot ] else : H0 = [ np . array ( x , dtype = np . complex128 ) for x in H0 ] Hc = [ np . array ( x , dtype = np . complex128 ) for x in Hc ] ctrl = [ np . array ( ctrl [ i ]) . repeat ( number ) for i in range ( len ( Hc ))] Htot = [] for i in range ( len ( ctrl [ 0 ])): S_ctrl = sum ([ Hc [ j ] * ctrl [ j ][ i ] for j in range ( len ( ctrl ))]) Htot . append ( H0 [ i ] + S_ctrl ) self . freeHamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in Htot ] if type ( dH ) != list : raise TypeError ( \"The derivative of Hamiltonian should be a list!\" ) if dH == []: dH = [ np . zeros (( len ( self . rho0 ), len ( self . rho0 )))] self . Hamiltonian_derivative = [ np . array ( x , dtype = np . complex128 ) for x in dH ] if decay == []: decay_opt = [ np . zeros (( len ( self . rho0 ), len ( self . rho0 )))] self . gamma = [ 0.0 ] else : decay_opt = [ decay [ i ][ 0 ] for i in range ( len ( decay ))] self . gamma = [ decay [ i ][ 1 ] for i in range ( len ( decay ))] self . decay_opt = [ np . array ( x , dtype = np . complex128 ) for x in decay_opt ] if any ( self . gamma ): self . dynamic = Main . QuanEstimation . Lindblad ( self . freeHamiltonian , self . Hamiltonian_derivative , self . rho0 , self . tspan , self . decay_opt , self . gamma , ) else : self . dynamic = Main . QuanEstimation . Lindblad ( self . freeHamiltonian , self . Hamiltonian_derivative , self . rho0 , self . tspan , ) self . output = Main . QuanEstimation . Output ( self . opt , save = self . savefile ) self . dynamics_type = \"dynamics\" def Kraus ( self , rho0 , K , dK ): r \"\"\" The parameterization of a state is \\begin{align} \\rho=\\sum_i K_i\\rho_0K_i^{\\dagger}, \\end{align} where $\\rho$ is the evolved density matrix, $K_i$ is the Kraus operator. Parameters ---------- > **rho0:** `matrix` -- Initial state (density matrix). > **K:** `list` -- Kraus operators. > **dK:** `list` -- Derivatives of the Kraus operators on the unknown parameters to be estimated. For example, dK[0] is the derivative vector on the first parameter. \"\"\" k_num = len ( K ) para_num = len ( dK [ 0 ]) self . para_num = para_num self . dK = [ [ np . array ( dK [ i ][ j ], dtype = np . complex128 ) for j in range ( para_num )] for i in range ( k_num ) ] self . rho0 = np . array ( rho0 , dtype = np . complex128 ) self . K = [ np . array ( x , dtype = np . complex128 ) for x in K ] if para_num == 1 : self . para_type = \"single_para\" else : self . para_type = \"multi_para\" if self . mtype == \"projection\" : if self . measurement0 == []: np . random . seed ( self . seed ) M = [[] for i in range ( len ( self . rho0 ))] for i in range ( len ( self . rho0 )): r_ini = 2 * np . random . random ( len ( self . rho0 )) - np . ones ( len ( self . rho0 ) ) r = r_ini / np . linalg . norm ( r_ini ) phi = 2 * np . pi * np . random . random ( len ( self . rho0 )) M [ i ] = [ r [ j ] * np . exp ( 1.0 j * phi [ j ]) for j in range ( len ( self . rho0 ))] self . C = gramschmidt ( np . array ( M )) self . measurement0 = [ np . array ([ self . C [ i ] for i in range ( len ( self . rho0 ))]) ] else : self . C = [ self . measurement0 [ 0 ][ i ] for i in range ( len ( self . rho0 ))] self . C = [ np . array ( x , dtype = np . complex128 ) for x in self . C ] self . opt = Main . QuanEstimation . Mopt_Projection ( M = self . C , seed = self . seed ) elif self . mtype == \"input\" : if self . minput [ 0 ] == \"LC\" : ## optimize the combination of a set of SIC-POVM if self . minput [ 1 ] == []: file_path = os . path . join ( os . path . dirname ( os . path . dirname ( __file__ )), \"sic_fiducial_vectors/d %d .txt\" % ( len ( self . rho0 )), ) data = np . loadtxt ( file_path ) fiducial = data [:, 0 ] + data [:, 1 ] * 1.0 j fiducial = np . array ( fiducial ) . reshape ( len ( fiducial ), 1 ) self . povm_basis = sic_povm ( fiducial ) self . M_num = self . minput [ 2 ] else : ## optimize the combination of a set of given POVMs if type ( self . minput [ 1 ]) != list : raise TypeError ( \"The given POVMs should be a list!\" ) else : accu = len ( str ( int ( 1 / self . eps ))) - 1 for i in range ( len ( self . minput [ 1 ])): val , vec = np . linalg . eig ( self . minput [ 1 ]) if np . all ( val . round ( accu ) >= 0 ): pass else : raise TypeError ( \"The given POVMs should be semidefinite!\" ) M = np . zeros ( ( len ( self . rho0 ), len ( self . rho0 )), dtype = np . complex128 ) for i in range ( len ( self . minput [ 1 ])): M += self . minput [ 1 ][ i ] if np . all ( M . round ( accu ) - np . identity ( len ( self . rho0 )) == 0 ): pass else : raise TypeError ( \"The sum of the given POVMs should be identity matrix!\" ) self . povm_basis = [ np . array ( x , dtype = np . complex128 ) for x in self . minput [ 1 ] ] self . M_num = self . minput [ 2 ] if self . measurement0 == []: self . B = [ np . random . random ( len ( self . povm_basis )) for i in range ( self . M_num ) ] self . measurement0 = [ np . array ( self . B )] elif len ( self . measurement0 ) >= 1 : self . B = [ self . measurement0 [ 0 ][ i ] for i in range ( len ( self . povm_basis )) ] self . opt = Main . QuanEstimation . Mopt_LinearComb ( B = self . B , POVM_basis = self . povm_basis , M_num = self . M_num , seed = self . seed ) elif self . minput [ 0 ] == \"rotation\" : ## optimize the coefficients of the rotation matrix if type ( self . minput [ 1 ]) != list : raise TypeError ( \"The given POVMs should be a list!\" ) else : if self . minput [ 1 ] == []: raise TypeError ( \"The initial POVM should not be empty!\" ) accu = len ( str ( int ( 1 / self . eps ))) - 1 for i in range ( len ( self . minput [ 1 ])): val , vec = np . linalg . eig ( self . minput [ 1 ]) if np . all ( val . round ( accu ) >= 0 ): pass else : raise TypeError ( \"The given POVMs should be semidefinite!\" ) M = np . zeros (( len ( self . rho0 ), len ( self . rho0 )), dtype = np . complex128 ) for i in range ( len ( self . minput [ 1 ])): M += self . minput [ 1 ][ i ] if np . all ( M . round ( accu ) - np . identity ( len ( self . rho0 )) == 0 ): pass else : raise TypeError ( \"The sum of the given POVMs should be identity matrix!\" ) self . povm_basis = [ np . array ( x , dtype = np . complex128 ) for x in self . minput [ 1 ] ] self . mtype = \"rotation\" if self . measurement0 == []: self . s = np . random . random ( len ( self . rho0 ) ** 2 ) self . measurement0 = [ self . s ] elif len ( self . measurement0 ) >= 1 : self . s = [ self . measurement0 [ 0 ][ i ] for i in range ( len ( self . rho0 ) * len ( self . rho0 )) ] self . opt = Main . QuanEstimation . Mopt_Rotation ( s = self . s , POVM_basis = self . povm_basis , Lambda = [], seed = self . seed ) else : raise ValueError ( \" {!r} is not a valid value for the first input of minput, supported values are 'LC' and 'rotation'.\" . format ( self . minput [ 0 ] ) ) else : raise ValueError ( \" {!r} is not a valid value for mtype, supported values are 'projection' and 'input'.\" . format ( self . mtype ) ) self . dynamic = Main . QuanEstimation . Kraus ( self . rho0 , self . K , self . dK ) self . output = Main . QuanEstimation . Output ( self . opt , save = self . savefile ) self . dynamics_type = \"Kraus\" def CFIM ( self , W = []): r \"\"\" Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" if self . dynamics_type == \"dynamics\" : if W == []: W = np . eye ( len ( self . Hamiltonian_derivative )) self . W = W elif self . dynamics_type == \"Kraus\" : if W == []: W = np . eye ( self . para_num ) self . W = W else : raise ValueError ( \"Supported type of dynamics are Lindblad and Kraus.\" ) self . obj = Main . QuanEstimation . CFIM_obj ( [], self . W , self . eps , self . para_type ) #### m=[] system = Main . QuanEstimation . QuanEstSystem ( self . opt , self . alg , self . obj , self . dynamic , self . output ) Main . QuanEstimation . run ( system ) self . load_save ()","title":"Base"},{"location":"API/python/classes/#quanestimation.MeasurementOpt.MeasurementStruct.MeasurementSystem.CFIM","text":"Choose CFI or \\(\\mathrm{Tr}(WI^{-1})\\) as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be \\(\\mathrm{Tr}(WI^{-1})\\) .","title":"CFIM()"},{"location":"API/python/classes/#quanestimation.MeasurementOpt.MeasurementStruct.MeasurementSystem.Kraus","text":"The parameterization of a state is \\begin{align} \\rho=\\sum_i K_i\\rho_0K_i^{\\dagger}, \\end{align} where \\(\\rho\\) is the evolved density matrix, \\(K_i\\) is the Kraus operator.","title":"Kraus()"},{"location":"API/python/classes/#quanestimation.MeasurementOpt.MeasurementStruct.MeasurementSystem.dynamics","text":"The dynamics of a density matrix is of the form \\[\\begin{align} \\partial_t\\rho &=\\mathcal{L}\\rho \\nonumber \\\\ &=-i[H,\\rho]+\\sum_i \\gamma_i\\left(\\Gamma_i\\rho\\Gamma^{\\dagger}_i-\\frac{1}{2} \\left\\{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\right\\}\\right), \\end{align}\\] where \\(\\rho\\) is the evolved density matrix, H is the Hamiltonian of the system, \\(\\Gamma_i\\) and \\(\\gamma_i\\) are the \\(i\\mathrm{th}\\) decay operator and corresponding decay rate.","title":"dynamics()"},{"location":"API/python/classes/#measurement-optimization-with-ad","text":"Bases: Measurement . MeasurementSystem","title":"Measurement optimization with AD"},{"location":"API/python/classes/#quanestimation.AD_Mopt--attributes","text":"savefile: bool -- Whether or not to save all the measurements. If set True then the measurements and the values of the objective function obtained in all episodes will be saved during the training. If set False the measurement in the final episode and the values of the objective function in all episodes will be saved. Adam: bool -- Whether or not to use Adam for updating measurements. measurement0: list of arrays -- Initial guesses of measurements. max_episode: int -- The number of episodes. epsilon: float -- Learning rate. beta1: float -- The exponential decay rate for the first moment estimates. beta2: float -- The exponential decay rate for the second moment estimates. eps: float -- Machine epsilon. load: bool -- Whether or not to load measurements in the current location. If set True then the program will load measurement from \"measurements.csv\" file in the current location and use it as the initial measurement. Source code in quanestimation/MeasurementOpt/AD_Mopt.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 class AD_Mopt ( Measurement . MeasurementSystem ): \"\"\" Attributes ---------- > **savefile:** `bool` -- Whether or not to save all the measurements. If set `True` then the measurements and the values of the objective function obtained in all episodes will be saved during the training. If set `False` the measurement in the final episode and the values of the objective function in all episodes will be saved. > **Adam:** `bool` -- Whether or not to use Adam for updating measurements. > **measurement0:** `list of arrays` -- Initial guesses of measurements. > **max_episode:** `int` -- The number of episodes. > **epsilon:** `float` -- Learning rate. > **beta1:** `float` -- The exponential decay rate for the first moment estimates. > **beta2:** `float` -- The exponential decay rate for the second moment estimates. > **eps:** `float` -- Machine epsilon. > **load:** `bool` -- Whether or not to load measurements in the current location. If set `True` then the program will load measurement from \"measurements.csv\" file in the current location and use it as the initial measurement. \"\"\" def __init__ ( self , mtype , minput , savefile = False , Adam = False , measurement0 = [], max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 , seed = 1234 , eps = 1e-8 , load = False , ): Measurement . MeasurementSystem . __init__ ( self , mtype , minput , savefile , measurement0 , seed , eps , load ) self . Adam = Adam self . max_episode = max_episode self . epsilon = epsilon self . beta1 = beta1 self . beta2 = beta2 self . mt = 0.0 self . vt = 0.0 self . seed = seed if self . Adam : self . alg = Main . QuanEstimation . AD ( self . max_episode , self . epsilon , self . beta1 , self . beta2 ) else : self . alg = Main . QuanEstimation . AD ( self . max_episode , self . epsilon ) def CFIM ( self , W = []): r \"\"\" Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" if self . mtype == \"projection\" : raise ValueError ( \"AD is not available when mtype is projection. Supported methods are 'PSO' and 'DE'.\" , ) else : super () . CFIM ( W )","title":"Attributes"},{"location":"API/python/classes/#quanestimation.MeasurementOpt.AD_Mopt.AD_Mopt.CFIM","text":"Choose CFI or \\(\\mathrm{Tr}(WI^{-1})\\) as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be \\(\\mathrm{Tr}(WI^{-1})\\) .","title":"CFIM()"},{"location":"API/python/classes/#measurement-optimization-with-pso","text":"Bases: Measurement . MeasurementSystem","title":"Measurement Optimization with PSO"},{"location":"API/python/classes/#quanestimation.PSO_Mopt--attributes","text":"savefile: bool -- Whether or not to save all the measurements. If set True then the measurements and the values of the objective function obtained in all episodes will be saved during the training. If set False the measurement in the final episode and the values of the objective function in all episodes will be saved. p_num: int -- The number of particles. measurement0: list of arrays -- Initial guesses of measurements. max_episode: int or list -- If it is an integer, for example max_episode=1000, it means the program will continuously run 1000 episodes. However, if it is an array, for example max_episode=[1000,100], the program will run 1000 episodes in total but replace measurements of all the particles with global best every 100 episodes. c0: float -- The damping factor that assists convergence, also known as inertia weight. c1: float -- The exploitation weight that attracts the particle to its best previous position, also known as cognitive learning factor. c2: float -- The exploitation weight that attracts the particle to the best position in the neighborhood, also known as social learning factor. seed: int -- Random seed. eps: float -- Machine epsilon. load: bool -- Whether or not to load measurements in the current location. If set True then the program will load measurement from \"measurements.csv\" file in the current location and use it as the initial measurement. Source code in quanestimation/MeasurementOpt/PSO_Mopt.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 class PSO_Mopt ( Measurement . MeasurementSystem ): \"\"\" Attributes ---------- > **savefile:** `bool` -- Whether or not to save all the measurements. If set `True` then the measurements and the values of the objective function obtained in all episodes will be saved during the training. If set `False` the measurement in the final episode and the values of the objective function in all episodes will be saved. > **p_num:** `int` -- The number of particles. > **measurement0:** `list of arrays` -- Initial guesses of measurements. > **max_episode:** `int or list` -- If it is an integer, for example max_episode=1000, it means the program will continuously run 1000 episodes. However, if it is an array, for example max_episode=[1000,100], the program will run 1000 episodes in total but replace measurements of all the particles with global best every 100 episodes. > **c0:** `float` -- The damping factor that assists convergence, also known as inertia weight. > **c1:** `float` -- The exploitation weight that attracts the particle to its best previous position, also known as cognitive learning factor. > **c2:** `float` -- The exploitation weight that attracts the particle to the best position in the neighborhood, also known as social learning factor. > **seed:** `int` -- Random seed. > **eps:** `float` -- Machine epsilon. > **load:** `bool` -- Whether or not to load measurements in the current location. If set `True` then the program will load measurement from \"measurements.csv\" file in the current location and use it as the initial measurement. \"\"\" def __init__ ( self , mtype , minput , savefile = False , p_num = 10 , measurement0 = [], max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 , seed = 1234 , eps = 1e-8 , load = False , ): Measurement . MeasurementSystem . __init__ ( self , mtype , minput , savefile , measurement0 , seed , eps , load ) self . p_num = p_num self . max_episode = max_episode self . c0 = c0 self . c1 = c1 self . c2 = c2 self . seed = seed def CFIM ( self , W = []): r \"\"\" Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" ini_particle = ([ self . measurement0 ],) self . alg = Main . QuanEstimation . PSO ( self . max_episode , self . p_num , ini_particle , self . c0 , self . c1 , self . c2 , ) super () . CFIM ( W )","title":"Attributes"},{"location":"API/python/classes/#quanestimation.MeasurementOpt.PSO_Mopt.PSO_Mopt.CFIM","text":"Choose CFI or \\(\\mathrm{Tr}(WI^{-1})\\) as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be \\(\\mathrm{Tr}(WI^{-1})\\) .","title":"CFIM()"},{"location":"API/python/classes/#measurement-optimization-with-de","text":"Bases: Measurement . MeasurementSystem","title":"Measurement Optimization with DE"},{"location":"API/python/classes/#quanestimation.DE_Mopt--attributes","text":"savefile: bool -- Whether or not to save all the measurements. If set True then the measurements and the values of the objective function obtained in all episodes will be saved during the training. If set False the measurement in the final episode and the values of the objective function in all episodes will be saved. p_num: int -- The number of populations. measurement0: list of arrays -- Initial guesses of measurements. max_episode: int -- The number of episodes. c: float -- Mutation constant. cr: float -- Crossover constant. seed: int -- Random seed. eps: float -- Machine epsilon. load: bool -- Whether or not to load measurements in the current location. If set True then the program will load measurement from \"measurements.csv\" file in the current location and use it as the initial measurement. Source code in quanestimation/MeasurementOpt/DE_Mopt.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 class DE_Mopt ( Measurement . MeasurementSystem ): \"\"\" Attributes ---------- > **savefile:** `bool` -- Whether or not to save all the measurements. If set `True` then the measurements and the values of the objective function obtained in all episodes will be saved during the training. If set `False` the measurement in the final episode and the values of the objective function in all episodes will be saved. > **p_num:** `int` -- The number of populations. > **measurement0:** `list of arrays` -- Initial guesses of measurements. > **max_episode:** `int` -- The number of episodes. > **c:** `float` -- Mutation constant. > **cr:** `float` -- Crossover constant. > **seed:** `int` -- Random seed. > **eps:** `float` -- Machine epsilon. > **load:** `bool` -- Whether or not to load measurements in the current location. If set `True` then the program will load measurement from \"measurements.csv\" file in the current location and use it as the initial measurement. \"\"\" def __init__ ( self , mtype , minput , savefile = False , p_num = 10 , measurement0 = [], max_episode = 1000 , c = 1.0 , cr = 0.5 , seed = 1234 , eps = 1e-8 , load = False , ): Measurement . MeasurementSystem . __init__ ( self , mtype , minput , savefile , measurement0 , seed , eps , load ) self . p_num = p_num self . max_episode = max_episode self . c = c self . cr = cr def CFIM ( self , W = []): r \"\"\" Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" ini_population = ([ self . measurement0 ],) self . alg = Main . QuanEstimation . DE ( self . max_episode , self . p_num , ini_population , self . c , self . cr , ) super () . CFIM ( W )","title":"Attributes"},{"location":"API/python/classes/#quanestimation.MeasurementOpt.DE_Mopt.DE_Mopt.CFIM","text":"Choose CFI or \\(\\mathrm{Tr}(WI^{-1})\\) as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be \\(\\mathrm{Tr}(WI^{-1})\\) .","title":"CFIM()"},{"location":"API/python/classes/#comprehensive-optimization","text":"In order to obtain the optimal parameter estimation schemes, it is necessary to simultaneously optimize the probe state, control and measurement. The comprehensive optimization for the probe state and measurement (SM), the probe state and control (SC), the control and measurement (CM) and the probe state, control and measurement (SCM) are proposed for this. In QuanEstimation, the comprehensive optimization algorithms are particle swarm optimization (PSO), differential evolution (DE), and automatic differentiation (AD).","title":"Comprehensive Optimization"},{"location":"API/python/classes/#base_3","text":"","title":"Base"},{"location":"API/python/classes/#quanestimation.ComprehensiveSystem--attributes","text":"savefile: bool -- Whether or not to save all the optimized variables (probe states, control coefficients and measurements). If set True then the optimized variables and the values of the objective function obtained in all episodes will be saved during the training. If set False the optimized variables in the final episode and the values of the objective function in all episodes will be saved. psi0: list of arrays -- Initial guesses of states. ctrl0: list of arrays -- Initial guesses of control coefficients. measurement0: list of arrays -- Initial guesses of measurements. seed: int -- Random seed. eps: float -- Machine epsilon. Source code in quanestimation/ComprehensiveOpt/ComprehensiveStruct.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 class ComprehensiveSystem : \"\"\" Attributes ---------- > **savefile:** `bool` -- Whether or not to save all the optimized variables (probe states, control coefficients and measurements). If set `True` then the optimized variables and the values of the objective function obtained in all episodes will be saved during the training. If set `False` the optimized variables in the final episode and the values of the objective function in all episodes will be saved. > **psi0:** `list of arrays` -- Initial guesses of states. > **ctrl0:** `list of arrays` -- Initial guesses of control coefficients. > **measurement0:** `list of arrays` -- Initial guesses of measurements. > **seed:** `int` -- Random seed. > **eps:** `float` -- Machine epsilon. \"\"\" def __init__ ( self , savefile , psi0 , ctrl0 , measurement0 , seed , eps ): self . savefile = savefile self . ctrl0 = ctrl0 self . psi0 = psi0 self . eps = eps self . seed = seed self . measurement0 = measurement0 def dynamics ( self , tspan , H0 , dH , Hc = [], ctrl = [], decay = [], ctrl_bound = []): r \"\"\" The dynamics of a density matrix is of the form \\begin{align} \\partial_t\\rho &=\\mathcal{L}\\rho \\nonumber \\\\ &=-i[H,\\rho]+\\sum_i \\gamma_i\\left(\\Gamma_i\\rho\\Gamma^{\\dagger}_i-\\frac{1}{2} \\left\\{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\right\\}\\right), \\end{align} where $\\rho$ is the evolved density matrix, H is the Hamiltonian of the system, $\\Gamma_i$ and $\\gamma_i$ are the $i\\mathrm{th}$ decay operator and corresponding decay rate. Parameters ---------- > **tspan:** `array` -- Time length for the evolution. > **H0:** `matrix or list` -- Free Hamiltonian. It is a matrix when the free Hamiltonian is time- independent and a list of length equal to `tspan` when it is time-dependent. > **dH:** `list` -- Derivatives of the free Hamiltonian on the unknown parameters to be estimated. For example, dH[0] is the derivative vector on the first parameter. > **Hc:** `list` -- Control Hamiltonians. > **ctrl:** `list of arrays` -- Control coefficients. > **decay:** `list` -- Decay operators and the corresponding decay rates. Its input rule is decay=[[$\\Gamma_1$, $\\gamma_1$], [$\\Gamma_2$,$\\gamma_2$],...], where $\\Gamma_1$ $(\\Gamma_2)$ represents the decay operator and $\\gamma_1$ $(\\gamma_2)$ is the corresponding decay rate. > **ctrl_bound:** `array` -- Lower and upper bounds of the control coefficients. `ctrl_bound[0]` represents the lower bound of the control coefficients and `ctrl_bound[1]` represents the upper bound of the control coefficients. \"\"\" self . tspan = tspan self . ctrl = ctrl self . Hc = Hc if type ( H0 ) == np . ndarray : self . freeHamiltonian = np . array ( H0 , dtype = np . complex128 ) self . dim = len ( self . freeHamiltonian ) else : self . freeHamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in H0 [: - 1 ]] self . dim = len ( self . freeHamiltonian [ 0 ]) if self . psi0 == []: np . random . seed ( self . seed ) r_ini = 2 * np . random . random ( self . dim ) - np . ones ( self . dim ) r = r_ini / np . linalg . norm ( r_ini ) phi = 2 * np . pi * np . random . random ( self . dim ) self . psi = np . array ([ r [ i ] * np . exp ( 1.0 j * phi [ i ]) for i in range ( self . dim )]) self . psi0 = [ self . psi ] else : self . psi = np . array ( self . psi0 [ 0 ], dtype = np . complex128 ) if Hc == []: Hc = [ np . zeros (( self . dim , self . dim ))] self . control_Hamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in Hc ] if type ( dH ) != list : raise TypeError ( \"The derivative of Hamiltonian should be a list!\" ) if dH == []: dH = [ np . zeros (( self . dim , self . dim ))] self . Hamiltonian_derivative = [ np . array ( x , dtype = np . complex128 ) for x in dH ] if len ( dH ) == 1 : self . para_type = \"single_para\" else : self . para_type = \"multi_para\" if decay == []: decay_opt = [ np . zeros (( self . dim , self . dim ))] self . gamma = [ 0.0 ] else : decay_opt = [ decay [ i ][ 0 ] for i in range ( len ( decay ))] self . gamma = [ decay [ i ][ 1 ] for i in range ( len ( decay ))] self . decay_opt = [ np . array ( x , dtype = np . complex128 ) for x in decay_opt ] if ctrl_bound == []: self . ctrl_bound = [ - np . inf , np . inf ] else : self . ctrl_bound = [ float ( ctrl_bound [ 0 ]), float ( ctrl_bound [ 1 ])] if self . ctrl0 == []: if ctrl_bound == []: ctrl0 = [ 2 * np . random . random ( len ( self . tspan ) - 1 ) - np . ones ( len ( self . tspan ) - 1 ) for i in range ( len ( self . control_Hamiltonian )) ] else : a = ctrl_bound [ 0 ] b = ctrl_bound [ 1 ] ctrl0 = [ ( b - a ) * np . random . random ( len ( self . tspan ) - 1 ) + a * np . ones ( len ( self . tspan ) - 1 ) for i in range ( len ( self . control_Hamiltonian )) ] self . control_coefficients = ctrl0 self . ctrl0 = [ np . array ( ctrl0 )] elif len ( self . ctrl0 ) >= 1 : self . control_coefficients = [ self . ctrl0 [ 0 ][ i ] for i in range ( len ( self . control_Hamiltonian )) ] ctrl_num = len ( self . control_coefficients ) Hc_num = len ( self . control_Hamiltonian ) if Hc_num < ctrl_num : raise TypeError ( \"There are %d control Hamiltonians but %d coefficients sequences: \\ too many coefficients sequences\" % ( Hc_num , ctrl_num ) ) elif Hc_num > ctrl_num : warnings . warn ( \"Not enough coefficients sequences: there are %d control Hamiltonians \\ but %d coefficients sequences. The rest of the control sequences are \\ set to be 0.\" % ( Hc_num , ctrl_num ), DeprecationWarning , ) for i in range ( Hc_num - ctrl_num ): self . control_coefficients = np . concatenate ( ( self . control_coefficients , np . zeros ( len ( self . control_coefficients [ 0 ])), ) ) else : pass if self . measurement0 == []: np . random . seed ( self . seed ) M = [[] for i in range ( self . dim )] for i in range ( self . dim ): r_ini = 2 * np . random . random ( self . dim ) - np . ones ( self . dim ) r = r_ini / np . linalg . norm ( r_ini ) phi = 2 * np . pi * np . random . random ( self . dim ) M [ i ] = [ r [ j ] * np . exp ( 1.0 j * phi [ j ]) for j in range ( self . dim )] self . C = gramschmidt ( np . array ( M )) self . measurement0 = [ np . array ([ self . C [ i ] for i in range ( self . dim )])] elif len ( self . measurement0 ) >= 1 : self . C = [ self . measurement0 [ 0 ][ i ] for i in range ( self . dim )] self . C = [ np . array ( x , dtype = np . complex128 ) for x in self . C ] if type ( H0 ) != np . ndarray : #### linear interpolation #### f = interp1d ( self . tspan , H0 , axis = 0 ) else : pass number = math . ceil (( len ( self . tspan ) - 1 ) / len ( self . control_coefficients [ 0 ])) if len ( self . tspan ) - 1 % len ( self . control_coefficients [ 0 ]) != 0 : tnum = number * len ( self . control_coefficients [ 0 ]) self . tspan = np . linspace ( self . tspan [ 0 ], self . tspan [ - 1 ], tnum + 1 ) if type ( H0 ) != np . ndarray : H0_inter = f ( self . tspan ) self . freeHamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in H0_inter [: - 1 ]] else : pass else : pass self . dynamics_type = \"dynamics\" def Kraus ( self , K , dK ): r \"\"\" The parameterization of a state is \\begin{align} \\rho=\\sum_i K_i\\rho_0K_i^{\\dagger}, \\end{align} where $\\rho$ is the evolved density matrix, $K_i$ is the Kraus operator. Parameters ---------- > **K:** `list` -- Kraus operators. > **dK:** `list` -- Derivatives of the Kraus operators on the unknown parameters to be estimated. For example, dK[0] is the derivative vector on the first parameter. \"\"\" k_num = len ( K ) para_num = len ( dK [ 0 ]) self . para_num = para_num dK_tp = [ [ np . array ( dK [ i ][ j ], dtype = np . complex128 ) for j in range ( para_num )] for i in range ( k_num ) ] self . K = [ np . array ( x , dtype = np . complex128 ) for x in K ] self . dK = dK_tp if para_num == 1 : self . para_type = \"single_para\" else : self . para_type = \"multi_para\" self . dim = len ( K [ 0 ]) if self . psi0 == []: np . random . seed ( self . seed ) r_ini = 2 * np . random . random ( self . dim ) - np . ones ( self . dim ) r = r_ini / np . linalg . norm ( r_ini ) phi = 2 * np . pi * np . random . random ( self . dim ) self . psi = np . array ([ r [ i ] * np . exp ( 1.0 j * phi [ i ]) for i in range ( self . dim )]) self . psi0 = [ self . psi ] else : self . psi = np . array ( self . psi0 [ 0 ], dtype = np . complex128 ) if self . measurement0 == []: np . random . seed ( self . seed ) M = [[] for i in range ( self . dim )] for i in range ( self . dim ): r_ini = 2 * np . random . random ( self . dim ) - np . ones ( self . dim ) r = r_ini / np . linalg . norm ( r_ini ) phi = 2 * np . pi * np . random . random ( self . dim ) M [ i ] = [ r [ i ] * np . exp ( 1.0 j * phi [ i ]) for i in range ( self . dim )] self . C = gramschmidt ( np . array ( M )) self . measurement0 = [ np . array ([ self . C [ i ] for i in range ( len ( self . psi ))])] elif len ( self . measurement0 ) >= 1 : self . C = [ self . measurement0 [ 0 ][ i ] for i in range ( len ( self . psi ))] self . C = [ np . array ( x , dtype = np . complex128 ) for x in self . C ] self . dynamic = Main . QuanEstimation . Kraus ( self . psi , self . K , self . dK ) self . dynamics_type = \"Kraus\" def SC ( self , W = [], M = [], target = \"QFIM\" , LDtype = \"SLD\" ): \"\"\" Comprehensive optimization of the probe state and control (SC). Parameters ---------- > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). > **target:** `string` -- Objective functions for comprehensive optimization. Options are: \"QFIM\" (default) -- choose QFI (QFIM) as the objective function. \"CFIM\" -- choose CFI (CFIM) as the objective function. \"HCRB\" -- choose HCRB as the objective function. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" if self . dynamics_type != \"dynamics\" : raise ValueError ( \"Supported type of dynamics is Lindblad.\" ) if W == []: W = np . eye ( len ( self . Hamiltonian_derivative )) self . W = W if M != []: M = [ np . array ( x , dtype = np . complex128 ) for x in M ] self . obj = Main . QuanEstimation . CFIM_obj ( M , self . W , self . eps , self . para_type ) else : if target == \"HCRB\" : if self . para_type == \"single_para\" : print ( \"Program terminated. In the single-parameter scenario, the HCRB is equivalent to the QFI. Please choose 'QFIM' as the objective function\" ) else : self . obj = Main . QuanEstimation . HCRB_obj ( self . W , self . eps , self . para_type ) elif target == \"QFIM\" and ( LDtype == \"SLD\" or LDtype == \"RLD\" or LDtype == \"LLD\" ): self . obj = Main . QuanEstimation . QFIM_obj ( self . W , self . eps , self . para_type , LDtype ) elif target == \"CFIM\" : M = SIC ( len ( self . psi )) self . obj = Main . QuanEstimation . CFIM_obj ( M , self . W , self . eps , self . para_type ) else : raise ValueError ( \"Please enter the correct values for target and LDtype. Supported target are 'QFIM', 'CFIM' and 'HCRB', supported LDtype are 'SLD', 'RLD' and 'LLD'.\" ) self . opt = Main . QuanEstimation . StateControlOpt ( psi = self . psi , ctrl = self . control_coefficients , ctrl_bound = self . ctrl_bound , seed = self . seed ) self . output = Main . QuanEstimation . Output ( self . opt , save = self . savefile ) self . dynamic = Main . QuanEstimation . Lindblad ( self . freeHamiltonian , self . Hamiltonian_derivative , self . control_Hamiltonian , self . control_coefficients , self . psi , self . tspan , self . decay_opt , self . gamma , ) system = Main . QuanEstimation . QuanEstSystem ( self . opt , self . alg , self . obj , self . dynamic , self . output ) Main . QuanEstimation . run ( system ) self . load_save_state () def CM ( self , rho0 , W = []): \"\"\" Comprehensive optimization of the control and measurement (CM). Parameters ---------- > **rho0:** `matrix` -- Initial state (density matrix). > **W:** `matrix` -- Weight matrix. \"\"\" if self . dynamics_type != \"dynamics\" : raise ValueError ( \"Supported type of dynamics is Lindblad.\" ) if W == []: W = np . eye ( len ( self . Hamiltonian_derivative )) self . W = W self . rho0 = np . array ( rho0 , dtype = np . complex128 ) self . obj = Main . QuanEstimation . CFIM_obj ([], self . W , self . eps , self . para_type ) self . opt = Main . QuanEstimation . ControlMeasurementOpt ( ctrl = self . control_coefficients , M = self . C , ctrl_bound = self . ctrl_bound , seed = self . seed ) self . output = Main . QuanEstimation . Output ( self . opt , save = self . savefile ) self . dynamic = Main . QuanEstimation . Lindblad ( self . freeHamiltonian , self . Hamiltonian_derivative , self . control_Hamiltonian , self . control_coefficients , rho0 , self . tspan , self . decay_opt , self . gamma , ) system = Main . QuanEstimation . QuanEstSystem ( self . opt , self . alg , self . obj , self . dynamic , self . output ) Main . QuanEstimation . run ( system ) self . load_save_meas () def SM ( self , W = []): \"\"\" Comprehensive optimization of the probe state and measurement (SM). Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" if self . dynamics_type == \"dynamics\" : if W == []: W = np . eye ( len ( self . Hamiltonian_derivative )) self . W = W if self . Hc == [] or self . ctrl == []: freeHamiltonian = self . freeHamiltonian else : ctrl_num = len ( self . ctrl ) Hc_num = len ( self . control_Hamiltonian ) if Hc_num < ctrl_num : raise TypeError ( \"There are %d control Hamiltonians but %d coefficients sequences: \\ too many coefficients sequences.\" % ( Hc_num , ctrl_num ) ) elif Hc_num > ctrl_num : warnings . warn ( \"Not enough coefficients sequences: there are %d control Hamiltonians \\ but %d coefficients sequences. The rest of the control sequences are \\ set to be 0.\" % ( Hc_num , ctrl_num ), DeprecationWarning , ) for i in range ( Hc_num - ctrl_num ): self . ctrl = np . concatenate ( ( self . ctrl , np . zeros ( len ( self . ctrl [ 0 ]))) ) else : pass if len ( self . ctrl [ 0 ]) == 1 : if type ( self . freeHamiltonian ) == np . ndarray : H0 = np . array ( self . freeHamiltonian , dtype = np . complex128 ) Hc = [ np . array ( x , dtype = np . complex128 ) for x in self . control_Hamiltonian ] Htot = H0 + sum ( [ self . control_Hamiltonian [ i ] * self . ctrl [ i ][ 0 ] for i in range ( ctrl_num ) ] ) freeHamiltonian = np . array ( Htot , dtype = np . complex128 ) else : H0 = [ np . array ( x , dtype = np . complex128 ) for x in self . freeHamiltonian ] Htot = [] for i in range ( len ( H0 )): Htot . append ( H0 [ i ] + sum ( [ self . control_Hamiltonian [ i ] * self . ctrl [ i ][ 0 ] for i in range ( ctrl_num ) ] ) ) freeHamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in Htot ] else : if type ( self . freeHamiltonian ) != np . ndarray : #### linear interpolation #### f = interp1d ( self . tspan , self . freeHamiltonian , axis = 0 ) else : pass number = math . ceil (( len ( self . tspan ) - 1 ) / len ( self . ctrl [ 0 ])) if len ( self . tspan ) - 1 % len ( self . ctrl [ 0 ]) != 0 : tnum = number * len ( self . ctrl [ 0 ]) self . tspan = np . linspace ( self . tspan [ 0 ], self . tspan [ - 1 ], tnum + 1 ) if type ( self . freeHamiltonian ) != np . ndarray : H0_inter = f ( self . tspan ) self . freeHamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in H0_inter ] else : pass else : pass if type ( self . freeHamiltonian ) == np . ndarray : H0 = np . array ( self . freeHamiltonian , dtype = np . complex128 ) Hc = [ np . array ( x , dtype = np . complex128 ) for x in self . control_Hamiltonian ] self . ctrl = [ np . array ( self . ctrl [ i ]) . repeat ( number ) for i in range ( len ( Hc ))] Htot = [] for i in range ( len ( self . ctrl [ 0 ])): S_ctrl = sum ( [ Hc [ j ] * self . ctrl [ j ][ i ] for j in range ( len ( self . ctrl ))] ) Htot . append ( H0 + S_ctrl ) freeHamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in Htot ] else : H0 = [ np . array ( x , dtype = np . complex128 ) for x in self . freeHamiltonian ] Hc = [ np . array ( x , dtype = np . complex128 ) for x in self . control_Hamiltonian ] self . ctrl = [ np . array ( self . ctrl [ i ]) . repeat ( number ) for i in range ( len ( Hc ))] Htot = [] for i in range ( len ( self . ctrl [ 0 ])): S_ctrl = sum ( [ Hc [ j ] * self . ctrl [ j ][ i ] for j in range ( len ( self . ctrl ))] ) Htot . append ( H0 [ i ] + S_ctrl ) freeHamiltonian = [ np . array ( x , dtype = np . complex128 ) for x in Htot ] self . dynamic = Main . QuanEstimation . Lindblad ( freeHamiltonian , self . Hamiltonian_derivative , self . psi , self . tspan , self . decay_opt , self . gamma , ) elif self . dynamics_type == \"Kraus\" : if W == []: W = np . eye ( self . para_num ) self . W = W else : raise ValueError ( \"Supported type of dynamics are Lindblad and Kraus.\" ) self . obj = Main . QuanEstimation . CFIM_obj ([], self . W , self . eps , self . para_type ) self . opt = Main . QuanEstimation . StateMeasurementOpt ( psi = self . psi , M = self . C , seed = self . seed ) self . output = Main . QuanEstimation . Output ( self . opt , save = self . savefile ) system = Main . QuanEstimation . QuanEstSystem ( self . opt , self . alg , self . obj , self . dynamic , self . output ) Main . QuanEstimation . run ( system ) self . load_save_state () self . load_save_meas () def SCM ( self , W = []): \"\"\" Comprehensive optimization of the probe state, control and measurement (SCM). Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" if self . dynamics_type != \"dynamics\" : raise ValueError ( \"Supported type of dynamics is Lindblad.\" ) if W == []: W = np . eye ( len ( self . Hamiltonian_derivative )) self . W = W self . obj = Main . QuanEstimation . CFIM_obj ([], self . W , self . eps , self . para_type ) self . opt = Main . QuanEstimation . StateControlMeasurementOpt ( psi = self . psi , ctrl = self . control_coefficients , M = self . C , ctrl_bound = self . ctrl_bound , seed = self . seed ) self . output = Main . QuanEstimation . Output ( self . opt , save = self . savefile ) self . dynamic = Main . QuanEstimation . Lindblad ( self . freeHamiltonian , self . Hamiltonian_derivative , self . control_Hamiltonian , self . control_coefficients , self . psi , self . tspan , self . decay_opt , self . gamma , ) system = Main . QuanEstimation . QuanEstSystem ( self . opt , self . alg , self . obj , self . dynamic , self . output ) Main . QuanEstimation . run ( system ) self . load_save_state () self . load_save_meas () def load_save_state ( self ): if os . path . exists ( \"states.csv\" ): file_load = open ( \"states.csv\" , \"r\" ) file_load = \"\" . join ([ i for i in file_load ]) . replace ( \"im\" , \"j\" ) file_load = \"\" . join ([ i for i in file_load ]) . replace ( \" \" , \"\" ) file_save = open ( \"states.csv\" , \"w\" ) file_save . writelines ( file_load ) file_save . close () else : pass def load_save_meas ( self ): if os . path . exists ( \"measurements.csv\" ): file_load = open ( \"measurements.csv\" , \"r\" ) file_load = \"\" . join ([ i for i in file_load ]) . replace ( \"im\" , \"j\" ) file_load = \"\" . join ([ i for i in file_load ]) . replace ( \" \" , \"\" ) file_save = open ( \"measurements.csv\" , \"w\" ) file_save . writelines ( file_load ) file_save . close () else : pass","title":"Attributes"},{"location":"API/python/classes/#quanestimation.ComprehensiveOpt.ComprehensiveStruct.ComprehensiveSystem.CM","text":"Comprehensive optimization of the control and measurement (CM).","title":"CM()"},{"location":"API/python/classes/#quanestimation.ComprehensiveOpt.ComprehensiveStruct.ComprehensiveSystem.Kraus","text":"The parameterization of a state is \\begin{align} \\rho=\\sum_i K_i\\rho_0K_i^{\\dagger}, \\end{align} where \\(\\rho\\) is the evolved density matrix, \\(K_i\\) is the Kraus operator.","title":"Kraus()"},{"location":"API/python/classes/#quanestimation.ComprehensiveOpt.ComprehensiveStruct.ComprehensiveSystem.SC","text":"Comprehensive optimization of the probe state and control (SC).","title":"SC()"},{"location":"API/python/classes/#quanestimation.ComprehensiveOpt.ComprehensiveStruct.ComprehensiveSystem.SCM","text":"Comprehensive optimization of the probe state, control and measurement (SCM).","title":"SCM()"},{"location":"API/python/classes/#quanestimation.ComprehensiveOpt.ComprehensiveStruct.ComprehensiveSystem.SM","text":"Comprehensive optimization of the probe state and measurement (SM).","title":"SM()"},{"location":"API/python/classes/#quanestimation.ComprehensiveOpt.ComprehensiveStruct.ComprehensiveSystem.dynamics","text":"The dynamics of a density matrix is of the form \\[\\begin{align} \\partial_t\\rho &=\\mathcal{L}\\rho \\nonumber \\\\ &=-i[H,\\rho]+\\sum_i \\gamma_i\\left(\\Gamma_i\\rho\\Gamma^{\\dagger}_i-\\frac{1}{2} \\left\\{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\right\\}\\right), \\end{align}\\] where \\(\\rho\\) is the evolved density matrix, H is the Hamiltonian of the system, \\(\\Gamma_i\\) and \\(\\gamma_i\\) are the \\(i\\mathrm{th}\\) decay operator and corresponding decay rate.","title":"dynamics()"},{"location":"API/python/classes/#comprehensive-optimization-with-ad","text":"Bases: Comp . ComprehensiveSystem","title":"Comprehensive optimization with AD"},{"location":"API/python/classes/#quanestimation.AD_Compopt--attributes","text":"savefile: bool -- Whether or not to save all the optimized variables (probe states, control coefficients and measurements). If set True then the optimized variables and the values of the objective function obtained in all episodes will be saved during the training. If set False the optimized variables in the final episode and the values of the objective function in all episodes will be saved. Adam: bool -- Whether or not to use Adam for updating. psi0: list of arrays -- Initial guesses of states. ctrl0: list of arrays -- Initial guesses of control coefficients. measurement0: list of arrays -- Initial guesses of measurements. max_episode: int -- The number of episodes. epsilon: float -- Learning rate. beta1: float -- The exponential decay rate for the first moment estimates. beta2: float -- The exponential decay rate for the second moment estimates. seed: int -- Random seed. eps: float -- Machine epsilon. Source code in quanestimation/ComprehensiveOpt/AD_Compopt.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 class AD_Compopt ( Comp . ComprehensiveSystem ): \"\"\" Attributes ---------- > **savefile:** `bool` -- Whether or not to save all the optimized variables (probe states, control coefficients and measurements). If set `True` then the optimized variables and the values of the objective function obtained in all episodes will be saved during the training. If set `False` the optimized variables in the final episode and the values of the objective function in all episodes will be saved. > **Adam:** `bool` -- Whether or not to use Adam for updating. > **psi0:** `list of arrays` -- Initial guesses of states. > **ctrl0:** `list of arrays` -- Initial guesses of control coefficients. > **measurement0:** `list of arrays` -- Initial guesses of measurements. > **max_episode:** `int` -- The number of episodes. > **epsilon:** `float` -- Learning rate. > **beta1:** `float` -- The exponential decay rate for the first moment estimates. > **beta2:** `float` -- The exponential decay rate for the second moment estimates. > **seed:** `int` -- Random seed. > **eps:** `float` -- Machine epsilon. \"\"\" def __init__ ( self , savefile = False , Adam = False , psi0 = [], ctrl0 = [], measurement0 = [], max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 , seed = 1234 , eps = 1e-8 , ): Comp . ComprehensiveSystem . __init__ ( self , savefile , psi0 , ctrl0 , measurement0 , seed , eps ) self . Adam = Adam self . max_episode = max_episode self . epsilon = epsilon self . beta1 = beta1 self . beta2 = beta2 self . mt = 0.0 self . vt = 0.0 self . seed = seed def SC ( self , W = [], M = [], target = \"QFIM\" , LDtype = \"SLD\" ): \"\"\" Comprehensive optimization of the probe state and control (SC). Parameters ---------- > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). > **target:** `string` -- Objective functions for searching the minimum time to reach the given value of the objective function. Options are: \"QFIM\" (default) -- choose QFI (QFIM) as the objective function. \"CFIM\" -- choose CFI (CFIM) as the objective function. \"HCRB\" -- choose HCRB as the objective function. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). **Note:** AD is only available when target is 'QFIM'. \"\"\" if M != []: raise ValueError ( \"AD is not available when target is 'CFIM'. Supported methods are 'PSO' and 'DE'.\" , ) elif target == \"HCRB\" : raise ValueError ( \"AD is not available when the target function is HCRB. Supported methods are 'PSO' and 'DE'.\" , ) if self . Adam : self . alg = Main . QuanEstimation . AD ( self . max_episode , self . epsilon , self . beta1 , self . beta2 ) else : self . alg = Main . QuanEstimation . AD ( self . max_episode , self . epsilon ) super () . SC ( W , M , target , LDtype )","title":"Attributes"},{"location":"API/python/classes/#quanestimation.ComprehensiveOpt.AD_Compopt.AD_Compopt.SC","text":"Comprehensive optimization of the probe state and control (SC).","title":"SC()"},{"location":"API/python/classes/#comprehensive-optimization-with-pso","text":"Bases: Comp . ComprehensiveSystem","title":"Comprehensive Optimization with PSO"},{"location":"API/python/classes/#quanestimation.PSO_Compopt--attributes","text":"savefile: bool -- Whether or not to save all the optimized variables (probe states, control coefficients and measurements). If set True then the optimized variables and the values of the objective function obtained in all episodes will be saved during the training. If set False the optimized variables in the final episode and the values of the objective function in all episodes will be saved. p_num: int -- The number of particles. psi0: list of arrays -- Initial guesses of states. ctrl0: list of arrays -- Initial guesses of control coefficients. measurement0: list of arrays -- Initial guesses of measurements. max_episode: int or list -- If it is an integer, for example max_episode=1000, it means the program will continuously run 1000 episodes. However, if it is an array, for example max_episode=[1000,100], the program will run 1000 episodes in total but replace states of all the particles with global best every 100 episodes. c0: float -- The damping factor that assists convergence, also known as inertia weight. c1: float -- The exploitation weight that attracts the particle to its best previous position, also known as cognitive learning factor. c2: float -- The exploitation weight that attracts the particle to the best position in the neighborhood, also known as social learning factor. seed: int -- Random seed. eps: float -- Machine epsilon. Source code in quanestimation/ComprehensiveOpt/PSO_Compopt.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 class PSO_Compopt ( Comp . ComprehensiveSystem ): \"\"\" Attributes ---------- > **savefile:** `bool` -- Whether or not to save all the optimized variables (probe states, control coefficients and measurements). If set `True` then the optimized variables and the values of the objective function obtained in all episodes will be saved during the training. If set `False` the optimized variables in the final episode and the values of the objective function in all episodes will be saved. > **p_num:** `int` -- The number of particles. > **psi0:** `list of arrays` -- Initial guesses of states. > **ctrl0:** `list of arrays` -- Initial guesses of control coefficients. > **measurement0:** `list of arrays` -- Initial guesses of measurements. > **max_episode:** `int or list` -- If it is an integer, for example max_episode=1000, it means the program will continuously run 1000 episodes. However, if it is an array, for example max_episode=[1000,100], the program will run 1000 episodes in total but replace states of all the particles with global best every 100 episodes. > **c0:** `float` -- The damping factor that assists convergence, also known as inertia weight. > **c1:** `float` -- The exploitation weight that attracts the particle to its best previous position, also known as cognitive learning factor. > **c2:** `float` -- The exploitation weight that attracts the particle to the best position in the neighborhood, also known as social learning factor. > **seed:** `int` -- Random seed. > **eps:** `float` -- Machine epsilon. \"\"\" def __init__ ( self , savefile = False , p_num = 10 , psi0 = [], ctrl0 = [], measurement0 = [], max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 , seed = 1234 , eps = 1e-8 , ): Comp . ComprehensiveSystem . __init__ ( self , savefile , psi0 , ctrl0 , measurement0 , seed , eps ) self . p_num = p_num self . max_episode = max_episode self . c0 = c0 self . c1 = c1 self . c2 = c2 self . seed = seed def SC ( self , W = [], M = [], target = \"QFIM\" , LDtype = \"SLD\" ): \"\"\" Comprehensive optimization of the probe state and control (SC). Parameters ---------- > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). > **target:** `string` -- Objective functions for searching the minimum time to reach the given value of the objective function. Options are: \"QFIM\" (default) -- choose QFI (QFIM) as the objective function. \"CFIM\" -- choose CFI (CFIM) as the objective function. \"HCRB\" -- choose HCRB as the objective function. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" ini_particle = ( self . psi0 , self . ctrl0 ) self . alg = Main . QuanEstimation . PSO ( self . max_episode , self . p_num , ini_particle , self . c0 , self . c1 , self . c2 , ) super () . SC ( W , M , target , LDtype ) def CM ( self , rho0 , W = []): \"\"\" Comprehensive optimization of the control and measurement (CM). Parameters ---------- > **rho0:** `matrix` -- Initial state (density matrix). > **W:** `matrix` -- Weight matrix. \"\"\" ini_particle = ( self . ctrl0 , self . measurement0 ) self . alg = Main . QuanEstimation . PSO ( self . max_episode , self . p_num , ini_particle , self . c0 , self . c1 , self . c2 , ) super () . CM ( rho0 , W ) def SM ( self , W = []): \"\"\" Comprehensive optimization of the probe state and measurement (SM). Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" ini_particle = ( self . psi0 , self . measurement0 ) self . alg = Main . QuanEstimation . PSO ( self . max_episode , self . p_num , ini_particle , self . c0 , self . c1 , self . c2 , ) super () . SM ( W ) def SCM ( self , W = []): \"\"\" Comprehensive optimization of the probe state, the control and measurements (SCM). Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" ini_particle = ( self . psi0 , self . ctrl0 , self . measurement0 ) self . alg = Main . QuanEstimation . PSO ( self . max_episode , self . p_num , ini_particle , self . c0 , self . c1 , self . c2 , ) super () . SCM ( W )","title":"Attributes"},{"location":"API/python/classes/#quanestimation.ComprehensiveOpt.PSO_Compopt.PSO_Compopt.CM","text":"Comprehensive optimization of the control and measurement (CM).","title":"CM()"},{"location":"API/python/classes/#quanestimation.ComprehensiveOpt.PSO_Compopt.PSO_Compopt.SC","text":"Comprehensive optimization of the probe state and control (SC).","title":"SC()"},{"location":"API/python/classes/#quanestimation.ComprehensiveOpt.PSO_Compopt.PSO_Compopt.SCM","text":"Comprehensive optimization of the probe state, the control and measurements (SCM).","title":"SCM()"},{"location":"API/python/classes/#quanestimation.ComprehensiveOpt.PSO_Compopt.PSO_Compopt.SM","text":"Comprehensive optimization of the probe state and measurement (SM).","title":"SM()"},{"location":"API/python/classes/#comprehensive-optimization-with-de","text":"Bases: Comp . ComprehensiveSystem","title":"Comprehensive Optimization with DE"},{"location":"API/python/classes/#quanestimation.DE_Compopt--attributes","text":"savefile: bool -- Whether or not to save all the optimized variables (probe states, control coefficients and measurements). If set True then the optimized variables and the values of the objective function obtained in all episodes will be saved during the training. If set False the optimized variables in the final episode and the values of the objective function in all episodes will be saved. p_num: int -- The number of populations. psi0: list of arrays -- Initial guesses of states. ctrl0: list of arrays -- Initial guesses of control coefficients. measurement0: list of arrays -- Initial guesses of measurements. max_episode: int -- The number of episodes. c: float -- Mutation constant. cr: float -- Crossover constant. seed: int -- Random seed. eps: float -- Machine epsilon. Source code in quanestimation/ComprehensiveOpt/DE_Compopt.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 class DE_Compopt ( Comp . ComprehensiveSystem ): \"\"\" Attributes ---------- > **savefile:** `bool` -- Whether or not to save all the optimized variables (probe states, control coefficients and measurements). If set `True` then the optimized variables and the values of the objective function obtained in all episodes will be saved during the training. If set `False` the optimized variables in the final episode and the values of the objective function in all episodes will be saved. > **p_num:** `int` -- The number of populations. > **psi0:** `list of arrays` -- Initial guesses of states. > **ctrl0:** `list of arrays` -- Initial guesses of control coefficients. > **measurement0:** `list of arrays` -- Initial guesses of measurements. > **max_episode:** `int` -- The number of episodes. > **c:** `float` -- Mutation constant. > **cr:** `float` -- Crossover constant. > **seed:** `int` -- Random seed. > **eps:** `float` -- Machine epsilon. \"\"\" def __init__ ( self , savefile = False , p_num = 10 , psi0 = [], ctrl0 = [], measurement0 = [], max_episode = 1000 , c = 1.0 , cr = 0.5 , seed = 1234 , eps = 1e-8 , ): Comp . ComprehensiveSystem . __init__ ( self , savefile , psi0 , ctrl0 , measurement0 , seed , eps ) self . p_num = p_num self . max_episode = max_episode self . c = c self . cr = cr self . seed = seed def SC ( self , W = [], M = [], target = \"QFIM\" , LDtype = \"SLD\" ): \"\"\" Comprehensive optimization of the probe state and control (SC). Parameters ---------- > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). > **target:** `string` -- Objective functions for searching the minimum time to reach the given value of the objective function. Options are: \"QFIM\" (default) -- choose QFI (QFIM) as the objective function. \"CFIM\" -- choose CFI (CFIM) as the objective function. \"HCRB\" -- choose HCRB as the objective function. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" ini_population = ( self . psi0 , self . ctrl0 ) self . alg = Main . QuanEstimation . DE ( self . max_episode , self . p_num , ini_population , self . c , self . cr , ) super () . SC ( W , M , target , LDtype ) def CM ( self , rho0 , W = []): \"\"\" Comprehensive optimization of the control and measurement (CM). Parameters ---------- > **rho0:** `matrix` -- Initial state (density matrix). > **W:** `matrix` -- Weight matrix. \"\"\" ini_population = ( self . ctrl0 , self . measurement0 ) self . alg = Main . QuanEstimation . DE ( self . max_episode , self . p_num , ini_population , self . c , self . cr , ) super () . CM ( rho0 , W ) def SM ( self , W = []): \"\"\" Comprehensive optimization of the probe state and measurement (SM). Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" ini_population = ( self . psi0 , self . measurement0 ) self . alg = Main . QuanEstimation . DE ( self . max_episode , self . p_num , ini_population , self . c , self . cr , ) super () . SM ( W ) def SCM ( self , W = []): \"\"\" Comprehensive optimization of the probe state, control and measurement (SCM). Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" ini_population = ( self . psi0 , self . ctrl0 , self . measurement0 ) self . alg = Main . QuanEstimation . DE ( self . max_episode , self . p_num , ini_population , self . c , self . cr , ) super () . SCM ( W )","title":"Attributes"},{"location":"API/python/classes/#quanestimation.ComprehensiveOpt.DE_Compopt.DE_Compopt.CM","text":"Comprehensive optimization of the control and measurement (CM).","title":"CM()"},{"location":"API/python/classes/#quanestimation.ComprehensiveOpt.DE_Compopt.DE_Compopt.SC","text":"Comprehensive optimization of the probe state and control (SC).","title":"SC()"},{"location":"API/python/classes/#quanestimation.ComprehensiveOpt.DE_Compopt.DE_Compopt.SCM","text":"Comprehensive optimization of the probe state, control and measurement (SCM).","title":"SCM()"},{"location":"API/python/classes/#quanestimation.ComprehensiveOpt.DE_Compopt.DE_Compopt.SM","text":"Comprehensive optimization of the probe state and measurement (SM).","title":"SM()"},{"location":"API/python/classes/#adaptive-measurement-schemes","text":"In QuanEstimation, the Hamiltonian of the adaptive system should be written as \\(H(\\textbf{x}+\\textbf{u})\\) with \\(\\textbf{x}\\) the unknown parameters and \\(\\textbf{u}\\) the tunable parameters. The tunable parameters \\(\\textbf{u}\\) are used to let the Hamiltonian work at the optimal point \\(\\textbf{x}_{\\mathrm{opt}}\\) .","title":"Adaptive measurement schemes"},{"location":"API/python/classes/#adaptive-measurement","text":"","title":"Adaptive measurement"},{"location":"API/python/classes/#quanestimation.Adaptive--attributes","text":"x: list -- The regimes of the parameters for the integral. p: multidimensional array -- The prior distribution. rho0: matrix -- Initial state (density matrix). savefile: bool -- Whether or not to save all the posterior distributions. If set True then three files \"pout.npy\", \"xout.npy\" and \"y.npy\" will be generated including the posterior distributions, the estimated values, and the experimental results in the iterations. If set False the posterior distribution in the final iteration, the estimated values and the experimental results in all iterations will be saved in \"pout.npy\", \"xout.npy\" and \"y.npy\". max_episode: int -- The number of episodes. eps: float -- Machine epsilon. Source code in quanestimation/AdaptiveScheme/Adaptive.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 class Adaptive : \"\"\" Attributes ---------- > **x:** `list` -- The regimes of the parameters for the integral. > **p:** `multidimensional array` -- The prior distribution. > **rho0:** `matrix` -- Initial state (density matrix). > **savefile:** `bool` -- Whether or not to save all the posterior distributions. If set `True` then three files \"pout.npy\", \"xout.npy\" and \"y.npy\" will be generated including the posterior distributions, the estimated values, and the experimental results in the iterations. If set `False` the posterior distribution in the final iteration, the estimated values and the experimental results in all iterations will be saved in \"pout.npy\", \"xout.npy\" and \"y.npy\". > **max_episode:** `int` -- The number of episodes. > **eps:** `float` -- Machine epsilon. \"\"\" def __init__ ( self , x , p , rho0 , savefile = False , max_episode = 1000 , eps = 1e-8 ): self . x = x self . p = p self . rho0 = np . array ( rho0 , dtype = np . complex128 ) self . max_episode = max_episode self . eps = eps self . para_num = len ( x ) self . savefile = savefile def dynamics ( self , tspan , H , dH , Hc = [], ctrl = [], decay = []): r \"\"\" Dynamics of the density matrix of the form \\begin{align} \\partial_t\\rho &=\\mathcal{L}\\rho \\nonumber \\\\ &=-i[H,\\rho]+\\sum_i \\gamma_i\\left(\\Gamma_i\\rho\\Gamma^{\\dagger}_i-\\frac{1}{2} \\left\\{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\right\\}\\right), \\end{align} where $\\rho$ is the evolved density matrix, H is the Hamiltonian of the system, $\\Gamma_i$ and $\\gamma_i$ are the $i\\mathrm{th}$ decay operator and decay rate. Parameters ---------- > **tspan:** `array` -- Time length for the evolution. > **H0:** `multidimensional list` -- Free Hamiltonian with respect to the values in x. > **dH:** `multidimensional list` -- Derivatives of the free Hamiltonian with respect to the unknown parameters to be estimated. > **Hc:** `list` -- Control Hamiltonians. > **ctrl:** `list` -- Control coefficients. > **decay:** `list` -- Decay operators and the corresponding decay rates. Its input rule is `decay=[[Gamma1, gamma1], [Gamma2,gamma2],...]`, where `Gamma1 (Gamma2)` represents the decay operator and `gamma1 (gamma2)` is the corresponding decay rate. \"\"\" self . tspan = tspan self . H = H self . dH = dH self . Hc = Hc self . ctrl = ctrl self . decay = decay self . dynamic_type = \"dynamics\" def Kraus ( self , K , dK ): r \"\"\" Dynamics of the density matrix of the form \\begin{align} \\rho=\\sum_i K_i\\rho_0K_i^{\\dagger} \\end{align} where $\\rho$ is the evolved density matrix, $K_i$ is the Kraus operator. Parameters ---------- > **K:** `multidimensional list` -- Kraus operator(s) with respect to the values in x. > **dK:** `multidimensional list` -- Derivatives of the Kraus operator(s) with respect to the unknown parameters to be estimated. \"\"\" self . K = K self . dK = dK self . dynamic_type = \"Kraus\" def CFIM ( self , M = [], W = []): r \"\"\" Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$. Parameters ---------- > **W:** `matrix` -- Weight matrix. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" if M == []: M = SIC ( len ( self . rho0 )) if W == []: W = np . eye ( len ( self . x )) self . W = W if self . dynamic_type == \"dynamics\" : adaptive_dynamics ( self . x , self . p , M , self . tspan , self . rho0 , self . H , self . dH , self . decay , self . Hc , self . ctrl , W , self . max_episode , self . eps , self . savefile , ) elif self . dynamic_type == \"Kraus\" : adaptive_Kraus ( self . x , self . p , M , self . rho0 , self . K , self . dK , W , self . max_episode , self . eps , self . savefile , ) else : raise ValueError ( \" {!r} is not a valid value for type of dynamics, supported values are 'dynamics' and 'Kraus'.\" . format ( self . dynamic_type ) ) def Mopt ( self , W = []): r \"\"\" Measurement optimization for the optimal x. Parameters ---------- > **W:** `matrix` -- Weight matrix. \"\"\" if W == []: W = np . identity ( self . para_num ) else : W = W if self . dynamic_type == \"dynamics\" : if self . para_num == 1 : F = [] for i in range ( len ( self . H )): dynamics = Lindblad ( self . tspan , self . rho0 , self . H [ i ], self . dH [ i ], decay = self . decay , Hc = self . Hc , ctrl = self . ctrl , ) rho_tp , drho_tp = dynamics . expm () rho , drho = rho_tp [ - 1 ], drho_tp [ - 1 ] F_tp = QFIM ( rho , drho ) F . append ( F_tp ) idx = np . argmax ( F ) H_res , dH_res = self . H [ idx ], self . dH [ idx ] else : p_ext = extract_ele ( self . p , self . para_num ) H_ext = extract_ele ( self . H , self . para_num ) dH_ext = extract_ele ( self . dH , self . para_num ) p_list , H_list , dH_list = [], [], [] for p_ele , H_ele , dH_ele in zip ( p_ext , H_ext , dH_ext ): p_list . append ( p_ele ) H_list . append ( H_ele ) dH_list . append ( dH_ele ) F = [] for i in range ( len ( p_list )): dynamics = Lindblad ( self . tspan , self . rho0 , self . H_list [ i ], self . dH_list [ i ], decay = self . decay , Hc = self . Hc , ctrl = self . ctrl , ) rho_tp , drho_tp = dynamics . expm () rho , drho = rho_tp [ - 1 ], drho_tp [ - 1 ] F_tp = QFIM ( rho , drho ) if np . linalg . det ( F_tp ) < self . eps : F . append ( self . eps ) else : F . append ( 1.0 / np . trace ( np . dot ( W , np . linalg . inv ( F_tp )))) idx = np . argmax ( F ) H_res , dH_res = self . H_list [ idx ], self . dH_list [ idx ] m = MeasurementOpt ( mtype = \"projection\" , minput = [], method = \"DE\" ) m . dynamics ( self . tspan , self . rho0 , H_res , dH_res , Hc = self . Hc , ctrl = self . ctrl , decay = self . decay , ) m . CFIM ( W = W ) elif self . dynamic_type == \"Kraus\" : if self . para_num == 1 : F = [] for hi in range ( len ( self . K )): rho_tp = sum ( [ np . dot ( Ki , np . dot ( self . rho0 , Ki . conj () . T )) for Ki in self . K [ hi ]] ) drho_tp = sum ( [ np . dot ( dKi , np . dot ( self . rho0 , Ki . conj () . T )) + np . dot ( Ki , np . dot ( self . rho0 , dKi . conj () . T )) for ( Ki , dKi ) in zip ( self . K [ hi ], self . dK [ hi ]) ] ) F_tp = QFIM ( rho_tp , drho_tp ) F . append ( F_tp ) idx = np . argmax ( F ) K_res , dK_res = self . K [ idx ], self . dK [ idx ] else : p_shape = np . shape ( self . p ) p_ext = extract_ele ( self . p , self . para_num ) K_ext = extract_ele ( self . K , self . para_num ) dK_ext = extract_ele ( self . dK , self . para_num ) p_list , K_list , dK_list = [], [], [] for K_ele , dK_ele in zip ( K_ext , dK_ext ): p_list . append ( p_ele ) K_list . append ( K_ele ) dK_list . append ( dK_ele ) F = [] for hi in range ( len ( p_list )): rho_tp = sum ( [ np . dot ( Ki , np . dot ( self . rho0 , Ki . conj () . T )) for Ki in K_list [ hi ]] ) dK_reshape = [ [ dK_list [ hi ][ i ][ j ] for i in range ( self . k_num )] for j in range ( self . para_num ) ] drho_tp = [ sum ( [ np . dot ( dKi , np . dot ( self . rho0 , Ki . conj () . T )) + np . dot ( Ki , np . dot ( self . rho0 , dKi . conj () . T )) for ( Ki , dKi ) in zip ( K_list [ hi ], dKj ) ] ) for dKj in dK_reshape ] F_tp = QFIM ( rho_tp , drho_tp ) if np . linalg . det ( F_tp ) < self . eps : F . append ( self . eps ) else : F . append ( 1.0 / np . trace ( np . dot ( W , np . linalg . inv ( F_tp )))) F = np . array ( F ) . reshape ( p_shape ) idx = np . where ( np . array ( F ) == np . max ( np . array ( F ))) K_res , dK_res = self . K_list [ idx ], self . dK_list [ idx ] m = MeasurementOpt ( mtype = \"projection\" , minput = [], method = \"DE\" ) m . Kraus ( self . rho0 , K_res , dK_res , decay = self . decay ) m . CFIM ( W = W ) else : raise ValueError ( \" {!r} is not a valid value for type of dynamics, supported values are 'dynamics' and 'Kraus'.\" . format ( self . dynamic_type ) )","title":"Attributes"},{"location":"API/python/classes/#quanestimation.AdaptiveScheme.Adaptive.Adaptive.CFIM","text":"Choose CFI or \\(\\mathrm{Tr}(WI^{-1})\\) as the objective function. In single parameter estimation the objective function is CFI and in multiparameter estimation it will be \\(\\mathrm{Tr}(WI^{-1})\\) .","title":"CFIM()"},{"location":"API/python/classes/#quanestimation.AdaptiveScheme.Adaptive.Adaptive.Kraus","text":"Dynamics of the density matrix of the form \\begin{align} \\rho=\\sum_i K_i\\rho_0K_i^{\\dagger} \\end{align} where \\(\\rho\\) is the evolved density matrix, \\(K_i\\) is the Kraus operator.","title":"Kraus()"},{"location":"API/python/classes/#quanestimation.AdaptiveScheme.Adaptive.Adaptive.Mopt","text":"Measurement optimization for the optimal x.","title":"Mopt()"},{"location":"API/python/classes/#quanestimation.AdaptiveScheme.Adaptive.Adaptive.dynamics","text":"Dynamics of the density matrix of the form \\[\\begin{align} \\partial_t\\rho &=\\mathcal{L}\\rho \\nonumber \\\\ &=-i[H,\\rho]+\\sum_i \\gamma_i\\left(\\Gamma_i\\rho\\Gamma^{\\dagger}_i-\\frac{1}{2} \\left\\{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\right\\}\\right), \\end{align}\\] where \\(\\rho\\) is the evolved density matrix, H is the Hamiltonian of the system, \\(\\Gamma_i\\) and \\(\\gamma_i\\) are the \\(i\\mathrm{th}\\) decay operator and decay rate.","title":"dynamics()"},{"location":"API/python/classes/#quanestimation.Adapt_MZI--attributes","text":"x: list -- The regimes of the parameters for the integral. p: multidimensional array -- The prior distribution. rho0: matrix -- Initial state (density matrix). Source code in quanestimation/AdaptiveScheme/Adapt_MZI.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 class Adapt_MZI : \"\"\" Attributes ---------- > **x:** `list` -- The regimes of the parameters for the integral. > **p:** `multidimensional array` -- The prior distribution. > **rho0:** `matrix` -- Initial state (density matrix). \"\"\" def __init__ ( self , x , p , rho0 ): self . x = x self . p = p self . rho0 = rho0 self . N = int ( np . sqrt ( len ( rho0 ))) - 1 self . a = annihilation ( self . N + 1 ) def general ( self ): self . MZI_type = \"general\" def online ( self , output = \"phi\" ): \"\"\" Parameters ---------- > **output:** `string` -- The output the class. Options are: \"phi\" (default) -- The tunable phase. \"dphi\" -- Phase difference. \"\"\" phi = Main . QuanEstimation . adaptMZI_online ( self . x , self . p , self . rho0 , self . a , output ) def offline ( self , method = \"DE\" , p_num = 10 , deltaphi0 = [], c = 1.0 , cr = 0.5 , c0 = 1.0 , c1 = 2.0 , c2 = 2.0 , seed = 1234 , max_episode = 1000 , eps = 1e-8 , ): \"\"\" Parameters ---------- > **method:** `string` -- The method for the adaptive phase estimation. Options are: \"DE\" (default) -- DE algorithm for the adaptive phase estimation. \"PSO\" -- PSO algorithm for the adaptive phase estimation. If the `method=DE`, the parameters are: > **p_num:** `int` -- The number of populations. > **deltaphi0:** `list` -- Initial guesses of phase difference. > **max_episode:** `int` -- The number of episodes. > **c:** `float` -- Mutation constant. > **cr:** `float` -- Crossover constant. > **seed:** `int` -- Random seed. > **eps:** `float` -- Machine epsilon. If the `method=PSO`, the parameters are: > **deltaphi0:** `list` -- Initial guesses of phase difference. > **max_episode:** `int or list` -- If it is an integer, for example max_episode=1000, it means the program will continuously run 1000 episodes. However, if it is an array, for example max_episode=[1000,100], the program will run 1000 episodes in total but replace states of all the particles with global best every 100 episodes. > **c0:** `float` -- The damping factor that assists convergence, also known as inertia weight. > **c1:** `float` -- The exploitation weight that attracts the particle to its best previous position, also known as cognitive learning factor. > **c2:** `float` -- The exploitation weight that attracts the particle to the best position in the neighborhood, also known as social learning factor. > **eps:** `float` -- Machine epsilon. \"\"\" comb_tp = brgd ( self . N ) comb = [ np . array ([ int ( list ( comb_tp [ i ])[ j ]) for j in range ( self . N )]) for i in range ( 2 ** self . N ) ] if method == \"DE\" : Main . QuanEstimation . DE_deltaphiOpt ( self . x , self . p , self . rho0 , self . a , comb , p_num , deltaphi0 , c , cr , seed , max_episode , eps , ) elif method == \"PSO\" : Main . QuanEstimation . PSO_deltaphiOpt ( self . x , self . p , self . rho0 , self . a , comb , p_num , deltaphi0 , c0 , c1 , c2 , seed , max_episode , eps , ) else : raise ValueError ( \" {!r} is not a valid value for method, supported values are 'DE' and 'PSO'.\" . format ( method ) )","title":"Attributes"},{"location":"API/python/classes/#quanestimation.AdaptiveScheme.Adapt_MZI.Adapt_MZI.offline","text":"","title":"offline()"},{"location":"API/python/classes/#quanestimation.AdaptiveScheme.Adapt_MZI.Adapt_MZI.online","text":"","title":"online()"},{"location":"API/python/functions/","text":"This part is the functions of the Python-Julia package which written in Python. Kraus \u00b6 The parameterization of a state is \\begin{align} \\rho=\\sum_i K_i\\rho_0K_i^{\\dagger}, \\end{align} where \\(\\rho\\) is the evolved density matrix, \\(K_i\\) is the Kraus operator. Parameters \u00b6 K: list -- Kraus operators. dK: list -- Derivatives of the Kraus operators with respect to the unknown parameters to be estimated. For example, dK[0] is the derivative vector on the first parameter. rho0: matrix -- Initial state (density matrix). Returns \u00b6 Density matrix and its derivatives on the unknown parameters. Source code in quanestimation/Parameterization/NonDynamics.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def Kraus ( rho0 , K , dK ): r \"\"\" The parameterization of a state is \\begin{align} \\rho=\\sum_i K_i\\rho_0K_i^{\\dagger}, \\end{align} where $\\rho$ is the evolved density matrix, $K_i$ is the Kraus operator. Parameters ---------- > **K:** `list` -- Kraus operators. > **dK:** `list` -- Derivatives of the Kraus operators with respect to the unknown parameters to be estimated. For example, dK[0] is the derivative vector on the first parameter. > **rho0:** `matrix` -- Initial state (density matrix). Returns ---------- Density matrix and its derivatives on the unknown parameters. \"\"\" k_num = len ( K ) para_num = len ( dK [ 0 ]) dK_reshape = [[ dK [ i ][ j ] for i in range ( k_num )] for j in range ( para_num )] rho = sum ([ np . dot ( Ki , np . dot ( rho0 , Ki . conj () . T )) for Ki in K ]) drho = [ sum ([( np . dot ( dKi , np . dot ( rho0 , Ki . conj () . T )) + np . dot ( Ki , np . dot ( rho0 , dKi . conj () . T ))) for ( Ki , dKi ) in zip ( K , dKj )]) for dKj in dK_reshape ] return rho , drho Metrological resources \u00b6 Calculation of spin squeezing parameter for a density matrix. Parameters \u00b6 rho: matrix -- Density matrix. basis: string -- The basis of the state. Options are: \"Dicke\" (default) -- Dicke basis. \"Pauli\" -- The original basis of each spin. output: string -- Types of spin squeezing can be calculated. Options are: \"KU\" (default) -- Spin squeezing defined by Kitagawa and Ueda. \"WBIMH\" -- Spin squeezing defined by Wineland et al. Returns \u00b6 \\(\\xi\\) : float -- spin squeezing parameter Source code in quanestimation/Resource/Resource.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 def SpinSqueezing ( rho , basis = \"Dicke\" , output = \"KU\" ): r \"\"\" Calculation of spin squeezing parameter for a density matrix. Parameters ---------- > **rho:** `matrix` -- Density matrix. > **basis:** `string` -- The basis of the state. Options are: \"Dicke\" (default) -- Dicke basis. \"Pauli\" -- The original basis of each spin. > **output:** `string` -- Types of spin squeezing can be calculated. Options are: \"KU\" (default) -- Spin squeezing defined by Kitagawa and Ueda. \"WBIMH\" -- Spin squeezing defined by Wineland et al. Returns ---------- **$\\xi$:** `float` -- spin squeezing parameter \"\"\" N = len ( rho ) - 1 coef = 4.0 / float ( N ) j = N / 2 if basis == \"Pauli\" : sp = np . array ([[ 0.0 , 1.0 ],[ 0.0 , 0.0 ]]) jp = [] for i in range ( 0 , N ): if i == 0 : jp_tp = np . kron ( sp , np . identity ( 2 ** ( N - 1 ))) elif i == N - 1 : jp_tp = np . kron ( np . identity ( 2 ** ( N - 1 )), sp ) else : jp_tp = np . kron ( np . identity ( 2 ** i ), np . kron ( sp , np . identity ( 2 ** ( N - 1 - i )))) jp . append ( jp_tp ) Jp = sum ( jp ) else : offdiag = [ np . sqrt ( float ( j * ( j + 1 ) - m * ( m + 1 ))) for m in np . arange ( j , - j - 1 , - 1 ) ][ 1 :] Jp = np . matrix ( np . diag ( offdiag , 1 )) Jx = 0.5 * ( Jp + Jp . H ) Jy = - 0.5 * 1 j * ( Jp - Jp . H ) Jz = np . diag ( np . arange ( j , - j - 1 , - 1 )) Jx_mean = np . trace ( rho * Jx ) Jy_mean = np . trace ( rho * Jy ) Jz_mean = np . trace ( rho * Jz ) costheta = Jz_mean / np . sqrt ( Jx_mean ** 2 + Jy_mean ** 2 + Jz_mean ** 2 ) sintheta = np . sin ( np . arccos ( costheta )) cosphi = Jx_mean / np . sqrt ( Jx_mean ** 2 + Jy_mean ** 2 ) if Jy_mean > 0 : sinphi = np . sin ( np . arccos ( cosphi )) else : sinphi = np . sin ( 2 * np . pi - np . arccos ( cosphi )) Jn1 = - Jx * sinphi + Jy * cosphi Jn2 = - Jx * costheta * cosphi - Jy * costheta * sinphi + Jz * sintheta A = np . trace ( rho * ( Jn1 * Jn1 - Jn2 * Jn2 )) B = np . trace ( rho * ( Jn1 * Jn2 + Jn2 * Jn1 )) C = np . trace ( rho * ( Jn1 * Jn1 + Jn2 * Jn2 )) V_minus = 0.5 * ( C - np . sqrt ( A ** 2 + B ** 2 )) V_minus = np . real ( V_minus ) Xi = coef * V_minus if Xi > 1.0 : Xi = 1.0 if output == \"KU\" : Xi = Xi elif output == \"WBIMH\" : Xi = ( N / 2 ) ** 2 * Xi / ( Jx_mean ** 2 + Jy_mean ** 2 + Jz_mean ** 2 ) else : raise NameError ( \"NameError: output should be choosen in {KU, WBIMH}\" ) return Xi Calculation of the time to reach a given precision limit. Parameters \u00b6 f: float -- The given value of the objective function. tspan: array -- Time length for the evolution. func: array -- The function for calculating the objective function. *args: string -- The corresponding input parameter. **kwargs: string -- Keyword arguments in func . Returns \u00b6 time: float -- Time to reach the given target. Source code in quanestimation/Resource/Resource.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 def TargetTime ( f , tspan , func , * args , ** kwargs ): \"\"\" Calculation of the time to reach a given precision limit. Parameters ---------- > **f:** `float` -- The given value of the objective function. > **tspan:** `array` -- Time length for the evolution. > **func:** `array` -- The function for calculating the objective function. > ***args:** `string` -- The corresponding input parameter. > ****kwargs:** `string` -- Keyword arguments in `func`. Returns ---------- **time:** `float` -- Time to reach the given target. \"\"\" args = list ( zip_broadcast ( * args )) f_last = func ( * ( args [ 0 ]), ** kwargs ) idx = 1 f_now = func ( * ( args [ 1 ]), ** kwargs ) while ( f_now - f ) * ( f_last - f ) > 0 and idx < ( len ( tspan ) - 1 ): f_last = f_now idx += 1 f_now = func ( * ( args [ idx ]), ** kwargs ) return tspan [ idx ] Quantum Cram\u00e9r-Rao bounds \u00b6 Calculation of the symmetric logarithmic derivative (SLD) for a density matrix. The SLD operator \\(L_a\\) is determined by \\begin{align} \\partial_{a}\\rho=\\frac{1}{2}(\\rho L_{a}+L_{a}\\rho) \\end{align} with \\(\\rho\\) the parameterized density matrix. The entries of SLD can be calculated as \\begin{align} \\langle\\lambda_i|L_{a}|\\lambda_j\\rangle=\\frac{2\\langle\\lambda_i| \\partial_{a}\\rho |\\lambda_j\\rangle}{\\lambda_i+\\lambda_j} \\end{align} for \\(\\lambda_i~(\\lambda_j) \\neq 0\\) . If \\(\\lambda_i=\\lambda_j=0\\) , the entry of SLD is set to be zero. Parameters \u00b6 rho: matrix -- Density matrix. drho: list -- Derivatives of the density matrix on the unknown parameters to be estimated. For example, drho[0] is the derivative vector on the first parameter. rep: string -- The basis for the SLDs. Options are: \"original\" (default) -- it means the basis is the same with the input density matrix (rho). \"eigen\" -- it means the basis is the same with theeigenspace of the density matrix (rho). eps: float -- Machine epsilon. Returns \u00b6 SLD(s): matrix or list --For single parameter estimation (the length of drho is equal to one), the output is a matrix and for multiparameter estimation (the length of drho is more than one), it returns a list. Source code in quanestimation/AsymptoticBound/CramerRao.py 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 def SLD ( rho , drho , rep = \"original\" , eps = 1e-8 ): r \"\"\" Calculation of the symmetric logarithmic derivative (SLD) for a density matrix. The SLD operator $L_a$ is determined by \\begin{align} \\partial_{a}\\rho=\\frac{1}{2}(\\rho L_{a}+L_{a}\\rho) \\end{align} with $\\rho$ the parameterized density matrix. The entries of SLD can be calculated as \\begin{align} \\langle\\lambda_i|L_{a}|\\lambda_j\\rangle=\\frac{2\\langle\\lambda_i| \\partial_{a}\\rho |\\lambda_j\\rangle}{\\lambda_i+\\lambda_j} \\end{align} for $\\lambda_i~(\\lambda_j) \\neq 0$. If $\\lambda_i=\\lambda_j=0$, the entry of SLD is set to be zero. Parameters ---------- > **rho:** `matrix` -- Density matrix. > **drho:** `list` -- Derivatives of the density matrix on the unknown parameters to be estimated. For example, drho[0] is the derivative vector on the first parameter. > **rep:** `string` -- The basis for the SLDs. Options are: \"original\" (default) -- it means the basis is the same with the input density matrix (rho). \"eigen\" -- it means the basis is the same with theeigenspace of the density matrix (rho). > **eps:** `float` -- Machine epsilon. Returns ---------- **SLD(s):** `matrix or list` --For single parameter estimation (the length of drho is equal to one), the output is a matrix and for multiparameter estimation (the length of drho is more than one), it returns a list. \"\"\" if type ( drho ) != list : raise TypeError ( \"Please make sure drho is a list!\" ) para_num = len ( drho ) dim = len ( rho ) SLD = [[] for i in range ( 0 , para_num )] purity = np . trace ( np . dot ( rho , rho )) if np . abs ( 1 - purity ) < eps : SLD_org = [[] for i in range ( 0 , para_num )] for para_i in range ( 0 , para_num ): SLD_org [ para_i ] = 2 * drho [ para_i ] if rep == \"original\" : SLD [ para_i ] = SLD_org [ para_i ] elif rep == \"eigen\" : val , vec = np . linalg . eig ( rho ) val = np . real ( val ) SLD [ para_i ] = np . dot ( vec . conj () . transpose (), np . dot ( SLD_org [ para_i ], vec ) ) else : raise ValueError ( \" {!r} is not a valid value for rep, supported values are 'original' and 'eigen'.\" . format ( rep )) if para_num == 1 : return SLD [ 0 ] else : return SLD else : val , vec = np . linalg . eig ( rho ) val = np . real ( val ) for para_i in range ( 0 , para_num ): SLD_eig = np . array ( [[ 0.0 + 0.0 * 1.0 j for i in range ( 0 , dim )] for i in range ( 0 , dim )] ) for fi in range ( 0 , dim ): for fj in range ( 0 , dim ): if np . abs ( val [ fi ] + val [ fj ]) > eps : SLD_eig [ fi ][ fj ] = ( 2 * np . dot ( vec [:, fi ] . conj () . transpose (), np . dot ( drho [ para_i ], vec [:, fj ]), ) / ( val [ fi ] + val [ fj ]) ) SLD_eig [ SLD_eig == np . inf ] = 0.0 if rep == \"original\" : SLD [ para_i ] = np . dot ( vec , np . dot ( SLD_eig , vec . conj () . transpose ())) elif rep == \"eigen\" : SLD [ para_i ] = SLD_eig else : raise ValueError ( \" {!r} is not a valid value for rep, supported values are 'original' and 'eigen'.\" . format ( rep )) if para_num == 1 : return SLD [ 0 ] else : return SLD Calculation of the right logarithmic derivative (RLD) for a density matrix. The RLD operator defined by \\(\\partial_{a}\\rho=\\rho \\mathcal{R}_a\\) with \\(\\rho\\) the parameterized density matrix. \\begin{align} \\langle\\lambda_i| \\mathcal{R}_{a} |\\lambda_j\\rangle=\\frac{1}{\\lambda_i}\\langle\\lambda_i| \\partial_a\\rho |\\lambda_j\\rangle \\end{align} for \\(\\lambda_i\\neq 0\\) is the \\(ij\\) th entry of RLD. Parameters \u00b6 rho: matrix -- Density matrix. drho: list -- Derivatives of the density matrix on the unknown parameters to be estimated. For example, drho[0] is the derivative vector on the first parameter. rep: string -- The basis for the RLD(s). Options are: \"original\" (default) -- it means the basis is the same with the input density matrix (rho). \"eigen\" -- it means the basis is the same with the eigenspace of the density matrix (rho). eps: float -- Machine epsilon. Returns \u00b6 RLD(s): matrix or list -- For single parameter estimation (the length of drho is equal to one), the output is a matrix and for multiparameter estimation (the length of drho is more than one), it returns a list. Source code in quanestimation/AsymptoticBound/CramerRao.py 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 def RLD ( rho , drho , rep = \"original\" , eps = 1e-8 ): r \"\"\" Calculation of the right logarithmic derivative (RLD) for a density matrix. The RLD operator defined by $\\partial_{a}\\rho=\\rho \\mathcal{R}_a$ with $\\rho$ the parameterized density matrix. \\begin{align} \\langle\\lambda_i| \\mathcal{R}_{a} |\\lambda_j\\rangle=\\frac{1}{\\lambda_i}\\langle\\lambda_i| \\partial_a\\rho |\\lambda_j\\rangle \\end{align} for $\\lambda_i\\neq 0$ is the $ij$th entry of RLD. Parameters ---------- > **rho:** `matrix` -- Density matrix. > **drho:** `list` -- Derivatives of the density matrix on the unknown parameters to be estimated. For example, drho[0] is the derivative vector on the first parameter. > **rep:** `string` -- The basis for the RLD(s). Options are: \"original\" (default) -- it means the basis is the same with the input density matrix (rho). \"eigen\" -- it means the basis is the same with the eigenspace of the density matrix (rho). > **eps:** `float` -- Machine epsilon. Returns ---------- **RLD(s):** `matrix or list` -- For single parameter estimation (the length of drho is equal to one), the output is a matrix and for multiparameter estimation (the length of drho is more than one), it returns a list. \"\"\" if type ( drho ) != list : raise TypeError ( \"Please make sure drho is a list!\" ) para_num = len ( drho ) dim = len ( rho ) RLD = [[] for i in range ( 0 , para_num )] val , vec = np . linalg . eig ( rho ) val = np . real ( val ) for para_i in range ( 0 , para_num ): RLD_eig = np . array ( [[ 0.0 + 0.0 * 1.0 j for i in range ( 0 , dim )] for i in range ( 0 , dim )] ) for fi in range ( 0 , dim ): for fj in range ( 0 , dim ): term_tp = np . dot ( vec [:, fi ] . conj () . transpose (), np . dot ( drho [ para_i ], vec [:, fj ])) if np . abs ( val [ fi ]) > eps : RLD_eig [ fi ][ fj ] = ( term_tp / val [ fi ]) else : if np . abs ( term_tp ) < eps : raise ValueError ( \"The RLD does not exist. It only exist when the support of drho is contained in the support of rho.\" , ) RLD_eig [ RLD_eig == np . inf ] = 0.0 if rep == \"original\" : RLD [ para_i ] = np . dot ( vec , np . dot ( RLD_eig , vec . conj () . transpose ())) elif rep == \"eigen\" : RLD [ para_i ] = RLD_eig else : raise ValueError ( \" {!r} is not a valid value for rep, supported values are 'original' and 'eigen'.\" . format ( rep )) if para_num == 1 : return RLD [ 0 ] else : return RLD Calculation of the left logarithmic derivative (LLD) for a density matrix \\(\\rho\\) . The LLD operator is defined by \\(\\partial_{a}\\rho=\\mathcal{R}_a^{\\dagger}\\rho\\) . The entries of LLD can be calculated as \\begin{align} \\langle\\lambda_i| \\mathcal{R}_{a}^{\\dagger} |\\lambda_j\\rangle=\\frac{1}{\\lambda_j}\\langle\\lambda_i| \\partial_a\\rho |\\lambda_j\\rangle \\end{align} for \\(\\lambda_j\\neq 0\\) . Parameters \u00b6 rho: matrix -- Density matrix. drho: list -- Derivatives of the density matrix on the unknown parameters to be estimated. For example, drho[0] is the derivative vector on the first parameter. rep: string -- The basis for the LLD(s). Options are: \"original\" (default) -- it means the basis is the same with the input density matrix (rho). \"eigen\" -- it means the basis is the same with the eigenspace of the density matrix (rho). eps: float -- Machine epsilon. Returns \u00b6 LLD(s): matrix or list -- For single parameter estimation (the length of drho is equal to one), the output is a matrix and for multiparameter estimation (the length of drho is more than one), it returns a list. Source code in quanestimation/AsymptoticBound/CramerRao.py 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 def LLD ( rho , drho , rep = \"original\" , eps = 1e-8 ): r \"\"\" Calculation of the left logarithmic derivative (LLD) for a density matrix $\\rho$. The LLD operator is defined by $\\partial_{a}\\rho=\\mathcal{R}_a^{\\dagger}\\rho$. The entries of LLD can be calculated as \\begin{align} \\langle\\lambda_i| \\mathcal{R}_{a}^{\\dagger} |\\lambda_j\\rangle=\\frac{1}{\\lambda_j}\\langle\\lambda_i| \\partial_a\\rho |\\lambda_j\\rangle \\end{align} for $\\lambda_j\\neq 0$. Parameters ---------- > **rho:** `matrix` -- Density matrix. > **drho:** `list` -- Derivatives of the density matrix on the unknown parameters to be estimated. For example, drho[0] is the derivative vector on the first parameter. > **rep:** `string` -- The basis for the LLD(s). Options are: \"original\" (default) -- it means the basis is the same with the input density matrix (rho). \"eigen\" -- it means the basis is the same with the eigenspace of the density matrix (rho). > **eps:** float -- Machine epsilon. Returns ---------- **LLD(s):** `matrix or list` -- For single parameter estimation (the length of drho is equal to one), the output is a matrix and for multiparameter estimation (the length of drho is more than one), it returns a list. \"\"\" if type ( drho ) != list : raise TypeError ( \"Please make sure drho is a list!\" ) para_num = len ( drho ) dim = len ( rho ) LLD = [[] for i in range ( 0 , para_num )] val , vec = np . linalg . eig ( rho ) val = np . real ( val ) for para_i in range ( 0 , para_num ): LLD_eig = np . array ( [[ 0.0 + 0.0 * 1.0 j for i in range ( 0 , dim )] for i in range ( 0 , dim )] ) for fi in range ( 0 , dim ): for fj in range ( 0 , dim ): term_tp = np . dot ( vec [:, fi ] . conj () . transpose (), np . dot ( drho [ para_i ], vec [:, fj ]),) if np . abs ( val [ fj ]) > eps : LLD_eig_tp = ( term_tp / val [ fj ]) LLD_eig [ fj ][ fi ] = LLD_eig_tp . conj () else : if np . abs ( term_tp ) < eps : raise ValueError ( \"The LLD does not exist. It only exist when the support of drho is contained in the support of rho.\" , ) LLD_eig [ LLD_eig == np . inf ] = 0.0 if rep == \"original\" : LLD [ para_i ] = np . dot ( vec , np . dot ( LLD_eig , vec . conj () . transpose ())) elif rep == \"eigen\" : LLD [ para_i ] = LLD_eig else : raise ValueError ( \" {!r} is not a valid value for rep, supported values are 'original' and 'eigen'.\" . format ( rep )) if para_num == 1 : return LLD [ 0 ] else : return LLD Calculation of the quantum Fisher information (QFI) and quantum Fisher information matrix (QFIM) for all types. The entry of QFIM \\(\\mathcal{F}\\) is defined as \\begin{align} \\mathcal{F}_{ab}=\\frac{1}{2}\\mathrm{Tr}(\\rho{L_a, L_b}) \\end{align} with \\(L_a, L_b\\) are SLD operators and and \\begin{align} \\mathcal{F}_{ab}=\\mathrm{Tr}(\\rho \\mathcal{R}_a \\mathcal{R}^{\\dagger}_b) \\end{align} with \\(\\mathcal{R}_a\\) the RLD or LLD operator. Parameters \u00b6 rho: matrix -- Density matrix. drho: list Derivatives of the density matrix on the unknown parameters to be estimated. For example, drho[0] is the derivative vector on the first parameter. LDtype: string -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). exportLD: bool -- Whether or not to export the values of logarithmic derivatives. If set True then the the values of logarithmic derivatives will be exported. eps: float -- Machine epsilon. Returns \u00b6 QFI or QFIM: float or matrix -- For single parameter estimation (the length of drho is equal to one), the output is QFI and for multiparameter estimation (the length of drho is more than one), it returns QFIM. Source code in quanestimation/AsymptoticBound/CramerRao.py 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 def QFIM ( rho , drho , LDtype = \"SLD\" , exportLD = False , eps = 1e-8 ): r \"\"\" Calculation of the quantum Fisher information (QFI) and quantum Fisher information matrix (QFIM) for all types. The entry of QFIM $\\mathcal{F}$ is defined as \\begin{align} \\mathcal{F}_{ab}=\\frac{1}{2}\\mathrm{Tr}(\\rho\\{L_a, L_b\\}) \\end{align} with $L_a, L_b$ are SLD operators and and \\begin{align} \\mathcal{F}_{ab}=\\mathrm{Tr}(\\rho \\mathcal{R}_a \\mathcal{R}^{\\dagger}_b) \\end{align} with $\\mathcal{R}_a$ the RLD or LLD operator. Parameters ---------- > **rho:** `matrix` -- Density matrix. > **drho:** `list` Derivatives of the density matrix on the unknown parameters to be estimated. For example, drho[0] is the derivative vector on the first parameter. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). > **exportLD:** `bool` -- Whether or not to export the values of logarithmic derivatives. If set True then the the values of logarithmic derivatives will be exported. > **eps:** `float` -- Machine epsilon. Returns ---------- **QFI or QFIM:** `float or matrix` -- For single parameter estimation (the length of drho is equal to one), the output is QFI and for multiparameter estimation (the length of drho is more than one), it returns QFIM. \"\"\" if type ( drho ) != list : raise TypeError ( \"Please make sure drho is a list\" ) para_num = len ( drho ) # single parameter estimation if para_num == 1 : if LDtype == \"SLD\" : LD_tp = SLD ( rho , drho , eps = eps ) SLD_ac = np . dot ( LD_tp , LD_tp ) + np . dot ( LD_tp , LD_tp ) QFIM_res = np . real ( 0.5 * np . trace ( np . dot ( rho , SLD_ac ))) elif LDtype == \"RLD\" : LD_tp = RLD ( rho , drho , eps = eps ) QFIM_res = np . real ( np . trace ( np . dot ( rho , np . dot ( LD_tp , LD_tp . conj () . transpose ()))) ) elif LDtype == \"LLD\" : LD_tp = LLD ( rho , drho , eps = eps ) QFIM_res = np . real ( np . trace ( np . dot ( rho , np . dot ( LD_tp , LD_tp . conj () . transpose ()))) ) else : raise ValueError ( \" {!r} is not a valid value for LDtype, supported values are 'SLD', 'RLD' and 'LLD'.\" . format ( LDtype )) # multiparameter estimation else : if LDtype == \"SLD\" : QFIM_res = np . zeros ([ para_num , para_num ]) LD_tp = SLD ( rho , drho , eps = eps ) for para_i in range ( 0 , para_num ): for para_j in range ( para_i , para_num ): SLD_ac = np . dot ( LD_tp [ para_i ], LD_tp [ para_j ]) + np . dot ( LD_tp [ para_j ], LD_tp [ para_i ] ) QFIM_res [ para_i ][ para_j ] = np . real ( 0.5 * np . trace ( np . dot ( rho , SLD_ac )) ) QFIM_res [ para_j ][ para_i ] = QFIM_res [ para_i ][ para_j ] elif LDtype == \"RLD\" : QFIM_res = np . zeros (( para_num , para_num ), dtype = np . complex128 ) LD_tp = RLD ( rho , drho , eps = eps ) for para_i in range ( 0 , para_num ): for para_j in range ( para_i , para_num ): QFIM_res [ para_i ][ para_j ] = np . trace ( np . dot ( rho , np . dot ( LD_tp [ para_i ], LD_tp [ para_j ] . conj () . transpose ()), ) ) QFIM_res [ para_j ][ para_i ] = QFIM_res [ para_i ][ para_j ] . conj () elif LDtype == \"LLD\" : QFIM_res = np . zeros (( para_num , para_num ), dtype = np . complex128 ) LD_tp = LLD ( rho , drho , eps = eps ) for para_i in range ( 0 , para_num ): for para_j in range ( para_i , para_num ): QFIM_res [ para_i ][ para_j ] = np . trace ( np . dot ( rho , np . dot ( LD_tp [ para_i ], LD_tp [ para_j ] . conj () . transpose ()), ) ) QFIM_res [ para_j ][ para_i ] = QFIM_res [ para_i ][ para_j ] . conj () else : raise ValueError ( \" {!r} is not a valid value for LDtype, supported values are 'SLD', 'RLD' and 'LLD'.\" . format ( LDtype )) if exportLD == False : return QFIM_res else : return QFIM_res , LD_tp Calculation of the quantum Fisher information (QFI) and quantum Fisher information matrix (QFIM) with Kraus operator(s) for all types. Parameters \u00b6 rho0: matrix -- Initial state (density matrix). K: list -- Kraus operator(s). dK: list -- Derivatives of the Kraus operator(s) on the unknown parameters to be estimated. For example, dK[0] is the derivative vector on the first parameter. LDtype: string -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). exportLD: bool -- Whether or not to export the values of logarithmic derivatives. If set True then the the values of logarithmic derivatives will be exported. eps: float -- Machine epsilon. Returns \u00b6 QFI or QFIM: float or matrix -- For single parameter estimation (the length of drho is equal to one), the output is QFI and for multiparameter estimation (the length of drho is more than one), it returns QFIM. Source code in quanestimation/AsymptoticBound/CramerRao.py 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 def QFIM_Kraus ( rho0 , K , dK , LDtype = \"SLD\" , exportLD = False , eps = 1e-8 ): \"\"\" Calculation of the quantum Fisher information (QFI) and quantum Fisher information matrix (QFIM) with Kraus operator(s) for all types. Parameters ---------- > **rho0:** `matrix` -- Initial state (density matrix). > **K:** `list` -- Kraus operator(s). > **dK:** `list` -- Derivatives of the Kraus operator(s) on the unknown parameters to be estimated. For example, dK[0] is the derivative vector on the first parameter. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). > **exportLD:** `bool` -- Whether or not to export the values of logarithmic derivatives. If set True then the the values of logarithmic derivatives will be exported. > **eps:** `float` -- Machine epsilon. Returns ---------- **QFI or QFIM:** `float or matrix` -- For single parameter estimation (the length of drho is equal to one), the output is QFI and for multiparameter estimation (the length of drho is more than one), it returns QFIM. \"\"\" dK = [[ dK [ i ][ j ] for i in range ( len ( K ))] for j in range ( len ( dK [ 0 ]))] rho = sum ([ np . dot ( Ki , np . dot ( rho0 , Ki . conj () . T )) for Ki in K ]) drho = [ sum ( [ ( np . dot ( dKi , np . dot ( rho0 , Ki . conj () . T )) + np . dot ( Ki , np . dot ( rho0 , dKi . conj () . T )) ) for ( Ki , dKi ) in zip ( K , dKj ) ] ) for dKj in dK ] return QFIM ( rho , drho , LDtype = LDtype , exportLD = exportLD , eps = eps ) Calculation of the classical Fisher information (CFI) and classical Fisher information matrix (CFIM) for a density matrix. The entry of CFIM \\(\\mathcal{I}\\) is defined as \\begin{align} \\mathcal{I}_{ab}=\\sum_y\\frac{1}{p(y|\\textbf{x})}[\\partial_a p(y|\\textbf{x})][\\partial_b p(y|\\textbf{x})], \\end{align} where \\(p(y|\\textbf{x})=\\mathrm{Tr}(\\rho\\Pi_y)\\) with \\(\\rho\\) the parameterized density matrix. Parameters \u00b6 rho: matrix -- Density matrix. drho: list -- Derivatives of the density matrix on the unknown parameters to be estimated. For example, drho[0] is the derivative vector on the first parameter. M: list of matrices -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). eps: float -- Machine epsilon. Returns \u00b6 CFI (CFIM): float or matrix -- For single parameter estimation (the length of drho is equal to one), the output is CFI and for multiparameter estimation (the length of drho is more than one), it returns CFIM. Note: SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from here . Source code in quanestimation/AsymptoticBound/CramerRao.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 def CFIM ( rho , drho , M = [], eps = 1e-8 ): r \"\"\" Calculation of the classical Fisher information (CFI) and classical Fisher information matrix (CFIM) for a density matrix. The entry of CFIM $\\mathcal{I}$ is defined as \\begin{align} \\mathcal{I}_{ab}=\\sum_y\\frac{1}{p(y|\\textbf{x})}[\\partial_a p(y|\\textbf{x})][\\partial_b p(y|\\textbf{x})], \\end{align} where $p(y|\\textbf{x})=\\mathrm{Tr}(\\rho\\Pi_y)$ with $\\rho$ the parameterized density matrix. Parameters ---------- > **rho:** `matrix` -- Density matrix. > **drho:** `list` -- Derivatives of the density matrix on the unknown parameters to be estimated. For example, drho[0] is the derivative vector on the first parameter. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). > **eps:** `float` -- Machine epsilon. Returns ---------- **CFI (CFIM):** `float or matrix` -- For single parameter estimation (the length of drho is equal to one), the output is CFI and for multiparameter estimation (the length of drho is more than one), it returns CFIM. **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" if type ( drho ) != list : raise TypeError ( \"Please make sure drho is a list!\" ) if M == []: M = SIC ( len ( rho [ 0 ])) else : if type ( M ) != list : raise TypeError ( \"Please make sure M is a list!\" ) m_num = len ( M ) para_num = len ( drho ) CFIM_res = np . zeros ([ para_num , para_num ]) for pi in range ( 0 , m_num ): Mp = M [ pi ] p = np . real ( np . trace ( np . dot ( rho , Mp ))) Cadd = np . zeros ([ para_num , para_num ]) if p > eps : for para_i in range ( 0 , para_num ): drho_i = drho [ para_i ] dp_i = np . real ( np . trace ( np . dot ( drho_i , Mp ))) for para_j in range ( para_i , para_num ): drho_j = drho [ para_j ] dp_j = np . real ( np . trace ( np . dot ( drho_j , Mp ))) Cadd [ para_i ][ para_j ] = np . real ( dp_i * dp_j / p ) Cadd [ para_j ][ para_i ] = np . real ( dp_i * dp_j / p ) CFIM_res += Cadd if para_num == 1 : return CFIM_res [ 0 ][ 0 ] else : return CFIM_res Calculation of the classical Fisher information (CFI) and classical Fisher information matrix (CFIM) for classical scenarios. The entry of FIM \\(I\\) is defined as \\begin{align} I_{ab}=\\sum_{y}\\frac{1}{p_y}[\\partial_a p_y][\\partial_b p_y], \\end{align} where \\(\\{p_y\\}\\) is a set of the discrete probability distribution. Parameters \u00b6 p: array -- The probability distribution. dp: list -- Derivatives of the probability distribution on the unknown parameters to be estimated. For example, dp[0] is the derivative vector on the first parameter. eps: float -- Machine epsilon. Returns \u00b6 CFI (CFIM): float or matrix -- For single parameter estimation (the length of drho is equal to one), the output is CFI and for multiparameter estimation (the length of drho is more than one), it returns CFIM. Source code in quanestimation/AsymptoticBound/CramerRao.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 def FIM ( p , dp , eps = 1e-8 ): r \"\"\" Calculation of the classical Fisher information (CFI) and classical Fisher information matrix (CFIM) for classical scenarios. The entry of FIM $I$ is defined as \\begin{align} I_{ab}=\\sum_{y}\\frac{1}{p_y}[\\partial_a p_y][\\partial_b p_y], \\end{align} where $\\{p_y\\}$ is a set of the discrete probability distribution. Parameters ---------- > **p:** `array` -- The probability distribution. > **dp:** `list` -- Derivatives of the probability distribution on the unknown parameters to be estimated. For example, dp[0] is the derivative vector on the first parameter. > **eps:** `float` -- Machine epsilon. Returns ---------- **CFI (CFIM):** `float or matrix` -- For single parameter estimation (the length of drho is equal to one), the output is CFI and for multiparameter estimation (the length of drho is more than one), it returns CFIM. \"\"\" para_num = len ( dp [ 0 ]) m_num = len ( p ) FIM_res = np . zeros ([ para_num , para_num ]) for pi in range ( 0 , m_num ): p_tp = p [ pi ] Cadd = np . zeros ([ para_num , para_num ]) if p_tp > eps : for para_i in range ( 0 , para_num ): dp_i = dp [ pi ][ para_i ] for para_j in range ( para_i , para_num ): dp_j = dp [ pi ][ para_j ] Cadd [ para_i ][ para_j ] = np . real ( dp_i * dp_j / p_tp ) Cadd [ para_j ][ para_i ] = np . real ( dp_i * dp_j / p_tp ) FIM_res += Cadd if para_num == 1 : return FIM_res [ 0 ][ 0 ] else : return FIM_res Calculation of the SLD based quantum Fisher information (QFI) and quantum Fisher information matrix (QFIM) in Bloch representation. Parameters \u00b6 r: list -- Parameterized Bloch vector. dr: list -- Derivatives of the Bloch vector on the unknown parameters to be estimated. For example, dr[0] is the derivative vector on the first parameter. eps: float -- Machine epsilon. Returns \u00b6 QFI or QFIM in Bloch representation: float or matrix -- For single parameter estimation (the length of drho is equal to one), the output is QFI and for multiparameter estimation (the length of drho is more than one), it returns QFIM. Source code in quanestimation/AsymptoticBound/CramerRao.py 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 def QFIM_Bloch ( r , dr , eps = 1e-8 ): \"\"\" Calculation of the SLD based quantum Fisher information (QFI) and quantum Fisher information matrix (QFIM) in Bloch representation. Parameters ---------- > **r:** `list` -- Parameterized Bloch vector. > **dr:** `list ` -- Derivatives of the Bloch vector on the unknown parameters to be estimated. For example, dr[0] is the derivative vector on the first parameter. > **eps:** `float` -- Machine epsilon. Returns ---------- **QFI or QFIM in Bloch representation:** `float or matrix` -- For single parameter estimation (the length of drho is equal to one), the output is QFI and for multiparameter estimation (the length of drho is more than one), it returns QFIM. \"\"\" if type ( dr ) != list : raise TypeError ( \"Please make sure dr is a list\" ) para_num = len ( dr ) QFIM_res = np . zeros ([ para_num , para_num ]) dim = int ( np . sqrt ( len ( r ) + 1 )) Lambda = suN_generator ( dim ) if dim == 2 : #### single-qubit system #### r_norm = np . linalg . norm ( r ) ** 2 if np . abs ( r_norm - 1.0 ) < eps : for para_i in range ( 0 , para_num ): for para_j in range ( para_i , para_num ): QFIM_res [ para_i ][ para_j ] = np . real ( np . inner ( dr [ para_i ], dr [ para_j ])) QFIM_res [ para_j ][ para_i ] = QFIM_res [ para_i ][ para_j ] else : for para_i in range ( 0 , para_num ): for para_j in range ( para_i , para_num ): QFIM_res [ para_i ][ para_j ] = np . real ( np . inner ( dr [ para_i ], dr [ para_j ]) + np . inner ( r , dr [ para_i ]) * np . inner ( r , dr [ para_j ]) / ( 1 - r_norm ) ) QFIM_res [ para_j ][ para_i ] = QFIM_res [ para_i ][ para_j ] else : rho = np . identity ( dim , dtype = np . complex128 ) / dim for di in range ( dim ** 2 - 1 ): rho += np . sqrt ( dim * ( dim - 1 ) / 2 ) * r [ di ] * Lambda [ di ] / dim G = np . zeros (( dim ** 2 - 1 , dim ** 2 - 1 ), dtype = np . complex128 ) for row_i in range ( dim ** 2 - 1 ): for col_j in range ( row_i , dim ** 2 - 1 ): anti_commu = np . dot ( Lambda [ row_i ], Lambda [ col_j ]) + np . dot ( Lambda [ col_j ], Lambda [ row_i ] ) G [ row_i ][ col_j ] = 0.5 * np . trace ( np . dot ( rho , anti_commu )) G [ col_j ][ row_i ] = G [ row_i ][ col_j ] mat_tp = G * dim / ( 2 * ( dim - 1 )) - np . dot ( np . array ( r ) . reshape ( len ( r ), 1 ), np . array ( r ) . reshape ( 1 , len ( r )) ) mat_inv = inv ( mat_tp ) for para_m in range ( 0 , para_num ): for para_n in range ( para_m , para_num ): QFIM_res [ para_m ][ para_n ] = np . real ( np . dot ( np . array ( dr [ para_n ]) . reshape ( 1 , len ( r )), np . dot ( mat_inv , np . array ( dr [ para_m ]) . reshape ( len ( r ), 1 )), )[ 0 ][ 0 ] ) QFIM_res [ para_n ][ para_m ] = QFIM_res [ para_m ][ para_n ] if para_num == 1 : return QFIM_res [ 0 ][ 0 ] else : return QFIM_res Calculation of the SLD based quantum Fisher information (QFI) and quantum Fisher information matrix (QFIM) with gaussian states. Parameters \u00b6 R: array -- First-order moment. dR: list -- Derivatives of the first-order moment on the unknown parameters to be estimated. For example, dR[0] is the derivative vector on the first parameter. D: matrix -- Second-order moment. dD: list -- Derivatives of the second-order moment on the unknown parameters to be estimated. For example, dD[0] is the derivative vector on the first parameter. eps: float -- Machine epsilon. Returns \u00b6 QFI or QFIM with gaussian states: float or matrix -- For single parameter estimation (the length of drho is equal to one), the output is QFI and for multiparameter estimation (the length of drho is more than one), it returns QFIM. Source code in quanestimation/AsymptoticBound/CramerRao.py 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 def QFIM_Gauss ( R , dR , D , dD ): \"\"\" Calculation of the SLD based quantum Fisher information (QFI) and quantum Fisher information matrix (QFIM) with gaussian states. Parameters ---------- > **R:** `array` -- First-order moment. > **dR:** `list` -- Derivatives of the first-order moment on the unknown parameters to be estimated. For example, dR[0] is the derivative vector on the first parameter. > **D:** `matrix` -- Second-order moment. > **dD:** `list` -- Derivatives of the second-order moment on the unknown parameters to be estimated. For example, dD[0] is the derivative vector on the first parameter. > **eps:** `float` -- Machine epsilon. Returns ---------- **QFI or QFIM with gaussian states:** `float or matrix` -- For single parameter estimation (the length of drho is equal to one), the output is QFI and for multiparameter estimation (the length of drho is more than one), it returns QFIM. \"\"\" para_num = len ( dR ) m = int ( len ( R ) / 2 ) QFIM_res = np . zeros ([ para_num , para_num ]) C = np . array ( [ [ D [ i ][ j ] - R [ i ] * R [ j ] for j in range ( 2 * m )] for i in range ( 2 * m ) ] ) dC = [ np . array ( [ [ dD [ k ][ i ][ j ] - dR [ k ][ i ] * R [ j ] - R [ i ] * dR [ k ][ j ] for j in range ( 2 * m ) ] for i in range ( 2 * m ) ] ) for k in range ( para_num ) ] C_sqrt = sqrtm ( C ) J = np . kron ([[ 0 , 1 ], [ - 1 , 0 ]], np . eye ( m )) B = C_sqrt @ J @ C_sqrt P = np . eye ( 2 * m ) P = np . vstack ([ P [:][:: 2 ], P [:][ 1 :: 2 ]]) T , Q = schur ( B ) vals = eigvals ( B ) c = vals [:: 2 ] . imag Diag = np . diagflat ( c **- 0.5 ) S = inv ( J @ C_sqrt @ Q @ P @ np . kron ([[ 0 , 1 ], [ - 1 , 0 ]], - Diag )) . T @ P . T sx = np . array ([[ 0.0 , 1.0 ], [ 1.0 , 0.0 ]]) sy = np . array ([[ 0.0 , - 1.0 j ], [ 1.0 j , 0.0 ]]) sz = np . array ([[ 1.0 , 0.0 ], [ 0.0 , - 1.0 ]]) a_Gauss = [ 1 j * sy , sz , np . eye ( 2 ), sx ] es = [ [ np . eye ( 1 , m ** 2 , m * i + j ) . reshape ( m , m ) for j in range ( m )] for i in range ( m ) ] As = [[ np . kron ( s , a_Gauss [ i ]) / np . sqrt ( 2 ) for s in es ] for i in range ( 4 )] gs = [ [[[ np . trace ( inv ( S ) @ dC @ inv ( S . T ) @ aa . T ) for aa in a ] for a in A ] for A in As ] for dC in dC ] G = [ np . zeros (( 2 * m , 2 * m )) . astype ( np . longdouble ) for _ in range ( para_num )] for i in range ( para_num ): for j in range ( m ): for k in range ( m ): for l in range ( 4 ): G [ i ] += np . real ( gs [ i ][ l ][ j ][ k ] / ( 4 * c [ j ] * c [ k ] + ( - 1 ) ** ( l + 1 )) * inv ( S . T ) @ As [ l ][ j ][ k ] @ inv ( S ) ) QFIM_res += np . real ( [ [ np . trace ( G [ i ] @ dC [ j ]) + dR [ i ] @ inv ( C ) @ dR [ j ] for j in range ( para_num )] for i in range ( para_num ) ] ) if para_num == 1 : return QFIM_res [ 0 ][ 0 ] else : return QFIM_res Holevo Cram\u00e9r-Rao bounds \u00b6 Calculation of the Holevo Cramer-Rao bound (HCRB) via the semidefinite program (SDP). Parameters \u00b6 rho: matrix -- Density matrix. drho: list -- Derivatives of the density matrix on the unknown parameters to be estimated. For example, drho[0] is the derivative vector on the first parameter. W: matrix -- Weight matrix. eps: float -- Machine epsilon. Returns \u00b6 HCRB: float -- The value of Holevo Cramer-Rao bound. Source code in quanestimation/AsymptoticBound/Holevo.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 def HCRB ( rho , drho , W , eps = 1e-8 ): \"\"\" Calculation of the Holevo Cramer-Rao bound (HCRB) via the semidefinite program (SDP). Parameters ---------- > **rho:** `matrix` -- Density matrix. > **drho:** `list` -- Derivatives of the density matrix on the unknown parameters to be estimated. For example, drho[0] is the derivative vector on the first parameter. > **W:** `matrix` -- Weight matrix. > **eps:** `float` -- Machine epsilon. Returns ---------- **HCRB:** `float` -- The value of Holevo Cramer-Rao bound. \"\"\" if type ( drho ) != list : raise TypeError ( \"Please make sure drho is a list!\" ) if len ( drho ) == 1 : print ( \"In single parameter scenario, HCRB is equivalent to QFI. This function will return the value of QFI.\" ) f = QFIM ( rho , drho , eps = eps ) return f elif matrix_rank ( W ) == 1 : print ( \"For rank-one weight matrix, the HCRB is equivalent to QFIM. This function will return the value of Tr(WF^{-1}).\" ) F = QFIM ( rho , drho , eps = eps ) return np . trace ( np . dot ( W , np . linalg . pinv ( F ))) else : dim = len ( rho ) num = dim * dim para_num = len ( drho ) Lambda = [ np . identity ( dim )] + suN_generator ( dim ) Lambda = Lambda / np . sqrt ( 2 ) vec_drho = [[] for i in range ( para_num )] for pi in range ( para_num ): vec_drho [ pi ] = np . array ( [ np . real ( np . trace ( np . dot ( drho [ pi ], Lambda [ i ]))) for i in range ( len ( Lambda )) ] ) S = np . zeros (( num , num ), dtype = np . complex128 ) for a in range ( num ): for b in range ( num ): S [ a ][ b ] = np . trace ( np . dot ( Lambda [ a ], np . dot ( Lambda [ b ], rho ))) accu = len ( str ( int ( 1 / eps ))) - 1 lu , d , perm = sp . linalg . ldl ( S . round ( accu )) R = np . dot ( lu , sp . linalg . sqrtm ( d )) . conj () . T # ============optimization variables================ V = cp . Variable (( para_num , para_num )) X = cp . Variable (( num , para_num )) # ================add constraints=================== constraints = [ cp . bmat ([[ V , X . T @ R . conj () . T ], [ R @ X , np . identity ( num )]]) >> 0 ] for i in range ( para_num ): for j in range ( para_num ): if i == j : constraints += [ X [:, i ] . T @ vec_drho [ j ] == 1 ] else : constraints += [ X [:, i ] . T @ vec_drho [ j ] == 0 ] prob = cp . Problem ( cp . Minimize ( cp . trace ( W @ V )), constraints ) prob . solve () return prob . value Bayesian Cram\u00e9r-Rao bounds \u00b6 Calculation of the Bayesian classical Fisher information (BCFI) and the Bayesian classical Fisher information matrix (BCFIM) of the form \\begin{align} \\mathcal{I}_{\\mathrm{Bayes}}=\\int p(\\textbf{x})\\mathcal{I}\\mathrm{d}\\textbf{x} \\end{align} with \\(\\mathcal{I}\\) the CFIM and \\(p(\\textbf{x})\\) the prior distribution. Parameters \u00b6 x: list -- The regimes of the parameters for the integral. p: multidimensional array -- The prior distribution. rho: multidimensional list -- Parameterized density matrix. drho: multidimensional list -- Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated. M: list of matrices -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). eps: float -- Machine epsilon. Returns \u00b6 BCFI or BCFIM: float or matrix -- For single parameter estimation (the length of x is equal to one), the output is BCFI and for multiparameter estimation (the length of x is more than one), it returns BCFIM. Note: SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from here . Source code in quanestimation/BayesianBound/BayesianCramerRao.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 def BCFIM ( x , p , rho , drho , M = [], eps = 1e-8 ): r \"\"\" Calculation of the Bayesian classical Fisher information (BCFI) and the Bayesian classical Fisher information matrix (BCFIM) of the form \\begin{align} \\mathcal{I}_{\\mathrm{Bayes}}=\\int p(\\textbf{x})\\mathcal{I}\\mathrm{d}\\textbf{x} \\end{align} with $\\mathcal{I}$ the CFIM and $p(\\textbf{x})$ the prior distribution. Parameters ---------- > **x:** `list` -- The regimes of the parameters for the integral. > **p:** `multidimensional array` -- The prior distribution. > **rho:** `multidimensional list` -- Parameterized density matrix. > **drho:** `multidimensional list` -- Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). > **eps:** `float` -- Machine epsilon. Returns ---------- **BCFI or BCFIM:** `float or matrix` -- For single parameter estimation (the length of x is equal to one), the output is BCFI and for multiparameter estimation (the length of x is more than one), it returns BCFIM. **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" para_num = len ( x ) if para_num == 1 : #### single parameter scenario #### if M == []: M = SIC ( len ( rho [ 0 ])) else : if type ( M ) != list : raise TypeError ( \"Please make sure M is a list!\" ) p_num = len ( p ) if type ( drho [ 0 ]) == list : drho = [ drho [ i ][ 0 ] for i in range ( p_num )] p_num = len ( p ) F_tp = np . zeros ( p_num ) for m in range ( p_num ): F_tp [ m ] = CFIM ( rho [ m ], [ drho [ m ]], M = M , eps = eps ) arr = [ p [ i ] * F_tp [ i ] for i in range ( p_num )] return simps ( arr , x [ 0 ]) else : #### multiparameter scenario #### p_shape = np . shape ( p ) p_ext = extract_ele ( p , para_num ) rho_ext = extract_ele ( rho , para_num ) drho_ext = extract_ele ( drho , para_num ) p_list , rho_list , drho_list = [], [], [] for p_ele , rho_ele , drho_ele in zip ( p_ext , rho_ext , drho_ext ): p_list . append ( p_ele ) rho_list . append ( rho_ele ) drho_list . append ( drho_ele ) dim = len ( rho_list [ 0 ]) if M == []: M = SIC ( dim ) else : if type ( M ) != list : raise TypeError ( \"Please make sure M is a list!\" ) F_list = [ [[ 0.0 for i in range ( len ( p_list ))] for j in range ( para_num )] for k in range ( para_num ) ] for i in range ( len ( p_list )): F_tp = CFIM ( rho_list [ i ], drho_list [ i ], M = M , eps = eps ) for pj in range ( para_num ): for pk in range ( para_num ): F_list [ pj ][ pk ][ i ] = F_tp [ pj ][ pk ] BCFIM_res = np . zeros ([ para_num , para_num ]) for para_i in range ( 0 , para_num ): for para_j in range ( para_i , para_num ): F_ij = np . array ( F_list [ para_i ][ para_j ]) . reshape ( p_shape ) arr = p * F_ij for si in reversed ( range ( para_num )): arr = simps ( arr , x [ si ]) BCFIM_res [ para_i ][ para_j ] = arr BCFIM_res [ para_j ][ para_i ] = arr return BCFIM_res Calculation of the Bayesian quantum Fisher information (BQFI) and the Bayesian quantum Fisher information matrix (BQFIM) of the form \\begin{align} \\mathcal{F}_{\\mathrm{Bayes}}=\\int p(\\textbf{x})\\mathcal{F}\\mathrm{d}\\textbf{x} \\end{align} with \\(\\mathcal{F}\\) the QFIM of all types and \\(p(\\textbf{x})\\) the prior distribution. Parameters \u00b6 x: list -- The regimes of the parameters for the integral. p: multidimensional array -- The prior distribution. rho: multidimensional list -- Parameterized density matrix. drho: multidimensional list -- Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated. LDtype: string -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). eps: float -- Machine epsilon. Returns \u00b6 BQFI or BQFIM: float or matrix -- For single parameter estimation (the length of x is equal to one), the output is BQFI and for multiparameter estimation (the length of x is more than one), it returns BQFIM. Source code in quanestimation/BayesianBound/BayesianCramerRao.py 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 def BQFIM ( x , p , rho , drho , LDtype = \"SLD\" , eps = 1e-8 ): r \"\"\" Calculation of the Bayesian quantum Fisher information (BQFI) and the Bayesian quantum Fisher information matrix (BQFIM) of the form \\begin{align} \\mathcal{F}_{\\mathrm{Bayes}}=\\int p(\\textbf{x})\\mathcal{F}\\mathrm{d}\\textbf{x} \\end{align} with $\\mathcal{F}$ the QFIM of all types and $p(\\textbf{x})$ the prior distribution. Parameters ---------- > **x:** `list` -- The regimes of the parameters for the integral. > **p:** `multidimensional array` -- The prior distribution. > **rho:** `multidimensional list` -- Parameterized density matrix. > **drho:** `multidimensional list` -- Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). > **eps:** `float` -- Machine epsilon. Returns ---------- **BQFI or BQFIM:** `float or matrix` -- For single parameter estimation (the length of x is equal to one), the output is BQFI and for multiparameter estimation (the length of x is more than one), it returns BQFIM. \"\"\" para_num = len ( x ) if para_num == 1 : #### single parameter scenario #### p_num = len ( p ) if type ( drho [ 0 ]) == list : drho = [ drho [ i ][ 0 ] for i in range ( p_num )] F_tp = np . zeros ( p_num ) for m in range ( p_num ): F_tp [ m ] = QFIM ( rho [ m ], [ drho [ m ]], LDtype = LDtype , eps = eps ) arr = [ p [ i ] * F_tp [ i ] for i in range ( p_num )] return simps ( arr , x [ 0 ]) else : #### multiparameter scenario #### p_shape = np . shape ( p ) p_ext = extract_ele ( p , para_num ) rho_ext = extract_ele ( rho , para_num ) drho_ext = extract_ele ( drho , para_num ) p_list , rho_list , drho_list = [], [], [] for p_ele , rho_ele , drho_ele in zip ( p_ext , rho_ext , drho_ext ): p_list . append ( p_ele ) rho_list . append ( rho_ele ) drho_list . append ( drho_ele ) F_list = [ [[ 0.0 for i in range ( len ( p_list ))] for j in range ( para_num )] for k in range ( para_num ) ] for i in range ( len ( p_list )): F_tp = QFIM ( rho_list [ i ], drho_list [ i ], LDtype = LDtype , eps = eps ) for pj in range ( para_num ): for pk in range ( para_num ): F_list [ pj ][ pk ][ i ] = F_tp [ pj ][ pk ] BQFIM_res = np . zeros ([ para_num , para_num ]) for para_i in range ( 0 , para_num ): for para_j in range ( para_i , para_num ): F_ij = np . array ( F_list [ para_i ][ para_j ]) . reshape ( p_shape ) arr = p * F_ij for si in reversed ( range ( para_num )): arr = simps ( arr , x [ si ]) BQFIM_res [ para_i ][ para_j ] = arr BQFIM_res [ para_j ][ para_i ] = arr return BQFIM_res Calculation of the Bayesian Cramer-Rao bound (BCRB). The covariance matrix with a prior distribution \\(p(\\textbf{x})\\) is defined as \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},{\\Pi_y})=\\int p(\\textbf{x})\\sum_y\\mathrm{Tr} (\\rho\\Pi_y)(\\hat{\\textbf{x}}-\\textbf{x})(\\hat{\\textbf{x}}-\\textbf{x})^{\\mathrm{T}} \\mathrm{d}\\textbf{x} \\end{align} where \\(\\textbf{x}=(x_0,x_1,\\dots)^{\\mathrm{T}}\\) are the unknown parameters to be estimated and the integral \\(\\int\\mathrm{d}\\textbf{x}:=\\iiint\\mathrm{d}x_0\\mathrm{d}x_1\\cdots\\) . \\(\\{\\Pi_y\\}\\) is a set of positive operator-valued measure (POVM) and \\(\\rho\\) represents the parameterized density matrix. This function calculates three types BCRB. The first one is \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},{\\Pi_y})\\geq \\int p(\\textbf{x})\\left(B\\mathcal{I}^{-1}B +\\textbf{b}\\textbf{b}^{\\mathrm{T}}\\right)\\mathrm{d}\\textbf{x}, \\end{align} where \\(\\textbf{b}\\) and \\(\\textbf{b}'\\) are the vectors of biase and its derivatives on parameters. \\(B\\) is a diagonal matrix with the \\(i\\) th entry \\(B_{ii}=1+[\\textbf{b}']_{i}\\) and \\(\\mathcal{I}\\) is the CFIM. The second one is \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},{\\Pi_y})\\geq \\mathcal{B}\\,\\mathcal{I}_{\\mathrm{Bayes}}^{-1}\\, \\mathcal{B}+\\int p(\\textbf{x})\\textbf{b}\\textbf{b}^{\\mathrm{T}}\\mathrm{d}\\textbf{x}, \\end{align} where \\(\\mathcal{B}=\\int p(\\textbf{x})B\\mathrm{d}\\textbf{x}\\) is the average of \\(B\\) and \\(\\mathcal{I}_{\\mathrm{Bayes}}=\\int p(\\textbf{x})\\mathcal{I}\\mathrm{d}\\textbf{x}\\) is the average CFIM. The third one is \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},{\\Pi_y})\\geq \\int p(\\textbf{x}) \\mathcal{G}\\left(\\mathcal{I}_p+\\mathcal{I}\\right)^{-1}\\mathcal{G}^{\\mathrm{T}}\\mathrm{d}\\textbf{x} \\end{align} with \\([\\mathcal{I}_{p}]_{ab}:=[\\partial_a \\ln p(\\textbf{x})][\\partial_b \\ln p(\\textbf{x})]\\) and \\(\\mathcal{G}_{ab}:=[\\partial_b\\ln p(\\textbf{x})][\\textbf{b}]_a+B_{aa}\\delta_{ab}\\) . Parameters \u00b6 x: list -- The regimes of the parameters for the integral. p: multidimensional array -- The prior distribution. rho: multidimensional list -- Parameterized density matrix. drho: multidimensional list -- Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated. M: list of matrices -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). b: list -- Vector of biases of the form \\(\\textbf{b}=(b(x_0),b(x_1),\\dots)^{\\mathrm{T}}\\) . db: list -- Derivatives of b with respect to the unknown parameters to be estimated, It should be expressed as \\(\\textbf{b}'=(\\partial_0 b(x_0),\\partial_1 b(x_1),\\dots)^{\\mathrm{T}}\\) . btype: int (1, 2, 3) -- Types of the BCRB. Options are: 1 (default) -- It means to calculate the first type of the BCRB. 2 -- It means to calculate the second type of the BCRB. 3 -- It means to calculate the third type of the BCRB. eps: float -- Machine epsilon. Returns \u00b6 BCRB: float or matrix -- For single parameter estimation (the length of x is equal to one), the output is a float and for multiparameter estimation (the length of x is more than one), it returns a matrix. Note: SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from here . Source code in quanestimation/BayesianBound/BayesianCramerRao.py 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 def BCRB ( x , p , dp , rho , drho , M = [], b = [], db = [], btype = 1 , eps = 1e-8 ): r \"\"\" Calculation of the Bayesian Cramer-Rao bound (BCRB). The covariance matrix with a prior distribution $p(\\textbf{x})$ is defined as \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},\\{\\Pi_y\\})=\\int p(\\textbf{x})\\sum_y\\mathrm{Tr} (\\rho\\Pi_y)(\\hat{\\textbf{x}}-\\textbf{x})(\\hat{\\textbf{x}}-\\textbf{x})^{\\mathrm{T}} \\mathrm{d}\\textbf{x} \\end{align} where $\\textbf{x}=(x_0,x_1,\\dots)^{\\mathrm{T}}$ are the unknown parameters to be estimated and the integral $\\int\\mathrm{d}\\textbf{x}:=\\iiint\\mathrm{d}x_0\\mathrm{d}x_1\\cdots$. $\\{\\Pi_y\\}$ is a set of positive operator-valued measure (POVM) and $\\rho$ represents the parameterized density matrix. This function calculates three types BCRB. The first one is \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},\\{\\Pi_y\\})\\geq \\int p(\\textbf{x})\\left(B\\mathcal{I}^{-1}B +\\textbf{b}\\textbf{b}^{\\mathrm{T}}\\right)\\mathrm{d}\\textbf{x}, \\end{align} where $\\textbf{b}$ and $\\textbf{b}'$ are the vectors of biase and its derivatives on parameters. $B$ is a diagonal matrix with the $i$th entry $B_{ii}=1+[\\textbf{b}']_{i}$ and $\\mathcal{I}$ is the CFIM. The second one is \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},\\{\\Pi_y\\})\\geq \\mathcal{B}\\,\\mathcal{I}_{\\mathrm{Bayes}}^{-1}\\, \\mathcal{B}+\\int p(\\textbf{x})\\textbf{b}\\textbf{b}^{\\mathrm{T}}\\mathrm{d}\\textbf{x}, \\end{align} where $\\mathcal{B}=\\int p(\\textbf{x})B\\mathrm{d}\\textbf{x}$ is the average of $B$ and $\\mathcal{I}_{\\mathrm{Bayes}}=\\int p(\\textbf{x})\\mathcal{I}\\mathrm{d}\\textbf{x}$ is the average CFIM. The third one is \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},\\{\\Pi_y\\})\\geq \\int p(\\textbf{x}) \\mathcal{G}\\left(\\mathcal{I}_p+\\mathcal{I}\\right)^{-1}\\mathcal{G}^{\\mathrm{T}}\\mathrm{d}\\textbf{x} \\end{align} with $[\\mathcal{I}_{p}]_{ab}:=[\\partial_a \\ln p(\\textbf{x})][\\partial_b \\ln p(\\textbf{x})]$ and $\\mathcal{G}_{ab}:=[\\partial_b\\ln p(\\textbf{x})][\\textbf{b}]_a+B_{aa}\\delta_{ab}$. Parameters ---------- > **x:** `list` -- The regimes of the parameters for the integral. > **p:** `multidimensional array` -- The prior distribution. > **rho:** `multidimensional list` -- Parameterized density matrix. > **drho:** `multidimensional list` -- Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). > **b:** `list` -- Vector of biases of the form $\\textbf{b}=(b(x_0),b(x_1),\\dots)^{\\mathrm{T}}$. > **db:** `list` -- Derivatives of b with respect to the unknown parameters to be estimated, It should be expressed as $\\textbf{b}'=(\\partial_0 b(x_0),\\partial_1 b(x_1),\\dots)^{\\mathrm{T}}$. > **btype:** `int (1, 2, 3)` -- Types of the BCRB. Options are: 1 (default) -- It means to calculate the first type of the BCRB. 2 -- It means to calculate the second type of the BCRB. 3 -- It means to calculate the third type of the BCRB. > **eps:** `float` -- Machine epsilon. Returns ---------- **BCRB:** `float or matrix` -- For single parameter estimation (the length of x is equal to one), the output is a float and for multiparameter estimation (the length of x is more than one), it returns a matrix. **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" para_num = len ( x ) if para_num == 1 : #### single parameter scenario #### p_num = len ( p ) if b == []: b = np . zeros ( p_num ) db = np . zeros ( p_num ) if b != [] and db == []: db = np . zeros ( p_num ) if M == []: M = SIC ( len ( rho [ 0 ])) else : if type ( M ) != list : raise TypeError ( \"Please make sure M is a list!\" ) if type ( drho [ 0 ]) == list : drho = [ drho [ i ][ 0 ] for i in range ( p_num )] if type ( b [ 0 ]) == list or type ( b [ 0 ]) == np . ndarray : b = b [ 0 ] if type ( db [ 0 ]) == list or type ( db [ 0 ]) == np . ndarray : db = db [ 0 ] F_tp = np . zeros ( p_num ) for m in range ( p_num ): F_tp [ m ] = CFIM ( rho [ m ], [ drho [ m ]], M = M , eps = eps ) if btype == 1 : arr = [ p [ i ] * (( 1 + db [ i ]) ** 2 / F_tp [ i ] + b [ i ] ** 2 ) for i in range ( p_num ) ] F = simps ( arr , x [ 0 ]) return F elif btype == 2 : arr = [ p [ i ] * F_tp [ i ] for i in range ( p_num )] F1 = simps ( arr , x [ 0 ]) arr2 = [ p [ j ] * ( 1 + db [ j ]) for j in range ( p_num )] B = simps ( arr2 , x [ 0 ]) arr3 = [ p [ k ] * b [ k ] ** 2 for k in range ( p_num )] bb = simps ( arr3 , x [ 0 ]) F = B ** 2 / F1 + bb return F elif btype == 3 : I_tp = [ np . real ( dp [ i ] * dp [ i ] / p [ i ] ** 2 ) for i in range ( p_num )] arr = [ p [ j ] * ( dp [ j ] * b [ j ] / p [ j ] + ( 1 + db [ j ])) ** 2 / ( I_tp [ j ] + F_tp [ j ]) for j in range ( p_num )] F = simps ( arr , x [ 0 ]) return F else : raise NameError ( \"NameError: btype should be choosen in {1, 2, 3}.\" ) else : #### multiparameter scenario #### if b == []: b , db = [], [] for i in range ( para_num ): b . append ( np . zeros ( len ( x [ i ]))) db . append ( np . zeros ( len ( x [ i ]))) if b != [] and db == []: db = [] for i in range ( para_num ): db . append ( np . zeros ( len ( x [ i ]))) p_shape = np . shape ( p ) p_ext = extract_ele ( p , para_num ) dp_ext = extract_ele ( dp , para_num ) rho_ext = extract_ele ( rho , para_num ) drho_ext = extract_ele ( drho , para_num ) b_pro = product ( * b ) db_pro = product ( * db ) p_list , dp_list , rho_list , drho_list = [], [], [], [] for p_ele , dp_ele , rho_ele , drho_ele in zip ( p_ext , dp_ext , rho_ext , drho_ext ): p_list . append ( p_ele ) dp_list . append ( dp_ele ) rho_list . append ( rho_ele ) drho_list . append ( drho_ele ) b_list , db_list = [], [] for b_ele , db_ele in zip ( b_pro , db_pro ): b_list . append ([ b_ele [ i ] for i in range ( para_num )]) db_list . append ([ db_ele [ j ] for j in range ( para_num )]) dim = len ( rho_list [ 0 ]) if M == []: M = SIC ( dim ) else : if type ( M ) != list : raise TypeError ( \"Please make sure M is a list!\" ) if btype == 1 : F_list = [ [[ 0.0 for i in range ( len ( p_list ))] for j in range ( para_num )] for k in range ( para_num ) ] for i in range ( len ( p_list )): F_tp = CFIM ( rho_list [ i ], drho_list [ i ], M = M , eps = eps ) F_inv = np . linalg . pinv ( F_tp ) B = np . diag ([( 1.0 + db_list [ i ][ j ]) for j in range ( para_num )]) term1 = np . dot ( B , np . dot ( F_inv , B )) term2 = np . dot ( np . array ( b_list [ i ]) . reshape ( para_num , 1 ), np . array ( b_list [ i ]) . reshape ( 1 , para_num ), ) for pj in range ( para_num ): for pk in range ( para_num ): F_list [ pj ][ pk ][ i ] = term1 [ pj ][ pk ] + term2 [ pj ][ pk ] res = np . zeros ([ para_num , para_num ]) for para_i in range ( 0 , para_num ): for para_j in range ( para_i , para_num ): F_ij = np . array ( F_list [ para_i ][ para_j ]) . reshape ( p_shape ) arr = p * F_ij for si in reversed ( range ( para_num )): arr = simps ( arr , x [ si ]) res [ para_i ][ para_j ] = arr res [ para_j ][ para_i ] = arr return res elif btype == 2 : F_list = [ [[ 0.0 for i in range ( len ( p_list ))] for j in range ( para_num )] for k in range ( para_num ) ] B_list = [ [[ 0.0 for i in range ( len ( p_list ))] for j in range ( para_num )] for k in range ( para_num ) ] bb_list = [ [[ 0.0 for i in range ( len ( p_list ))] for j in range ( para_num )] for k in range ( para_num ) ] for i in range ( len ( p_list )): F_tp = CFIM ( rho_list [ i ], drho_list [ i ], M = M , eps = eps ) B_tp = np . diag ([( 1.0 + db_list [ i ][ j ]) for j in range ( para_num )]) bb_tp = np . dot ( np . array ( b_list [ i ]) . reshape ( para_num , 1 ), np . array ( b_list [ i ]) . reshape ( 1 , para_num ), ) for pj in range ( para_num ): for pk in range ( para_num ): F_list [ pj ][ pk ][ i ] = F_tp [ pj ][ pk ] B_list [ pj ][ pk ][ i ] = B_tp [ pj ][ pk ] bb_list [ pj ][ pk ][ i ] = bb_tp [ pj ][ pk ] F_res = np . zeros ([ para_num , para_num ]) for para_i in range ( 0 , para_num ): for para_j in range ( para_i , para_num ): F_ij = np . array ( F_list [ para_i ][ para_j ]) . reshape ( p_shape ) arr = p * F_ij for si in reversed ( range ( para_num )): arr = simps ( arr , x [ si ]) F_res [ para_i ][ para_j ] = arr F_res [ para_j ][ para_i ] = arr B_res = np . zeros ([ para_num , para_num ]) bb_res = np . zeros ([ para_num , para_num ]) for para_m in range ( para_num ): for para_n in range ( para_num ): B_mn = np . array ( B_list [ para_m ][ para_n ]) . reshape ( p_shape ) bb_mn = np . array ( bb_list [ para_m ][ para_n ]) . reshape ( p_shape ) arr2 = p * B_mn arr3 = p * bb_mn for sj in reversed ( range ( para_num )): arr2 = simps ( arr2 , x [ sj ]) arr3 = simps ( arr3 , x [ sj ]) B_res [ para_m ][ para_n ] = arr2 bb_res [ para_m ][ para_n ] = arr3 res = np . dot ( B_res , np . dot ( np . linalg . pinv ( F_res ), B_res )) + bb_res return res elif btype == 3 : F_list = [ [[ 0.0 for i in range ( len ( p_list ))] for j in range ( para_num )] for k in range ( para_num ) ] for i in range ( len ( p_list )): F_tp = CFIM ( rho_list [ i ], drho_list [ i ], M = M , eps = eps ) I_tp = np . zeros (( para_num , para_num )) G_tp = np . zeros (( para_num , para_num )) for pm in range ( para_num ): for pn in range ( para_num ): if pm == pn : G_tp [ pm ][ pn ] = dp_list [ i ][ pn ] * b_list [ i ][ pm ] / p_list [ i ] + ( 1.0 + db_list [ i ][ pm ]) else : G_tp [ pm ][ pn ] = dp_list [ i ][ pn ] * b_list [ i ][ pm ] / p_list [ i ] I_tp [ pm ][ pn ] = dp_list [ i ][ pm ] * dp_list [ i ][ pn ] / p_list [ i ] ** 2 F_tot = np . dot ( G_tp , np . dot ( np . linalg . pinv ( F_tp + I_tp ), G_tp . T )) for pj in range ( para_num ): for pk in range ( para_num ): F_list [ pj ][ pk ][ i ] = F_tot [ pj ][ pk ] res = np . zeros ([ para_num , para_num ]) for para_i in range ( 0 , para_num ): for para_j in range ( para_i , para_num ): F_ij = np . array ( F_list [ para_i ][ para_j ]) . reshape ( p_shape ) arr = p * F_ij for si in reversed ( range ( para_num )): arr = simps ( arr , x [ si ]) res [ para_i ][ para_j ] = arr res [ para_j ][ para_i ] = arr return res else : raise NameError ( \"NameError: btype should be choosen in {1, 2, 3}.\" ) Calculation of the Bayesian quantum Cramer-Rao bound (BQCRB). The covariance matrix with a prior distribution \\(p(\\textbf{x})\\) is defined as \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},{\\Pi_y})=\\int p(\\textbf{x})\\sum_y\\mathrm{Tr} (\\rho\\Pi_y)(\\hat{\\textbf{x}}-\\textbf{x})(\\hat{\\textbf{x}}-\\textbf{x})^{\\mathrm{T}} \\mathrm{d}\\textbf{x} \\end{align} where \\(\\textbf{x}=(x_0,x_1,\\dots)^{\\mathrm{T}}\\) are the unknown parameters to be estimated and the integral \\(\\int\\mathrm{d}\\textbf{x}:=\\iiint\\mathrm{d}x_0\\mathrm{d}x_1\\cdots\\) . \\(\\{\\Pi_y\\}\\) is a set of positive operator-valued measure (POVM) and \\(\\rho\\) represent the parameterized density matrix. This function calculates three types of the BQCRB. The first one is \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},{\\Pi_y})\\geq\\int p(\\textbf{x})\\left(B\\mathcal{F}^{-1}B +\\textbf{b}\\textbf{b}^{\\mathrm{T}}\\right)\\mathrm{d}\\textbf{x}, \\end{align} where \\(\\textbf{b}\\) and \\(\\textbf{b}'\\) are the vectors of biase and its derivatives on parameters. \\(B\\) is a diagonal matrix with the \\(i\\) th entry \\(B_{ii}=1+[\\textbf{b}']_{i}\\) and \\(\\mathcal{F}\\) is the QFIM for all types. The second one is \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},{\\Pi_y})\\geq \\mathcal{B}\\,\\mathcal{F}_{\\mathrm{Bayes}}^{-1}\\, \\mathcal{B}+\\int p(\\textbf{x})\\textbf{b}\\textbf{b}^{\\mathrm{T}}\\mathrm{d}\\textbf{x}, \\end{align} where \\(\\mathcal{B}=\\int p(\\textbf{x})B\\mathrm{d}\\textbf{x}\\) is the average of \\(B\\) and \\(\\mathcal{F}_{\\mathrm{Bayes}}=\\int p(\\textbf{x})\\mathcal{F}\\mathrm{d}\\textbf{x}\\) is the average QFIM. The third one is \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},{\\Pi_y})\\geq \\int p(\\textbf{x}) \\mathcal{G}\\left(\\mathcal{I}_p+\\mathcal{F}\\right)^{-1}\\mathcal{G}^{\\mathrm{T}}\\mathrm{d}\\textbf{x} \\end{align} with \\([\\mathcal{I}_{p}]_{ab}:=[\\partial_a \\ln p(\\textbf{x})][\\partial_b \\ln p(\\textbf{x})]\\) and \\(\\mathcal{G}_{ab}:=[\\partial_b\\ln p(\\textbf{x})][\\textbf{b}]_a+B_{aa}\\delta_{ab}\\) . Parameters \u00b6 x: list -- The regimes of the parameters for the integral. p: multidimensional array -- The prior distribution. rho: multidimensional list -- Parameterized density matrix. drho: multidimensional list -- Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated. b: list -- Vector of biases of the form \\(\\textbf{b}=(b(x_0),b(x_1),\\dots)^{\\mathrm{T}}\\) . db: list -- Derivatives of b with respect to the unknown parameters to be estimated, It should be expressed as \\(\\textbf{b}'=(\\partial_0 b(x_0),\\partial_1 b(x_1),\\dots)^{\\mathrm{T}}\\) . btype: int (1, 2, 3) -- Types of the BQCRB. Options are: 1 (default) -- It means to calculate the first type of the BQCRB. 2 -- It means to calculate the second type of the BQCRB. 3 -- It means to calculate the third type of the BCRB. LDtype: string -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). eps: float -- Machine epsilon. Returns \u00b6 BQCRB: float or matrix -- For single parameter estimation (the length of x is equal to one), the output is a float and for multiparameter estimation (the length of x is more than one), it returns a matrix. Source code in quanestimation/BayesianBound/BayesianCramerRao.py 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 def BQCRB ( x , p , dp , rho , drho , b = [], db = [], btype = 1 , LDtype = \"SLD\" , eps = 1e-8 ): r \"\"\" Calculation of the Bayesian quantum Cramer-Rao bound (BQCRB). The covariance matrix with a prior distribution $p(\\textbf{x})$ is defined as \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},\\{\\Pi_y\\})=\\int p(\\textbf{x})\\sum_y\\mathrm{Tr} (\\rho\\Pi_y)(\\hat{\\textbf{x}}-\\textbf{x})(\\hat{\\textbf{x}}-\\textbf{x})^{\\mathrm{T}} \\mathrm{d}\\textbf{x} \\end{align} where $\\textbf{x}=(x_0,x_1,\\dots)^{\\mathrm{T}}$ are the unknown parameters to be estimated and the integral $\\int\\mathrm{d}\\textbf{x}:=\\iiint\\mathrm{d}x_0\\mathrm{d}x_1\\cdots$. $\\{\\Pi_y\\}$ is a set of positive operator-valued measure (POVM) and $\\rho$ represent the parameterized density matrix. This function calculates three types of the BQCRB. The first one is \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},\\{\\Pi_y\\})\\geq\\int p(\\textbf{x})\\left(B\\mathcal{F}^{-1}B +\\textbf{b}\\textbf{b}^{\\mathrm{T}}\\right)\\mathrm{d}\\textbf{x}, \\end{align} where $\\textbf{b}$ and $\\textbf{b}'$ are the vectors of biase and its derivatives on parameters. $B$ is a diagonal matrix with the $i$th entry $B_{ii}=1+[\\textbf{b}']_{i}$ and $\\mathcal{F}$ is the QFIM for all types. The second one is \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},\\{\\Pi_y\\})\\geq \\mathcal{B}\\,\\mathcal{F}_{\\mathrm{Bayes}}^{-1}\\, \\mathcal{B}+\\int p(\\textbf{x})\\textbf{b}\\textbf{b}^{\\mathrm{T}}\\mathrm{d}\\textbf{x}, \\end{align} where $\\mathcal{B}=\\int p(\\textbf{x})B\\mathrm{d}\\textbf{x}$ is the average of $B$ and $\\mathcal{F}_{\\mathrm{Bayes}}=\\int p(\\textbf{x})\\mathcal{F}\\mathrm{d}\\textbf{x}$ is the average QFIM. The third one is \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},\\{\\Pi_y\\})\\geq \\int p(\\textbf{x}) \\mathcal{G}\\left(\\mathcal{I}_p+\\mathcal{F}\\right)^{-1}\\mathcal{G}^{\\mathrm{T}}\\mathrm{d}\\textbf{x} \\end{align} with $[\\mathcal{I}_{p}]_{ab}:=[\\partial_a \\ln p(\\textbf{x})][\\partial_b \\ln p(\\textbf{x})]$ and $\\mathcal{G}_{ab}:=[\\partial_b\\ln p(\\textbf{x})][\\textbf{b}]_a+B_{aa}\\delta_{ab}$. Parameters ---------- > **x:** `list` -- The regimes of the parameters for the integral. > **p:** `multidimensional array` -- The prior distribution. > **rho:** `multidimensional list` -- Parameterized density matrix. > **drho:** `multidimensional list` -- Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated. > **b:** `list` -- Vector of biases of the form $\\textbf{b}=(b(x_0),b(x_1),\\dots)^{\\mathrm{T}}$. > **db:** `list` -- Derivatives of b with respect to the unknown parameters to be estimated, It should be expressed as $\\textbf{b}'=(\\partial_0 b(x_0),\\partial_1 b(x_1),\\dots)^{\\mathrm{T}}$. > **btype:** `int (1, 2, 3)` -- Types of the BQCRB. Options are: 1 (default) -- It means to calculate the first type of the BQCRB. 2 -- It means to calculate the second type of the BQCRB. 3 -- It means to calculate the third type of the BCRB. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). > **eps:** `float` -- Machine epsilon. Returns ---------- **BQCRB:** `float or matrix` -- For single parameter estimation (the length of x is equal to one), the output is a float and for multiparameter estimation (the length of x is more than one), it returns a matrix. \"\"\" para_num = len ( x ) if para_num == 1 : #### single parameter scenario #### p_num = len ( p ) if b == []: b = np . zeros ( p_num ) db = np . zeros ( p_num ) if b != [] and db == []: db = np . zeros ( p_num ) if type ( drho [ 0 ]) == list : drho = [ drho [ i ][ 0 ] for i in range ( p_num )] if type ( b [ 0 ]) == list or type ( b [ 0 ]) == np . ndarray : b = b [ 0 ] if type ( db [ 0 ]) == list or type ( db [ 0 ]) == np . ndarray : db = db [ 0 ] F_tp = np . zeros ( p_num ) for m in range ( p_num ): F_tp [ m ] = QFIM ( rho [ m ], [ drho [ m ]], LDtype = LDtype , eps = eps ) if btype == 1 : arr = [ p [ i ] * (( 1 + db [ i ]) ** 2 / F_tp [ i ] + b [ i ] ** 2 ) for i in range ( p_num ) ] F = simps ( arr , x [ 0 ]) return F elif btype == 2 : arr2 = [ p [ i ] * F_tp [ i ] for i in range ( p_num )] F2 = simps ( arr2 , x [ 0 ]) arr2 = [ p [ j ] * ( 1 + db [ j ]) for j in range ( p_num )] B = simps ( arr2 , x [ 0 ]) arr3 = [ p [ k ] * b [ k ] ** 2 for k in range ( p_num )] bb = simps ( arr3 , x [ 0 ]) F = B ** 2 / F2 + bb return F elif btype == 3 : I_tp = [ np . real ( dp [ i ] * dp [ i ] / p [ i ] ** 2 ) for i in range ( p_num )] arr = [ p [ j ] * ( dp [ j ] * b [ j ] / p [ j ] + ( 1 + db [ j ])) ** 2 / ( I_tp [ j ] + F_tp [ j ]) for j in range ( p_num )] F = simps ( arr , x [ 0 ]) return F else : raise NameError ( \"NameError: btype should be choosen in {1, 2, 3}.\" ) else : #### multiparameter scenario #### if b == []: b , db = [], [] for i in range ( para_num ): b . append ( np . zeros ( len ( x [ i ]))) db . append ( np . zeros ( len ( x [ i ]))) if b != [] and db == []: db = [] for i in range ( para_num ): db . append ( np . zeros ( len ( x [ i ]))) p_shape = np . shape ( p ) p_ext = extract_ele ( p , para_num ) dp_ext = extract_ele ( dp , para_num ) rho_ext = extract_ele ( rho , para_num ) drho_ext = extract_ele ( drho , para_num ) b_pro = product ( * b ) db_pro = product ( * db ) p_list , dp_list , rho_list , drho_list = [], [], [], [] for p_ele , dp_ele , rho_ele , drho_ele in zip ( p_ext , dp_ext , rho_ext , drho_ext ): p_list . append ( p_ele ) dp_list . append ( dp_ele ) rho_list . append ( rho_ele ) drho_list . append ( drho_ele ) b_list , db_list = [], [] for b_ele , db_ele in zip ( b_pro , db_pro ): b_list . append ([ b_ele [ i ] for i in range ( para_num )]) db_list . append ([ db_ele [ j ] for j in range ( para_num )]) if btype == 1 : F_list = [ [[ 0.0 for i in range ( len ( p_list ))] for j in range ( para_num )] for k in range ( para_num ) ] for i in range ( len ( p_list )): F_tp = QFIM ( rho_list [ i ], drho_list [ i ], LDtype = LDtype , eps = eps ) F_inv = np . linalg . pinv ( F_tp ) B = np . diag ([( 1.0 + db_list [ i ][ j ]) for j in range ( para_num )]) term1 = np . dot ( B , np . dot ( F_inv , B )) term2 = np . dot ( np . array ( b_list [ i ]) . reshape ( para_num , 1 ), np . array ( b_list [ i ]) . reshape ( 1 , para_num ), ) for pj in range ( para_num ): for pk in range ( para_num ): F_list [ pj ][ pk ][ i ] = term1 [ pj ][ pk ] + term2 [ pj ][ pk ] res = np . zeros ([ para_num , para_num ]) for para_i in range ( 0 , para_num ): for para_j in range ( para_i , para_num ): F_ij = np . array ( F_list [ para_i ][ para_j ]) . reshape ( p_shape ) arr = p * F_ij for si in reversed ( range ( para_num )): arr = simps ( arr , x [ si ]) res [ para_i ][ para_j ] = arr res [ para_j ][ para_i ] = arr return res elif btype == 2 : F_list = [ [[ 0.0 for i in range ( len ( p_list ))] for j in range ( para_num )] for k in range ( para_num ) ] B_list = [ [[ 0.0 for i in range ( len ( p_list ))] for j in range ( para_num )] for k in range ( para_num ) ] bb_list = [ [[ 0.0 for i in range ( len ( p_list ))] for j in range ( para_num )] for k in range ( para_num ) ] for i in range ( len ( p_list )): F_tp = QFIM ( rho_list [ i ], drho_list [ i ], LDtype = LDtype , eps = eps ) B_tp = np . diag ([( 1.0 + db_list [ i ][ j ]) for j in range ( para_num )]) bb_tp = np . dot ( np . array ( b_list [ i ]) . reshape ( para_num , 1 ), np . array ( b_list [ i ]) . reshape ( 1 , para_num ), ) for pj in range ( para_num ): for pk in range ( para_num ): F_list [ pj ][ pk ][ i ] = F_tp [ pj ][ pk ] B_list [ pj ][ pk ][ i ] = B_tp [ pj ][ pk ] bb_list [ pj ][ pk ][ i ] = bb_tp [ pj ][ pk ] F_res = np . zeros ([ para_num , para_num ]) for para_i in range ( 0 , para_num ): for para_j in range ( para_i , para_num ): F_ij = np . array ( F_list [ para_i ][ para_j ]) . reshape ( p_shape ) arr = p * F_ij for si in reversed ( range ( para_num )): arr = simps ( arr , x [ si ]) F_res [ para_i ][ para_j ] = arr F_res [ para_j ][ para_i ] = arr B_res = np . zeros ([ para_num , para_num ]) bb_res = np . zeros ([ para_num , para_num ]) for para_m in range ( para_num ): for para_n in range ( para_num ): B_mn = np . array ( B_list [ para_m ][ para_n ]) . reshape ( p_shape ) bb_mn = np . array ( bb_list [ para_m ][ para_n ]) . reshape ( p_shape ) arr2 = p * B_mn arr3 = p * bb_mn for sj in reversed ( range ( para_num )): arr2 = simps ( arr2 , x [ sj ]) arr3 = simps ( arr3 , x [ sj ]) B_res [ para_m ][ para_n ] = arr2 bb_res [ para_m ][ para_n ] = arr3 res = np . dot ( B_res , np . dot ( np . linalg . pinv ( F_res ), B_res )) + bb_res return res elif btype == 3 : F_list = [ [[ 0.0 for i in range ( len ( p_list ))] for j in range ( para_num )] for k in range ( para_num ) ] for i in range ( len ( p_list )): F_tp = QFIM ( rho_list [ i ], drho_list [ i ], LDtype = LDtype , eps = eps ) I_tp = np . zeros (( para_num , para_num )) G_tp = np . zeros (( para_num , para_num )) for pm in range ( para_num ): for pn in range ( para_num ): if pm == pn : G_tp [ pm ][ pn ] = dp_list [ i ][ pn ] * b_list [ i ][ pm ] / p_list [ i ] + ( 1.0 + db_list [ i ][ pm ]) else : G_tp [ pm ][ pn ] = dp_list [ i ][ pn ] * b_list [ i ][ pm ] / p_list [ i ] I_tp [ pm ][ pn ] = dp_list [ i ][ pm ] * dp_list [ i ][ pn ] / p_list [ i ] ** 2 F_tot = np . dot ( G_tp , np . dot ( np . linalg . pinv ( F_tp + I_tp ), G_tp . T )) for pj in range ( para_num ): for pk in range ( para_num ): F_list [ pj ][ pk ][ i ] = F_tot [ pj ][ pk ] res = np . zeros ([ para_num , para_num ]) for para_i in range ( 0 , para_num ): for para_j in range ( para_i , para_num ): F_ij = np . array ( F_list [ para_i ][ para_j ]) . reshape ( p_shape ) arr = p * F_ij for si in reversed ( range ( para_num )): arr = simps ( arr , x [ si ]) res [ para_i ][ para_j ] = arr res [ para_j ][ para_i ] = arr return res else : raise NameError ( \"NameError: btype should be choosen in {1, 2, 3}.\" ) Calculation of the optimal biased bound based on the first type of the BQCRB in the case of single parameter estimation. The expression of OBB with a prior distribution \\(p(x)\\) is \\begin{align} \\mathrm{var}(\\hat{x},{\\Pi_y})\\geq\\int p(x)\\left(\\frac{(1+b')^2}{F} +b^2\\right)\\mathrm{d}x, \\end{align} where \\(b\\) and \\(b'\\) are the vector of biase and its derivative on \\(x\\) . \\(F\\) is the QFI for all types. Parameters \u00b6 x: list -- The regimes of the parameters for the integral. p: array -- The prior distribution. dp: list -- Derivatives of the prior distribution with respect to the unknown parameters to to estimated. For example, dp[0] is the derivative vector with respect to the first parameter. rho: list -- Parameterized density matrix. drho: list -- Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated. drho: list -- Second order Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated. LDtype: string -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). eps: float -- Machine epsilon. Returns \u00b6 QVTB: float or matrix -- For single parameter estimation (the length of x is equal to one), the output is a float and for multiparameter estimation (the length of x is more than one), it returns a matrix. Source code in quanestimation/BayesianBound/BayesianCramerRao.py 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 def OBB ( x , p , dp , rho , drho , d2rho , LDtype = \"SLD\" , eps = 1e-8 ): r \"\"\" Calculation of the optimal biased bound based on the first type of the BQCRB in the case of single parameter estimation. The expression of OBB with a prior distribution $p(x)$ is \\begin{align} \\mathrm{var}(\\hat{x},\\{\\Pi_y\\})\\geq\\int p(x)\\left(\\frac{(1+b')^2}{F} +b^2\\right)\\mathrm{d}x, \\end{align} where $b$ and $b'$ are the vector of biase and its derivative on $x$. $F$ is the QFI for all types. Parameters ---------- > **x:** `list` -- The regimes of the parameters for the integral. > **p:** `array` -- The prior distribution. > **dp:** `list` -- Derivatives of the prior distribution with respect to the unknown parameters to to estimated. For example, dp[0] is the derivative vector with respect to the first parameter. > **rho:** `list` -- Parameterized density matrix. > **drho:** `list` -- Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated. > **drho:** `list` -- Second order Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). > **eps:** `float` -- Machine epsilon. Returns ---------- **QVTB:** `float or matrix` -- For single parameter estimation (the length of x is equal to one), the output is a float and for multiparameter estimation (the length of x is more than one), it returns a matrix. \"\"\" #### single parameter scenario #### p_num = len ( p ) if type ( drho [ 0 ]) == list : drho = [ drho [ i ][ 0 ] for i in range ( p_num )] if type ( d2rho [ 0 ]) == list : d2rho = [ d2rho [ i ][ 0 ] for i in range ( p_num )] if type ( dp [ 0 ]) == list or type ( dp [ 0 ]) == np . ndarray : dp = [ dp [ i ][ 0 ] for i in range ( p_num )] if type ( x [ 0 ]) != float or type ( x [ 0 ]) != int : x = x [ 0 ] F , J = np . zeros ( p_num ), np . zeros ( p_num ) bias , dbias = np . zeros ( p_num ), np . zeros ( p_num ) for m in range ( p_num ): f , LD = QFIM ( rho [ m ], [ drho [ m ]], LDtype = LDtype , exportLD = True , eps = eps ) F [ m ] = f term1 = np . dot ( np . dot ( d2rho [ m ], d2rho [ m ]), LD ) term2 = np . dot ( np . dot ( LD , LD ), drho [ m ]) dF = np . real ( np . trace ( 2 * term1 - term2 )) J [ m ] = dp [ m ] / p [ m ] - dF / f y_guess = np . zeros (( 2 , x . size )) fun = lambda m , n : OBB_func ( m , n , x , J , F ) result = solve_bvp ( fun , boundary_condition , x , y_guess ) res = result . sol ( x ) bias , dbias = res [ 0 ], res [ 1 ] value = [ p [ i ] * (( 1 + dbias [ i ]) ** 2 / F [ i ] + bias [ i ] ** 2 ) for i in range ( p_num )] return simps ( value , x ) Calculation of the Bayesian version of Cramer-Rao bound introduced by Van Trees (VTB). The covariance matrix with a prior distribution \\(p(\\textbf{x})\\) is defined as \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},{\\Pi_y})=\\int p(\\textbf{x})\\sum_y\\mathrm{Tr} (\\rho\\Pi_y)(\\hat{\\textbf{x}}-\\textbf{x})(\\hat{\\textbf{x}}-\\textbf{x})^{\\mathrm{T}} \\mathrm{d}\\textbf{x} \\end{align} where \\(\\textbf{x}=(x_0,x_1,\\dots)^{\\mathrm{T}}\\) are the unknown parameters to be estimated and the integral \\(\\int\\mathrm{d}\\textbf{x}:=\\iiint\\mathrm{d}x_0\\mathrm{d}x_1\\cdots\\) . \\(\\{\\Pi_y\\}\\) is a set of positive operator-valued measure (POVM) and \\(\\rho\\) represent the parameterized density matrix. \\[\\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},\\{\\Pi_y\\})\\geq \\left(\\mathcal{I}_{\\mathrm{prior}} +\\mathcal{I}_{\\mathrm{Bayes}}\\right)^{-1}, \\end{align}\\] where \\(\\mathcal{I}_{\\mathrm{prior}}=\\int p(\\textbf{x})\\mathcal{I}_{p}\\mathrm{d}\\textbf{x}\\) is the CFIM for \\(p(\\textbf{x})\\) and \\(\\mathcal{I}_{\\mathrm{Bayes}}=\\int p(\\textbf{x})\\mathcal{I}\\mathrm{d}\\textbf{x}\\) is the average CFIM. Parameters \u00b6 x: list -- The regimes of the parameters for the integral. p: multidimensional array -- The prior distribution. dp: list -- Derivatives of the prior distribution with respect to the unknown parameters to be estimated. For example, dp[0] is the derivative vector with respect to the first parameter. rho: multidimensional list -- Parameterized density matrix. drho: multidimensional list -- Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated. M: list of matrices -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). eps: float -- Machine epsilon. Returns \u00b6 VTB: float or matrix -- For single parameter estimation (the length of x is equal to one), the output is a float and for multiparameter estimation (the length of x is more than one), it returns a matrix. Note: SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from here . Source code in quanestimation/BayesianBound/BayesianCramerRao.py 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 def VTB ( x , p , dp , rho , drho , M = [], eps = 1e-8 ): r \"\"\" Calculation of the Bayesian version of Cramer-Rao bound introduced by Van Trees (VTB). The covariance matrix with a prior distribution $p(\\textbf{x})$ is defined as \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},\\{\\Pi_y\\})=\\int p(\\textbf{x})\\sum_y\\mathrm{Tr} (\\rho\\Pi_y)(\\hat{\\textbf{x}}-\\textbf{x})(\\hat{\\textbf{x}}-\\textbf{x})^{\\mathrm{T}} \\mathrm{d}\\textbf{x} \\end{align} where $\\textbf{x}=(x_0,x_1,\\dots)^{\\mathrm{T}}$ are the unknown parameters to be estimated and the integral $\\int\\mathrm{d}\\textbf{x}:=\\iiint\\mathrm{d}x_0\\mathrm{d}x_1\\cdots$. $\\{\\Pi_y\\}$ is a set of positive operator-valued measure (POVM) and $\\rho$ represent the parameterized density matrix. \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},\\{\\Pi_y\\})\\geq \\left(\\mathcal{I}_{\\mathrm{prior}} +\\mathcal{I}_{\\mathrm{Bayes}}\\right)^{-1}, \\end{align} where $\\mathcal{I}_{\\mathrm{prior}}=\\int p(\\textbf{x})\\mathcal{I}_{p}\\mathrm{d}\\textbf{x}$ is the CFIM for $p(\\textbf{x})$ and $\\mathcal{I}_{\\mathrm{Bayes}}=\\int p(\\textbf{x})\\mathcal{I}\\mathrm{d}\\textbf{x}$ is the average CFIM. Parameters ---------- > **x:** `list` -- The regimes of the parameters for the integral. > **p:** `multidimensional array` -- The prior distribution. > **dp:** `list` -- Derivatives of the prior distribution with respect to the unknown parameters to be estimated. For example, dp[0] is the derivative vector with respect to the first parameter. > **rho:** `multidimensional list` -- Parameterized density matrix. > **drho:** `multidimensional list` -- Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). > **eps:** `float` -- Machine epsilon. Returns ---------- **VTB:** `float or matrix` -- For single parameter estimation (the length of x is equal to one), the output is a float and for multiparameter estimation (the length of x is more than one), it returns a matrix. **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" para_num = len ( x ) p_num = len ( p ) if para_num == 1 : #### single parameter scenario #### if M == []: M = SIC ( len ( rho [ 0 ])) else : if type ( M ) != list : raise TypeError ( \"Please make sure M is a list!\" ) if type ( drho [ 0 ]) == list : drho = [ drho [ i ][ 0 ] for i in range ( p_num )] if type ( dp [ 0 ]) == list or type ( dp [ 0 ]) == np . ndarray : dp = [ dp [ i ][ 0 ] for i in range ( p_num )] F_tp = np . zeros ( p_num ) for m in range ( p_num ): F_tp [ m ] = CFIM ( rho [ m ], [ drho [ m ]], M = M , eps = eps ) arr1 = [ np . real ( dp [ i ] * dp [ i ] / p [ i ]) for i in range ( p_num )] I = simps ( arr1 , x [ 0 ]) arr2 = [ np . real ( F_tp [ j ] * p [ j ]) for j in range ( p_num )] F = simps ( arr2 , x [ 0 ]) return 1.0 / ( I + F ) else : #### multiparameter scenario #### p_shape = np . shape ( p ) p_ext = extract_ele ( p , para_num ) dp_ext = extract_ele ( dp , para_num ) rho_ext = extract_ele ( rho , para_num ) drho_ext = extract_ele ( drho , para_num ) p_list , dp_list , rho_list , drho_list = [], [], [], [] for p_ele , dp_ele , rho_ele , drho_ele in zip ( p_ext , dp_ext , rho_ext , drho_ext ): p_list . append ( p_ele ) dp_list . append ( dp_ele ) rho_list . append ( rho_ele ) drho_list . append ( drho_ele ) dim = len ( rho_list [ 0 ]) if M == []: M = SIC ( dim ) else : if type ( M ) != list : raise TypeError ( \"Please make sure M is a list!\" ) F_list = [ [[ 0.0 for i in range ( len ( p_list ))] for j in range ( para_num )] for k in range ( para_num ) ] I_list = [ [[ 0.0 for i in range ( len ( p_list ))] for j in range ( para_num )] for k in range ( para_num ) ] for i in range ( len ( p_list )): F_tp = CFIM ( rho_list [ i ], drho_list [ i ], M = M , eps = eps ) for pj in range ( para_num ): for pk in range ( para_num ): F_list [ pj ][ pk ][ i ] = F_tp [ pj ][ pk ] I_list [ pj ][ pk ][ i ] = ( dp_list [ i ][ pj ] * dp_list [ i ][ pk ] / p_list [ i ] ** 2 ) F_res = np . zeros ([ para_num , para_num ]) I_res = np . zeros ([ para_num , para_num ]) for para_i in range ( 0 , para_num ): for para_j in range ( para_i , para_num ): F_ij = np . array ( F_list [ para_i ][ para_j ]) . reshape ( p_shape ) I_ij = np . array ( I_list [ para_i ][ para_j ]) . reshape ( p_shape ) arr1 = p * F_ij arr2 = p * I_ij for si in reversed ( range ( para_num )): arr1 = simps ( arr1 , x [ si ]) arr2 = simps ( arr2 , x [ si ]) F_res [ para_i ][ para_j ] = arr1 F_res [ para_j ][ para_i ] = arr1 I_res [ para_i ][ para_j ] = arr2 I_res [ para_j ][ para_i ] = arr2 return np . linalg . pinv ( F_res + I_res ) Calculation of the Bayesian version of quantum Cramer-Rao bound introduced by Van Trees (QVTB). The covariance matrix with a prior distribution p(\\textbf{x}) is defined as \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},{\\Pi_y})=\\int p(\\textbf{x})\\sum_y\\mathrm{Tr} (\\rho\\Pi_y)(\\hat{\\textbf{x}}-\\textbf{x})(\\hat{\\textbf{x}}-\\textbf{x})^{\\mathrm{T}} \\mathrm{d}\\textbf{x} \\end{align} where \\(\\textbf{x}=(x_0,x_1,\\dots)^{\\mathrm{T}}\\) are the unknown parameters to be estimated and the integral \\(\\int\\mathrm{d}\\textbf{x}:=\\iiint\\mathrm{d}x_0\\mathrm{d}x_1\\cdots\\) . \\(\\{\\Pi_y\\}\\) is a set of positive operator-valued measure (POVM) and \\(\\rho\\) represent the parameterized density matrix. \\[\\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},\\{\\Pi_y\\})\\geq \\left(\\mathcal{I}_{\\mathrm{prior}} +\\mathcal{F}_{\\mathrm{Bayes}}\\right)^{-1}, \\end{align}\\] where \\(\\mathcal{I}_{\\mathrm{prior}}=\\int p(\\textbf{x})\\mathcal{I}_{p}\\mathrm{d}\\textbf{x}\\) is the CFIM for \\(p(\\textbf{x})\\) and \\(\\mathcal{F}_{\\mathrm{Bayes}}=\\int p(\\textbf{x})\\mathcal{F} \\mathrm{d}\\textbf{x}\\) is the average QFIM of all types. Parameters \u00b6 x: list -- The regimes of the parameters for the integral. p: multidimensional array -- The prior distribution. dp: list -- Derivatives of the prior distribution with respect to the unknown parameters to to estimated. For example, dp[0] is the derivative vector with respect to the first parameter. rho: multidimensional list -- Parameterized density matrix. drho: multidimensional list -- Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated. LDtype: string -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). eps: float -- Machine epsilon. Returns \u00b6 QVTB: float or matrix -- For single parameter estimation (the length of x is equal to one), the output is a float and for multiparameter estimation (the length of x is more than one), it returns a matrix. Source code in quanestimation/BayesianBound/BayesianCramerRao.py 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 def QVTB ( x , p , dp , rho , drho , LDtype = \"SLD\" , eps = 1e-8 ): r \"\"\" Calculation of the Bayesian version of quantum Cramer-Rao bound introduced by Van Trees (QVTB). The covariance matrix with a prior distribution p(\\textbf{x}) is defined as \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},\\{\\Pi_y\\})=\\int p(\\textbf{x})\\sum_y\\mathrm{Tr} (\\rho\\Pi_y)(\\hat{\\textbf{x}}-\\textbf{x})(\\hat{\\textbf{x}}-\\textbf{x})^{\\mathrm{T}} \\mathrm{d}\\textbf{x} \\end{align} where $\\textbf{x}=(x_0,x_1,\\dots)^{\\mathrm{T}}$ are the unknown parameters to be estimated and the integral $\\int\\mathrm{d}\\textbf{x}:=\\iiint\\mathrm{d}x_0\\mathrm{d}x_1\\cdots$. $\\{\\Pi_y\\}$ is a set of positive operator-valued measure (POVM) and $\\rho$ represent the parameterized density matrix. \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},\\{\\Pi_y\\})\\geq \\left(\\mathcal{I}_{\\mathrm{prior}} +\\mathcal{F}_{\\mathrm{Bayes}}\\right)^{-1}, \\end{align} where $\\mathcal{I}_{\\mathrm{prior}}=\\int p(\\textbf{x})\\mathcal{I}_{p}\\mathrm{d}\\textbf{x}$ is the CFIM for $p(\\textbf{x})$ and $\\mathcal{F}_{\\mathrm{Bayes}}=\\int p(\\textbf{x})\\mathcal{F} \\mathrm{d}\\textbf{x}$ is the average QFIM of all types. Parameters ---------- > **x:** `list` -- The regimes of the parameters for the integral. > **p:** multidimensional array -- The prior distribution. > **dp:** `list` -- Derivatives of the prior distribution with respect to the unknown parameters to to estimated. For example, dp[0] is the derivative vector with respect to the first parameter. > **rho:** `multidimensional list` -- Parameterized density matrix. > **drho:** `multidimensional list` -- Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). > **eps:** `float` -- Machine epsilon. Returns ---------- **QVTB:** `float or matrix` -- For single parameter estimation (the length of x is equal to one), the output is a float and for multiparameter estimation (the length of x is more than one), it returns a matrix. \"\"\" para_num = len ( x ) p_num = len ( p ) if para_num == 1 : if type ( drho [ 0 ]) == list : drho = [ drho [ i ][ 0 ] for i in range ( p_num )] if type ( dp [ 0 ]) == list or type ( dp [ 0 ]) == np . ndarray : dp = [ dp [ i ][ 0 ] for i in range ( p_num )] F_tp = np . zeros ( p_num ) for m in range ( p_num ): F_tp [ m ] = QFIM ( rho [ m ], [ drho [ m ]], LDtype = LDtype , eps = eps ) arr1 = [ np . real ( dp [ i ] * dp [ i ] / p [ i ]) for i in range ( p_num )] I = simps ( arr1 , x [ 0 ]) arr2 = [ np . real ( F_tp [ j ] * p [ j ]) for j in range ( p_num )] F = simps ( arr2 , x [ 0 ]) return 1.0 / ( I + F ) else : #### multiparameter scenario #### p_shape = np . shape ( p ) p_ext = extract_ele ( p , para_num ) dp_ext = extract_ele ( dp , para_num ) rho_ext = extract_ele ( rho , para_num ) drho_ext = extract_ele ( drho , para_num ) p_list , dp_list , rho_list , drho_list , = ( [], [], [], [], ) for p_ele , dp_ele , rho_ele , drho_ele in zip ( p_ext , dp_ext , rho_ext , drho_ext ): p_list . append ( p_ele ) dp_list . append ( dp_ele ) rho_list . append ( rho_ele ) drho_list . append ( drho_ele ) F_list = [ [[ 0.0 for i in range ( len ( p_list ))] for j in range ( para_num )] for k in range ( para_num ) ] I_list = [ [[ 0.0 for i in range ( len ( p_list ))] for j in range ( para_num )] for k in range ( para_num ) ] for i in range ( len ( p_list )): F_tp = QFIM ( rho_list [ i ], drho_list [ i ], LDtype = LDtype , eps = eps ) for pj in range ( para_num ): for pk in range ( para_num ): F_list [ pj ][ pk ][ i ] = F_tp [ pj ][ pk ] I_list [ pj ][ pk ][ i ] = ( dp_list [ i ][ pj ] * dp_list [ i ][ pk ] / p_list [ i ] ** 2 ) F_res = np . zeros ([ para_num , para_num ]) I_res = np . zeros ([ para_num , para_num ]) for para_i in range ( 0 , para_num ): for para_j in range ( para_i , para_num ): F_ij = np . array ( F_list [ para_i ][ para_j ]) . reshape ( p_shape ) I_ij = np . array ( I_list [ para_i ][ para_j ]) . reshape ( p_shape ) arr1 = p * F_ij arr2 = p * I_ij for si in reversed ( range ( para_num )): arr1 = simps ( arr1 , x [ si ]) arr2 = simps ( arr2 , x [ si ]) F_res [ para_i ][ para_j ] = arr1 F_res [ para_j ][ para_i ] = arr1 I_res [ para_i ][ para_j ] = arr2 I_res [ para_j ][ para_i ] = arr2 return np . linalg . pinv ( F_res + I_res ) Quantum Ziv-Zakai bound \u00b6 Calculation of the quantum Ziv-Zakai bound (QZZB). The expression of QZZB with a prior distribution p(x) in a finite regime \\([\\alpha,\\beta]\\) is \\[\\begin{eqnarray} \\mathrm{var}(\\hat{x},\\{\\Pi_y\\}) &\\geq & \\frac{1}{2}\\int_0^\\infty \\mathrm{d}\\tau\\tau \\mathcal{V}\\int_{-\\infty}^{\\infty} \\mathrm{d}x\\min\\!\\left\\{p(x), p(x+\\tau)\\right\\} \\nonumber \\\\ & & \\times\\left(1-\\frac{1}{2}||\\rho(x)-\\rho(x+\\tau)||\\right), \\end{eqnarray}\\] where \\(||\\cdot||\\) represents the trace norm and \\(\\mathcal{V}\\) is the \"valley-filling\" operator satisfying \\(\\mathcal{V}f(\\tau)=\\max_{h\\geq 0}f(\\tau+h)\\) . \\(\\rho(x)\\) is the parameterized density matrix. Parameters \u00b6 x: list -- The regimes of the parameters for the integral. p: multidimensional array -- The prior distribution. rho: multidimensional list -- Parameterized density matrix. eps: float -- Machine epsilon. Returns \u00b6 QZZB: float -- Quantum Ziv-Zakai bound (QZZB). Source code in quanestimation/BayesianBound/ZivZakai.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def QZZB ( x , p , rho , eps = 1e-8 ): r \"\"\" Calculation of the quantum Ziv-Zakai bound (QZZB). The expression of QZZB with a prior distribution p(x) in a finite regime $[\\alpha,\\beta]$ is \\begin{eqnarray} \\mathrm{var}(\\hat{x},\\{\\Pi_y\\}) &\\geq & \\frac{1}{2}\\int_0^\\infty \\mathrm{d}\\tau\\tau \\mathcal{V}\\int_{-\\infty}^{\\infty} \\mathrm{d}x\\min\\!\\left\\{p(x), p(x+\\tau)\\right\\} \\nonumber \\\\ & & \\times\\left(1-\\frac{1}{2}||\\rho(x)-\\rho(x+\\tau)||\\right), \\end{eqnarray} where $||\\cdot||$ represents the trace norm and $\\mathcal{V}$ is the \"valley-filling\" operator satisfying $\\mathcal{V}f(\\tau)=\\max_{h\\geq 0}f(\\tau+h)$. $\\rho(x)$ is the parameterized density matrix. Parameters ---------- > **x:** `list` -- The regimes of the parameters for the integral. > **p:** `multidimensional array` -- The prior distribution. > **rho:** `multidimensional list` -- Parameterized density matrix. > **eps:** `float` -- Machine epsilon. Returns ---------- **QZZB:** `float` -- Quantum Ziv-Zakai bound (QZZB). \"\"\" if type ( x [ 0 ]) == list or type ( x [ 0 ]) == np . ndarray : x = x [ 0 ] p_num = len ( p ) tau = [ xi - x [ 0 ] for xi in x ] f_tau = np . zeros ( p_num ) for i in range ( p_num ): arr = [ np . real ( 2 * min ( p [ j ], p [ j + i ]) * helstrom_dm ( rho [ j ], rho [ j + i ], eps )) for j in range ( p_num - i ) ] f_tp = simps ( arr , x [ 0 : p_num - i ]) f_tau [ i ] = f_tp arr2 = [ tau [ m ] * max ( f_tau [ m :]) for m in range ( p_num )] I = simps ( arr2 , tau ) return 0.5 * I Bayesian estimation \u00b6 Bayesian estimation. The prior distribution is updated via the posterior distribution obtained by the Bayes\u2019 rule and the estimated value of parameters are updated via the expectation value of the distribution or maximum a posteriori probability (MAP). Parameters \u00b6 x: list -- The regimes of the parameters for the integral. p: multidimensional array -- The prior distribution. rho: multidimensional list -- Parameterized density matrix. y: array -- The experimental results obtained in practice. M: list of matrices -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). estimator: string -- Estimators for the bayesian estimation. Options are: \"mean\" -- The expectation value of the distribution. \"MAP\" -- Maximum a posteriori probability. savefile: bool -- Whether or not to save all the posterior distributions. If set True then two files \"pout.npy\" and \"xout.npy\" will be generated including the posterior distributions and the estimated values in the iterations. If set False the posterior distribution in the final iteration and the estimated values in all iterations will be saved in \"pout.npy\" and \"xout.npy\". Returns \u00b6 pout and xout: array and float -- The posterior distribution and the estimated values in the final iteration. Note: SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from here . Source code in quanestimation/BayesianBound/BayesEstimation.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 def Bayes ( x , p , rho , y , M = [], estimator = \"mean\" , savefile = False ): \"\"\" Bayesian estimation. The prior distribution is updated via the posterior distribution obtained by the Bayes\u2019 rule and the estimated value of parameters are updated via the expectation value of the distribution or maximum a posteriori probability (MAP). Parameters ---------- > **x:** `list` -- The regimes of the parameters for the integral. > **p:** `multidimensional array` -- The prior distribution. > **rho:** `multidimensional list` -- Parameterized density matrix. > **y:** `array` -- The experimental results obtained in practice. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). > **estimator:** `string` -- Estimators for the bayesian estimation. Options are: \"mean\" -- The expectation value of the distribution. \"MAP\" -- Maximum a posteriori probability. > **savefile:** `bool` -- Whether or not to save all the posterior distributions. If set `True` then two files \"pout.npy\" and \"xout.npy\" will be generated including the posterior distributions and the estimated values in the iterations. If set `False` the posterior distribution in the final iteration and the estimated values in all iterations will be saved in \"pout.npy\" and \"xout.npy\". Returns ---------- **pout and xout:** `array and float` -- The posterior distribution and the estimated values in the final iteration. **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" para_num = len ( x ) max_episode = len ( y ) if para_num == 1 : #### single parameter scenario #### if M == []: M = SIC ( len ( rho [ 0 ])) else : if type ( M ) != list : raise TypeError ( \"Please make sure M is a list!\" ) if savefile == False : x_out = [] if estimator == \"mean\" : for mi in range ( max_episode ): res_exp = int ( y [ mi ]) pyx = np . zeros ( len ( x [ 0 ])) for xi in range ( len ( x [ 0 ])): p_tp = np . real ( np . trace ( np . dot ( rho [ xi ], M [ res_exp ]))) pyx [ xi ] = p_tp arr = [ pyx [ m ] * p [ m ] for m in range ( len ( x [ 0 ]))] py = simps ( arr , x [ 0 ]) p_update = pyx * p / py p = p_update mean = simps ([ p [ m ] * x [ 0 ][ m ] for m in range ( len ( x [ 0 ]))], x [ 0 ]) x_out . append ( mean ) elif estimator == \"MAP\" : for mi in range ( max_episode ): res_exp = int ( y [ mi ]) pyx = np . zeros ( len ( x [ 0 ])) for xi in range ( len ( x [ 0 ])): p_tp = np . real ( np . trace ( np . dot ( rho [ xi ], M [ res_exp ]))) pyx [ xi ] = p_tp arr = [ pyx [ m ] * p [ m ] for m in range ( len ( x [ 0 ]))] py = simps ( arr , x [ 0 ]) p_update = pyx * p / py p = p_update indx = np . where ( p == max ( p ))[ 0 ][ 0 ] x_out . append ( x [ 0 ][ indx ]) else : raise ValueError ( \" {!r} is not a valid value for estimator, supported values are 'mean' and 'MAP'.\" . format ( estimator )) np . save ( \"pout\" , p ) np . save ( \"xout\" , x_out ) return p , x_out [ - 1 ] else : p_out , x_out = [], [] if estimator == \"mean\" : for mi in range ( max_episode ): res_exp = int ( y [ mi ]) pyx = np . zeros ( len ( x [ 0 ])) for xi in range ( len ( x [ 0 ])): p_tp = np . real ( np . trace ( np . dot ( rho [ xi ], M [ res_exp ]))) pyx [ xi ] = p_tp arr = [ pyx [ m ] * p [ m ] for m in range ( len ( x [ 0 ]))] py = simps ( arr , x [ 0 ]) p_update = pyx * p / py p = p_update mean = simps ([ p [ m ] * x [ 0 ][ m ] for m in range ( len ( x [ 0 ]))], x [ 0 ]) p_out . append ( p ) x_out . append ( mean ) elif estimator == \"MAP\" : for mi in range ( max_episode ): res_exp = int ( y [ mi ]) pyx = np . zeros ( len ( x [ 0 ])) for xi in range ( len ( x [ 0 ])): p_tp = np . real ( np . trace ( np . dot ( rho [ xi ], M [ res_exp ]))) pyx [ xi ] = p_tp arr = [ pyx [ m ] * p [ m ] for m in range ( len ( x [ 0 ]))] py = simps ( arr , x [ 0 ]) p_update = pyx * p / py p = p_update indx = np . where ( p == max ( p ))[ 0 ][ 0 ] p_out . append ( p ) x_out . append ( x [ 0 ][ indx ]) else : raise ValueError ( \" {!r} is not a valid value for estimator, supported values are 'mean' and 'MAP'.\" . format ( estimator )) np . save ( \"pout\" , p_out ) np . save ( \"xout\" , x_out ) return p , x_out [ - 1 ] else : #### multiparameter scenario #### p_shape = np . shape ( p ) p_ext = extract_ele ( p , para_num ) rho_ext = extract_ele ( rho , para_num ) p_list , rho_list = [], [] for p_ele , rho_ele in zip ( p_ext , rho_ext ): p_list . append ( p_ele ) rho_list . append ( rho_ele ) dim = len ( rho_list [ 0 ]) if M == []: M = SIC ( dim ) else : if type ( M ) != list : raise TypeError ( \"Please make sure M is a list!\" ) if savefile == False : x_out = [] if estimator == \"mean\" : for mi in range ( max_episode ): res_exp = int ( y [ mi ]) pyx_list = np . zeros ( len ( p_list )) for xi in range ( len ( p_list )): p_tp = np . real ( np . trace ( np . dot ( rho_list [ xi ], M [ res_exp ]))) pyx_list [ xi ] = p_tp pyx = pyx_list . reshape ( p_shape ) arr = p * pyx for si in reversed ( range ( para_num )): arr = simps ( arr , x [ si ]) py = arr p_update = p * pyx / py p = p_update mean = integ ( x , p ) x_out . append ( mean ) elif estimator == \"MAP\" : for mi in range ( max_episode ): res_exp = int ( y [ mi ]) pyx_list = np . zeros ( len ( p_list )) for xi in range ( len ( p_list )): p_tp = np . real ( np . trace ( np . dot ( rho_list [ xi ], M [ res_exp ]))) pyx_list [ xi ] = p_tp pyx = pyx_list . reshape ( p_shape ) arr = p * pyx for si in reversed ( range ( para_num )): arr = simps ( arr , x [ si ]) py = arr p_update = p * pyx / py p = p_update indx = np . where ( np . array ( p ) == np . max ( np . array ( p ))) x_out . append ([ x [ i ][ indx [ i ][ 0 ]] for i in range ( para_num )]) else : raise ValueError ( \" {!r} is not a valid value for estimator, supported values are 'mean' and 'MAP'.\" . format ( estimator )) np . save ( \"Lout\" , p ) np . save ( \"xout\" , x_out ) return p , x_out [ - 1 ] else : p_out , x_out = [], [] if estimator == \"mean\" : for mi in range ( max_episode ): res_exp = int ( y [ mi ]) pyx_list = np . zeros ( len ( p_list )) for xi in range ( len ( p_list )): p_tp = np . real ( np . trace ( np . dot ( rho_list [ xi ], M [ res_exp ]))) pyx_list [ xi ] = p_tp pyx = pyx_list . reshape ( p_shape ) arr = p * pyx for si in reversed ( range ( para_num )): arr = simps ( arr , x [ si ]) py = arr p_update = p * pyx / py p = p_update mean = integ ( x , p ) p_out . append ( p ) x_out . append ( mean ) elif estimator == \"MAP\" : for mi in range ( max_episode ): res_exp = int ( y [ mi ]) pyx_list = np . zeros ( len ( p_list )) for xi in range ( len ( p_list )): p_tp = np . real ( np . trace ( np . dot ( rho_list [ xi ], M [ res_exp ]))) pyx_list [ xi ] = p_tp pyx = pyx_list . reshape ( p_shape ) arr = p * pyx for si in reversed ( range ( para_num )): arr = simps ( arr , x [ si ]) py = arr p_update = p * pyx / py p = p_update indx = np . where ( np . array ( p ) == np . max ( np . array ( p ))) p_out . append ( p ) x_out . append ([ x [ i ][ indx [ i ][ 0 ]] for i in range ( para_num )]) else : raise ValueError ( \" {!r} is not a valid value for estimator, supported values are 'mean' and 'MAP'.\" . format ( estimator )) np . save ( \"pout\" , p_out ) np . save ( \"xout\" , x_out ) return p , x_out [ - 1 ] Bayesian estimation. The estimated value of parameters obtained via the maximum likelihood estimation (MLE). Parameters \u00b6 x: list -- The regimes of the parameters for the integral. rho: multidimensional list -- Parameterized density matrix. y: array -- The experimental results obtained in practice. M: list of matrices -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). savefile: bool -- Whether or not to save all the likelihood functions. If set True then two files \"Lout.npy\" and \"xout.npy\" will be generated including the likelihood functions and the estimated values in the iterations. If set False the likelihood function in the final iteration and the estimated values in all iterations will be saved in \"Lout.npy\" and \"xout.npy\". Returns \u00b6 Lout and xout: array and float -- The likelihood function and the estimated values in the final iteration. Note: SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from here . Source code in quanestimation/BayesianBound/BayesEstimation.py 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 def MLE ( x , rho , y , M = [], savefile = False ): \"\"\" Bayesian estimation. The estimated value of parameters obtained via the maximum likelihood estimation (MLE). Parameters ---------- > **x:** `list` -- The regimes of the parameters for the integral. > **rho:** `multidimensional list` -- Parameterized density matrix. > **y:** `array` -- The experimental results obtained in practice. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). > **savefile:** `bool` -- Whether or not to save all the likelihood functions. If set `True` then two files \"Lout.npy\" and \"xout.npy\" will be generated including the likelihood functions and the estimated values in the iterations. If set `False` the likelihood function in the final iteration and the estimated values in all iterations will be saved in \"Lout.npy\" and \"xout.npy\". Returns ---------- **Lout and xout:** `array and float` -- The likelihood function and the estimated values in the final iteration. **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" para_num = len ( x ) max_episode = len ( y ) if para_num == 1 : #### single parameter scenario #### if M == []: M = SIC ( len ( rho [ 0 ])) else : if type ( M ) != list : raise TypeError ( \"Please make sure M is a list!\" ) if savefile == False : x_out = [] L_out = np . ones ( len ( x [ 0 ])) for mi in range ( max_episode ): res_exp = int ( y [ mi ]) for xi in range ( len ( x [ 0 ])): p_tp = np . real ( np . trace ( np . dot ( rho [ xi ], M [ res_exp ]))) L_out [ xi ] = L_out [ xi ] * p_tp indx = np . where ( L_out == max ( L_out ))[ 0 ][ 0 ] x_out . append ( x [ 0 ][ indx ]) np . save ( \"Lout\" , L_out ) np . save ( \"xout\" , x_out ) return L_out , x_out [ - 1 ] else : L_out , x_out = [], [] L_tp = np . ones ( len ( x [ 0 ])) for mi in range ( max_episode ): res_exp = int ( y [ mi ]) for xi in range ( len ( x [ 0 ])): p_tp = np . real ( np . trace ( np . dot ( rho [ xi ], M [ res_exp ]))) L_tp [ xi ] = L_tp [ xi ] * p_tp indx = np . where ( L_tp == max ( L_tp ))[ 0 ][ 0 ] L_out . append ( L_tp ) x_out . append ( x [ 0 ][ indx ]) np . save ( \"Lout\" , L_out ) np . save ( \"xout\" , x_out ) return L_tp , x_out [ - 1 ] else : #### multiparameter scenario #### p_shape = [] for i in range ( para_num ): p_shape . append ( len ( x [ i ])) rho_ext = extract_ele ( rho , para_num ) rho_list = [] for rho_ele in rho_ext : rho_list . append ( rho_ele ) dim = len ( rho_list [ 0 ]) if M == []: M = SIC ( dim ) else : if type ( M ) != list : raise TypeError ( \"Please make sure M is a list!\" ) if savefile == False : x_out = [] L_list = np . ones ( len ( rho_list )) for mi in range ( max_episode ): res_exp = int ( y [ mi ]) for xi in range ( len ( rho_list )): p_tp = np . real ( np . trace ( np . dot ( rho_list [ xi ], M [ res_exp ]))) L_list [ xi ] = L_list [ xi ] * p_tp L_out = L_list . reshape ( p_shape ) indx = np . where ( L_out == np . max ( L_out )) x_out . append ([ x [ i ][ indx [ i ][ 0 ]] for i in range ( para_num )]) np . save ( \"Lout\" , L_out ) np . save ( \"xout\" , x_out ) return L_out , x_out [ - 1 ] else : L_out , x_out = [], [] L_list = np . ones ( len ( rho_list )) for mi in range ( max_episode ): res_exp = int ( y [ mi ]) for xi in range ( len ( rho_list )): p_tp = np . real ( np . trace ( np . dot ( rho_list [ xi ], M [ res_exp ]))) L_list [ xi ] = L_list [ xi ] * p_tp L_tp = L_list . reshape ( p_shape ) indx = np . where ( L_tp == np . max ( L_tp )) L_out . append ( L_tp ) x_out . append ([ x [ i ][ indx [ i ][ 0 ]] for i in range ( para_num )]) np . save ( \"Lout\" , L_out ) np . save ( \"xout\" , x_out ) return L_tp , x_out [ - 1 ] Calculation of the average Bayesian cost with a quadratic cost function. Parameters \u00b6 x: list -- The regimes of the parameters for the integral. p: multidimensional array -- The prior distribution. xest: list -- The estimators. rho: multidimensional list -- Parameterized density matrix. M: array -- A set of POVM. W: array -- Weight matrix. eps: float -- Machine epsilon. Returns \u00b6 The average Bayesian cost: float -- The average Bayesian cost. Source code in quanestimation/BayesianBound/BayesEstimation.py 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 def BayesCost ( x , p , xest , rho , M , W = [], eps = 1e-8 ): \"\"\" Calculation of the average Bayesian cost with a quadratic cost function. Parameters ---------- > **x:** `list` -- The regimes of the parameters for the integral. > **p:** `multidimensional array` -- The prior distribution. > **xest:** `list` -- The estimators. > **rho:** `multidimensional list` -- Parameterized density matrix. > **M:** `array` -- A set of POVM. > **W:** `array` -- Weight matrix. > **eps:** `float` -- Machine epsilon. Returns ---------- **The average Bayesian cost:** `float` -- The average Bayesian cost. \"\"\" para_num = len ( x ) if para_num == 1 : # single-parameter scenario if M == []: M = SIC ( len ( rho [ 0 ])) else : if type ( M ) != list : raise TypeError ( \"Please make sure M is a list!\" ) p_num = len ( x [ 0 ]) value = [ p [ i ] * sum ([ np . trace ( np . dot ( rho [ i ], M [ mi ])) * ( x [ 0 ][ i ] - xest [ mi ][ 0 ]) ** 2 for mi in range ( len ( M ))]) for i in range ( p_num )] C = simps ( value , x [ 0 ]) return np . real ( C ) else : # multi-parameter scenario p_shape = np . shape ( p ) p_ext = extract_ele ( p , para_num ) rho_ext = extract_ele ( rho , para_num ) p_list , rho_list = [], [] for p_ele , rho_ele in zip ( p_ext , rho_ext ): p_list . append ( p_ele ) rho_list . append ( rho_ele ) x_pro = product ( * x ) x_list = [] for x_ele in x_pro : x_list . append ([ x_ele [ i ] for i in range ( para_num )]) dim = len ( rho_list [ 0 ]) p_num = len ( p_list ) if W == []: W = np . identity ( para_num ) if M == []: M = SIC ( dim ) else : if type ( M ) != list : raise TypeError ( \"Please make sure M is a list!\" ) value = [ 0.0 for i in range ( p_num )] for i in range ( p_num ): x_tp = np . array ( x_list [ i ]) xCx = 0.0 for mi in range ( len ( M )): xCx += np . trace ( np . dot ( rho_list [ i ], M [ mi ])) * np . dot (( x_tp - xest [ mi ]) . reshape ( 1 , - 1 ), np . dot ( W , ( x_tp - xest [ mi ]) . reshape ( - 1 , 1 )))[ 0 ][ 0 ] value [ i ] = p_list [ i ] * xCx C = np . array ( value ) . reshape ( p_shape ) for si in reversed ( range ( para_num )): C = simps ( C , x [ si ]) return np . real ( C ) Calculation of the Bayesian cost bound with a quadratic cost function. Parameters \u00b6 x: list -- The regimes of the parameters for the integral. p: multidimensional array -- The prior distribution. rho: multidimensional list -- Parameterized density matrix. W: array -- Weight matrix. eps: float -- Machine epsilon. Returns \u00b6 BCB: float -- The value of the minimum Bayesian cost. Source code in quanestimation/BayesianBound/BayesEstimation.py 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 def BCB ( x , p , rho , W = [], eps = 1e-8 ): \"\"\" Calculation of the Bayesian cost bound with a quadratic cost function. Parameters ---------- > **x:** `list` -- The regimes of the parameters for the integral. > **p:** `multidimensional array` -- The prior distribution. > **rho:** `multidimensional list` -- Parameterized density matrix. > **W:** `array` -- Weight matrix. > **eps:** `float` -- Machine epsilon. Returns ---------- **BCB:** `float` -- The value of the minimum Bayesian cost. \"\"\" para_num = len ( x ) if para_num == 1 : # single-parameter scenario dim = len ( rho [ 0 ]) p_num = len ( x [ 0 ]) value = [ p [ i ] * x [ 0 ][ i ] ** 2 for i in range ( p_num )] delta2_x = simps ( value , x [ 0 ]) rho_avg = np . zeros (( dim , dim ), dtype = np . complex128 ) rho_pri = np . zeros (( dim , dim ), dtype = np . complex128 ) for di in range ( dim ): for dj in range ( dim ): rho_avg_arr = [ p [ m ] * rho [ m ][ di ][ dj ] for m in range ( p_num )] rho_pri_arr = [ p [ n ] * x [ 0 ][ n ] * rho [ n ][ di ][ dj ] for n in range ( p_num )] rho_avg [ di ][ dj ] = simps ( rho_avg_arr , x [ 0 ]) rho_pri [ di ][ dj ] = simps ( rho_pri_arr , x [ 0 ]) Lambda = Lambda_avg ( rho_avg , [ rho_pri ], eps = eps ) minBC = delta2_x - np . real ( np . trace ( np . dot ( np . dot ( rho_avg , Lambda [ 0 ]), Lambda [ 0 ]))) return minBC else : # multi-parameter scenario p_shape = np . shape ( p ) p_ext = extract_ele ( p , para_num ) rho_ext = extract_ele ( rho , para_num ) p_list , rho_list = [], [] for p_ele , rho_ele in zip ( p_ext , rho_ext ): p_list . append ( p_ele ) rho_list . append ( rho_ele ) dim = len ( rho_list [ 0 ]) p_num = len ( p_list ) x_pro = product ( * x ) x_list = [] for x_ele in x_pro : x_list . append ([ x_ele [ i ] for i in range ( para_num )]) if W == []: W = np . identity ( para_num ) value = [ 0.0 for i in range ( p_num )] for i in range ( p_num ): x_tp = np . array ( x_list [ i ]) xCx = np . dot ( x_tp . reshape ( 1 , - 1 ), np . dot ( W , x_tp . reshape ( - 1 , 1 )))[ 0 ][ 0 ] value [ i ] = p_list [ i ] * xCx delta2_x = np . array ( value ) . reshape ( p_shape ) for si in reversed ( range ( para_num )): delta2_x = simps ( delta2_x , x [ si ]) rho_avg = np . zeros (( dim , dim ), dtype = np . complex128 ) rho_pri = [ np . zeros (( dim , dim ), dtype = np . complex128 ) for i in range ( para_num )] for di in range ( dim ): for dj in range ( dim ): rho_avg_arr = [ p_list [ m ] * rho_list [ m ][ di ][ dj ] for m in range ( p_num )] rho_avg_tp = np . array ( rho_avg_arr ) . reshape ( p_shape ) for si in reversed ( range ( para_num )): rho_avg_tp = simps ( rho_avg_tp , x [ si ]) rho_avg [ di ][ dj ] = rho_avg_tp for para_i in range ( para_num ): rho_pri_arr = [ p_list [ n ] * x_list [ n ][ para_i ] * rho_list [ n ][ di ][ dj ] for n in range ( p_num )] rho_pri_tp = np . array ( rho_pri_arr ) . reshape ( p_shape ) for si in reversed ( range ( para_num )): rho_pri_tp = simps ( rho_pri_tp , x [ si ]) rho_pri [ para_i ][ di ][ dj ] = rho_pri_tp Lambda = Lambda_avg ( rho_avg , rho_pri , eps = eps ) Mat = np . zeros (( para_num , para_num ), dtype = np . complex128 ) for para_m in range ( para_num ): for para_n in range ( para_num ): Mat += W [ para_m ][ para_n ] * np . dot ( Lambda [ para_m ], Lambda [ para_n ]) minBC = delta2_x - np . real ( np . trace ( np . dot ( rho_avg , Mat ))) return minBC Common \u00b6 Generation of the input variables H, dH (or K, dK). Parameters \u00b6 x: list -- The regimes of the parameters for the integral. func: list -- Function defined by the users which returns H or K. dfunc: list -- Function defined by the users which returns dH or dK. channel: string -- Seeting the output of this function. Options are: \"dynamics\" (default) -- The output of this function is H and dH. \"Kraus\" (default) -- The output of this function is K and dHK. Returns \u00b6 H, dH (or K, dK). Source code in quanestimation/Common/Common.py 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 def BayesInput ( x , func , dfunc , channel = \"dynamics\" ): \"\"\" Generation of the input variables H, dH (or K, dK). Parameters ---------- > **x:** `list` -- The regimes of the parameters for the integral. > **func:** `list` -- Function defined by the users which returns H or K. > **dfunc:** `list` -- Function defined by the users which returns dH or dK. > **channel:** `string` -- Seeting the output of this function. Options are: \"dynamics\" (default) -- The output of this function is H and dH. \"Kraus\" (default) -- The output of this function is K and dHK. Returns ---------- H, dH (or K, dK). \"\"\" para_num = len ( x ) size = [ len ( x [ i ]) for i in range ( len ( x ))] x_all = product ( * x ) if channel == \"dynamics\" : dim = len ( func ([ 0 for i in range ( para_num )])) H_list , dH_list = [], [] for xi in x_all : H_list . append ( func ([ i for i in xi ])) dH_list . append ( dfunc ([ i for i in xi ])) H_res = np . reshape ( H_list , [ * size , * [ dim , dim ]]) dH_res = np . reshape ( dH_list , [ * size , * [ para_num , dim , dim ]]) return H_res , dH_res elif channel == \"Kraus\" : k_num = len ( func ([ 0 for i in range ( para_num )])) dim = len ( func ([ 0 for i in range ( para_num )])[ 0 ]) K_list , dK_list = [], [] if para_num == 1 : for xi in x_all : K_list . append ( func ([ i for i in xi ])) dK_list . append ( dfunc ([ i for i in xi ])) K_res = np . reshape ( K_list , [ * size , * [ k_num , dim , dim ]]) dK_res = np . reshape ( dK_list , [ * size , * [ para_num , k_num , dim , dim ]]) else : for xi in x_all : K_list . append ( func ([ i for i in xi ])) dK_list . append ( dfunc ([ i for i in xi ])) K_res = np . reshape ( K_list , [ * size , * [ k_num , dim , dim ]]) dK_res = np . reshape ( dK_list , [ * size , * [ k_num , para_num , dim , dim ]]) return K_res , dK_res else : raise ValueError ( \" {!r} is not a valid value for channel, supported values are 'dynamics' and 'Kraus'.\" . format ( channel ) ) Generation of a set of rank-one symmetric informationally complete positive operator-valued measure (SIC-POVM). Parameters \u00b6 dim: int -- The dimension of the system. Returns \u00b6 A set of SCI-POVM. Note: SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from here . Source code in quanestimation/Common/Common.py 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 def SIC ( dim ): \"\"\" Generation of a set of rank-one symmetric informationally complete positive operator-valued measure (SIC-POVM). Parameters ---------- > **dim:** `int` -- The dimension of the system. Returns ---------- A set of SCI-POVM. **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" if dim <= 151 : file_path = os . path . join ( os . path . dirname ( os . path . dirname ( __file__ )), \"sic_fiducial_vectors/d %d .txt\" % ( dim ), ) data = np . loadtxt ( file_path ) fiducial = data [:, 0 ] + data [:, 1 ] * 1.0 j fiducial = np . array ( fiducial ) . reshape ( len ( fiducial ), 1 ) M = sic_povm ( fiducial ) return M else : raise ValueError ( \"The dimension of the space should be less or equal to 151.\" ) Generation of the SU( \\(N\\) ) generators with \\(N\\) the dimension of the system. Parameters \u00b6 n: int -- The dimension of the system. Returns \u00b6 SU( \\(N\\) ) generators. Source code in quanestimation/Common/Common.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 def suN_generator ( n ): r \"\"\" Generation of the SU($N$) generators with $N$ the dimension of the system. Parameters ---------- > **n:** `int` -- The dimension of the system. Returns ---------- SU($N$) generators. \"\"\" symm , anti_symm , diag = suN_unsorted ( n ) if n == 2 : return [ symm [ 0 ], anti_symm [ 0 ], diag [ 0 ]] else : Lambda = [ 0.0 for i in range ( len ( symm + anti_symm + diag ))] Lambda [ 0 ], Lambda [ 1 ], Lambda [ 2 ] = symm [ 0 ], anti_symm [ 0 ], diag [ 0 ] repeat_times = 2 m1 , n1 , k1 = 0 , 3 , 1 while True : m1 += n1 j , l = 0 , 0 for i in range ( repeat_times ): Lambda [ m1 + j ] = symm [ k1 ] Lambda [ m1 + j + 1 ] = anti_symm [ k1 ] j += 2 k1 += 1 repeat_times += 1 n1 = n1 + 2 if k1 == len ( symm ): break m2 , n2 , k2 = 2 , 5 , 1 while True : m2 += n2 Lambda [ m2 ] = diag [ k2 ] n2 = n2 + 2 k2 = k2 + 1 if k2 == len ( diag ): break return Lambda","title":"Functions"},{"location":"API/python/functions/#kraus","text":"The parameterization of a state is \\begin{align} \\rho=\\sum_i K_i\\rho_0K_i^{\\dagger}, \\end{align} where \\(\\rho\\) is the evolved density matrix, \\(K_i\\) is the Kraus operator.","title":"Kraus"},{"location":"API/python/functions/#quanestimation.Kraus--parameters","text":"K: list -- Kraus operators. dK: list -- Derivatives of the Kraus operators with respect to the unknown parameters to be estimated. For example, dK[0] is the derivative vector on the first parameter. rho0: matrix -- Initial state (density matrix).","title":"Parameters"},{"location":"API/python/functions/#quanestimation.Kraus--returns","text":"Density matrix and its derivatives on the unknown parameters. Source code in quanestimation/Parameterization/NonDynamics.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def Kraus ( rho0 , K , dK ): r \"\"\" The parameterization of a state is \\begin{align} \\rho=\\sum_i K_i\\rho_0K_i^{\\dagger}, \\end{align} where $\\rho$ is the evolved density matrix, $K_i$ is the Kraus operator. Parameters ---------- > **K:** `list` -- Kraus operators. > **dK:** `list` -- Derivatives of the Kraus operators with respect to the unknown parameters to be estimated. For example, dK[0] is the derivative vector on the first parameter. > **rho0:** `matrix` -- Initial state (density matrix). Returns ---------- Density matrix and its derivatives on the unknown parameters. \"\"\" k_num = len ( K ) para_num = len ( dK [ 0 ]) dK_reshape = [[ dK [ i ][ j ] for i in range ( k_num )] for j in range ( para_num )] rho = sum ([ np . dot ( Ki , np . dot ( rho0 , Ki . conj () . T )) for Ki in K ]) drho = [ sum ([( np . dot ( dKi , np . dot ( rho0 , Ki . conj () . T )) + np . dot ( Ki , np . dot ( rho0 , dKi . conj () . T ))) for ( Ki , dKi ) in zip ( K , dKj )]) for dKj in dK_reshape ] return rho , drho","title":"Returns"},{"location":"API/python/functions/#metrological-resources","text":"Calculation of spin squeezing parameter for a density matrix.","title":"Metrological resources"},{"location":"API/python/functions/#quanestimation.SpinSqueezing--parameters","text":"rho: matrix -- Density matrix. basis: string -- The basis of the state. Options are: \"Dicke\" (default) -- Dicke basis. \"Pauli\" -- The original basis of each spin. output: string -- Types of spin squeezing can be calculated. Options are: \"KU\" (default) -- Spin squeezing defined by Kitagawa and Ueda. \"WBIMH\" -- Spin squeezing defined by Wineland et al.","title":"Parameters"},{"location":"API/python/functions/#quanestimation.SpinSqueezing--returns","text":"\\(\\xi\\) : float -- spin squeezing parameter Source code in quanestimation/Resource/Resource.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 def SpinSqueezing ( rho , basis = \"Dicke\" , output = \"KU\" ): r \"\"\" Calculation of spin squeezing parameter for a density matrix. Parameters ---------- > **rho:** `matrix` -- Density matrix. > **basis:** `string` -- The basis of the state. Options are: \"Dicke\" (default) -- Dicke basis. \"Pauli\" -- The original basis of each spin. > **output:** `string` -- Types of spin squeezing can be calculated. Options are: \"KU\" (default) -- Spin squeezing defined by Kitagawa and Ueda. \"WBIMH\" -- Spin squeezing defined by Wineland et al. Returns ---------- **$\\xi$:** `float` -- spin squeezing parameter \"\"\" N = len ( rho ) - 1 coef = 4.0 / float ( N ) j = N / 2 if basis == \"Pauli\" : sp = np . array ([[ 0.0 , 1.0 ],[ 0.0 , 0.0 ]]) jp = [] for i in range ( 0 , N ): if i == 0 : jp_tp = np . kron ( sp , np . identity ( 2 ** ( N - 1 ))) elif i == N - 1 : jp_tp = np . kron ( np . identity ( 2 ** ( N - 1 )), sp ) else : jp_tp = np . kron ( np . identity ( 2 ** i ), np . kron ( sp , np . identity ( 2 ** ( N - 1 - i )))) jp . append ( jp_tp ) Jp = sum ( jp ) else : offdiag = [ np . sqrt ( float ( j * ( j + 1 ) - m * ( m + 1 ))) for m in np . arange ( j , - j - 1 , - 1 ) ][ 1 :] Jp = np . matrix ( np . diag ( offdiag , 1 )) Jx = 0.5 * ( Jp + Jp . H ) Jy = - 0.5 * 1 j * ( Jp - Jp . H ) Jz = np . diag ( np . arange ( j , - j - 1 , - 1 )) Jx_mean = np . trace ( rho * Jx ) Jy_mean = np . trace ( rho * Jy ) Jz_mean = np . trace ( rho * Jz ) costheta = Jz_mean / np . sqrt ( Jx_mean ** 2 + Jy_mean ** 2 + Jz_mean ** 2 ) sintheta = np . sin ( np . arccos ( costheta )) cosphi = Jx_mean / np . sqrt ( Jx_mean ** 2 + Jy_mean ** 2 ) if Jy_mean > 0 : sinphi = np . sin ( np . arccos ( cosphi )) else : sinphi = np . sin ( 2 * np . pi - np . arccos ( cosphi )) Jn1 = - Jx * sinphi + Jy * cosphi Jn2 = - Jx * costheta * cosphi - Jy * costheta * sinphi + Jz * sintheta A = np . trace ( rho * ( Jn1 * Jn1 - Jn2 * Jn2 )) B = np . trace ( rho * ( Jn1 * Jn2 + Jn2 * Jn1 )) C = np . trace ( rho * ( Jn1 * Jn1 + Jn2 * Jn2 )) V_minus = 0.5 * ( C - np . sqrt ( A ** 2 + B ** 2 )) V_minus = np . real ( V_minus ) Xi = coef * V_minus if Xi > 1.0 : Xi = 1.0 if output == \"KU\" : Xi = Xi elif output == \"WBIMH\" : Xi = ( N / 2 ) ** 2 * Xi / ( Jx_mean ** 2 + Jy_mean ** 2 + Jz_mean ** 2 ) else : raise NameError ( \"NameError: output should be choosen in {KU, WBIMH}\" ) return Xi Calculation of the time to reach a given precision limit.","title":"Returns"},{"location":"API/python/functions/#quanestimation.TargetTime--parameters","text":"f: float -- The given value of the objective function. tspan: array -- Time length for the evolution. func: array -- The function for calculating the objective function. *args: string -- The corresponding input parameter. **kwargs: string -- Keyword arguments in func .","title":"Parameters"},{"location":"API/python/functions/#quanestimation.TargetTime--returns","text":"time: float -- Time to reach the given target. Source code in quanestimation/Resource/Resource.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 def TargetTime ( f , tspan , func , * args , ** kwargs ): \"\"\" Calculation of the time to reach a given precision limit. Parameters ---------- > **f:** `float` -- The given value of the objective function. > **tspan:** `array` -- Time length for the evolution. > **func:** `array` -- The function for calculating the objective function. > ***args:** `string` -- The corresponding input parameter. > ****kwargs:** `string` -- Keyword arguments in `func`. Returns ---------- **time:** `float` -- Time to reach the given target. \"\"\" args = list ( zip_broadcast ( * args )) f_last = func ( * ( args [ 0 ]), ** kwargs ) idx = 1 f_now = func ( * ( args [ 1 ]), ** kwargs ) while ( f_now - f ) * ( f_last - f ) > 0 and idx < ( len ( tspan ) - 1 ): f_last = f_now idx += 1 f_now = func ( * ( args [ idx ]), ** kwargs ) return tspan [ idx ]","title":"Returns"},{"location":"API/python/functions/#quantum-cramer-rao-bounds","text":"Calculation of the symmetric logarithmic derivative (SLD) for a density matrix. The SLD operator \\(L_a\\) is determined by \\begin{align} \\partial_{a}\\rho=\\frac{1}{2}(\\rho L_{a}+L_{a}\\rho) \\end{align} with \\(\\rho\\) the parameterized density matrix. The entries of SLD can be calculated as \\begin{align} \\langle\\lambda_i|L_{a}|\\lambda_j\\rangle=\\frac{2\\langle\\lambda_i| \\partial_{a}\\rho |\\lambda_j\\rangle}{\\lambda_i+\\lambda_j} \\end{align} for \\(\\lambda_i~(\\lambda_j) \\neq 0\\) . If \\(\\lambda_i=\\lambda_j=0\\) , the entry of SLD is set to be zero.","title":"Quantum Cram\u00e9r-Rao bounds"},{"location":"API/python/functions/#quanestimation.SLD--parameters","text":"rho: matrix -- Density matrix. drho: list -- Derivatives of the density matrix on the unknown parameters to be estimated. For example, drho[0] is the derivative vector on the first parameter. rep: string -- The basis for the SLDs. Options are: \"original\" (default) -- it means the basis is the same with the input density matrix (rho). \"eigen\" -- it means the basis is the same with theeigenspace of the density matrix (rho). eps: float -- Machine epsilon.","title":"Parameters"},{"location":"API/python/functions/#quanestimation.SLD--returns","text":"SLD(s): matrix or list --For single parameter estimation (the length of drho is equal to one), the output is a matrix and for multiparameter estimation (the length of drho is more than one), it returns a list. Source code in quanestimation/AsymptoticBound/CramerRao.py 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 def SLD ( rho , drho , rep = \"original\" , eps = 1e-8 ): r \"\"\" Calculation of the symmetric logarithmic derivative (SLD) for a density matrix. The SLD operator $L_a$ is determined by \\begin{align} \\partial_{a}\\rho=\\frac{1}{2}(\\rho L_{a}+L_{a}\\rho) \\end{align} with $\\rho$ the parameterized density matrix. The entries of SLD can be calculated as \\begin{align} \\langle\\lambda_i|L_{a}|\\lambda_j\\rangle=\\frac{2\\langle\\lambda_i| \\partial_{a}\\rho |\\lambda_j\\rangle}{\\lambda_i+\\lambda_j} \\end{align} for $\\lambda_i~(\\lambda_j) \\neq 0$. If $\\lambda_i=\\lambda_j=0$, the entry of SLD is set to be zero. Parameters ---------- > **rho:** `matrix` -- Density matrix. > **drho:** `list` -- Derivatives of the density matrix on the unknown parameters to be estimated. For example, drho[0] is the derivative vector on the first parameter. > **rep:** `string` -- The basis for the SLDs. Options are: \"original\" (default) -- it means the basis is the same with the input density matrix (rho). \"eigen\" -- it means the basis is the same with theeigenspace of the density matrix (rho). > **eps:** `float` -- Machine epsilon. Returns ---------- **SLD(s):** `matrix or list` --For single parameter estimation (the length of drho is equal to one), the output is a matrix and for multiparameter estimation (the length of drho is more than one), it returns a list. \"\"\" if type ( drho ) != list : raise TypeError ( \"Please make sure drho is a list!\" ) para_num = len ( drho ) dim = len ( rho ) SLD = [[] for i in range ( 0 , para_num )] purity = np . trace ( np . dot ( rho , rho )) if np . abs ( 1 - purity ) < eps : SLD_org = [[] for i in range ( 0 , para_num )] for para_i in range ( 0 , para_num ): SLD_org [ para_i ] = 2 * drho [ para_i ] if rep == \"original\" : SLD [ para_i ] = SLD_org [ para_i ] elif rep == \"eigen\" : val , vec = np . linalg . eig ( rho ) val = np . real ( val ) SLD [ para_i ] = np . dot ( vec . conj () . transpose (), np . dot ( SLD_org [ para_i ], vec ) ) else : raise ValueError ( \" {!r} is not a valid value for rep, supported values are 'original' and 'eigen'.\" . format ( rep )) if para_num == 1 : return SLD [ 0 ] else : return SLD else : val , vec = np . linalg . eig ( rho ) val = np . real ( val ) for para_i in range ( 0 , para_num ): SLD_eig = np . array ( [[ 0.0 + 0.0 * 1.0 j for i in range ( 0 , dim )] for i in range ( 0 , dim )] ) for fi in range ( 0 , dim ): for fj in range ( 0 , dim ): if np . abs ( val [ fi ] + val [ fj ]) > eps : SLD_eig [ fi ][ fj ] = ( 2 * np . dot ( vec [:, fi ] . conj () . transpose (), np . dot ( drho [ para_i ], vec [:, fj ]), ) / ( val [ fi ] + val [ fj ]) ) SLD_eig [ SLD_eig == np . inf ] = 0.0 if rep == \"original\" : SLD [ para_i ] = np . dot ( vec , np . dot ( SLD_eig , vec . conj () . transpose ())) elif rep == \"eigen\" : SLD [ para_i ] = SLD_eig else : raise ValueError ( \" {!r} is not a valid value for rep, supported values are 'original' and 'eigen'.\" . format ( rep )) if para_num == 1 : return SLD [ 0 ] else : return SLD Calculation of the right logarithmic derivative (RLD) for a density matrix. The RLD operator defined by \\(\\partial_{a}\\rho=\\rho \\mathcal{R}_a\\) with \\(\\rho\\) the parameterized density matrix. \\begin{align} \\langle\\lambda_i| \\mathcal{R}_{a} |\\lambda_j\\rangle=\\frac{1}{\\lambda_i}\\langle\\lambda_i| \\partial_a\\rho |\\lambda_j\\rangle \\end{align} for \\(\\lambda_i\\neq 0\\) is the \\(ij\\) th entry of RLD.","title":"Returns"},{"location":"API/python/functions/#quanestimation.RLD--parameters","text":"rho: matrix -- Density matrix. drho: list -- Derivatives of the density matrix on the unknown parameters to be estimated. For example, drho[0] is the derivative vector on the first parameter. rep: string -- The basis for the RLD(s). Options are: \"original\" (default) -- it means the basis is the same with the input density matrix (rho). \"eigen\" -- it means the basis is the same with the eigenspace of the density matrix (rho). eps: float -- Machine epsilon.","title":"Parameters"},{"location":"API/python/functions/#quanestimation.RLD--returns","text":"RLD(s): matrix or list -- For single parameter estimation (the length of drho is equal to one), the output is a matrix and for multiparameter estimation (the length of drho is more than one), it returns a list. Source code in quanestimation/AsymptoticBound/CramerRao.py 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 def RLD ( rho , drho , rep = \"original\" , eps = 1e-8 ): r \"\"\" Calculation of the right logarithmic derivative (RLD) for a density matrix. The RLD operator defined by $\\partial_{a}\\rho=\\rho \\mathcal{R}_a$ with $\\rho$ the parameterized density matrix. \\begin{align} \\langle\\lambda_i| \\mathcal{R}_{a} |\\lambda_j\\rangle=\\frac{1}{\\lambda_i}\\langle\\lambda_i| \\partial_a\\rho |\\lambda_j\\rangle \\end{align} for $\\lambda_i\\neq 0$ is the $ij$th entry of RLD. Parameters ---------- > **rho:** `matrix` -- Density matrix. > **drho:** `list` -- Derivatives of the density matrix on the unknown parameters to be estimated. For example, drho[0] is the derivative vector on the first parameter. > **rep:** `string` -- The basis for the RLD(s). Options are: \"original\" (default) -- it means the basis is the same with the input density matrix (rho). \"eigen\" -- it means the basis is the same with the eigenspace of the density matrix (rho). > **eps:** `float` -- Machine epsilon. Returns ---------- **RLD(s):** `matrix or list` -- For single parameter estimation (the length of drho is equal to one), the output is a matrix and for multiparameter estimation (the length of drho is more than one), it returns a list. \"\"\" if type ( drho ) != list : raise TypeError ( \"Please make sure drho is a list!\" ) para_num = len ( drho ) dim = len ( rho ) RLD = [[] for i in range ( 0 , para_num )] val , vec = np . linalg . eig ( rho ) val = np . real ( val ) for para_i in range ( 0 , para_num ): RLD_eig = np . array ( [[ 0.0 + 0.0 * 1.0 j for i in range ( 0 , dim )] for i in range ( 0 , dim )] ) for fi in range ( 0 , dim ): for fj in range ( 0 , dim ): term_tp = np . dot ( vec [:, fi ] . conj () . transpose (), np . dot ( drho [ para_i ], vec [:, fj ])) if np . abs ( val [ fi ]) > eps : RLD_eig [ fi ][ fj ] = ( term_tp / val [ fi ]) else : if np . abs ( term_tp ) < eps : raise ValueError ( \"The RLD does not exist. It only exist when the support of drho is contained in the support of rho.\" , ) RLD_eig [ RLD_eig == np . inf ] = 0.0 if rep == \"original\" : RLD [ para_i ] = np . dot ( vec , np . dot ( RLD_eig , vec . conj () . transpose ())) elif rep == \"eigen\" : RLD [ para_i ] = RLD_eig else : raise ValueError ( \" {!r} is not a valid value for rep, supported values are 'original' and 'eigen'.\" . format ( rep )) if para_num == 1 : return RLD [ 0 ] else : return RLD Calculation of the left logarithmic derivative (LLD) for a density matrix \\(\\rho\\) . The LLD operator is defined by \\(\\partial_{a}\\rho=\\mathcal{R}_a^{\\dagger}\\rho\\) . The entries of LLD can be calculated as \\begin{align} \\langle\\lambda_i| \\mathcal{R}_{a}^{\\dagger} |\\lambda_j\\rangle=\\frac{1}{\\lambda_j}\\langle\\lambda_i| \\partial_a\\rho |\\lambda_j\\rangle \\end{align} for \\(\\lambda_j\\neq 0\\) .","title":"Returns"},{"location":"API/python/functions/#quanestimation.LLD--parameters","text":"rho: matrix -- Density matrix. drho: list -- Derivatives of the density matrix on the unknown parameters to be estimated. For example, drho[0] is the derivative vector on the first parameter. rep: string -- The basis for the LLD(s). Options are: \"original\" (default) -- it means the basis is the same with the input density matrix (rho). \"eigen\" -- it means the basis is the same with the eigenspace of the density matrix (rho). eps: float -- Machine epsilon.","title":"Parameters"},{"location":"API/python/functions/#quanestimation.LLD--returns","text":"LLD(s): matrix or list -- For single parameter estimation (the length of drho is equal to one), the output is a matrix and for multiparameter estimation (the length of drho is more than one), it returns a list. Source code in quanestimation/AsymptoticBound/CramerRao.py 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 def LLD ( rho , drho , rep = \"original\" , eps = 1e-8 ): r \"\"\" Calculation of the left logarithmic derivative (LLD) for a density matrix $\\rho$. The LLD operator is defined by $\\partial_{a}\\rho=\\mathcal{R}_a^{\\dagger}\\rho$. The entries of LLD can be calculated as \\begin{align} \\langle\\lambda_i| \\mathcal{R}_{a}^{\\dagger} |\\lambda_j\\rangle=\\frac{1}{\\lambda_j}\\langle\\lambda_i| \\partial_a\\rho |\\lambda_j\\rangle \\end{align} for $\\lambda_j\\neq 0$. Parameters ---------- > **rho:** `matrix` -- Density matrix. > **drho:** `list` -- Derivatives of the density matrix on the unknown parameters to be estimated. For example, drho[0] is the derivative vector on the first parameter. > **rep:** `string` -- The basis for the LLD(s). Options are: \"original\" (default) -- it means the basis is the same with the input density matrix (rho). \"eigen\" -- it means the basis is the same with the eigenspace of the density matrix (rho). > **eps:** float -- Machine epsilon. Returns ---------- **LLD(s):** `matrix or list` -- For single parameter estimation (the length of drho is equal to one), the output is a matrix and for multiparameter estimation (the length of drho is more than one), it returns a list. \"\"\" if type ( drho ) != list : raise TypeError ( \"Please make sure drho is a list!\" ) para_num = len ( drho ) dim = len ( rho ) LLD = [[] for i in range ( 0 , para_num )] val , vec = np . linalg . eig ( rho ) val = np . real ( val ) for para_i in range ( 0 , para_num ): LLD_eig = np . array ( [[ 0.0 + 0.0 * 1.0 j for i in range ( 0 , dim )] for i in range ( 0 , dim )] ) for fi in range ( 0 , dim ): for fj in range ( 0 , dim ): term_tp = np . dot ( vec [:, fi ] . conj () . transpose (), np . dot ( drho [ para_i ], vec [:, fj ]),) if np . abs ( val [ fj ]) > eps : LLD_eig_tp = ( term_tp / val [ fj ]) LLD_eig [ fj ][ fi ] = LLD_eig_tp . conj () else : if np . abs ( term_tp ) < eps : raise ValueError ( \"The LLD does not exist. It only exist when the support of drho is contained in the support of rho.\" , ) LLD_eig [ LLD_eig == np . inf ] = 0.0 if rep == \"original\" : LLD [ para_i ] = np . dot ( vec , np . dot ( LLD_eig , vec . conj () . transpose ())) elif rep == \"eigen\" : LLD [ para_i ] = LLD_eig else : raise ValueError ( \" {!r} is not a valid value for rep, supported values are 'original' and 'eigen'.\" . format ( rep )) if para_num == 1 : return LLD [ 0 ] else : return LLD Calculation of the quantum Fisher information (QFI) and quantum Fisher information matrix (QFIM) for all types. The entry of QFIM \\(\\mathcal{F}\\) is defined as \\begin{align} \\mathcal{F}_{ab}=\\frac{1}{2}\\mathrm{Tr}(\\rho{L_a, L_b}) \\end{align} with \\(L_a, L_b\\) are SLD operators and and \\begin{align} \\mathcal{F}_{ab}=\\mathrm{Tr}(\\rho \\mathcal{R}_a \\mathcal{R}^{\\dagger}_b) \\end{align} with \\(\\mathcal{R}_a\\) the RLD or LLD operator.","title":"Returns"},{"location":"API/python/functions/#quanestimation.QFIM--parameters","text":"rho: matrix -- Density matrix. drho: list Derivatives of the density matrix on the unknown parameters to be estimated. For example, drho[0] is the derivative vector on the first parameter. LDtype: string -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). exportLD: bool -- Whether or not to export the values of logarithmic derivatives. If set True then the the values of logarithmic derivatives will be exported. eps: float -- Machine epsilon.","title":"Parameters"},{"location":"API/python/functions/#quanestimation.QFIM--returns","text":"QFI or QFIM: float or matrix -- For single parameter estimation (the length of drho is equal to one), the output is QFI and for multiparameter estimation (the length of drho is more than one), it returns QFIM. Source code in quanestimation/AsymptoticBound/CramerRao.py 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 def QFIM ( rho , drho , LDtype = \"SLD\" , exportLD = False , eps = 1e-8 ): r \"\"\" Calculation of the quantum Fisher information (QFI) and quantum Fisher information matrix (QFIM) for all types. The entry of QFIM $\\mathcal{F}$ is defined as \\begin{align} \\mathcal{F}_{ab}=\\frac{1}{2}\\mathrm{Tr}(\\rho\\{L_a, L_b\\}) \\end{align} with $L_a, L_b$ are SLD operators and and \\begin{align} \\mathcal{F}_{ab}=\\mathrm{Tr}(\\rho \\mathcal{R}_a \\mathcal{R}^{\\dagger}_b) \\end{align} with $\\mathcal{R}_a$ the RLD or LLD operator. Parameters ---------- > **rho:** `matrix` -- Density matrix. > **drho:** `list` Derivatives of the density matrix on the unknown parameters to be estimated. For example, drho[0] is the derivative vector on the first parameter. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). > **exportLD:** `bool` -- Whether or not to export the values of logarithmic derivatives. If set True then the the values of logarithmic derivatives will be exported. > **eps:** `float` -- Machine epsilon. Returns ---------- **QFI or QFIM:** `float or matrix` -- For single parameter estimation (the length of drho is equal to one), the output is QFI and for multiparameter estimation (the length of drho is more than one), it returns QFIM. \"\"\" if type ( drho ) != list : raise TypeError ( \"Please make sure drho is a list\" ) para_num = len ( drho ) # single parameter estimation if para_num == 1 : if LDtype == \"SLD\" : LD_tp = SLD ( rho , drho , eps = eps ) SLD_ac = np . dot ( LD_tp , LD_tp ) + np . dot ( LD_tp , LD_tp ) QFIM_res = np . real ( 0.5 * np . trace ( np . dot ( rho , SLD_ac ))) elif LDtype == \"RLD\" : LD_tp = RLD ( rho , drho , eps = eps ) QFIM_res = np . real ( np . trace ( np . dot ( rho , np . dot ( LD_tp , LD_tp . conj () . transpose ()))) ) elif LDtype == \"LLD\" : LD_tp = LLD ( rho , drho , eps = eps ) QFIM_res = np . real ( np . trace ( np . dot ( rho , np . dot ( LD_tp , LD_tp . conj () . transpose ()))) ) else : raise ValueError ( \" {!r} is not a valid value for LDtype, supported values are 'SLD', 'RLD' and 'LLD'.\" . format ( LDtype )) # multiparameter estimation else : if LDtype == \"SLD\" : QFIM_res = np . zeros ([ para_num , para_num ]) LD_tp = SLD ( rho , drho , eps = eps ) for para_i in range ( 0 , para_num ): for para_j in range ( para_i , para_num ): SLD_ac = np . dot ( LD_tp [ para_i ], LD_tp [ para_j ]) + np . dot ( LD_tp [ para_j ], LD_tp [ para_i ] ) QFIM_res [ para_i ][ para_j ] = np . real ( 0.5 * np . trace ( np . dot ( rho , SLD_ac )) ) QFIM_res [ para_j ][ para_i ] = QFIM_res [ para_i ][ para_j ] elif LDtype == \"RLD\" : QFIM_res = np . zeros (( para_num , para_num ), dtype = np . complex128 ) LD_tp = RLD ( rho , drho , eps = eps ) for para_i in range ( 0 , para_num ): for para_j in range ( para_i , para_num ): QFIM_res [ para_i ][ para_j ] = np . trace ( np . dot ( rho , np . dot ( LD_tp [ para_i ], LD_tp [ para_j ] . conj () . transpose ()), ) ) QFIM_res [ para_j ][ para_i ] = QFIM_res [ para_i ][ para_j ] . conj () elif LDtype == \"LLD\" : QFIM_res = np . zeros (( para_num , para_num ), dtype = np . complex128 ) LD_tp = LLD ( rho , drho , eps = eps ) for para_i in range ( 0 , para_num ): for para_j in range ( para_i , para_num ): QFIM_res [ para_i ][ para_j ] = np . trace ( np . dot ( rho , np . dot ( LD_tp [ para_i ], LD_tp [ para_j ] . conj () . transpose ()), ) ) QFIM_res [ para_j ][ para_i ] = QFIM_res [ para_i ][ para_j ] . conj () else : raise ValueError ( \" {!r} is not a valid value for LDtype, supported values are 'SLD', 'RLD' and 'LLD'.\" . format ( LDtype )) if exportLD == False : return QFIM_res else : return QFIM_res , LD_tp Calculation of the quantum Fisher information (QFI) and quantum Fisher information matrix (QFIM) with Kraus operator(s) for all types.","title":"Returns"},{"location":"API/python/functions/#quanestimation.QFIM_Kraus--parameters","text":"rho0: matrix -- Initial state (density matrix). K: list -- Kraus operator(s). dK: list -- Derivatives of the Kraus operator(s) on the unknown parameters to be estimated. For example, dK[0] is the derivative vector on the first parameter. LDtype: string -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). exportLD: bool -- Whether or not to export the values of logarithmic derivatives. If set True then the the values of logarithmic derivatives will be exported. eps: float -- Machine epsilon.","title":"Parameters"},{"location":"API/python/functions/#quanestimation.QFIM_Kraus--returns","text":"QFI or QFIM: float or matrix -- For single parameter estimation (the length of drho is equal to one), the output is QFI and for multiparameter estimation (the length of drho is more than one), it returns QFIM. Source code in quanestimation/AsymptoticBound/CramerRao.py 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 def QFIM_Kraus ( rho0 , K , dK , LDtype = \"SLD\" , exportLD = False , eps = 1e-8 ): \"\"\" Calculation of the quantum Fisher information (QFI) and quantum Fisher information matrix (QFIM) with Kraus operator(s) for all types. Parameters ---------- > **rho0:** `matrix` -- Initial state (density matrix). > **K:** `list` -- Kraus operator(s). > **dK:** `list` -- Derivatives of the Kraus operator(s) on the unknown parameters to be estimated. For example, dK[0] is the derivative vector on the first parameter. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). > **exportLD:** `bool` -- Whether or not to export the values of logarithmic derivatives. If set True then the the values of logarithmic derivatives will be exported. > **eps:** `float` -- Machine epsilon. Returns ---------- **QFI or QFIM:** `float or matrix` -- For single parameter estimation (the length of drho is equal to one), the output is QFI and for multiparameter estimation (the length of drho is more than one), it returns QFIM. \"\"\" dK = [[ dK [ i ][ j ] for i in range ( len ( K ))] for j in range ( len ( dK [ 0 ]))] rho = sum ([ np . dot ( Ki , np . dot ( rho0 , Ki . conj () . T )) for Ki in K ]) drho = [ sum ( [ ( np . dot ( dKi , np . dot ( rho0 , Ki . conj () . T )) + np . dot ( Ki , np . dot ( rho0 , dKi . conj () . T )) ) for ( Ki , dKi ) in zip ( K , dKj ) ] ) for dKj in dK ] return QFIM ( rho , drho , LDtype = LDtype , exportLD = exportLD , eps = eps ) Calculation of the classical Fisher information (CFI) and classical Fisher information matrix (CFIM) for a density matrix. The entry of CFIM \\(\\mathcal{I}\\) is defined as \\begin{align} \\mathcal{I}_{ab}=\\sum_y\\frac{1}{p(y|\\textbf{x})}[\\partial_a p(y|\\textbf{x})][\\partial_b p(y|\\textbf{x})], \\end{align} where \\(p(y|\\textbf{x})=\\mathrm{Tr}(\\rho\\Pi_y)\\) with \\(\\rho\\) the parameterized density matrix.","title":"Returns"},{"location":"API/python/functions/#quanestimation.CFIM--parameters","text":"rho: matrix -- Density matrix. drho: list -- Derivatives of the density matrix on the unknown parameters to be estimated. For example, drho[0] is the derivative vector on the first parameter. M: list of matrices -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). eps: float -- Machine epsilon.","title":"Parameters"},{"location":"API/python/functions/#quanestimation.CFIM--returns","text":"CFI (CFIM): float or matrix -- For single parameter estimation (the length of drho is equal to one), the output is CFI and for multiparameter estimation (the length of drho is more than one), it returns CFIM. Note: SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from here . Source code in quanestimation/AsymptoticBound/CramerRao.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 def CFIM ( rho , drho , M = [], eps = 1e-8 ): r \"\"\" Calculation of the classical Fisher information (CFI) and classical Fisher information matrix (CFIM) for a density matrix. The entry of CFIM $\\mathcal{I}$ is defined as \\begin{align} \\mathcal{I}_{ab}=\\sum_y\\frac{1}{p(y|\\textbf{x})}[\\partial_a p(y|\\textbf{x})][\\partial_b p(y|\\textbf{x})], \\end{align} where $p(y|\\textbf{x})=\\mathrm{Tr}(\\rho\\Pi_y)$ with $\\rho$ the parameterized density matrix. Parameters ---------- > **rho:** `matrix` -- Density matrix. > **drho:** `list` -- Derivatives of the density matrix on the unknown parameters to be estimated. For example, drho[0] is the derivative vector on the first parameter. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). > **eps:** `float` -- Machine epsilon. Returns ---------- **CFI (CFIM):** `float or matrix` -- For single parameter estimation (the length of drho is equal to one), the output is CFI and for multiparameter estimation (the length of drho is more than one), it returns CFIM. **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" if type ( drho ) != list : raise TypeError ( \"Please make sure drho is a list!\" ) if M == []: M = SIC ( len ( rho [ 0 ])) else : if type ( M ) != list : raise TypeError ( \"Please make sure M is a list!\" ) m_num = len ( M ) para_num = len ( drho ) CFIM_res = np . zeros ([ para_num , para_num ]) for pi in range ( 0 , m_num ): Mp = M [ pi ] p = np . real ( np . trace ( np . dot ( rho , Mp ))) Cadd = np . zeros ([ para_num , para_num ]) if p > eps : for para_i in range ( 0 , para_num ): drho_i = drho [ para_i ] dp_i = np . real ( np . trace ( np . dot ( drho_i , Mp ))) for para_j in range ( para_i , para_num ): drho_j = drho [ para_j ] dp_j = np . real ( np . trace ( np . dot ( drho_j , Mp ))) Cadd [ para_i ][ para_j ] = np . real ( dp_i * dp_j / p ) Cadd [ para_j ][ para_i ] = np . real ( dp_i * dp_j / p ) CFIM_res += Cadd if para_num == 1 : return CFIM_res [ 0 ][ 0 ] else : return CFIM_res Calculation of the classical Fisher information (CFI) and classical Fisher information matrix (CFIM) for classical scenarios. The entry of FIM \\(I\\) is defined as \\begin{align} I_{ab}=\\sum_{y}\\frac{1}{p_y}[\\partial_a p_y][\\partial_b p_y], \\end{align} where \\(\\{p_y\\}\\) is a set of the discrete probability distribution.","title":"Returns"},{"location":"API/python/functions/#quanestimation.FIM--parameters","text":"p: array -- The probability distribution. dp: list -- Derivatives of the probability distribution on the unknown parameters to be estimated. For example, dp[0] is the derivative vector on the first parameter. eps: float -- Machine epsilon.","title":"Parameters"},{"location":"API/python/functions/#quanestimation.FIM--returns","text":"CFI (CFIM): float or matrix -- For single parameter estimation (the length of drho is equal to one), the output is CFI and for multiparameter estimation (the length of drho is more than one), it returns CFIM. Source code in quanestimation/AsymptoticBound/CramerRao.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 def FIM ( p , dp , eps = 1e-8 ): r \"\"\" Calculation of the classical Fisher information (CFI) and classical Fisher information matrix (CFIM) for classical scenarios. The entry of FIM $I$ is defined as \\begin{align} I_{ab}=\\sum_{y}\\frac{1}{p_y}[\\partial_a p_y][\\partial_b p_y], \\end{align} where $\\{p_y\\}$ is a set of the discrete probability distribution. Parameters ---------- > **p:** `array` -- The probability distribution. > **dp:** `list` -- Derivatives of the probability distribution on the unknown parameters to be estimated. For example, dp[0] is the derivative vector on the first parameter. > **eps:** `float` -- Machine epsilon. Returns ---------- **CFI (CFIM):** `float or matrix` -- For single parameter estimation (the length of drho is equal to one), the output is CFI and for multiparameter estimation (the length of drho is more than one), it returns CFIM. \"\"\" para_num = len ( dp [ 0 ]) m_num = len ( p ) FIM_res = np . zeros ([ para_num , para_num ]) for pi in range ( 0 , m_num ): p_tp = p [ pi ] Cadd = np . zeros ([ para_num , para_num ]) if p_tp > eps : for para_i in range ( 0 , para_num ): dp_i = dp [ pi ][ para_i ] for para_j in range ( para_i , para_num ): dp_j = dp [ pi ][ para_j ] Cadd [ para_i ][ para_j ] = np . real ( dp_i * dp_j / p_tp ) Cadd [ para_j ][ para_i ] = np . real ( dp_i * dp_j / p_tp ) FIM_res += Cadd if para_num == 1 : return FIM_res [ 0 ][ 0 ] else : return FIM_res Calculation of the SLD based quantum Fisher information (QFI) and quantum Fisher information matrix (QFIM) in Bloch representation.","title":"Returns"},{"location":"API/python/functions/#quanestimation.QFIM_Bloch--parameters","text":"r: list -- Parameterized Bloch vector. dr: list -- Derivatives of the Bloch vector on the unknown parameters to be estimated. For example, dr[0] is the derivative vector on the first parameter. eps: float -- Machine epsilon.","title":"Parameters"},{"location":"API/python/functions/#quanestimation.QFIM_Bloch--returns","text":"QFI or QFIM in Bloch representation: float or matrix -- For single parameter estimation (the length of drho is equal to one), the output is QFI and for multiparameter estimation (the length of drho is more than one), it returns QFIM. Source code in quanestimation/AsymptoticBound/CramerRao.py 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 def QFIM_Bloch ( r , dr , eps = 1e-8 ): \"\"\" Calculation of the SLD based quantum Fisher information (QFI) and quantum Fisher information matrix (QFIM) in Bloch representation. Parameters ---------- > **r:** `list` -- Parameterized Bloch vector. > **dr:** `list ` -- Derivatives of the Bloch vector on the unknown parameters to be estimated. For example, dr[0] is the derivative vector on the first parameter. > **eps:** `float` -- Machine epsilon. Returns ---------- **QFI or QFIM in Bloch representation:** `float or matrix` -- For single parameter estimation (the length of drho is equal to one), the output is QFI and for multiparameter estimation (the length of drho is more than one), it returns QFIM. \"\"\" if type ( dr ) != list : raise TypeError ( \"Please make sure dr is a list\" ) para_num = len ( dr ) QFIM_res = np . zeros ([ para_num , para_num ]) dim = int ( np . sqrt ( len ( r ) + 1 )) Lambda = suN_generator ( dim ) if dim == 2 : #### single-qubit system #### r_norm = np . linalg . norm ( r ) ** 2 if np . abs ( r_norm - 1.0 ) < eps : for para_i in range ( 0 , para_num ): for para_j in range ( para_i , para_num ): QFIM_res [ para_i ][ para_j ] = np . real ( np . inner ( dr [ para_i ], dr [ para_j ])) QFIM_res [ para_j ][ para_i ] = QFIM_res [ para_i ][ para_j ] else : for para_i in range ( 0 , para_num ): for para_j in range ( para_i , para_num ): QFIM_res [ para_i ][ para_j ] = np . real ( np . inner ( dr [ para_i ], dr [ para_j ]) + np . inner ( r , dr [ para_i ]) * np . inner ( r , dr [ para_j ]) / ( 1 - r_norm ) ) QFIM_res [ para_j ][ para_i ] = QFIM_res [ para_i ][ para_j ] else : rho = np . identity ( dim , dtype = np . complex128 ) / dim for di in range ( dim ** 2 - 1 ): rho += np . sqrt ( dim * ( dim - 1 ) / 2 ) * r [ di ] * Lambda [ di ] / dim G = np . zeros (( dim ** 2 - 1 , dim ** 2 - 1 ), dtype = np . complex128 ) for row_i in range ( dim ** 2 - 1 ): for col_j in range ( row_i , dim ** 2 - 1 ): anti_commu = np . dot ( Lambda [ row_i ], Lambda [ col_j ]) + np . dot ( Lambda [ col_j ], Lambda [ row_i ] ) G [ row_i ][ col_j ] = 0.5 * np . trace ( np . dot ( rho , anti_commu )) G [ col_j ][ row_i ] = G [ row_i ][ col_j ] mat_tp = G * dim / ( 2 * ( dim - 1 )) - np . dot ( np . array ( r ) . reshape ( len ( r ), 1 ), np . array ( r ) . reshape ( 1 , len ( r )) ) mat_inv = inv ( mat_tp ) for para_m in range ( 0 , para_num ): for para_n in range ( para_m , para_num ): QFIM_res [ para_m ][ para_n ] = np . real ( np . dot ( np . array ( dr [ para_n ]) . reshape ( 1 , len ( r )), np . dot ( mat_inv , np . array ( dr [ para_m ]) . reshape ( len ( r ), 1 )), )[ 0 ][ 0 ] ) QFIM_res [ para_n ][ para_m ] = QFIM_res [ para_m ][ para_n ] if para_num == 1 : return QFIM_res [ 0 ][ 0 ] else : return QFIM_res Calculation of the SLD based quantum Fisher information (QFI) and quantum Fisher information matrix (QFIM) with gaussian states.","title":"Returns"},{"location":"API/python/functions/#quanestimation.QFIM_Gauss--parameters","text":"R: array -- First-order moment. dR: list -- Derivatives of the first-order moment on the unknown parameters to be estimated. For example, dR[0] is the derivative vector on the first parameter. D: matrix -- Second-order moment. dD: list -- Derivatives of the second-order moment on the unknown parameters to be estimated. For example, dD[0] is the derivative vector on the first parameter. eps: float -- Machine epsilon.","title":"Parameters"},{"location":"API/python/functions/#quanestimation.QFIM_Gauss--returns","text":"QFI or QFIM with gaussian states: float or matrix -- For single parameter estimation (the length of drho is equal to one), the output is QFI and for multiparameter estimation (the length of drho is more than one), it returns QFIM. Source code in quanestimation/AsymptoticBound/CramerRao.py 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 def QFIM_Gauss ( R , dR , D , dD ): \"\"\" Calculation of the SLD based quantum Fisher information (QFI) and quantum Fisher information matrix (QFIM) with gaussian states. Parameters ---------- > **R:** `array` -- First-order moment. > **dR:** `list` -- Derivatives of the first-order moment on the unknown parameters to be estimated. For example, dR[0] is the derivative vector on the first parameter. > **D:** `matrix` -- Second-order moment. > **dD:** `list` -- Derivatives of the second-order moment on the unknown parameters to be estimated. For example, dD[0] is the derivative vector on the first parameter. > **eps:** `float` -- Machine epsilon. Returns ---------- **QFI or QFIM with gaussian states:** `float or matrix` -- For single parameter estimation (the length of drho is equal to one), the output is QFI and for multiparameter estimation (the length of drho is more than one), it returns QFIM. \"\"\" para_num = len ( dR ) m = int ( len ( R ) / 2 ) QFIM_res = np . zeros ([ para_num , para_num ]) C = np . array ( [ [ D [ i ][ j ] - R [ i ] * R [ j ] for j in range ( 2 * m )] for i in range ( 2 * m ) ] ) dC = [ np . array ( [ [ dD [ k ][ i ][ j ] - dR [ k ][ i ] * R [ j ] - R [ i ] * dR [ k ][ j ] for j in range ( 2 * m ) ] for i in range ( 2 * m ) ] ) for k in range ( para_num ) ] C_sqrt = sqrtm ( C ) J = np . kron ([[ 0 , 1 ], [ - 1 , 0 ]], np . eye ( m )) B = C_sqrt @ J @ C_sqrt P = np . eye ( 2 * m ) P = np . vstack ([ P [:][:: 2 ], P [:][ 1 :: 2 ]]) T , Q = schur ( B ) vals = eigvals ( B ) c = vals [:: 2 ] . imag Diag = np . diagflat ( c **- 0.5 ) S = inv ( J @ C_sqrt @ Q @ P @ np . kron ([[ 0 , 1 ], [ - 1 , 0 ]], - Diag )) . T @ P . T sx = np . array ([[ 0.0 , 1.0 ], [ 1.0 , 0.0 ]]) sy = np . array ([[ 0.0 , - 1.0 j ], [ 1.0 j , 0.0 ]]) sz = np . array ([[ 1.0 , 0.0 ], [ 0.0 , - 1.0 ]]) a_Gauss = [ 1 j * sy , sz , np . eye ( 2 ), sx ] es = [ [ np . eye ( 1 , m ** 2 , m * i + j ) . reshape ( m , m ) for j in range ( m )] for i in range ( m ) ] As = [[ np . kron ( s , a_Gauss [ i ]) / np . sqrt ( 2 ) for s in es ] for i in range ( 4 )] gs = [ [[[ np . trace ( inv ( S ) @ dC @ inv ( S . T ) @ aa . T ) for aa in a ] for a in A ] for A in As ] for dC in dC ] G = [ np . zeros (( 2 * m , 2 * m )) . astype ( np . longdouble ) for _ in range ( para_num )] for i in range ( para_num ): for j in range ( m ): for k in range ( m ): for l in range ( 4 ): G [ i ] += np . real ( gs [ i ][ l ][ j ][ k ] / ( 4 * c [ j ] * c [ k ] + ( - 1 ) ** ( l + 1 )) * inv ( S . T ) @ As [ l ][ j ][ k ] @ inv ( S ) ) QFIM_res += np . real ( [ [ np . trace ( G [ i ] @ dC [ j ]) + dR [ i ] @ inv ( C ) @ dR [ j ] for j in range ( para_num )] for i in range ( para_num ) ] ) if para_num == 1 : return QFIM_res [ 0 ][ 0 ] else : return QFIM_res","title":"Returns"},{"location":"API/python/functions/#holevo-cramer-rao-bounds","text":"Calculation of the Holevo Cramer-Rao bound (HCRB) via the semidefinite program (SDP).","title":"Holevo Cram\u00e9r-Rao bounds"},{"location":"API/python/functions/#quanestimation.HCRB--parameters","text":"rho: matrix -- Density matrix. drho: list -- Derivatives of the density matrix on the unknown parameters to be estimated. For example, drho[0] is the derivative vector on the first parameter. W: matrix -- Weight matrix. eps: float -- Machine epsilon.","title":"Parameters"},{"location":"API/python/functions/#quanestimation.HCRB--returns","text":"HCRB: float -- The value of Holevo Cramer-Rao bound. Source code in quanestimation/AsymptoticBound/Holevo.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 def HCRB ( rho , drho , W , eps = 1e-8 ): \"\"\" Calculation of the Holevo Cramer-Rao bound (HCRB) via the semidefinite program (SDP). Parameters ---------- > **rho:** `matrix` -- Density matrix. > **drho:** `list` -- Derivatives of the density matrix on the unknown parameters to be estimated. For example, drho[0] is the derivative vector on the first parameter. > **W:** `matrix` -- Weight matrix. > **eps:** `float` -- Machine epsilon. Returns ---------- **HCRB:** `float` -- The value of Holevo Cramer-Rao bound. \"\"\" if type ( drho ) != list : raise TypeError ( \"Please make sure drho is a list!\" ) if len ( drho ) == 1 : print ( \"In single parameter scenario, HCRB is equivalent to QFI. This function will return the value of QFI.\" ) f = QFIM ( rho , drho , eps = eps ) return f elif matrix_rank ( W ) == 1 : print ( \"For rank-one weight matrix, the HCRB is equivalent to QFIM. This function will return the value of Tr(WF^{-1}).\" ) F = QFIM ( rho , drho , eps = eps ) return np . trace ( np . dot ( W , np . linalg . pinv ( F ))) else : dim = len ( rho ) num = dim * dim para_num = len ( drho ) Lambda = [ np . identity ( dim )] + suN_generator ( dim ) Lambda = Lambda / np . sqrt ( 2 ) vec_drho = [[] for i in range ( para_num )] for pi in range ( para_num ): vec_drho [ pi ] = np . array ( [ np . real ( np . trace ( np . dot ( drho [ pi ], Lambda [ i ]))) for i in range ( len ( Lambda )) ] ) S = np . zeros (( num , num ), dtype = np . complex128 ) for a in range ( num ): for b in range ( num ): S [ a ][ b ] = np . trace ( np . dot ( Lambda [ a ], np . dot ( Lambda [ b ], rho ))) accu = len ( str ( int ( 1 / eps ))) - 1 lu , d , perm = sp . linalg . ldl ( S . round ( accu )) R = np . dot ( lu , sp . linalg . sqrtm ( d )) . conj () . T # ============optimization variables================ V = cp . Variable (( para_num , para_num )) X = cp . Variable (( num , para_num )) # ================add constraints=================== constraints = [ cp . bmat ([[ V , X . T @ R . conj () . T ], [ R @ X , np . identity ( num )]]) >> 0 ] for i in range ( para_num ): for j in range ( para_num ): if i == j : constraints += [ X [:, i ] . T @ vec_drho [ j ] == 1 ] else : constraints += [ X [:, i ] . T @ vec_drho [ j ] == 0 ] prob = cp . Problem ( cp . Minimize ( cp . trace ( W @ V )), constraints ) prob . solve () return prob . value","title":"Returns"},{"location":"API/python/functions/#bayesian-cramer-rao-bounds","text":"Calculation of the Bayesian classical Fisher information (BCFI) and the Bayesian classical Fisher information matrix (BCFIM) of the form \\begin{align} \\mathcal{I}_{\\mathrm{Bayes}}=\\int p(\\textbf{x})\\mathcal{I}\\mathrm{d}\\textbf{x} \\end{align} with \\(\\mathcal{I}\\) the CFIM and \\(p(\\textbf{x})\\) the prior distribution.","title":"Bayesian Cram\u00e9r-Rao bounds"},{"location":"API/python/functions/#quanestimation.BCFIM--parameters","text":"x: list -- The regimes of the parameters for the integral. p: multidimensional array -- The prior distribution. rho: multidimensional list -- Parameterized density matrix. drho: multidimensional list -- Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated. M: list of matrices -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). eps: float -- Machine epsilon.","title":"Parameters"},{"location":"API/python/functions/#quanestimation.BCFIM--returns","text":"BCFI or BCFIM: float or matrix -- For single parameter estimation (the length of x is equal to one), the output is BCFI and for multiparameter estimation (the length of x is more than one), it returns BCFIM. Note: SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from here . Source code in quanestimation/BayesianBound/BayesianCramerRao.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 def BCFIM ( x , p , rho , drho , M = [], eps = 1e-8 ): r \"\"\" Calculation of the Bayesian classical Fisher information (BCFI) and the Bayesian classical Fisher information matrix (BCFIM) of the form \\begin{align} \\mathcal{I}_{\\mathrm{Bayes}}=\\int p(\\textbf{x})\\mathcal{I}\\mathrm{d}\\textbf{x} \\end{align} with $\\mathcal{I}$ the CFIM and $p(\\textbf{x})$ the prior distribution. Parameters ---------- > **x:** `list` -- The regimes of the parameters for the integral. > **p:** `multidimensional array` -- The prior distribution. > **rho:** `multidimensional list` -- Parameterized density matrix. > **drho:** `multidimensional list` -- Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). > **eps:** `float` -- Machine epsilon. Returns ---------- **BCFI or BCFIM:** `float or matrix` -- For single parameter estimation (the length of x is equal to one), the output is BCFI and for multiparameter estimation (the length of x is more than one), it returns BCFIM. **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" para_num = len ( x ) if para_num == 1 : #### single parameter scenario #### if M == []: M = SIC ( len ( rho [ 0 ])) else : if type ( M ) != list : raise TypeError ( \"Please make sure M is a list!\" ) p_num = len ( p ) if type ( drho [ 0 ]) == list : drho = [ drho [ i ][ 0 ] for i in range ( p_num )] p_num = len ( p ) F_tp = np . zeros ( p_num ) for m in range ( p_num ): F_tp [ m ] = CFIM ( rho [ m ], [ drho [ m ]], M = M , eps = eps ) arr = [ p [ i ] * F_tp [ i ] for i in range ( p_num )] return simps ( arr , x [ 0 ]) else : #### multiparameter scenario #### p_shape = np . shape ( p ) p_ext = extract_ele ( p , para_num ) rho_ext = extract_ele ( rho , para_num ) drho_ext = extract_ele ( drho , para_num ) p_list , rho_list , drho_list = [], [], [] for p_ele , rho_ele , drho_ele in zip ( p_ext , rho_ext , drho_ext ): p_list . append ( p_ele ) rho_list . append ( rho_ele ) drho_list . append ( drho_ele ) dim = len ( rho_list [ 0 ]) if M == []: M = SIC ( dim ) else : if type ( M ) != list : raise TypeError ( \"Please make sure M is a list!\" ) F_list = [ [[ 0.0 for i in range ( len ( p_list ))] for j in range ( para_num )] for k in range ( para_num ) ] for i in range ( len ( p_list )): F_tp = CFIM ( rho_list [ i ], drho_list [ i ], M = M , eps = eps ) for pj in range ( para_num ): for pk in range ( para_num ): F_list [ pj ][ pk ][ i ] = F_tp [ pj ][ pk ] BCFIM_res = np . zeros ([ para_num , para_num ]) for para_i in range ( 0 , para_num ): for para_j in range ( para_i , para_num ): F_ij = np . array ( F_list [ para_i ][ para_j ]) . reshape ( p_shape ) arr = p * F_ij for si in reversed ( range ( para_num )): arr = simps ( arr , x [ si ]) BCFIM_res [ para_i ][ para_j ] = arr BCFIM_res [ para_j ][ para_i ] = arr return BCFIM_res Calculation of the Bayesian quantum Fisher information (BQFI) and the Bayesian quantum Fisher information matrix (BQFIM) of the form \\begin{align} \\mathcal{F}_{\\mathrm{Bayes}}=\\int p(\\textbf{x})\\mathcal{F}\\mathrm{d}\\textbf{x} \\end{align} with \\(\\mathcal{F}\\) the QFIM of all types and \\(p(\\textbf{x})\\) the prior distribution.","title":"Returns"},{"location":"API/python/functions/#quanestimation.BQFIM--parameters","text":"x: list -- The regimes of the parameters for the integral. p: multidimensional array -- The prior distribution. rho: multidimensional list -- Parameterized density matrix. drho: multidimensional list -- Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated. LDtype: string -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). eps: float -- Machine epsilon.","title":"Parameters"},{"location":"API/python/functions/#quanestimation.BQFIM--returns","text":"BQFI or BQFIM: float or matrix -- For single parameter estimation (the length of x is equal to one), the output is BQFI and for multiparameter estimation (the length of x is more than one), it returns BQFIM. Source code in quanestimation/BayesianBound/BayesianCramerRao.py 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 def BQFIM ( x , p , rho , drho , LDtype = \"SLD\" , eps = 1e-8 ): r \"\"\" Calculation of the Bayesian quantum Fisher information (BQFI) and the Bayesian quantum Fisher information matrix (BQFIM) of the form \\begin{align} \\mathcal{F}_{\\mathrm{Bayes}}=\\int p(\\textbf{x})\\mathcal{F}\\mathrm{d}\\textbf{x} \\end{align} with $\\mathcal{F}$ the QFIM of all types and $p(\\textbf{x})$ the prior distribution. Parameters ---------- > **x:** `list` -- The regimes of the parameters for the integral. > **p:** `multidimensional array` -- The prior distribution. > **rho:** `multidimensional list` -- Parameterized density matrix. > **drho:** `multidimensional list` -- Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). > **eps:** `float` -- Machine epsilon. Returns ---------- **BQFI or BQFIM:** `float or matrix` -- For single parameter estimation (the length of x is equal to one), the output is BQFI and for multiparameter estimation (the length of x is more than one), it returns BQFIM. \"\"\" para_num = len ( x ) if para_num == 1 : #### single parameter scenario #### p_num = len ( p ) if type ( drho [ 0 ]) == list : drho = [ drho [ i ][ 0 ] for i in range ( p_num )] F_tp = np . zeros ( p_num ) for m in range ( p_num ): F_tp [ m ] = QFIM ( rho [ m ], [ drho [ m ]], LDtype = LDtype , eps = eps ) arr = [ p [ i ] * F_tp [ i ] for i in range ( p_num )] return simps ( arr , x [ 0 ]) else : #### multiparameter scenario #### p_shape = np . shape ( p ) p_ext = extract_ele ( p , para_num ) rho_ext = extract_ele ( rho , para_num ) drho_ext = extract_ele ( drho , para_num ) p_list , rho_list , drho_list = [], [], [] for p_ele , rho_ele , drho_ele in zip ( p_ext , rho_ext , drho_ext ): p_list . append ( p_ele ) rho_list . append ( rho_ele ) drho_list . append ( drho_ele ) F_list = [ [[ 0.0 for i in range ( len ( p_list ))] for j in range ( para_num )] for k in range ( para_num ) ] for i in range ( len ( p_list )): F_tp = QFIM ( rho_list [ i ], drho_list [ i ], LDtype = LDtype , eps = eps ) for pj in range ( para_num ): for pk in range ( para_num ): F_list [ pj ][ pk ][ i ] = F_tp [ pj ][ pk ] BQFIM_res = np . zeros ([ para_num , para_num ]) for para_i in range ( 0 , para_num ): for para_j in range ( para_i , para_num ): F_ij = np . array ( F_list [ para_i ][ para_j ]) . reshape ( p_shape ) arr = p * F_ij for si in reversed ( range ( para_num )): arr = simps ( arr , x [ si ]) BQFIM_res [ para_i ][ para_j ] = arr BQFIM_res [ para_j ][ para_i ] = arr return BQFIM_res Calculation of the Bayesian Cramer-Rao bound (BCRB). The covariance matrix with a prior distribution \\(p(\\textbf{x})\\) is defined as \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},{\\Pi_y})=\\int p(\\textbf{x})\\sum_y\\mathrm{Tr} (\\rho\\Pi_y)(\\hat{\\textbf{x}}-\\textbf{x})(\\hat{\\textbf{x}}-\\textbf{x})^{\\mathrm{T}} \\mathrm{d}\\textbf{x} \\end{align} where \\(\\textbf{x}=(x_0,x_1,\\dots)^{\\mathrm{T}}\\) are the unknown parameters to be estimated and the integral \\(\\int\\mathrm{d}\\textbf{x}:=\\iiint\\mathrm{d}x_0\\mathrm{d}x_1\\cdots\\) . \\(\\{\\Pi_y\\}\\) is a set of positive operator-valued measure (POVM) and \\(\\rho\\) represents the parameterized density matrix. This function calculates three types BCRB. The first one is \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},{\\Pi_y})\\geq \\int p(\\textbf{x})\\left(B\\mathcal{I}^{-1}B +\\textbf{b}\\textbf{b}^{\\mathrm{T}}\\right)\\mathrm{d}\\textbf{x}, \\end{align} where \\(\\textbf{b}\\) and \\(\\textbf{b}'\\) are the vectors of biase and its derivatives on parameters. \\(B\\) is a diagonal matrix with the \\(i\\) th entry \\(B_{ii}=1+[\\textbf{b}']_{i}\\) and \\(\\mathcal{I}\\) is the CFIM. The second one is \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},{\\Pi_y})\\geq \\mathcal{B}\\,\\mathcal{I}_{\\mathrm{Bayes}}^{-1}\\, \\mathcal{B}+\\int p(\\textbf{x})\\textbf{b}\\textbf{b}^{\\mathrm{T}}\\mathrm{d}\\textbf{x}, \\end{align} where \\(\\mathcal{B}=\\int p(\\textbf{x})B\\mathrm{d}\\textbf{x}\\) is the average of \\(B\\) and \\(\\mathcal{I}_{\\mathrm{Bayes}}=\\int p(\\textbf{x})\\mathcal{I}\\mathrm{d}\\textbf{x}\\) is the average CFIM. The third one is \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},{\\Pi_y})\\geq \\int p(\\textbf{x}) \\mathcal{G}\\left(\\mathcal{I}_p+\\mathcal{I}\\right)^{-1}\\mathcal{G}^{\\mathrm{T}}\\mathrm{d}\\textbf{x} \\end{align} with \\([\\mathcal{I}_{p}]_{ab}:=[\\partial_a \\ln p(\\textbf{x})][\\partial_b \\ln p(\\textbf{x})]\\) and \\(\\mathcal{G}_{ab}:=[\\partial_b\\ln p(\\textbf{x})][\\textbf{b}]_a+B_{aa}\\delta_{ab}\\) .","title":"Returns"},{"location":"API/python/functions/#quanestimation.BCRB--parameters","text":"x: list -- The regimes of the parameters for the integral. p: multidimensional array -- The prior distribution. rho: multidimensional list -- Parameterized density matrix. drho: multidimensional list -- Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated. M: list of matrices -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). b: list -- Vector of biases of the form \\(\\textbf{b}=(b(x_0),b(x_1),\\dots)^{\\mathrm{T}}\\) . db: list -- Derivatives of b with respect to the unknown parameters to be estimated, It should be expressed as \\(\\textbf{b}'=(\\partial_0 b(x_0),\\partial_1 b(x_1),\\dots)^{\\mathrm{T}}\\) . btype: int (1, 2, 3) -- Types of the BCRB. Options are: 1 (default) -- It means to calculate the first type of the BCRB. 2 -- It means to calculate the second type of the BCRB. 3 -- It means to calculate the third type of the BCRB. eps: float -- Machine epsilon.","title":"Parameters"},{"location":"API/python/functions/#quanestimation.BCRB--returns","text":"BCRB: float or matrix -- For single parameter estimation (the length of x is equal to one), the output is a float and for multiparameter estimation (the length of x is more than one), it returns a matrix. Note: SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from here . Source code in quanestimation/BayesianBound/BayesianCramerRao.py 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 def BCRB ( x , p , dp , rho , drho , M = [], b = [], db = [], btype = 1 , eps = 1e-8 ): r \"\"\" Calculation of the Bayesian Cramer-Rao bound (BCRB). The covariance matrix with a prior distribution $p(\\textbf{x})$ is defined as \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},\\{\\Pi_y\\})=\\int p(\\textbf{x})\\sum_y\\mathrm{Tr} (\\rho\\Pi_y)(\\hat{\\textbf{x}}-\\textbf{x})(\\hat{\\textbf{x}}-\\textbf{x})^{\\mathrm{T}} \\mathrm{d}\\textbf{x} \\end{align} where $\\textbf{x}=(x_0,x_1,\\dots)^{\\mathrm{T}}$ are the unknown parameters to be estimated and the integral $\\int\\mathrm{d}\\textbf{x}:=\\iiint\\mathrm{d}x_0\\mathrm{d}x_1\\cdots$. $\\{\\Pi_y\\}$ is a set of positive operator-valued measure (POVM) and $\\rho$ represents the parameterized density matrix. This function calculates three types BCRB. The first one is \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},\\{\\Pi_y\\})\\geq \\int p(\\textbf{x})\\left(B\\mathcal{I}^{-1}B +\\textbf{b}\\textbf{b}^{\\mathrm{T}}\\right)\\mathrm{d}\\textbf{x}, \\end{align} where $\\textbf{b}$ and $\\textbf{b}'$ are the vectors of biase and its derivatives on parameters. $B$ is a diagonal matrix with the $i$th entry $B_{ii}=1+[\\textbf{b}']_{i}$ and $\\mathcal{I}$ is the CFIM. The second one is \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},\\{\\Pi_y\\})\\geq \\mathcal{B}\\,\\mathcal{I}_{\\mathrm{Bayes}}^{-1}\\, \\mathcal{B}+\\int p(\\textbf{x})\\textbf{b}\\textbf{b}^{\\mathrm{T}}\\mathrm{d}\\textbf{x}, \\end{align} where $\\mathcal{B}=\\int p(\\textbf{x})B\\mathrm{d}\\textbf{x}$ is the average of $B$ and $\\mathcal{I}_{\\mathrm{Bayes}}=\\int p(\\textbf{x})\\mathcal{I}\\mathrm{d}\\textbf{x}$ is the average CFIM. The third one is \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},\\{\\Pi_y\\})\\geq \\int p(\\textbf{x}) \\mathcal{G}\\left(\\mathcal{I}_p+\\mathcal{I}\\right)^{-1}\\mathcal{G}^{\\mathrm{T}}\\mathrm{d}\\textbf{x} \\end{align} with $[\\mathcal{I}_{p}]_{ab}:=[\\partial_a \\ln p(\\textbf{x})][\\partial_b \\ln p(\\textbf{x})]$ and $\\mathcal{G}_{ab}:=[\\partial_b\\ln p(\\textbf{x})][\\textbf{b}]_a+B_{aa}\\delta_{ab}$. Parameters ---------- > **x:** `list` -- The regimes of the parameters for the integral. > **p:** `multidimensional array` -- The prior distribution. > **rho:** `multidimensional list` -- Parameterized density matrix. > **drho:** `multidimensional list` -- Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). > **b:** `list` -- Vector of biases of the form $\\textbf{b}=(b(x_0),b(x_1),\\dots)^{\\mathrm{T}}$. > **db:** `list` -- Derivatives of b with respect to the unknown parameters to be estimated, It should be expressed as $\\textbf{b}'=(\\partial_0 b(x_0),\\partial_1 b(x_1),\\dots)^{\\mathrm{T}}$. > **btype:** `int (1, 2, 3)` -- Types of the BCRB. Options are: 1 (default) -- It means to calculate the first type of the BCRB. 2 -- It means to calculate the second type of the BCRB. 3 -- It means to calculate the third type of the BCRB. > **eps:** `float` -- Machine epsilon. Returns ---------- **BCRB:** `float or matrix` -- For single parameter estimation (the length of x is equal to one), the output is a float and for multiparameter estimation (the length of x is more than one), it returns a matrix. **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" para_num = len ( x ) if para_num == 1 : #### single parameter scenario #### p_num = len ( p ) if b == []: b = np . zeros ( p_num ) db = np . zeros ( p_num ) if b != [] and db == []: db = np . zeros ( p_num ) if M == []: M = SIC ( len ( rho [ 0 ])) else : if type ( M ) != list : raise TypeError ( \"Please make sure M is a list!\" ) if type ( drho [ 0 ]) == list : drho = [ drho [ i ][ 0 ] for i in range ( p_num )] if type ( b [ 0 ]) == list or type ( b [ 0 ]) == np . ndarray : b = b [ 0 ] if type ( db [ 0 ]) == list or type ( db [ 0 ]) == np . ndarray : db = db [ 0 ] F_tp = np . zeros ( p_num ) for m in range ( p_num ): F_tp [ m ] = CFIM ( rho [ m ], [ drho [ m ]], M = M , eps = eps ) if btype == 1 : arr = [ p [ i ] * (( 1 + db [ i ]) ** 2 / F_tp [ i ] + b [ i ] ** 2 ) for i in range ( p_num ) ] F = simps ( arr , x [ 0 ]) return F elif btype == 2 : arr = [ p [ i ] * F_tp [ i ] for i in range ( p_num )] F1 = simps ( arr , x [ 0 ]) arr2 = [ p [ j ] * ( 1 + db [ j ]) for j in range ( p_num )] B = simps ( arr2 , x [ 0 ]) arr3 = [ p [ k ] * b [ k ] ** 2 for k in range ( p_num )] bb = simps ( arr3 , x [ 0 ]) F = B ** 2 / F1 + bb return F elif btype == 3 : I_tp = [ np . real ( dp [ i ] * dp [ i ] / p [ i ] ** 2 ) for i in range ( p_num )] arr = [ p [ j ] * ( dp [ j ] * b [ j ] / p [ j ] + ( 1 + db [ j ])) ** 2 / ( I_tp [ j ] + F_tp [ j ]) for j in range ( p_num )] F = simps ( arr , x [ 0 ]) return F else : raise NameError ( \"NameError: btype should be choosen in {1, 2, 3}.\" ) else : #### multiparameter scenario #### if b == []: b , db = [], [] for i in range ( para_num ): b . append ( np . zeros ( len ( x [ i ]))) db . append ( np . zeros ( len ( x [ i ]))) if b != [] and db == []: db = [] for i in range ( para_num ): db . append ( np . zeros ( len ( x [ i ]))) p_shape = np . shape ( p ) p_ext = extract_ele ( p , para_num ) dp_ext = extract_ele ( dp , para_num ) rho_ext = extract_ele ( rho , para_num ) drho_ext = extract_ele ( drho , para_num ) b_pro = product ( * b ) db_pro = product ( * db ) p_list , dp_list , rho_list , drho_list = [], [], [], [] for p_ele , dp_ele , rho_ele , drho_ele in zip ( p_ext , dp_ext , rho_ext , drho_ext ): p_list . append ( p_ele ) dp_list . append ( dp_ele ) rho_list . append ( rho_ele ) drho_list . append ( drho_ele ) b_list , db_list = [], [] for b_ele , db_ele in zip ( b_pro , db_pro ): b_list . append ([ b_ele [ i ] for i in range ( para_num )]) db_list . append ([ db_ele [ j ] for j in range ( para_num )]) dim = len ( rho_list [ 0 ]) if M == []: M = SIC ( dim ) else : if type ( M ) != list : raise TypeError ( \"Please make sure M is a list!\" ) if btype == 1 : F_list = [ [[ 0.0 for i in range ( len ( p_list ))] for j in range ( para_num )] for k in range ( para_num ) ] for i in range ( len ( p_list )): F_tp = CFIM ( rho_list [ i ], drho_list [ i ], M = M , eps = eps ) F_inv = np . linalg . pinv ( F_tp ) B = np . diag ([( 1.0 + db_list [ i ][ j ]) for j in range ( para_num )]) term1 = np . dot ( B , np . dot ( F_inv , B )) term2 = np . dot ( np . array ( b_list [ i ]) . reshape ( para_num , 1 ), np . array ( b_list [ i ]) . reshape ( 1 , para_num ), ) for pj in range ( para_num ): for pk in range ( para_num ): F_list [ pj ][ pk ][ i ] = term1 [ pj ][ pk ] + term2 [ pj ][ pk ] res = np . zeros ([ para_num , para_num ]) for para_i in range ( 0 , para_num ): for para_j in range ( para_i , para_num ): F_ij = np . array ( F_list [ para_i ][ para_j ]) . reshape ( p_shape ) arr = p * F_ij for si in reversed ( range ( para_num )): arr = simps ( arr , x [ si ]) res [ para_i ][ para_j ] = arr res [ para_j ][ para_i ] = arr return res elif btype == 2 : F_list = [ [[ 0.0 for i in range ( len ( p_list ))] for j in range ( para_num )] for k in range ( para_num ) ] B_list = [ [[ 0.0 for i in range ( len ( p_list ))] for j in range ( para_num )] for k in range ( para_num ) ] bb_list = [ [[ 0.0 for i in range ( len ( p_list ))] for j in range ( para_num )] for k in range ( para_num ) ] for i in range ( len ( p_list )): F_tp = CFIM ( rho_list [ i ], drho_list [ i ], M = M , eps = eps ) B_tp = np . diag ([( 1.0 + db_list [ i ][ j ]) for j in range ( para_num )]) bb_tp = np . dot ( np . array ( b_list [ i ]) . reshape ( para_num , 1 ), np . array ( b_list [ i ]) . reshape ( 1 , para_num ), ) for pj in range ( para_num ): for pk in range ( para_num ): F_list [ pj ][ pk ][ i ] = F_tp [ pj ][ pk ] B_list [ pj ][ pk ][ i ] = B_tp [ pj ][ pk ] bb_list [ pj ][ pk ][ i ] = bb_tp [ pj ][ pk ] F_res = np . zeros ([ para_num , para_num ]) for para_i in range ( 0 , para_num ): for para_j in range ( para_i , para_num ): F_ij = np . array ( F_list [ para_i ][ para_j ]) . reshape ( p_shape ) arr = p * F_ij for si in reversed ( range ( para_num )): arr = simps ( arr , x [ si ]) F_res [ para_i ][ para_j ] = arr F_res [ para_j ][ para_i ] = arr B_res = np . zeros ([ para_num , para_num ]) bb_res = np . zeros ([ para_num , para_num ]) for para_m in range ( para_num ): for para_n in range ( para_num ): B_mn = np . array ( B_list [ para_m ][ para_n ]) . reshape ( p_shape ) bb_mn = np . array ( bb_list [ para_m ][ para_n ]) . reshape ( p_shape ) arr2 = p * B_mn arr3 = p * bb_mn for sj in reversed ( range ( para_num )): arr2 = simps ( arr2 , x [ sj ]) arr3 = simps ( arr3 , x [ sj ]) B_res [ para_m ][ para_n ] = arr2 bb_res [ para_m ][ para_n ] = arr3 res = np . dot ( B_res , np . dot ( np . linalg . pinv ( F_res ), B_res )) + bb_res return res elif btype == 3 : F_list = [ [[ 0.0 for i in range ( len ( p_list ))] for j in range ( para_num )] for k in range ( para_num ) ] for i in range ( len ( p_list )): F_tp = CFIM ( rho_list [ i ], drho_list [ i ], M = M , eps = eps ) I_tp = np . zeros (( para_num , para_num )) G_tp = np . zeros (( para_num , para_num )) for pm in range ( para_num ): for pn in range ( para_num ): if pm == pn : G_tp [ pm ][ pn ] = dp_list [ i ][ pn ] * b_list [ i ][ pm ] / p_list [ i ] + ( 1.0 + db_list [ i ][ pm ]) else : G_tp [ pm ][ pn ] = dp_list [ i ][ pn ] * b_list [ i ][ pm ] / p_list [ i ] I_tp [ pm ][ pn ] = dp_list [ i ][ pm ] * dp_list [ i ][ pn ] / p_list [ i ] ** 2 F_tot = np . dot ( G_tp , np . dot ( np . linalg . pinv ( F_tp + I_tp ), G_tp . T )) for pj in range ( para_num ): for pk in range ( para_num ): F_list [ pj ][ pk ][ i ] = F_tot [ pj ][ pk ] res = np . zeros ([ para_num , para_num ]) for para_i in range ( 0 , para_num ): for para_j in range ( para_i , para_num ): F_ij = np . array ( F_list [ para_i ][ para_j ]) . reshape ( p_shape ) arr = p * F_ij for si in reversed ( range ( para_num )): arr = simps ( arr , x [ si ]) res [ para_i ][ para_j ] = arr res [ para_j ][ para_i ] = arr return res else : raise NameError ( \"NameError: btype should be choosen in {1, 2, 3}.\" ) Calculation of the Bayesian quantum Cramer-Rao bound (BQCRB). The covariance matrix with a prior distribution \\(p(\\textbf{x})\\) is defined as \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},{\\Pi_y})=\\int p(\\textbf{x})\\sum_y\\mathrm{Tr} (\\rho\\Pi_y)(\\hat{\\textbf{x}}-\\textbf{x})(\\hat{\\textbf{x}}-\\textbf{x})^{\\mathrm{T}} \\mathrm{d}\\textbf{x} \\end{align} where \\(\\textbf{x}=(x_0,x_1,\\dots)^{\\mathrm{T}}\\) are the unknown parameters to be estimated and the integral \\(\\int\\mathrm{d}\\textbf{x}:=\\iiint\\mathrm{d}x_0\\mathrm{d}x_1\\cdots\\) . \\(\\{\\Pi_y\\}\\) is a set of positive operator-valued measure (POVM) and \\(\\rho\\) represent the parameterized density matrix. This function calculates three types of the BQCRB. The first one is \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},{\\Pi_y})\\geq\\int p(\\textbf{x})\\left(B\\mathcal{F}^{-1}B +\\textbf{b}\\textbf{b}^{\\mathrm{T}}\\right)\\mathrm{d}\\textbf{x}, \\end{align} where \\(\\textbf{b}\\) and \\(\\textbf{b}'\\) are the vectors of biase and its derivatives on parameters. \\(B\\) is a diagonal matrix with the \\(i\\) th entry \\(B_{ii}=1+[\\textbf{b}']_{i}\\) and \\(\\mathcal{F}\\) is the QFIM for all types. The second one is \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},{\\Pi_y})\\geq \\mathcal{B}\\,\\mathcal{F}_{\\mathrm{Bayes}}^{-1}\\, \\mathcal{B}+\\int p(\\textbf{x})\\textbf{b}\\textbf{b}^{\\mathrm{T}}\\mathrm{d}\\textbf{x}, \\end{align} where \\(\\mathcal{B}=\\int p(\\textbf{x})B\\mathrm{d}\\textbf{x}\\) is the average of \\(B\\) and \\(\\mathcal{F}_{\\mathrm{Bayes}}=\\int p(\\textbf{x})\\mathcal{F}\\mathrm{d}\\textbf{x}\\) is the average QFIM. The third one is \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},{\\Pi_y})\\geq \\int p(\\textbf{x}) \\mathcal{G}\\left(\\mathcal{I}_p+\\mathcal{F}\\right)^{-1}\\mathcal{G}^{\\mathrm{T}}\\mathrm{d}\\textbf{x} \\end{align} with \\([\\mathcal{I}_{p}]_{ab}:=[\\partial_a \\ln p(\\textbf{x})][\\partial_b \\ln p(\\textbf{x})]\\) and \\(\\mathcal{G}_{ab}:=[\\partial_b\\ln p(\\textbf{x})][\\textbf{b}]_a+B_{aa}\\delta_{ab}\\) .","title":"Returns"},{"location":"API/python/functions/#quanestimation.BQCRB--parameters","text":"x: list -- The regimes of the parameters for the integral. p: multidimensional array -- The prior distribution. rho: multidimensional list -- Parameterized density matrix. drho: multidimensional list -- Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated. b: list -- Vector of biases of the form \\(\\textbf{b}=(b(x_0),b(x_1),\\dots)^{\\mathrm{T}}\\) . db: list -- Derivatives of b with respect to the unknown parameters to be estimated, It should be expressed as \\(\\textbf{b}'=(\\partial_0 b(x_0),\\partial_1 b(x_1),\\dots)^{\\mathrm{T}}\\) . btype: int (1, 2, 3) -- Types of the BQCRB. Options are: 1 (default) -- It means to calculate the first type of the BQCRB. 2 -- It means to calculate the second type of the BQCRB. 3 -- It means to calculate the third type of the BCRB. LDtype: string -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). eps: float -- Machine epsilon.","title":"Parameters"},{"location":"API/python/functions/#quanestimation.BQCRB--returns","text":"BQCRB: float or matrix -- For single parameter estimation (the length of x is equal to one), the output is a float and for multiparameter estimation (the length of x is more than one), it returns a matrix. Source code in quanestimation/BayesianBound/BayesianCramerRao.py 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 def BQCRB ( x , p , dp , rho , drho , b = [], db = [], btype = 1 , LDtype = \"SLD\" , eps = 1e-8 ): r \"\"\" Calculation of the Bayesian quantum Cramer-Rao bound (BQCRB). The covariance matrix with a prior distribution $p(\\textbf{x})$ is defined as \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},\\{\\Pi_y\\})=\\int p(\\textbf{x})\\sum_y\\mathrm{Tr} (\\rho\\Pi_y)(\\hat{\\textbf{x}}-\\textbf{x})(\\hat{\\textbf{x}}-\\textbf{x})^{\\mathrm{T}} \\mathrm{d}\\textbf{x} \\end{align} where $\\textbf{x}=(x_0,x_1,\\dots)^{\\mathrm{T}}$ are the unknown parameters to be estimated and the integral $\\int\\mathrm{d}\\textbf{x}:=\\iiint\\mathrm{d}x_0\\mathrm{d}x_1\\cdots$. $\\{\\Pi_y\\}$ is a set of positive operator-valued measure (POVM) and $\\rho$ represent the parameterized density matrix. This function calculates three types of the BQCRB. The first one is \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},\\{\\Pi_y\\})\\geq\\int p(\\textbf{x})\\left(B\\mathcal{F}^{-1}B +\\textbf{b}\\textbf{b}^{\\mathrm{T}}\\right)\\mathrm{d}\\textbf{x}, \\end{align} where $\\textbf{b}$ and $\\textbf{b}'$ are the vectors of biase and its derivatives on parameters. $B$ is a diagonal matrix with the $i$th entry $B_{ii}=1+[\\textbf{b}']_{i}$ and $\\mathcal{F}$ is the QFIM for all types. The second one is \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},\\{\\Pi_y\\})\\geq \\mathcal{B}\\,\\mathcal{F}_{\\mathrm{Bayes}}^{-1}\\, \\mathcal{B}+\\int p(\\textbf{x})\\textbf{b}\\textbf{b}^{\\mathrm{T}}\\mathrm{d}\\textbf{x}, \\end{align} where $\\mathcal{B}=\\int p(\\textbf{x})B\\mathrm{d}\\textbf{x}$ is the average of $B$ and $\\mathcal{F}_{\\mathrm{Bayes}}=\\int p(\\textbf{x})\\mathcal{F}\\mathrm{d}\\textbf{x}$ is the average QFIM. The third one is \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},\\{\\Pi_y\\})\\geq \\int p(\\textbf{x}) \\mathcal{G}\\left(\\mathcal{I}_p+\\mathcal{F}\\right)^{-1}\\mathcal{G}^{\\mathrm{T}}\\mathrm{d}\\textbf{x} \\end{align} with $[\\mathcal{I}_{p}]_{ab}:=[\\partial_a \\ln p(\\textbf{x})][\\partial_b \\ln p(\\textbf{x})]$ and $\\mathcal{G}_{ab}:=[\\partial_b\\ln p(\\textbf{x})][\\textbf{b}]_a+B_{aa}\\delta_{ab}$. Parameters ---------- > **x:** `list` -- The regimes of the parameters for the integral. > **p:** `multidimensional array` -- The prior distribution. > **rho:** `multidimensional list` -- Parameterized density matrix. > **drho:** `multidimensional list` -- Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated. > **b:** `list` -- Vector of biases of the form $\\textbf{b}=(b(x_0),b(x_1),\\dots)^{\\mathrm{T}}$. > **db:** `list` -- Derivatives of b with respect to the unknown parameters to be estimated, It should be expressed as $\\textbf{b}'=(\\partial_0 b(x_0),\\partial_1 b(x_1),\\dots)^{\\mathrm{T}}$. > **btype:** `int (1, 2, 3)` -- Types of the BQCRB. Options are: 1 (default) -- It means to calculate the first type of the BQCRB. 2 -- It means to calculate the second type of the BQCRB. 3 -- It means to calculate the third type of the BCRB. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). > **eps:** `float` -- Machine epsilon. Returns ---------- **BQCRB:** `float or matrix` -- For single parameter estimation (the length of x is equal to one), the output is a float and for multiparameter estimation (the length of x is more than one), it returns a matrix. \"\"\" para_num = len ( x ) if para_num == 1 : #### single parameter scenario #### p_num = len ( p ) if b == []: b = np . zeros ( p_num ) db = np . zeros ( p_num ) if b != [] and db == []: db = np . zeros ( p_num ) if type ( drho [ 0 ]) == list : drho = [ drho [ i ][ 0 ] for i in range ( p_num )] if type ( b [ 0 ]) == list or type ( b [ 0 ]) == np . ndarray : b = b [ 0 ] if type ( db [ 0 ]) == list or type ( db [ 0 ]) == np . ndarray : db = db [ 0 ] F_tp = np . zeros ( p_num ) for m in range ( p_num ): F_tp [ m ] = QFIM ( rho [ m ], [ drho [ m ]], LDtype = LDtype , eps = eps ) if btype == 1 : arr = [ p [ i ] * (( 1 + db [ i ]) ** 2 / F_tp [ i ] + b [ i ] ** 2 ) for i in range ( p_num ) ] F = simps ( arr , x [ 0 ]) return F elif btype == 2 : arr2 = [ p [ i ] * F_tp [ i ] for i in range ( p_num )] F2 = simps ( arr2 , x [ 0 ]) arr2 = [ p [ j ] * ( 1 + db [ j ]) for j in range ( p_num )] B = simps ( arr2 , x [ 0 ]) arr3 = [ p [ k ] * b [ k ] ** 2 for k in range ( p_num )] bb = simps ( arr3 , x [ 0 ]) F = B ** 2 / F2 + bb return F elif btype == 3 : I_tp = [ np . real ( dp [ i ] * dp [ i ] / p [ i ] ** 2 ) for i in range ( p_num )] arr = [ p [ j ] * ( dp [ j ] * b [ j ] / p [ j ] + ( 1 + db [ j ])) ** 2 / ( I_tp [ j ] + F_tp [ j ]) for j in range ( p_num )] F = simps ( arr , x [ 0 ]) return F else : raise NameError ( \"NameError: btype should be choosen in {1, 2, 3}.\" ) else : #### multiparameter scenario #### if b == []: b , db = [], [] for i in range ( para_num ): b . append ( np . zeros ( len ( x [ i ]))) db . append ( np . zeros ( len ( x [ i ]))) if b != [] and db == []: db = [] for i in range ( para_num ): db . append ( np . zeros ( len ( x [ i ]))) p_shape = np . shape ( p ) p_ext = extract_ele ( p , para_num ) dp_ext = extract_ele ( dp , para_num ) rho_ext = extract_ele ( rho , para_num ) drho_ext = extract_ele ( drho , para_num ) b_pro = product ( * b ) db_pro = product ( * db ) p_list , dp_list , rho_list , drho_list = [], [], [], [] for p_ele , dp_ele , rho_ele , drho_ele in zip ( p_ext , dp_ext , rho_ext , drho_ext ): p_list . append ( p_ele ) dp_list . append ( dp_ele ) rho_list . append ( rho_ele ) drho_list . append ( drho_ele ) b_list , db_list = [], [] for b_ele , db_ele in zip ( b_pro , db_pro ): b_list . append ([ b_ele [ i ] for i in range ( para_num )]) db_list . append ([ db_ele [ j ] for j in range ( para_num )]) if btype == 1 : F_list = [ [[ 0.0 for i in range ( len ( p_list ))] for j in range ( para_num )] for k in range ( para_num ) ] for i in range ( len ( p_list )): F_tp = QFIM ( rho_list [ i ], drho_list [ i ], LDtype = LDtype , eps = eps ) F_inv = np . linalg . pinv ( F_tp ) B = np . diag ([( 1.0 + db_list [ i ][ j ]) for j in range ( para_num )]) term1 = np . dot ( B , np . dot ( F_inv , B )) term2 = np . dot ( np . array ( b_list [ i ]) . reshape ( para_num , 1 ), np . array ( b_list [ i ]) . reshape ( 1 , para_num ), ) for pj in range ( para_num ): for pk in range ( para_num ): F_list [ pj ][ pk ][ i ] = term1 [ pj ][ pk ] + term2 [ pj ][ pk ] res = np . zeros ([ para_num , para_num ]) for para_i in range ( 0 , para_num ): for para_j in range ( para_i , para_num ): F_ij = np . array ( F_list [ para_i ][ para_j ]) . reshape ( p_shape ) arr = p * F_ij for si in reversed ( range ( para_num )): arr = simps ( arr , x [ si ]) res [ para_i ][ para_j ] = arr res [ para_j ][ para_i ] = arr return res elif btype == 2 : F_list = [ [[ 0.0 for i in range ( len ( p_list ))] for j in range ( para_num )] for k in range ( para_num ) ] B_list = [ [[ 0.0 for i in range ( len ( p_list ))] for j in range ( para_num )] for k in range ( para_num ) ] bb_list = [ [[ 0.0 for i in range ( len ( p_list ))] for j in range ( para_num )] for k in range ( para_num ) ] for i in range ( len ( p_list )): F_tp = QFIM ( rho_list [ i ], drho_list [ i ], LDtype = LDtype , eps = eps ) B_tp = np . diag ([( 1.0 + db_list [ i ][ j ]) for j in range ( para_num )]) bb_tp = np . dot ( np . array ( b_list [ i ]) . reshape ( para_num , 1 ), np . array ( b_list [ i ]) . reshape ( 1 , para_num ), ) for pj in range ( para_num ): for pk in range ( para_num ): F_list [ pj ][ pk ][ i ] = F_tp [ pj ][ pk ] B_list [ pj ][ pk ][ i ] = B_tp [ pj ][ pk ] bb_list [ pj ][ pk ][ i ] = bb_tp [ pj ][ pk ] F_res = np . zeros ([ para_num , para_num ]) for para_i in range ( 0 , para_num ): for para_j in range ( para_i , para_num ): F_ij = np . array ( F_list [ para_i ][ para_j ]) . reshape ( p_shape ) arr = p * F_ij for si in reversed ( range ( para_num )): arr = simps ( arr , x [ si ]) F_res [ para_i ][ para_j ] = arr F_res [ para_j ][ para_i ] = arr B_res = np . zeros ([ para_num , para_num ]) bb_res = np . zeros ([ para_num , para_num ]) for para_m in range ( para_num ): for para_n in range ( para_num ): B_mn = np . array ( B_list [ para_m ][ para_n ]) . reshape ( p_shape ) bb_mn = np . array ( bb_list [ para_m ][ para_n ]) . reshape ( p_shape ) arr2 = p * B_mn arr3 = p * bb_mn for sj in reversed ( range ( para_num )): arr2 = simps ( arr2 , x [ sj ]) arr3 = simps ( arr3 , x [ sj ]) B_res [ para_m ][ para_n ] = arr2 bb_res [ para_m ][ para_n ] = arr3 res = np . dot ( B_res , np . dot ( np . linalg . pinv ( F_res ), B_res )) + bb_res return res elif btype == 3 : F_list = [ [[ 0.0 for i in range ( len ( p_list ))] for j in range ( para_num )] for k in range ( para_num ) ] for i in range ( len ( p_list )): F_tp = QFIM ( rho_list [ i ], drho_list [ i ], LDtype = LDtype , eps = eps ) I_tp = np . zeros (( para_num , para_num )) G_tp = np . zeros (( para_num , para_num )) for pm in range ( para_num ): for pn in range ( para_num ): if pm == pn : G_tp [ pm ][ pn ] = dp_list [ i ][ pn ] * b_list [ i ][ pm ] / p_list [ i ] + ( 1.0 + db_list [ i ][ pm ]) else : G_tp [ pm ][ pn ] = dp_list [ i ][ pn ] * b_list [ i ][ pm ] / p_list [ i ] I_tp [ pm ][ pn ] = dp_list [ i ][ pm ] * dp_list [ i ][ pn ] / p_list [ i ] ** 2 F_tot = np . dot ( G_tp , np . dot ( np . linalg . pinv ( F_tp + I_tp ), G_tp . T )) for pj in range ( para_num ): for pk in range ( para_num ): F_list [ pj ][ pk ][ i ] = F_tot [ pj ][ pk ] res = np . zeros ([ para_num , para_num ]) for para_i in range ( 0 , para_num ): for para_j in range ( para_i , para_num ): F_ij = np . array ( F_list [ para_i ][ para_j ]) . reshape ( p_shape ) arr = p * F_ij for si in reversed ( range ( para_num )): arr = simps ( arr , x [ si ]) res [ para_i ][ para_j ] = arr res [ para_j ][ para_i ] = arr return res else : raise NameError ( \"NameError: btype should be choosen in {1, 2, 3}.\" ) Calculation of the optimal biased bound based on the first type of the BQCRB in the case of single parameter estimation. The expression of OBB with a prior distribution \\(p(x)\\) is \\begin{align} \\mathrm{var}(\\hat{x},{\\Pi_y})\\geq\\int p(x)\\left(\\frac{(1+b')^2}{F} +b^2\\right)\\mathrm{d}x, \\end{align} where \\(b\\) and \\(b'\\) are the vector of biase and its derivative on \\(x\\) . \\(F\\) is the QFI for all types.","title":"Returns"},{"location":"API/python/functions/#quanestimation.OBB--parameters","text":"x: list -- The regimes of the parameters for the integral. p: array -- The prior distribution. dp: list -- Derivatives of the prior distribution with respect to the unknown parameters to to estimated. For example, dp[0] is the derivative vector with respect to the first parameter. rho: list -- Parameterized density matrix. drho: list -- Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated. drho: list -- Second order Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated. LDtype: string -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). eps: float -- Machine epsilon.","title":"Parameters"},{"location":"API/python/functions/#quanestimation.OBB--returns","text":"QVTB: float or matrix -- For single parameter estimation (the length of x is equal to one), the output is a float and for multiparameter estimation (the length of x is more than one), it returns a matrix. Source code in quanestimation/BayesianBound/BayesianCramerRao.py 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 def OBB ( x , p , dp , rho , drho , d2rho , LDtype = \"SLD\" , eps = 1e-8 ): r \"\"\" Calculation of the optimal biased bound based on the first type of the BQCRB in the case of single parameter estimation. The expression of OBB with a prior distribution $p(x)$ is \\begin{align} \\mathrm{var}(\\hat{x},\\{\\Pi_y\\})\\geq\\int p(x)\\left(\\frac{(1+b')^2}{F} +b^2\\right)\\mathrm{d}x, \\end{align} where $b$ and $b'$ are the vector of biase and its derivative on $x$. $F$ is the QFI for all types. Parameters ---------- > **x:** `list` -- The regimes of the parameters for the integral. > **p:** `array` -- The prior distribution. > **dp:** `list` -- Derivatives of the prior distribution with respect to the unknown parameters to to estimated. For example, dp[0] is the derivative vector with respect to the first parameter. > **rho:** `list` -- Parameterized density matrix. > **drho:** `list` -- Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated. > **drho:** `list` -- Second order Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). > **eps:** `float` -- Machine epsilon. Returns ---------- **QVTB:** `float or matrix` -- For single parameter estimation (the length of x is equal to one), the output is a float and for multiparameter estimation (the length of x is more than one), it returns a matrix. \"\"\" #### single parameter scenario #### p_num = len ( p ) if type ( drho [ 0 ]) == list : drho = [ drho [ i ][ 0 ] for i in range ( p_num )] if type ( d2rho [ 0 ]) == list : d2rho = [ d2rho [ i ][ 0 ] for i in range ( p_num )] if type ( dp [ 0 ]) == list or type ( dp [ 0 ]) == np . ndarray : dp = [ dp [ i ][ 0 ] for i in range ( p_num )] if type ( x [ 0 ]) != float or type ( x [ 0 ]) != int : x = x [ 0 ] F , J = np . zeros ( p_num ), np . zeros ( p_num ) bias , dbias = np . zeros ( p_num ), np . zeros ( p_num ) for m in range ( p_num ): f , LD = QFIM ( rho [ m ], [ drho [ m ]], LDtype = LDtype , exportLD = True , eps = eps ) F [ m ] = f term1 = np . dot ( np . dot ( d2rho [ m ], d2rho [ m ]), LD ) term2 = np . dot ( np . dot ( LD , LD ), drho [ m ]) dF = np . real ( np . trace ( 2 * term1 - term2 )) J [ m ] = dp [ m ] / p [ m ] - dF / f y_guess = np . zeros (( 2 , x . size )) fun = lambda m , n : OBB_func ( m , n , x , J , F ) result = solve_bvp ( fun , boundary_condition , x , y_guess ) res = result . sol ( x ) bias , dbias = res [ 0 ], res [ 1 ] value = [ p [ i ] * (( 1 + dbias [ i ]) ** 2 / F [ i ] + bias [ i ] ** 2 ) for i in range ( p_num )] return simps ( value , x ) Calculation of the Bayesian version of Cramer-Rao bound introduced by Van Trees (VTB). The covariance matrix with a prior distribution \\(p(\\textbf{x})\\) is defined as \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},{\\Pi_y})=\\int p(\\textbf{x})\\sum_y\\mathrm{Tr} (\\rho\\Pi_y)(\\hat{\\textbf{x}}-\\textbf{x})(\\hat{\\textbf{x}}-\\textbf{x})^{\\mathrm{T}} \\mathrm{d}\\textbf{x} \\end{align} where \\(\\textbf{x}=(x_0,x_1,\\dots)^{\\mathrm{T}}\\) are the unknown parameters to be estimated and the integral \\(\\int\\mathrm{d}\\textbf{x}:=\\iiint\\mathrm{d}x_0\\mathrm{d}x_1\\cdots\\) . \\(\\{\\Pi_y\\}\\) is a set of positive operator-valued measure (POVM) and \\(\\rho\\) represent the parameterized density matrix. \\[\\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},\\{\\Pi_y\\})\\geq \\left(\\mathcal{I}_{\\mathrm{prior}} +\\mathcal{I}_{\\mathrm{Bayes}}\\right)^{-1}, \\end{align}\\] where \\(\\mathcal{I}_{\\mathrm{prior}}=\\int p(\\textbf{x})\\mathcal{I}_{p}\\mathrm{d}\\textbf{x}\\) is the CFIM for \\(p(\\textbf{x})\\) and \\(\\mathcal{I}_{\\mathrm{Bayes}}=\\int p(\\textbf{x})\\mathcal{I}\\mathrm{d}\\textbf{x}\\) is the average CFIM.","title":"Returns"},{"location":"API/python/functions/#quanestimation.VTB--parameters","text":"x: list -- The regimes of the parameters for the integral. p: multidimensional array -- The prior distribution. dp: list -- Derivatives of the prior distribution with respect to the unknown parameters to be estimated. For example, dp[0] is the derivative vector with respect to the first parameter. rho: multidimensional list -- Parameterized density matrix. drho: multidimensional list -- Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated. M: list of matrices -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). eps: float -- Machine epsilon.","title":"Parameters"},{"location":"API/python/functions/#quanestimation.VTB--returns","text":"VTB: float or matrix -- For single parameter estimation (the length of x is equal to one), the output is a float and for multiparameter estimation (the length of x is more than one), it returns a matrix. Note: SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from here . Source code in quanestimation/BayesianBound/BayesianCramerRao.py 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 def VTB ( x , p , dp , rho , drho , M = [], eps = 1e-8 ): r \"\"\" Calculation of the Bayesian version of Cramer-Rao bound introduced by Van Trees (VTB). The covariance matrix with a prior distribution $p(\\textbf{x})$ is defined as \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},\\{\\Pi_y\\})=\\int p(\\textbf{x})\\sum_y\\mathrm{Tr} (\\rho\\Pi_y)(\\hat{\\textbf{x}}-\\textbf{x})(\\hat{\\textbf{x}}-\\textbf{x})^{\\mathrm{T}} \\mathrm{d}\\textbf{x} \\end{align} where $\\textbf{x}=(x_0,x_1,\\dots)^{\\mathrm{T}}$ are the unknown parameters to be estimated and the integral $\\int\\mathrm{d}\\textbf{x}:=\\iiint\\mathrm{d}x_0\\mathrm{d}x_1\\cdots$. $\\{\\Pi_y\\}$ is a set of positive operator-valued measure (POVM) and $\\rho$ represent the parameterized density matrix. \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},\\{\\Pi_y\\})\\geq \\left(\\mathcal{I}_{\\mathrm{prior}} +\\mathcal{I}_{\\mathrm{Bayes}}\\right)^{-1}, \\end{align} where $\\mathcal{I}_{\\mathrm{prior}}=\\int p(\\textbf{x})\\mathcal{I}_{p}\\mathrm{d}\\textbf{x}$ is the CFIM for $p(\\textbf{x})$ and $\\mathcal{I}_{\\mathrm{Bayes}}=\\int p(\\textbf{x})\\mathcal{I}\\mathrm{d}\\textbf{x}$ is the average CFIM. Parameters ---------- > **x:** `list` -- The regimes of the parameters for the integral. > **p:** `multidimensional array` -- The prior distribution. > **dp:** `list` -- Derivatives of the prior distribution with respect to the unknown parameters to be estimated. For example, dp[0] is the derivative vector with respect to the first parameter. > **rho:** `multidimensional list` -- Parameterized density matrix. > **drho:** `multidimensional list` -- Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). > **eps:** `float` -- Machine epsilon. Returns ---------- **VTB:** `float or matrix` -- For single parameter estimation (the length of x is equal to one), the output is a float and for multiparameter estimation (the length of x is more than one), it returns a matrix. **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" para_num = len ( x ) p_num = len ( p ) if para_num == 1 : #### single parameter scenario #### if M == []: M = SIC ( len ( rho [ 0 ])) else : if type ( M ) != list : raise TypeError ( \"Please make sure M is a list!\" ) if type ( drho [ 0 ]) == list : drho = [ drho [ i ][ 0 ] for i in range ( p_num )] if type ( dp [ 0 ]) == list or type ( dp [ 0 ]) == np . ndarray : dp = [ dp [ i ][ 0 ] for i in range ( p_num )] F_tp = np . zeros ( p_num ) for m in range ( p_num ): F_tp [ m ] = CFIM ( rho [ m ], [ drho [ m ]], M = M , eps = eps ) arr1 = [ np . real ( dp [ i ] * dp [ i ] / p [ i ]) for i in range ( p_num )] I = simps ( arr1 , x [ 0 ]) arr2 = [ np . real ( F_tp [ j ] * p [ j ]) for j in range ( p_num )] F = simps ( arr2 , x [ 0 ]) return 1.0 / ( I + F ) else : #### multiparameter scenario #### p_shape = np . shape ( p ) p_ext = extract_ele ( p , para_num ) dp_ext = extract_ele ( dp , para_num ) rho_ext = extract_ele ( rho , para_num ) drho_ext = extract_ele ( drho , para_num ) p_list , dp_list , rho_list , drho_list = [], [], [], [] for p_ele , dp_ele , rho_ele , drho_ele in zip ( p_ext , dp_ext , rho_ext , drho_ext ): p_list . append ( p_ele ) dp_list . append ( dp_ele ) rho_list . append ( rho_ele ) drho_list . append ( drho_ele ) dim = len ( rho_list [ 0 ]) if M == []: M = SIC ( dim ) else : if type ( M ) != list : raise TypeError ( \"Please make sure M is a list!\" ) F_list = [ [[ 0.0 for i in range ( len ( p_list ))] for j in range ( para_num )] for k in range ( para_num ) ] I_list = [ [[ 0.0 for i in range ( len ( p_list ))] for j in range ( para_num )] for k in range ( para_num ) ] for i in range ( len ( p_list )): F_tp = CFIM ( rho_list [ i ], drho_list [ i ], M = M , eps = eps ) for pj in range ( para_num ): for pk in range ( para_num ): F_list [ pj ][ pk ][ i ] = F_tp [ pj ][ pk ] I_list [ pj ][ pk ][ i ] = ( dp_list [ i ][ pj ] * dp_list [ i ][ pk ] / p_list [ i ] ** 2 ) F_res = np . zeros ([ para_num , para_num ]) I_res = np . zeros ([ para_num , para_num ]) for para_i in range ( 0 , para_num ): for para_j in range ( para_i , para_num ): F_ij = np . array ( F_list [ para_i ][ para_j ]) . reshape ( p_shape ) I_ij = np . array ( I_list [ para_i ][ para_j ]) . reshape ( p_shape ) arr1 = p * F_ij arr2 = p * I_ij for si in reversed ( range ( para_num )): arr1 = simps ( arr1 , x [ si ]) arr2 = simps ( arr2 , x [ si ]) F_res [ para_i ][ para_j ] = arr1 F_res [ para_j ][ para_i ] = arr1 I_res [ para_i ][ para_j ] = arr2 I_res [ para_j ][ para_i ] = arr2 return np . linalg . pinv ( F_res + I_res ) Calculation of the Bayesian version of quantum Cramer-Rao bound introduced by Van Trees (QVTB). The covariance matrix with a prior distribution p(\\textbf{x}) is defined as \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},{\\Pi_y})=\\int p(\\textbf{x})\\sum_y\\mathrm{Tr} (\\rho\\Pi_y)(\\hat{\\textbf{x}}-\\textbf{x})(\\hat{\\textbf{x}}-\\textbf{x})^{\\mathrm{T}} \\mathrm{d}\\textbf{x} \\end{align} where \\(\\textbf{x}=(x_0,x_1,\\dots)^{\\mathrm{T}}\\) are the unknown parameters to be estimated and the integral \\(\\int\\mathrm{d}\\textbf{x}:=\\iiint\\mathrm{d}x_0\\mathrm{d}x_1\\cdots\\) . \\(\\{\\Pi_y\\}\\) is a set of positive operator-valued measure (POVM) and \\(\\rho\\) represent the parameterized density matrix. \\[\\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},\\{\\Pi_y\\})\\geq \\left(\\mathcal{I}_{\\mathrm{prior}} +\\mathcal{F}_{\\mathrm{Bayes}}\\right)^{-1}, \\end{align}\\] where \\(\\mathcal{I}_{\\mathrm{prior}}=\\int p(\\textbf{x})\\mathcal{I}_{p}\\mathrm{d}\\textbf{x}\\) is the CFIM for \\(p(\\textbf{x})\\) and \\(\\mathcal{F}_{\\mathrm{Bayes}}=\\int p(\\textbf{x})\\mathcal{F} \\mathrm{d}\\textbf{x}\\) is the average QFIM of all types.","title":"Returns"},{"location":"API/python/functions/#quanestimation.QVTB--parameters","text":"x: list -- The regimes of the parameters for the integral. p: multidimensional array -- The prior distribution. dp: list -- Derivatives of the prior distribution with respect to the unknown parameters to to estimated. For example, dp[0] is the derivative vector with respect to the first parameter. rho: multidimensional list -- Parameterized density matrix. drho: multidimensional list -- Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated. LDtype: string -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). eps: float -- Machine epsilon.","title":"Parameters"},{"location":"API/python/functions/#quanestimation.QVTB--returns","text":"QVTB: float or matrix -- For single parameter estimation (the length of x is equal to one), the output is a float and for multiparameter estimation (the length of x is more than one), it returns a matrix. Source code in quanestimation/BayesianBound/BayesianCramerRao.py 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 def QVTB ( x , p , dp , rho , drho , LDtype = \"SLD\" , eps = 1e-8 ): r \"\"\" Calculation of the Bayesian version of quantum Cramer-Rao bound introduced by Van Trees (QVTB). The covariance matrix with a prior distribution p(\\textbf{x}) is defined as \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},\\{\\Pi_y\\})=\\int p(\\textbf{x})\\sum_y\\mathrm{Tr} (\\rho\\Pi_y)(\\hat{\\textbf{x}}-\\textbf{x})(\\hat{\\textbf{x}}-\\textbf{x})^{\\mathrm{T}} \\mathrm{d}\\textbf{x} \\end{align} where $\\textbf{x}=(x_0,x_1,\\dots)^{\\mathrm{T}}$ are the unknown parameters to be estimated and the integral $\\int\\mathrm{d}\\textbf{x}:=\\iiint\\mathrm{d}x_0\\mathrm{d}x_1\\cdots$. $\\{\\Pi_y\\}$ is a set of positive operator-valued measure (POVM) and $\\rho$ represent the parameterized density matrix. \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},\\{\\Pi_y\\})\\geq \\left(\\mathcal{I}_{\\mathrm{prior}} +\\mathcal{F}_{\\mathrm{Bayes}}\\right)^{-1}, \\end{align} where $\\mathcal{I}_{\\mathrm{prior}}=\\int p(\\textbf{x})\\mathcal{I}_{p}\\mathrm{d}\\textbf{x}$ is the CFIM for $p(\\textbf{x})$ and $\\mathcal{F}_{\\mathrm{Bayes}}=\\int p(\\textbf{x})\\mathcal{F} \\mathrm{d}\\textbf{x}$ is the average QFIM of all types. Parameters ---------- > **x:** `list` -- The regimes of the parameters for the integral. > **p:** multidimensional array -- The prior distribution. > **dp:** `list` -- Derivatives of the prior distribution with respect to the unknown parameters to to estimated. For example, dp[0] is the derivative vector with respect to the first parameter. > **rho:** `multidimensional list` -- Parameterized density matrix. > **drho:** `multidimensional list` -- Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated. > **LDtype:** `string` -- Types of QFI (QFIM) can be set as the objective function. Options are: \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD). \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD). \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). > **eps:** `float` -- Machine epsilon. Returns ---------- **QVTB:** `float or matrix` -- For single parameter estimation (the length of x is equal to one), the output is a float and for multiparameter estimation (the length of x is more than one), it returns a matrix. \"\"\" para_num = len ( x ) p_num = len ( p ) if para_num == 1 : if type ( drho [ 0 ]) == list : drho = [ drho [ i ][ 0 ] for i in range ( p_num )] if type ( dp [ 0 ]) == list or type ( dp [ 0 ]) == np . ndarray : dp = [ dp [ i ][ 0 ] for i in range ( p_num )] F_tp = np . zeros ( p_num ) for m in range ( p_num ): F_tp [ m ] = QFIM ( rho [ m ], [ drho [ m ]], LDtype = LDtype , eps = eps ) arr1 = [ np . real ( dp [ i ] * dp [ i ] / p [ i ]) for i in range ( p_num )] I = simps ( arr1 , x [ 0 ]) arr2 = [ np . real ( F_tp [ j ] * p [ j ]) for j in range ( p_num )] F = simps ( arr2 , x [ 0 ]) return 1.0 / ( I + F ) else : #### multiparameter scenario #### p_shape = np . shape ( p ) p_ext = extract_ele ( p , para_num ) dp_ext = extract_ele ( dp , para_num ) rho_ext = extract_ele ( rho , para_num ) drho_ext = extract_ele ( drho , para_num ) p_list , dp_list , rho_list , drho_list , = ( [], [], [], [], ) for p_ele , dp_ele , rho_ele , drho_ele in zip ( p_ext , dp_ext , rho_ext , drho_ext ): p_list . append ( p_ele ) dp_list . append ( dp_ele ) rho_list . append ( rho_ele ) drho_list . append ( drho_ele ) F_list = [ [[ 0.0 for i in range ( len ( p_list ))] for j in range ( para_num )] for k in range ( para_num ) ] I_list = [ [[ 0.0 for i in range ( len ( p_list ))] for j in range ( para_num )] for k in range ( para_num ) ] for i in range ( len ( p_list )): F_tp = QFIM ( rho_list [ i ], drho_list [ i ], LDtype = LDtype , eps = eps ) for pj in range ( para_num ): for pk in range ( para_num ): F_list [ pj ][ pk ][ i ] = F_tp [ pj ][ pk ] I_list [ pj ][ pk ][ i ] = ( dp_list [ i ][ pj ] * dp_list [ i ][ pk ] / p_list [ i ] ** 2 ) F_res = np . zeros ([ para_num , para_num ]) I_res = np . zeros ([ para_num , para_num ]) for para_i in range ( 0 , para_num ): for para_j in range ( para_i , para_num ): F_ij = np . array ( F_list [ para_i ][ para_j ]) . reshape ( p_shape ) I_ij = np . array ( I_list [ para_i ][ para_j ]) . reshape ( p_shape ) arr1 = p * F_ij arr2 = p * I_ij for si in reversed ( range ( para_num )): arr1 = simps ( arr1 , x [ si ]) arr2 = simps ( arr2 , x [ si ]) F_res [ para_i ][ para_j ] = arr1 F_res [ para_j ][ para_i ] = arr1 I_res [ para_i ][ para_j ] = arr2 I_res [ para_j ][ para_i ] = arr2 return np . linalg . pinv ( F_res + I_res )","title":"Returns"},{"location":"API/python/functions/#quantum-ziv-zakai-bound","text":"Calculation of the quantum Ziv-Zakai bound (QZZB). The expression of QZZB with a prior distribution p(x) in a finite regime \\([\\alpha,\\beta]\\) is \\[\\begin{eqnarray} \\mathrm{var}(\\hat{x},\\{\\Pi_y\\}) &\\geq & \\frac{1}{2}\\int_0^\\infty \\mathrm{d}\\tau\\tau \\mathcal{V}\\int_{-\\infty}^{\\infty} \\mathrm{d}x\\min\\!\\left\\{p(x), p(x+\\tau)\\right\\} \\nonumber \\\\ & & \\times\\left(1-\\frac{1}{2}||\\rho(x)-\\rho(x+\\tau)||\\right), \\end{eqnarray}\\] where \\(||\\cdot||\\) represents the trace norm and \\(\\mathcal{V}\\) is the \"valley-filling\" operator satisfying \\(\\mathcal{V}f(\\tau)=\\max_{h\\geq 0}f(\\tau+h)\\) . \\(\\rho(x)\\) is the parameterized density matrix.","title":"Quantum Ziv-Zakai bound"},{"location":"API/python/functions/#quanestimation.QZZB--parameters","text":"x: list -- The regimes of the parameters for the integral. p: multidimensional array -- The prior distribution. rho: multidimensional list -- Parameterized density matrix. eps: float -- Machine epsilon.","title":"Parameters"},{"location":"API/python/functions/#quanestimation.QZZB--returns","text":"QZZB: float -- Quantum Ziv-Zakai bound (QZZB). Source code in quanestimation/BayesianBound/ZivZakai.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def QZZB ( x , p , rho , eps = 1e-8 ): r \"\"\" Calculation of the quantum Ziv-Zakai bound (QZZB). The expression of QZZB with a prior distribution p(x) in a finite regime $[\\alpha,\\beta]$ is \\begin{eqnarray} \\mathrm{var}(\\hat{x},\\{\\Pi_y\\}) &\\geq & \\frac{1}{2}\\int_0^\\infty \\mathrm{d}\\tau\\tau \\mathcal{V}\\int_{-\\infty}^{\\infty} \\mathrm{d}x\\min\\!\\left\\{p(x), p(x+\\tau)\\right\\} \\nonumber \\\\ & & \\times\\left(1-\\frac{1}{2}||\\rho(x)-\\rho(x+\\tau)||\\right), \\end{eqnarray} where $||\\cdot||$ represents the trace norm and $\\mathcal{V}$ is the \"valley-filling\" operator satisfying $\\mathcal{V}f(\\tau)=\\max_{h\\geq 0}f(\\tau+h)$. $\\rho(x)$ is the parameterized density matrix. Parameters ---------- > **x:** `list` -- The regimes of the parameters for the integral. > **p:** `multidimensional array` -- The prior distribution. > **rho:** `multidimensional list` -- Parameterized density matrix. > **eps:** `float` -- Machine epsilon. Returns ---------- **QZZB:** `float` -- Quantum Ziv-Zakai bound (QZZB). \"\"\" if type ( x [ 0 ]) == list or type ( x [ 0 ]) == np . ndarray : x = x [ 0 ] p_num = len ( p ) tau = [ xi - x [ 0 ] for xi in x ] f_tau = np . zeros ( p_num ) for i in range ( p_num ): arr = [ np . real ( 2 * min ( p [ j ], p [ j + i ]) * helstrom_dm ( rho [ j ], rho [ j + i ], eps )) for j in range ( p_num - i ) ] f_tp = simps ( arr , x [ 0 : p_num - i ]) f_tau [ i ] = f_tp arr2 = [ tau [ m ] * max ( f_tau [ m :]) for m in range ( p_num )] I = simps ( arr2 , tau ) return 0.5 * I","title":"Returns"},{"location":"API/python/functions/#bayesian-estimation","text":"Bayesian estimation. The prior distribution is updated via the posterior distribution obtained by the Bayes\u2019 rule and the estimated value of parameters are updated via the expectation value of the distribution or maximum a posteriori probability (MAP).","title":"Bayesian estimation"},{"location":"API/python/functions/#quanestimation.Bayes--parameters","text":"x: list -- The regimes of the parameters for the integral. p: multidimensional array -- The prior distribution. rho: multidimensional list -- Parameterized density matrix. y: array -- The experimental results obtained in practice. M: list of matrices -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). estimator: string -- Estimators for the bayesian estimation. Options are: \"mean\" -- The expectation value of the distribution. \"MAP\" -- Maximum a posteriori probability. savefile: bool -- Whether or not to save all the posterior distributions. If set True then two files \"pout.npy\" and \"xout.npy\" will be generated including the posterior distributions and the estimated values in the iterations. If set False the posterior distribution in the final iteration and the estimated values in all iterations will be saved in \"pout.npy\" and \"xout.npy\".","title":"Parameters"},{"location":"API/python/functions/#quanestimation.Bayes--returns","text":"pout and xout: array and float -- The posterior distribution and the estimated values in the final iteration. Note: SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from here . Source code in quanestimation/BayesianBound/BayesEstimation.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 def Bayes ( x , p , rho , y , M = [], estimator = \"mean\" , savefile = False ): \"\"\" Bayesian estimation. The prior distribution is updated via the posterior distribution obtained by the Bayes\u2019 rule and the estimated value of parameters are updated via the expectation value of the distribution or maximum a posteriori probability (MAP). Parameters ---------- > **x:** `list` -- The regimes of the parameters for the integral. > **p:** `multidimensional array` -- The prior distribution. > **rho:** `multidimensional list` -- Parameterized density matrix. > **y:** `array` -- The experimental results obtained in practice. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). > **estimator:** `string` -- Estimators for the bayesian estimation. Options are: \"mean\" -- The expectation value of the distribution. \"MAP\" -- Maximum a posteriori probability. > **savefile:** `bool` -- Whether or not to save all the posterior distributions. If set `True` then two files \"pout.npy\" and \"xout.npy\" will be generated including the posterior distributions and the estimated values in the iterations. If set `False` the posterior distribution in the final iteration and the estimated values in all iterations will be saved in \"pout.npy\" and \"xout.npy\". Returns ---------- **pout and xout:** `array and float` -- The posterior distribution and the estimated values in the final iteration. **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" para_num = len ( x ) max_episode = len ( y ) if para_num == 1 : #### single parameter scenario #### if M == []: M = SIC ( len ( rho [ 0 ])) else : if type ( M ) != list : raise TypeError ( \"Please make sure M is a list!\" ) if savefile == False : x_out = [] if estimator == \"mean\" : for mi in range ( max_episode ): res_exp = int ( y [ mi ]) pyx = np . zeros ( len ( x [ 0 ])) for xi in range ( len ( x [ 0 ])): p_tp = np . real ( np . trace ( np . dot ( rho [ xi ], M [ res_exp ]))) pyx [ xi ] = p_tp arr = [ pyx [ m ] * p [ m ] for m in range ( len ( x [ 0 ]))] py = simps ( arr , x [ 0 ]) p_update = pyx * p / py p = p_update mean = simps ([ p [ m ] * x [ 0 ][ m ] for m in range ( len ( x [ 0 ]))], x [ 0 ]) x_out . append ( mean ) elif estimator == \"MAP\" : for mi in range ( max_episode ): res_exp = int ( y [ mi ]) pyx = np . zeros ( len ( x [ 0 ])) for xi in range ( len ( x [ 0 ])): p_tp = np . real ( np . trace ( np . dot ( rho [ xi ], M [ res_exp ]))) pyx [ xi ] = p_tp arr = [ pyx [ m ] * p [ m ] for m in range ( len ( x [ 0 ]))] py = simps ( arr , x [ 0 ]) p_update = pyx * p / py p = p_update indx = np . where ( p == max ( p ))[ 0 ][ 0 ] x_out . append ( x [ 0 ][ indx ]) else : raise ValueError ( \" {!r} is not a valid value for estimator, supported values are 'mean' and 'MAP'.\" . format ( estimator )) np . save ( \"pout\" , p ) np . save ( \"xout\" , x_out ) return p , x_out [ - 1 ] else : p_out , x_out = [], [] if estimator == \"mean\" : for mi in range ( max_episode ): res_exp = int ( y [ mi ]) pyx = np . zeros ( len ( x [ 0 ])) for xi in range ( len ( x [ 0 ])): p_tp = np . real ( np . trace ( np . dot ( rho [ xi ], M [ res_exp ]))) pyx [ xi ] = p_tp arr = [ pyx [ m ] * p [ m ] for m in range ( len ( x [ 0 ]))] py = simps ( arr , x [ 0 ]) p_update = pyx * p / py p = p_update mean = simps ([ p [ m ] * x [ 0 ][ m ] for m in range ( len ( x [ 0 ]))], x [ 0 ]) p_out . append ( p ) x_out . append ( mean ) elif estimator == \"MAP\" : for mi in range ( max_episode ): res_exp = int ( y [ mi ]) pyx = np . zeros ( len ( x [ 0 ])) for xi in range ( len ( x [ 0 ])): p_tp = np . real ( np . trace ( np . dot ( rho [ xi ], M [ res_exp ]))) pyx [ xi ] = p_tp arr = [ pyx [ m ] * p [ m ] for m in range ( len ( x [ 0 ]))] py = simps ( arr , x [ 0 ]) p_update = pyx * p / py p = p_update indx = np . where ( p == max ( p ))[ 0 ][ 0 ] p_out . append ( p ) x_out . append ( x [ 0 ][ indx ]) else : raise ValueError ( \" {!r} is not a valid value for estimator, supported values are 'mean' and 'MAP'.\" . format ( estimator )) np . save ( \"pout\" , p_out ) np . save ( \"xout\" , x_out ) return p , x_out [ - 1 ] else : #### multiparameter scenario #### p_shape = np . shape ( p ) p_ext = extract_ele ( p , para_num ) rho_ext = extract_ele ( rho , para_num ) p_list , rho_list = [], [] for p_ele , rho_ele in zip ( p_ext , rho_ext ): p_list . append ( p_ele ) rho_list . append ( rho_ele ) dim = len ( rho_list [ 0 ]) if M == []: M = SIC ( dim ) else : if type ( M ) != list : raise TypeError ( \"Please make sure M is a list!\" ) if savefile == False : x_out = [] if estimator == \"mean\" : for mi in range ( max_episode ): res_exp = int ( y [ mi ]) pyx_list = np . zeros ( len ( p_list )) for xi in range ( len ( p_list )): p_tp = np . real ( np . trace ( np . dot ( rho_list [ xi ], M [ res_exp ]))) pyx_list [ xi ] = p_tp pyx = pyx_list . reshape ( p_shape ) arr = p * pyx for si in reversed ( range ( para_num )): arr = simps ( arr , x [ si ]) py = arr p_update = p * pyx / py p = p_update mean = integ ( x , p ) x_out . append ( mean ) elif estimator == \"MAP\" : for mi in range ( max_episode ): res_exp = int ( y [ mi ]) pyx_list = np . zeros ( len ( p_list )) for xi in range ( len ( p_list )): p_tp = np . real ( np . trace ( np . dot ( rho_list [ xi ], M [ res_exp ]))) pyx_list [ xi ] = p_tp pyx = pyx_list . reshape ( p_shape ) arr = p * pyx for si in reversed ( range ( para_num )): arr = simps ( arr , x [ si ]) py = arr p_update = p * pyx / py p = p_update indx = np . where ( np . array ( p ) == np . max ( np . array ( p ))) x_out . append ([ x [ i ][ indx [ i ][ 0 ]] for i in range ( para_num )]) else : raise ValueError ( \" {!r} is not a valid value for estimator, supported values are 'mean' and 'MAP'.\" . format ( estimator )) np . save ( \"Lout\" , p ) np . save ( \"xout\" , x_out ) return p , x_out [ - 1 ] else : p_out , x_out = [], [] if estimator == \"mean\" : for mi in range ( max_episode ): res_exp = int ( y [ mi ]) pyx_list = np . zeros ( len ( p_list )) for xi in range ( len ( p_list )): p_tp = np . real ( np . trace ( np . dot ( rho_list [ xi ], M [ res_exp ]))) pyx_list [ xi ] = p_tp pyx = pyx_list . reshape ( p_shape ) arr = p * pyx for si in reversed ( range ( para_num )): arr = simps ( arr , x [ si ]) py = arr p_update = p * pyx / py p = p_update mean = integ ( x , p ) p_out . append ( p ) x_out . append ( mean ) elif estimator == \"MAP\" : for mi in range ( max_episode ): res_exp = int ( y [ mi ]) pyx_list = np . zeros ( len ( p_list )) for xi in range ( len ( p_list )): p_tp = np . real ( np . trace ( np . dot ( rho_list [ xi ], M [ res_exp ]))) pyx_list [ xi ] = p_tp pyx = pyx_list . reshape ( p_shape ) arr = p * pyx for si in reversed ( range ( para_num )): arr = simps ( arr , x [ si ]) py = arr p_update = p * pyx / py p = p_update indx = np . where ( np . array ( p ) == np . max ( np . array ( p ))) p_out . append ( p ) x_out . append ([ x [ i ][ indx [ i ][ 0 ]] for i in range ( para_num )]) else : raise ValueError ( \" {!r} is not a valid value for estimator, supported values are 'mean' and 'MAP'.\" . format ( estimator )) np . save ( \"pout\" , p_out ) np . save ( \"xout\" , x_out ) return p , x_out [ - 1 ] Bayesian estimation. The estimated value of parameters obtained via the maximum likelihood estimation (MLE).","title":"Returns"},{"location":"API/python/functions/#quanestimation.MLE--parameters","text":"x: list -- The regimes of the parameters for the integral. rho: multidimensional list -- Parameterized density matrix. y: array -- The experimental results obtained in practice. M: list of matrices -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). savefile: bool -- Whether or not to save all the likelihood functions. If set True then two files \"Lout.npy\" and \"xout.npy\" will be generated including the likelihood functions and the estimated values in the iterations. If set False the likelihood function in the final iteration and the estimated values in all iterations will be saved in \"Lout.npy\" and \"xout.npy\".","title":"Parameters"},{"location":"API/python/functions/#quanestimation.MLE--returns","text":"Lout and xout: array and float -- The likelihood function and the estimated values in the final iteration. Note: SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from here . Source code in quanestimation/BayesianBound/BayesEstimation.py 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 def MLE ( x , rho , y , M = [], savefile = False ): \"\"\" Bayesian estimation. The estimated value of parameters obtained via the maximum likelihood estimation (MLE). Parameters ---------- > **x:** `list` -- The regimes of the parameters for the integral. > **rho:** `multidimensional list` -- Parameterized density matrix. > **y:** `array` -- The experimental results obtained in practice. > **M:** `list of matrices` -- A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM). > **savefile:** `bool` -- Whether or not to save all the likelihood functions. If set `True` then two files \"Lout.npy\" and \"xout.npy\" will be generated including the likelihood functions and the estimated values in the iterations. If set `False` the likelihood function in the final iteration and the estimated values in all iterations will be saved in \"Lout.npy\" and \"xout.npy\". Returns ---------- **Lout and xout:** `array and float` -- The likelihood function and the estimated values in the final iteration. **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" para_num = len ( x ) max_episode = len ( y ) if para_num == 1 : #### single parameter scenario #### if M == []: M = SIC ( len ( rho [ 0 ])) else : if type ( M ) != list : raise TypeError ( \"Please make sure M is a list!\" ) if savefile == False : x_out = [] L_out = np . ones ( len ( x [ 0 ])) for mi in range ( max_episode ): res_exp = int ( y [ mi ]) for xi in range ( len ( x [ 0 ])): p_tp = np . real ( np . trace ( np . dot ( rho [ xi ], M [ res_exp ]))) L_out [ xi ] = L_out [ xi ] * p_tp indx = np . where ( L_out == max ( L_out ))[ 0 ][ 0 ] x_out . append ( x [ 0 ][ indx ]) np . save ( \"Lout\" , L_out ) np . save ( \"xout\" , x_out ) return L_out , x_out [ - 1 ] else : L_out , x_out = [], [] L_tp = np . ones ( len ( x [ 0 ])) for mi in range ( max_episode ): res_exp = int ( y [ mi ]) for xi in range ( len ( x [ 0 ])): p_tp = np . real ( np . trace ( np . dot ( rho [ xi ], M [ res_exp ]))) L_tp [ xi ] = L_tp [ xi ] * p_tp indx = np . where ( L_tp == max ( L_tp ))[ 0 ][ 0 ] L_out . append ( L_tp ) x_out . append ( x [ 0 ][ indx ]) np . save ( \"Lout\" , L_out ) np . save ( \"xout\" , x_out ) return L_tp , x_out [ - 1 ] else : #### multiparameter scenario #### p_shape = [] for i in range ( para_num ): p_shape . append ( len ( x [ i ])) rho_ext = extract_ele ( rho , para_num ) rho_list = [] for rho_ele in rho_ext : rho_list . append ( rho_ele ) dim = len ( rho_list [ 0 ]) if M == []: M = SIC ( dim ) else : if type ( M ) != list : raise TypeError ( \"Please make sure M is a list!\" ) if savefile == False : x_out = [] L_list = np . ones ( len ( rho_list )) for mi in range ( max_episode ): res_exp = int ( y [ mi ]) for xi in range ( len ( rho_list )): p_tp = np . real ( np . trace ( np . dot ( rho_list [ xi ], M [ res_exp ]))) L_list [ xi ] = L_list [ xi ] * p_tp L_out = L_list . reshape ( p_shape ) indx = np . where ( L_out == np . max ( L_out )) x_out . append ([ x [ i ][ indx [ i ][ 0 ]] for i in range ( para_num )]) np . save ( \"Lout\" , L_out ) np . save ( \"xout\" , x_out ) return L_out , x_out [ - 1 ] else : L_out , x_out = [], [] L_list = np . ones ( len ( rho_list )) for mi in range ( max_episode ): res_exp = int ( y [ mi ]) for xi in range ( len ( rho_list )): p_tp = np . real ( np . trace ( np . dot ( rho_list [ xi ], M [ res_exp ]))) L_list [ xi ] = L_list [ xi ] * p_tp L_tp = L_list . reshape ( p_shape ) indx = np . where ( L_tp == np . max ( L_tp )) L_out . append ( L_tp ) x_out . append ([ x [ i ][ indx [ i ][ 0 ]] for i in range ( para_num )]) np . save ( \"Lout\" , L_out ) np . save ( \"xout\" , x_out ) return L_tp , x_out [ - 1 ] Calculation of the average Bayesian cost with a quadratic cost function.","title":"Returns"},{"location":"API/python/functions/#quanestimation.BayesCost--parameters","text":"x: list -- The regimes of the parameters for the integral. p: multidimensional array -- The prior distribution. xest: list -- The estimators. rho: multidimensional list -- Parameterized density matrix. M: array -- A set of POVM. W: array -- Weight matrix. eps: float -- Machine epsilon.","title":"Parameters"},{"location":"API/python/functions/#quanestimation.BayesCost--returns","text":"The average Bayesian cost: float -- The average Bayesian cost. Source code in quanestimation/BayesianBound/BayesEstimation.py 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 def BayesCost ( x , p , xest , rho , M , W = [], eps = 1e-8 ): \"\"\" Calculation of the average Bayesian cost with a quadratic cost function. Parameters ---------- > **x:** `list` -- The regimes of the parameters for the integral. > **p:** `multidimensional array` -- The prior distribution. > **xest:** `list` -- The estimators. > **rho:** `multidimensional list` -- Parameterized density matrix. > **M:** `array` -- A set of POVM. > **W:** `array` -- Weight matrix. > **eps:** `float` -- Machine epsilon. Returns ---------- **The average Bayesian cost:** `float` -- The average Bayesian cost. \"\"\" para_num = len ( x ) if para_num == 1 : # single-parameter scenario if M == []: M = SIC ( len ( rho [ 0 ])) else : if type ( M ) != list : raise TypeError ( \"Please make sure M is a list!\" ) p_num = len ( x [ 0 ]) value = [ p [ i ] * sum ([ np . trace ( np . dot ( rho [ i ], M [ mi ])) * ( x [ 0 ][ i ] - xest [ mi ][ 0 ]) ** 2 for mi in range ( len ( M ))]) for i in range ( p_num )] C = simps ( value , x [ 0 ]) return np . real ( C ) else : # multi-parameter scenario p_shape = np . shape ( p ) p_ext = extract_ele ( p , para_num ) rho_ext = extract_ele ( rho , para_num ) p_list , rho_list = [], [] for p_ele , rho_ele in zip ( p_ext , rho_ext ): p_list . append ( p_ele ) rho_list . append ( rho_ele ) x_pro = product ( * x ) x_list = [] for x_ele in x_pro : x_list . append ([ x_ele [ i ] for i in range ( para_num )]) dim = len ( rho_list [ 0 ]) p_num = len ( p_list ) if W == []: W = np . identity ( para_num ) if M == []: M = SIC ( dim ) else : if type ( M ) != list : raise TypeError ( \"Please make sure M is a list!\" ) value = [ 0.0 for i in range ( p_num )] for i in range ( p_num ): x_tp = np . array ( x_list [ i ]) xCx = 0.0 for mi in range ( len ( M )): xCx += np . trace ( np . dot ( rho_list [ i ], M [ mi ])) * np . dot (( x_tp - xest [ mi ]) . reshape ( 1 , - 1 ), np . dot ( W , ( x_tp - xest [ mi ]) . reshape ( - 1 , 1 )))[ 0 ][ 0 ] value [ i ] = p_list [ i ] * xCx C = np . array ( value ) . reshape ( p_shape ) for si in reversed ( range ( para_num )): C = simps ( C , x [ si ]) return np . real ( C ) Calculation of the Bayesian cost bound with a quadratic cost function.","title":"Returns"},{"location":"API/python/functions/#quanestimation.BCB--parameters","text":"x: list -- The regimes of the parameters for the integral. p: multidimensional array -- The prior distribution. rho: multidimensional list -- Parameterized density matrix. W: array -- Weight matrix. eps: float -- Machine epsilon.","title":"Parameters"},{"location":"API/python/functions/#quanestimation.BCB--returns","text":"BCB: float -- The value of the minimum Bayesian cost. Source code in quanestimation/BayesianBound/BayesEstimation.py 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 def BCB ( x , p , rho , W = [], eps = 1e-8 ): \"\"\" Calculation of the Bayesian cost bound with a quadratic cost function. Parameters ---------- > **x:** `list` -- The regimes of the parameters for the integral. > **p:** `multidimensional array` -- The prior distribution. > **rho:** `multidimensional list` -- Parameterized density matrix. > **W:** `array` -- Weight matrix. > **eps:** `float` -- Machine epsilon. Returns ---------- **BCB:** `float` -- The value of the minimum Bayesian cost. \"\"\" para_num = len ( x ) if para_num == 1 : # single-parameter scenario dim = len ( rho [ 0 ]) p_num = len ( x [ 0 ]) value = [ p [ i ] * x [ 0 ][ i ] ** 2 for i in range ( p_num )] delta2_x = simps ( value , x [ 0 ]) rho_avg = np . zeros (( dim , dim ), dtype = np . complex128 ) rho_pri = np . zeros (( dim , dim ), dtype = np . complex128 ) for di in range ( dim ): for dj in range ( dim ): rho_avg_arr = [ p [ m ] * rho [ m ][ di ][ dj ] for m in range ( p_num )] rho_pri_arr = [ p [ n ] * x [ 0 ][ n ] * rho [ n ][ di ][ dj ] for n in range ( p_num )] rho_avg [ di ][ dj ] = simps ( rho_avg_arr , x [ 0 ]) rho_pri [ di ][ dj ] = simps ( rho_pri_arr , x [ 0 ]) Lambda = Lambda_avg ( rho_avg , [ rho_pri ], eps = eps ) minBC = delta2_x - np . real ( np . trace ( np . dot ( np . dot ( rho_avg , Lambda [ 0 ]), Lambda [ 0 ]))) return minBC else : # multi-parameter scenario p_shape = np . shape ( p ) p_ext = extract_ele ( p , para_num ) rho_ext = extract_ele ( rho , para_num ) p_list , rho_list = [], [] for p_ele , rho_ele in zip ( p_ext , rho_ext ): p_list . append ( p_ele ) rho_list . append ( rho_ele ) dim = len ( rho_list [ 0 ]) p_num = len ( p_list ) x_pro = product ( * x ) x_list = [] for x_ele in x_pro : x_list . append ([ x_ele [ i ] for i in range ( para_num )]) if W == []: W = np . identity ( para_num ) value = [ 0.0 for i in range ( p_num )] for i in range ( p_num ): x_tp = np . array ( x_list [ i ]) xCx = np . dot ( x_tp . reshape ( 1 , - 1 ), np . dot ( W , x_tp . reshape ( - 1 , 1 )))[ 0 ][ 0 ] value [ i ] = p_list [ i ] * xCx delta2_x = np . array ( value ) . reshape ( p_shape ) for si in reversed ( range ( para_num )): delta2_x = simps ( delta2_x , x [ si ]) rho_avg = np . zeros (( dim , dim ), dtype = np . complex128 ) rho_pri = [ np . zeros (( dim , dim ), dtype = np . complex128 ) for i in range ( para_num )] for di in range ( dim ): for dj in range ( dim ): rho_avg_arr = [ p_list [ m ] * rho_list [ m ][ di ][ dj ] for m in range ( p_num )] rho_avg_tp = np . array ( rho_avg_arr ) . reshape ( p_shape ) for si in reversed ( range ( para_num )): rho_avg_tp = simps ( rho_avg_tp , x [ si ]) rho_avg [ di ][ dj ] = rho_avg_tp for para_i in range ( para_num ): rho_pri_arr = [ p_list [ n ] * x_list [ n ][ para_i ] * rho_list [ n ][ di ][ dj ] for n in range ( p_num )] rho_pri_tp = np . array ( rho_pri_arr ) . reshape ( p_shape ) for si in reversed ( range ( para_num )): rho_pri_tp = simps ( rho_pri_tp , x [ si ]) rho_pri [ para_i ][ di ][ dj ] = rho_pri_tp Lambda = Lambda_avg ( rho_avg , rho_pri , eps = eps ) Mat = np . zeros (( para_num , para_num ), dtype = np . complex128 ) for para_m in range ( para_num ): for para_n in range ( para_num ): Mat += W [ para_m ][ para_n ] * np . dot ( Lambda [ para_m ], Lambda [ para_n ]) minBC = delta2_x - np . real ( np . trace ( np . dot ( rho_avg , Mat ))) return minBC","title":"Returns"},{"location":"API/python/functions/#common","text":"Generation of the input variables H, dH (or K, dK).","title":"Common"},{"location":"API/python/functions/#quanestimation.BayesInput--parameters","text":"x: list -- The regimes of the parameters for the integral. func: list -- Function defined by the users which returns H or K. dfunc: list -- Function defined by the users which returns dH or dK. channel: string -- Seeting the output of this function. Options are: \"dynamics\" (default) -- The output of this function is H and dH. \"Kraus\" (default) -- The output of this function is K and dHK.","title":"Parameters"},{"location":"API/python/functions/#quanestimation.BayesInput--returns","text":"H, dH (or K, dK). Source code in quanestimation/Common/Common.py 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 def BayesInput ( x , func , dfunc , channel = \"dynamics\" ): \"\"\" Generation of the input variables H, dH (or K, dK). Parameters ---------- > **x:** `list` -- The regimes of the parameters for the integral. > **func:** `list` -- Function defined by the users which returns H or K. > **dfunc:** `list` -- Function defined by the users which returns dH or dK. > **channel:** `string` -- Seeting the output of this function. Options are: \"dynamics\" (default) -- The output of this function is H and dH. \"Kraus\" (default) -- The output of this function is K and dHK. Returns ---------- H, dH (or K, dK). \"\"\" para_num = len ( x ) size = [ len ( x [ i ]) for i in range ( len ( x ))] x_all = product ( * x ) if channel == \"dynamics\" : dim = len ( func ([ 0 for i in range ( para_num )])) H_list , dH_list = [], [] for xi in x_all : H_list . append ( func ([ i for i in xi ])) dH_list . append ( dfunc ([ i for i in xi ])) H_res = np . reshape ( H_list , [ * size , * [ dim , dim ]]) dH_res = np . reshape ( dH_list , [ * size , * [ para_num , dim , dim ]]) return H_res , dH_res elif channel == \"Kraus\" : k_num = len ( func ([ 0 for i in range ( para_num )])) dim = len ( func ([ 0 for i in range ( para_num )])[ 0 ]) K_list , dK_list = [], [] if para_num == 1 : for xi in x_all : K_list . append ( func ([ i for i in xi ])) dK_list . append ( dfunc ([ i for i in xi ])) K_res = np . reshape ( K_list , [ * size , * [ k_num , dim , dim ]]) dK_res = np . reshape ( dK_list , [ * size , * [ para_num , k_num , dim , dim ]]) else : for xi in x_all : K_list . append ( func ([ i for i in xi ])) dK_list . append ( dfunc ([ i for i in xi ])) K_res = np . reshape ( K_list , [ * size , * [ k_num , dim , dim ]]) dK_res = np . reshape ( dK_list , [ * size , * [ k_num , para_num , dim , dim ]]) return K_res , dK_res else : raise ValueError ( \" {!r} is not a valid value for channel, supported values are 'dynamics' and 'Kraus'.\" . format ( channel ) ) Generation of a set of rank-one symmetric informationally complete positive operator-valued measure (SIC-POVM).","title":"Returns"},{"location":"API/python/functions/#quanestimation.SIC--parameters","text":"dim: int -- The dimension of the system.","title":"Parameters"},{"location":"API/python/functions/#quanestimation.SIC--returns","text":"A set of SCI-POVM. Note: SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from here . Source code in quanestimation/Common/Common.py 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 def SIC ( dim ): \"\"\" Generation of a set of rank-one symmetric informationally complete positive operator-valued measure (SIC-POVM). Parameters ---------- > **dim:** `int` -- The dimension of the system. Returns ---------- A set of SCI-POVM. **Note:** SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/ solutions.html). \"\"\" if dim <= 151 : file_path = os . path . join ( os . path . dirname ( os . path . dirname ( __file__ )), \"sic_fiducial_vectors/d %d .txt\" % ( dim ), ) data = np . loadtxt ( file_path ) fiducial = data [:, 0 ] + data [:, 1 ] * 1.0 j fiducial = np . array ( fiducial ) . reshape ( len ( fiducial ), 1 ) M = sic_povm ( fiducial ) return M else : raise ValueError ( \"The dimension of the space should be less or equal to 151.\" ) Generation of the SU( \\(N\\) ) generators with \\(N\\) the dimension of the system.","title":"Returns"},{"location":"API/python/functions/#quanestimation.suN_generator--parameters","text":"n: int -- The dimension of the system.","title":"Parameters"},{"location":"API/python/functions/#quanestimation.suN_generator--returns","text":"SU( \\(N\\) ) generators. Source code in quanestimation/Common/Common.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 def suN_generator ( n ): r \"\"\" Generation of the SU($N$) generators with $N$ the dimension of the system. Parameters ---------- > **n:** `int` -- The dimension of the system. Returns ---------- SU($N$) generators. \"\"\" symm , anti_symm , diag = suN_unsorted ( n ) if n == 2 : return [ symm [ 0 ], anti_symm [ 0 ], diag [ 0 ]] else : Lambda = [ 0.0 for i in range ( len ( symm + anti_symm + diag ))] Lambda [ 0 ], Lambda [ 1 ], Lambda [ 2 ] = symm [ 0 ], anti_symm [ 0 ], diag [ 0 ] repeat_times = 2 m1 , n1 , k1 = 0 , 3 , 1 while True : m1 += n1 j , l = 0 , 0 for i in range ( repeat_times ): Lambda [ m1 + j ] = symm [ k1 ] Lambda [ m1 + j + 1 ] = anti_symm [ k1 ] j += 2 k1 += 1 repeat_times += 1 n1 = n1 + 2 if k1 == len ( symm ): break m2 , n2 , k2 = 2 , 5 , 1 while True : m2 += n2 Lambda [ m2 ] = diag [ k2 ] n2 = n2 + 2 k2 = k2 + 1 if k2 == len ( diag ): break return Lambda","title":"Returns"},{"location":"guide/guide_Compopt/","text":"Comprehensive optimization \u00b6 In order to obtain the optimal parameter estimation schemes, it is necessary to simultaneously optimize the probe state, control and measurement. The comprehensive optimization for the probe state and measurement (SM), the probe state and control (SC), the control and measurement (CM) and the probe state, control and measurement (SCM) are proposed in QuanEstiamtion. In the package, the comprehensive optimization algorithms are particle swarm optimization (PSO) [1] , differential evolution (DE) [2] , and automatic differentiation (AD) [3] . Python com = ComprehensiveOpt ( savefile = False , method = \"DE\" , ** kwargs ) com . dynamics ( tspan , H0 , dH , Hc = [], ctrl = [], decay = [], ctrl_bound = []) SM com . SM ( W = []) SC com . SC ( W = [], M = [], target = \"QFIM\" , LDtype = \"SLD\" ) CM com . CM ( rho0 , W = []) SCM com . SCM ( W = []) Here savefile means whether to save all the optimized variables (probe states, control coefficients and measurements). If set True then the optimized variables and the values of the objective function obtained in all episodes will be saved during the training, otherwise, the optimized variables in the final episode and the values of the objective function in all episodes will be saved. method represents the optimization algorithm used, options are: \"PSO\", \"DE\", and \"AD\". **kwargs is the keyword and the default value corresponding to the optimization algorithm which will be introduced in detail below. If the dynamics of the system can be described by the master equation, then the dynamics data tspan , H0 , and dH shoule be input. tspan is the time length for the evolution, H0 and dH are the free Hamiltonian and its derivatives on the unknown parameters to be estimated. H0 is a matrix when the free Hamiltonian is time-independent and a list with the length equal to tspan when it is time-dependent. dH should be input as \\([\\partial_a{H_0}, \\partial_b{H_0}, \\cdots]\\) . Hc and ctrl are two lists represent the control Hamiltonians and the corresponding control coefficients. decay contains decay operators \\((\\Gamma_1, \\Gamma_2, \\cdots)\\) and the corresponding decay rates \\((\\gamma_1, \\gamma_2, \\cdots)\\) with the input rule decay=[[ \\(\\Gamma_1\\) , \\(\\gamma_1\\) ], [ \\(\\Gamma_2\\) , \\(\\gamma_2\\) ],...]. The default values for decay , Hc and ctrl are empty which means the dynamics is unitary and only governed by the free Hamiltonian. ctrl_bound is an array with two elements representing the lower and upper bound of the control coefficients, respectively. The default value of ctrl_bound=[] which means the control coefficients are in the regime \\([-\\infty,\\infty]\\) . QuanEstimation contains four comprehensive optimizations which are com.SM() , com.SC() , com.CM() and com.SCM() . The target in com.SC() can be set as target=\"QFIM\" (default), target=\"CFIM and target=\"HCRB for the corresponding objective functions are QFI ( \\(\\mathrm{Tr}(W\\mathcal{F}^{-1})\\) ), CFI ( \\(\\mathrm{Tr}(W\\mathcal{I}^{-1})\\) ) and HCRB, respectively. Here \\(\\mathcal{F}\\) and \\(\\mathcal{I}\\) are the QFIM and CFIM, \\(W\\) corresponds to W is the weight matrix which defaults to the identity matrix. If the users set target=\"HCRB for single parameter scenario, the program will exit and print \"Program terminated. In the single-parameter scenario, the HCRB is equivalent to the QFI. Please choose 'QFIM' as the objective function\" . LDtype represents the types of the QFIM, it can be set as LDtype=\"SLD\" (default), LDtype=\"RLD\" and LDtype=\"LLD\" . For the other three scenarios, the objective function is CFI ( \\(\\mathrm{Tr}(W\\mathcal{I}^{-1})\\) ). Julia SM opt = SMopt ( psi = psi , M = M , seed = 1234 ) alg = DE ( kwargs ... ) dynamics = Lindblad ( opt , tspan , H0 , dH ; Hc = missing , ctrl = missing , decay = missing ) obj = CFIM_obj ( W = missing ) run ( opt , alg , obj , dynamics ; savefile = false ) SC opt = SCopt ( psi = psi , ctrl = ctrl , ctrl_bound = ctrl_bound , seed = 1234 ) alg = DE ( kwargs ... ) dynamics = Lindblad ( opt , tspan , H0 , dH , Hc ; decay = missing ) QFIM obj = QFIM_obj ( W = missing , LDtype = :SLD ) CFIM obj = CFIM_obj ( W = missing ) HCRB obj = HCRB_obj ( W = missing ) run ( opt , alg , obj , dynamics ; savefile = false ) CM opt = CMopt ( ctrl = ctrl , M = M , ctrl_bound = ctrl_bound , seed = 1234 ) alg = DE ( kwargs ... ) dynamics = Lindblad ( opt , tspan , H0 , dH , Hc ; decay = missing ) obj = CFIM_obj ( W = missing ) run ( opt , alg , obj , dynamics ; savefile = false ) SCM opt = SCMopt ( psi = psi , ctrl = ctrl , M = M , ctrl_bound = ctrl_bound , seed = 1234 ) alg = DE ( kwargs ... ) dynamics = Lindblad ( opt , tspan , H0 , dH , Hc ; decay = missing ) obj = CFIM_obj ( W = missing ) run ( opt , alg , obj , dynamics ; savefile = false ) QuanEstimation contains four comprehensive optimizations which are SMopt() , SCopt() , CMopt() and SCMopt() . The optimization variables including initial state, control and measurement can be input via ctrl=ctrl , psi=psi and M=M for constructing a comprehensive optimization problem. Here, ctrl is a list of arrays with the length equal to control Hamiltonians, psi is an array representing the state and M is a list of arrays with the length equal to the dimension of the system which representing the projective measurement basis. Besides, the boundary value of each control coefficients can be input via ctrl_bound=ctrl_bound when the optimized variable contains control. ctrl_bound is an array with two elements representing the lower and upper bound of the control coefficients, respectively. The default value of ctrl_bound= missing which means the control coefficients are in the regime \\([-\\infty,\\infty]\\) . seed is the random seed which can ensure the reproducibility of results. The objective function of SCopt() can be chosen as QFIM_obj() (default), CFIM_obj() and HCRB_obj() for the corresponding objective functions are QFI ( \\(\\mathrm{Tr}(W\\mathcal{F}^ {-1})\\) ), CFI ( \\(\\mathrm{Tr}(W\\mathcal{I}^{-1})\\) ) and HCRB, respectively. Here \\(\\mathcal{F}\\) and \\(\\mathcal{I}\\) are the QFIM and CFIM, \\(W\\) corresponds to W is the weight matrix which defaults to the identity matrix. If the users set HCRB_obj() for single parameter scenario, the program will exit and print \"Program terminated. In the single-parameter scenario, the HCRB is equivalent to the QFI. Please choose 'QFIM_obj()' as the objective function\" . LDtype represents the types of the QFIM, it can be set as LDtype=:SLD (default), LDtype=:RLD and LDtype=:LLD . For the other three scenarios, the objective function is CFIM_obj() . If the dynamics of the system can be described by the master equation, then the dynamics data tspan , H0 , and dH shoule be input. tspan is the time length for the evolution, H0 and dH are the free Hamiltonian and its derivatives on the unknown parameters to be estimated. H0 is a matrix when the free Hamiltonian is time-independent and a list with the length equal to tspan when it is time-dependent. dH should be input as \\([\\partial_a{H_0}, \\partial_b{H_0}, \\cdots]\\) . Hc and ctrl are two lists represent the control Hamiltonians and the corresponding control coefficients. decay contains decay operators \\((\\Gamma_1, \\Gamma_2, \\cdots)\\) and the corresponding decay rates \\((\\gamma_1, \\gamma_2, \\cdots)\\) with the input rule decay=[[ \\(\\Gamma_1\\) , \\(\\gamma_1\\) ], [ \\(\\Gamma_2\\) , \\(\\gamma_2\\) ],...]. The variable savefile means whether to save all the optimized variables (probe states, control coefficients and measurements). If set true then the optimized variables and the values of the objective function obtained in all episodes will be saved during the training, otherwise, the optimized variables in the final episode and the values of the objective function in all episodes will be saved. The algorithm used in QuanEstimation for comprehensive optimizaiton are PSO, DE and AD. kwargs... is the keywords and the default values corresponding to the optimization algorithm which will be introduced in detail below. PSO \u00b6 The code for comprehensive optimization with PSO is as follows Python com = ComprehensiveOpt ( method = \"PSO\" , ** kwargs ) where kwargs is of the form kwargs = { \"p_num\" : 10 , \"psi0\" :[], \"ctrl0\" :[], \"measurement0\" :[], \"max_episode\" :[ 1000 , 100 ], \"c0\" : 1.0 , \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } The keywords and the default values of PSO can be seen in the following table \\(~~~~~~~~~~\\) **kwargs \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"p_num\" 10 \"psi0\" [ ] \"ctrl0\" [ ] \"measurement0\" [ ] \"max_episode\" [1000,100] \"c0\" 1.0 \"c1\" 2.0 \"c2\" 2.0 \"seed\" 1234 psi0 , ctrl0 and measurement0 in the algorithms represent the initial guesses of states, control coefficients and measurements, respectively, seed is the random seed. Here p_num is the number of particles, c0 , c1 , and c2 are the PSO parameters representing the inertia weight, cognitive learning factor and social learning factor, respectively. max_episode accepts both integers and arrays with two elements. If it is an integer, for example max_episode=1000, it means the program will continuously run 1000 episodes. However, if it is an array, for example max_episode=[1000,100], the program will run 1000 episodes in total but replace control coefficients of all the particles with global best every 100 episodes. Julia alg = PSO ( p_num = 10 , ini_particle = missing , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) The keywords and the default values of PSO can be seen in the following table \\(~~~~~~~~~~\\) keywords \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"p_num\" 10 \"ini_particle\" missing \"max_episode\" [1000,100] \"c0\" 1.0 \"c1\" 2.0 \"c2\" 2.0 ini_particle is a tuple contains psi0 , ctrl0 and measurement0 , which representing the initial guesses of states, control coefficients and measurements, respectively. The input rule of ini_particle shoule be ini_particle=(psi0, measurement0) (SM), ini_particle=(psi0, ctrl0) (SC), ini_particle=(ctrl0, measurement0) (CM) and ini_particle=(psi0, ctrl0, measurement0) (SCM). Here p_num is the number of particles, c0 , c1 , and c2 are the PSO parameters representing the inertia weight, cognitive learning factor and social learning factor, respectively. max_episode accepts both integers and arrays with two elements. If it is an integer, for example max_episode=1000, it means the program will continuously run 1000 episodes. However, if it is an array, for example max_episode=[1000,100], the program will run 1000 episodes in total but replace control coefficients of all the particles with global best every 100 episodes. DE \u00b6 The code for comprehensive optimization with DE is as follows Python com = ComprehensiveOpt ( method = \"DE\" , ** kwargs ) where kwargs is of the form kwargs = { \"p_num\" : 10 , \"psi0\" :[], \"ctrl0\" :[], \"measurement0\" :[], \"max_episode\" : 1000 , \"c\" : 1.0 , \"cr\" : 0.5 , \"seed\" : 1234 } The keywords and the default values of DE can be seen in the following table \\(~~~~~~~~~~\\) **kwargs \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"p_num\" 10 \"psi0\" [ ] \"ctrl0\" [ ] \"measurement0\" [ ] \"max_episode\" 1000 \"c\" 1.0 \"cr\" 0.5 \"seed\" 1234 p_num is the number of populations. Here max_episode is an integer representing the number of episodes. c and cr are constants for mutation and crossover. Julia alg = DE ( p_num = 10 , ini_population = missing , max_episode = 1000 , c = 1.0 , cr = 0.5 ) The keywords and the default values of DE can be seen in the following table \\(~~~~~~~~~~\\) keywords \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"p_num\" 10 \"ini_population\" missing \"max_episode\" 1000 \"c\" 1.0 \"cr\" 0.5 Here max_episode is an integer representing the number of episodes. p_num represents the number of populations. c and cr are constants for mutation and crossover. ini_particle is a tuple contains psi0 , ctrl0 and measurement0 , which representing the initial guesses of states, control coefficients and measurements, respectively. The input rule of ini_particle shoule be ini_particle=(psi0, measurement0) (SM), ini_particle=(psi0, ctrl0) (SC), ini_particle=(ctrl0, measurement0) (CM) and ini_particle=(psi0, ctrl0, measurement0) (SCM). AD \u00b6 The code for comprehensive optimization with AD is as follows Python com = ComprehensiveOpt ( method = \"AD\" , ** kwargs ) where kwargs is of the form kwargs = { \"Adam\" : True , \"psi0\" :[], \"ctrl0\" :[], \"measurement0\" :[], \"max_episode\" : 300 , \"epsilon\" : 0.01 , \"beta1\" : 0.90 , \"beta2\" : 0.99 } The keywords and the default values of AD can be seen in the following table \\(~~~~~~~~~~\\) **kwargs \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"Adam\" False \"psi0\" [ ] \"ctrl0\" [ ] \"measurement0\" [ ] \"max_episode\" 300 \"epsilon\" 0.01 \"beta1\" 0.90 \"beta2\" 0.99 The optimized variables will update according to the learning rate \"epsilon\" when Adam=False . However, If Adam=True , Adam algorithm will be used and the Adam parameters include learning rate, the exponential decay rate for the first moment estimates and the second moment estimates can be set by the user via epsilon , beta1 and beta2 . Julia alg = AD ( Adam = false , max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 ) The keywords and the default values of AD can be seen in the following table \\(~~~~~~~~~~\\) keywords \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"Adam\" false \"max_episode\" 300 \"epsilon\" 0.01 \"beta1\" 0.90 \"beta2\" 0.99 The optimized variables will update according to the learning rate \"epsilon\" when Adam=false . However, If Adam=true , Adam algorithm will be used and the Adam parameters include learning rate, the exponential decay rate for the first moment estimates and the second moment estimates can be set by the user via epsilon , beta1 and beta2 . Example 8.1 A single qubit system whose free evolution Hamiltonian is \\(H_0 = \\frac{1}{2}\\omega \\sigma_3\\) with \\(\\omega\\) the frequency and \\(\\sigma_3\\) a Pauli matrix. The dynamics of the system is governed by \\begin{align} \\partial_t\\rho=-i[H_0, \\rho]+ \\gamma_{+}\\left(\\sigma_{+}\\rho\\sigma_{-}-\\frac{1}{2}{\\sigma_{-}\\sigma_{+},\\rho}\\right)+ \\gamma_{-}\\left(\\sigma_{-}\\rho\\sigma_{+}-\\frac{1}{2}{\\sigma_{+}\\sigma_{-},\\rho}\\right), \\end{align} where \\(\\gamma_{+}\\) , \\(\\gamma_{-}\\) are decay rates and \\(\\sigma_{\\pm}=(\\sigma_1 \\pm \\sigma_2)/2\\) . The control Hamiltonian \\begin{align} H_\\mathrm{c}=u_1(t)\\sigma_1+u_2(t)\\sigma_2+u_3(t)\\sigma_3 \\end{align} with \\(u_i(t)\\) \\((i=1,2,3)\\) the control field. Here \\(\\sigma_{1}\\) , \\(\\sigma_{2}\\) are also Pauli matrices. In this case, we consider two types of comprehensive optimization, the first one is optimization of probe state and control (SC), and the other is optimization of probe state, control and measurement (SCM). QFI is taken as the target function for SC and CFI for SCM. Python from quanestimation import * import numpy as np # initial state rho0 = 0.5 * np . array ([[ 1. , 1. ], [ 1. , 1. ]]) # free Hamiltonian omega = 1.0 sx = np . array ([[ 0. , 1. ], [ 1. , 0. ]]) sy = np . array ([[ 0. , - 1. j ], [ 1. j , 0. ]]) sz = np . array ([[ 1. , 0. ], [ 0. , - 1. ]]) H0 = 0.5 * omega * sz # derivative of the free Hamiltonian on omega dH = [ 0.5 * sz ] # control Hamiltonians Hc = [ sx , sy , sz ] # dissipation sp = np . array ([[ 0. , 1. ], [ 0. , 0. ]]) sm = np . array ([[ 0. , 0. ], [ 1. , 0. ]]) decay = [[ sp , 0. ], [ sm , 0.1 ]] # measurement M1 = 0.5 * np . array ([[ 1. , 1. ], [ 1. , 1. ]]) M2 = 0.5 * np . array ([[ 1. , - 1. ], [ - 1. , 1. ]]) M = [ M1 , M2 ] # time length for the evolution tspan = np . linspace ( 0. , 10. , 2500 ) SM DE # comprehensive optimization algorithm: DE DE_paras = { \"p_num\" : 10 , \"psi0\" :[], \"ctrl0\" :[], \"measurement0\" :[], \\ \"max_episode\" : 1000 , \"c\" : 1.0 , \"cr\" : 0.5 , \"seed\" : 1234 } com = ComprehensiveOpt ( savefile = False , method = \"DE\" , ** DE_paras ) com . dynamics ( tspan , H0 , dH , decay = decay ) com . SM () PSO # comprehensive optimization algorithm: PSO PSO_paras = { \"p_num\" : 10 , \"psi0\" :[], \"ctrl0\" :[], \\ \"measurement0\" :[], \"max_episode\" :[ 1000 , 100 ], \"c0\" : 1.0 , \\ \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } com = ComprehensiveOpt ( savefile = False , method = \"PSO\" , ** PSO_paras ) com . dynamics ( tspan , H0 , dH , decay = decay ) com . SM () SC DE # comprehensive optimization algorithm: DE DE_paras = { \"p_num\" : 10 , \"psi0\" :[], \"ctrl0\" :[], \"measurement0\" :[], \\ \"max_episode\" : 1000 , \"c\" : 1.0 , \"cr\" : 0.5 , \"seed\" : 1234 } com = ComprehensiveOpt ( savefile = False , method = \"DE\" , ** DE_paras ) com . dynamics ( tspan , H0 , dH , Hc = Hc , decay = decay , ctrl_bound = [ - 2.0 , 2.0 ]) QFIM com . SC ( W = [], target = \"QFIM\" , LDtype = \"SLD\" ) CFIM com . SC ( W = [], M = M , target = \"CFIM\" ) PSO # comprehensive optimization algorithm: PSO PSO_paras = { \"p_num\" : 10 , \"psi0\" :[], \"ctrl0\" :[], \\ \"measurement0\" :[], \"max_episode\" :[ 1000 , 100 ], \"c0\" : 1.0 , \\ \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } com = ComprehensiveOpt ( savefile = False , method = \"PSO\" , ** PSO_paras ) com . dynamics ( tspan , H0 , dH , Hc = Hc , decay = decay , ctrl_bound = [ - 2.0 , 2.0 ]) QFIM com . SC ( W = [], target = \"QFIM\" , LDtype = \"SLD\" ) CFIM com . SC ( W = [], M = M , target = \"CFIM\" ) AD # comprehensive optimization algorithm: AD AD_paras = { \"Adam\" : False , \"psi0\" :[], \"ctrl0\" :[], \"measurement0\" :[], \\ \"max_episode\" : 300 , \"epsilon\" : 0.01 , \"beta1\" : 0.90 , \"beta2\" : 0.99 } com = ComprehensiveOpt ( savefile = False , method = \"AD\" , ** AD_paras ) com . dynamics ( tspan , H0 , dH , Hc = Hc , decay = decay ) com . SC ( W = [], target = \"QFIM\" , LDtype = \"SLD\" , ctrl_bound = [ - 2.0 , 2.0 ]) QFIM com . SC ( W = [], target = \"QFIM\" , LDtype = \"SLD\" ) CFIM com . SC ( W = [], M = M , target = \"CFIM\" ) CM DE # comprehensive optimization algorithm: DE DE_paras = { \"p_num\" : 10 , \"psi0\" :[], \"ctrl0\" :[], \"measurement0\" :[], \\ \"max_episode\" : 1000 , \"c\" : 1.0 , \"cr\" : 0.5 , \"seed\" : 1234 } com = ComprehensiveOpt ( savefile = False , method = \"DE\" , ** DE_paras ) com . dynamics ( tspan , H0 , dH , Hc = Hc , decay = decay , ctrl_bound = [ - 2.0 , 2.0 ]) com . CM ( rho0 ) PSO # comprehensive optimization algorithm: PSO PSO_paras = { \"p_num\" : 10 , \"psi0\" :[], \"ctrl0\" :[], \\ \"measurement0\" :[], \"max_episode\" :[ 1000 , 100 ], \"c0\" : 1.0 , \\ \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } com = ComprehensiveOpt ( savefile = False , method = \"PSO\" , ** PSO_paras ) com . dynamics ( tspan , H0 , dH , Hc = Hc , decay = decay , ctrl_bound = [ - 2.0 , 2.0 ]) com . CM ( rho0 ) SCM DE # comprehensive optimization algorithm: DE DE_paras = { \"p_num\" : 10 , \"psi0\" :[], \"ctrl0\" :[], \"measurement0\" :[], \\ \"max_episode\" : 1000 , \"c\" : 1.0 , \"cr\" : 0.5 , \"seed\" : 1234 } com = ComprehensiveOpt ( savefile = False , method = \"DE\" , ** DE_paras ) com . dynamics ( tspan , H0 , dH , Hc = Hc , decay = decay , ctrl_bound = [ - 2.0 , 2.0 ]) com . SCM () PSO # comprehensive optimization algorithm: PSO PSO_paras = { \"p_num\" : 10 , \"psi0\" :[], \"ctrl0\" :[], \\ \"measurement0\" :[], \"max_episode\" :[ 1000 , 100 ], \"c0\" : 1.0 , \\ \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } com = ComprehensiveOpt ( savefile = False , method = \"PSO\" , ** PSO_paras ) com . dynamics ( tspan , H0 , dH , Hc = Hc , decay = decay , ctrl_bound = [ - 2.0 , 2.0 ]) com . SCM () Julia using QuanEstimation # initial state rho0 = 0.5 * ones ( 2 , 2 ) # free Hamiltonian omega = 1.0 sx = [ 0. 1. ; 1. 0.0 im ] sy = [ 0. - im ; im 0. ] sz = [ 1. 0.0 im ; 0. - 1. ] H0 = 0.5 * omega * sz # derivative of the free Hamiltonian on omega dH = [ 0.5 * sz ] # control Hamiltonians Hc = [ sx , sy , sz ] # dissipation sp = [ 0. 1. ; 0. 0.0 im ] sm = [ 0. 0. ; 1. 0.0 im ] decay = [[ sp , 0.0 ], [ sm , 0.1 ]] # measurement M1 = 0.5 * [ 1.0 + 0.0 im 1. ; 1. 1. ] M2 = 0.5 * [ 1.0 + 0.0 im - 1. ; - 1. 1. ] M = [ M1 , M2 ] # time length for the evolution tspan = range ( 0. , 10. , length = 2500 ) SM opt = QuanEstimation . SMopt ( seed = 1234 ) DE # comprehensive optimization algorithm: DE alg = QuanEstimation . DE ( p_num = 10 , max_episode = 1000 , c = 1.0 , cr = 0.5 ) # input the dynamics data dynamics = QuanEstimation . Lindblad ( opt , tspan , H0 , dH , decay = decay ) # objective function: CFI obj = QuanEstimation . CFIM_obj ( M = M ) PSO # comprehensive optimization algorithm: PSO alg = QuanEstimation . PSO ( p_num = 10 , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) # input the dynamics data dynamics = QuanEstimation . Lindblad ( opt , tspan , H0 , dH , decay = decay ) # objective function: CFI obj = QuanEstimation . CFIM_obj ( M = M ) SC opt = QuanEstimation . SMopt ( ctrl_bound = [ - 2.0 , 2.0 ], seed = 1234 ) DE # comprehensive optimization algorithm: DE alg = QuanEstimation . DE ( p_num = 10 , max_episode = 1000 , c = 1.0 , cr = 0.5 ) # input the dynamics data dynamics = QuanEstimation . Lindblad ( opt , tspan , H0 , dH , Hc , decay = decay ) QFIM # objective function: QFI obj = QuanEstimation . QFIM_obj () CFIM # objective function: CFI obj = QuanEstimation . CFIM_obj ( M = M ) PSO # comprehensive optimization algorithm: PSO alg = QuanEstimation . PSO ( p_num = 10 , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) # input the dynamics data dynamics = QuanEstimation . Lindblad ( opt , tspan , H0 , dH , Hc , decay = decay ) QFIM # objective function: QFI obj = QuanEstimation . QFIM_obj () CFIM # objective function: CFI obj = QuanEstimation . CFIM_obj ( M = M ) AD # comprehensive optimization algorithm: AD alg = QuanEstimation . AD ( Adam = true , max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 ) # input the dynamics data dynamics = QuanEstimation . Lindblad ( opt , tspan , H0 , dH , Hc , decay = decay ) QFIM # objective function: QFI obj = QuanEstimation . QFIM_obj () CFIM # objective function: CFI obj = QuanEstimation . CFIM_obj ( M = M ) CM opt = QuanEstimation . CMopt ( ctrl_bound = [ - 2.0 , 2.0 ], seed = 1234 ) DE # comprehensive optimization algorithm: DE alg = QuanEstimation . DE ( p_num = 10 , max_episode = 1000 , c = 1.0 , cr = 0.5 ) # input the dynamics data dynamics = QuanEstimation . Lindblad ( opt , tspan , rho0 , H0 , dH , Hc , decay = decay ) # objective function: CFI obj = QuanEstimation . CFIM_obj ( M = M ) PSO # comprehensive optimization algorithm: PSO alg = QuanEstimation . PSO ( p_num = 10 , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) # input the dynamics data dynamics = QuanEstimation . Lindblad ( opt , tspan , rho0 , H0 , dH , Hc , decay = decay ) # objective function: CFI obj = QuanEstimation . CFIM_obj ( M = M ) SCM opt = QuanEstimation . SCMopt ( ctrl_bound = [ - 2.0 , 2.0 ], seed = 1234 ) DE # comprehensive optimization algorithm: DE alg = QuanEstimation . DE ( p_num = 10 , max_episode = 1000 , c = 1.0 , cr = 0.5 ) # input the dynamics data dynamics = QuanEstimation . Lindblad ( opt , tspan , H0 , dH , Hc , decay = decay ) # objective function: CFI obj = QuanEstimation . CFIM_obj ( M = M ) PSO # comprehensive optimization algorithm: PSO alg = QuanEstimation . PSO ( p_num = 10 , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) # input the dynamics data dynamics = QuanEstimation . Lindblad ( opt , tspan , H0 , dH , Hc , decay = decay ) # objective function: CFI obj = QuanEstimation . CFIM_obj ( M = M ) # run the comprehensive optimization problem QuanEstimation . run ( opt , alg , obj , dynamics ; savefile = false ) Example 8.2 The Hamiltonian of a controlled system can be written as \\begin{align} H = H_0(\\textbf{x})+\\sum_{k=1}^K u_k(t) H_k, \\end{align} where \\(H_0(\\textbf{x})\\) is the free evolution Hamiltonian with unknown parameters \\(\\textbf{x}\\) and \\(H_k\\) represents the \\(k\\) th control Hamiltonian with \\(u_k\\) the correspong control coefficient. In the multiparameter scenario, the dynamics of electron and nuclear coupling in NV \\(^{-}\\) can be expressed as \\begin{align} \\partial_t\\rho=-i[H_0+H_{\\mathrm{c}},\\rho]+\\frac{\\gamma}{2}(S_3\\rho S_3-S^2_3\\rho-\\rho S^2_3) \\end{align} with \\(\\gamma\\) the dephasing rate. And \\begin{align} H_0/\\hbar=DS^2_3+g_{\\mathrm{S}}\\vec{B}\\cdot\\vec{S}+g_{\\mathrm{I}}\\vec{B}\\cdot\\vec{I}+\\vec{S}^{\\,\\mathrm{T}}\\mathcal{A}\\vec{I} \\end{align} is the free evolution Hamiltonian, where \\(\\vec{S}=(S_1,S_2,S_3)^{\\mathrm{T}}\\) and \\(\\vec{I}=(I_1,I_2,I_3)^{\\mathrm{T}}\\) with \\(S_i=s_i\\otimes I\\) and \\(I_i=I\\otimes \\sigma_i\\) ( \\(i=1,2,3\\) ) the electron and nuclear operators. \\(\\mathcal{A}=\\mathrm{diag} (A_1,A_1,A_2)\\) is the hyperfine tensor with \\(A_1\\) and \\(A_2\\) the axial and transverse magnetic hyperfine coupling coefficients. The coefficients \\(g_{\\mathrm{S}}=g_\\mathrm{e}\\mu_\\mathrm{B}/\\hbar\\) and \\(g_{\\mathrm{I}}=g_\\mathrm{n}\\mu_\\mathrm{n}/\\hbar\\) , where \\(g_\\mathrm{e}\\) ( \\(g_\\mathrm{n}\\) ) is the \\(g\\) factor of the electron (nuclear), \\(\\mu_\\mathrm{B}\\) ( \\(\\mu_\\mathrm{n}\\) ) is the Bohr (nuclear) magneton and \\(\\hbar\\) is the Plank's constant. \\(\\vec{B}\\) is the magnetic field which be estimated. The control Hamiltonian is \\begin{align} H_{\\mathrm{c}}/\\hbar=\\sum^3_{i=1}\\Omega_i(t)S_i \\end{align} with \\(\\Omega_i(t)\\) the time-dependent Rabi frequency. In this case, the initial state is taken as \\(\\frac{1}{\\sqrt{2}}(|1\\rangle+|\\!-\\!1\\rangle)\\otimes|\\!\\!\\uparrow\\rangle\\) , where \\(\\frac{1}{\\sqrt{2}}(|1\\rangle+|\\!-\\!1\\rangle)\\) is an electron state with \\(|1\\rangle\\) \\((|\\!-\\!1\\rangle)\\) the eigenstate of \\(s_3\\) with respect to the eigenvalue \\(1\\) ( \\(-1\\) ). \\(|\\!\\!\\uparrow\\rangle\\) is a nuclear state and the eigenstate of \\(\\sigma_3\\) with respect to the eigenvalue 1. \\(W\\) is set to be identity. Python from quanestimation import * import numpy as np # initial state rho0 = np . zeros (( 6 , 6 ), dtype = np . complex128 ) rho0 [ 0 ][ 0 ], rho0 [ 0 ][ 4 ], rho0 [ 4 ][ 0 ], rho0 [ 4 ][ 4 ] = 0.5 , 0.5 , 0.5 , 0.5 # free Hamiltonian sx = np . array ([[ 0. , 1. ],[ 1. , 0. ]]) sy = np . array ([[ 0. , - 1. j ],[ 1. j , 0. ]]) sz = np . array ([[ 1. , 0. ],[ 0. , - 1. ]]) ide2 = np . array ([[ 1. , 0. ],[ 0. , 1. ]]) s1 = np . array ([[ 0. , 1. , 0. ],[ 1. , 0. , 1. ],[ 0. , 1. , 0. ]]) / np . sqrt ( 2 ) s2 = np . array ([[ 0. , - 1. j , 0. ],[ 1. j , 0. , - 1. j ],[ 0. , 1. j , 0. ]]) / np . sqrt ( 2 ) s3 = np . array ([[ 1. , 0. , 0. ],[ 0. , 0. , 0. ],[ 0. , 0. , - 1. ]]) ide3 = np . array ([[ 1. , 0. , 0. ],[ 0. , 1. , 0. ],[ 0. , 0. , 1. ]]) I1 , I2 , I3 = np . kron ( ide3 , sx ), np . kron ( ide3 , sy ), np . kron ( ide3 , sz ) S1 , S2 , S3 = np . kron ( s1 , ide2 ), np . kron ( s2 , ide2 ), np . kron ( s3 , ide2 ) B1 , B2 , B3 = 5.0e-4 , 5.0e-4 , 5.0e-4 # All numbers are divided by 100 in this example # for better calculation accurancy cons = 100 D = ( 2 * np . pi * 2.87 * 1000 ) / cons gS = ( 2 * np . pi * 28.03 * 1000 ) / cons gI = ( 2 * np . pi * 4.32 ) / cons A1 = ( 2 * np . pi * 3.65 ) / cons A2 = ( 2 * np . pi * 3.03 ) / cons H0 = D * np . kron ( np . dot ( s3 , s3 ), ide2 ) + gS * ( B1 * S1 + B2 * S2 + B3 * S3 ) \\ + gI * ( B1 * I1 + B2 * I2 + B3 * I3 ) + A1 * ( np . kron ( s1 , sx ) + np . kron ( s2 , sy )) \\ + A2 * np . kron ( s3 , sz ) # derivatives of the free Hamiltonian on B1, B2 and B3 dH = [ gS * S1 + gI * I1 , gS * S2 + gI * I2 , gS * S3 + gI * I3 ] # control Hamiltonians Hc = [ S1 , S2 , S3 ] # dissipation decay = [[ S3 , 2 * np . pi / cons ]] # measurement dim = len ( rho0 ) M = [ np . dot ( basis ( dim , i ), basis ( dim , i ) . conj () . T ) for i in range ( dim )] # time length for the evolution tspan = np . linspace ( 0. , 2. , 4000 ) # guessed control coefficients cnum = 10 ctrl0 = - 0.2 * np . ones (( len ( Hc ), cnum )) SM DE # comprehensive optimization algorithm: DE DE_paras = { \"p_num\" : 10 , \"psi0\" :[], \"ctrl0\" :[], \"measurement0\" :[], \\ \"max_episode\" : 100 , \"c\" : 1.0 , \"cr\" : 0.5 , \"seed\" : 1234 } com = ComprehensiveOpt ( savefile = False , method = \"DE\" , ** DE_paras ) com . dynamics ( tspan , H0 , dH , decay = decay ) com . SM () PSO # comprehensive optimization algorithm: PSO PSO_paras = { \"p_num\" : 10 , \"psi0\" :[], \"ctrl0\" :[], \\ \"measurement0\" :[], \"max_episode\" :[ 1000 , 100 ], \"c0\" : 1.0 , \\ \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } com = ComprehensiveOpt ( savefile = False , method = \"PSO\" , ** PSO_paras ) com . dynamics ( tspan , H0 , dH , decay = decay ) com . SM () SC DE # comprehensive optimization algorithm: DE DE_paras = { \"p_num\" : 10 , \"psi0\" :[], \"ctrl0\" :[], \"measurement0\" :[], \\ \"max_episode\" : 100 , \"c\" : 1.0 , \"cr\" : 0.5 , \"seed\" : 1234 } com = ComprehensiveOpt ( savefile = False , method = \"DE\" , ** DE_paras ) com . dynamics ( tspan , H0 , dH , Hc = Hc , decay = decay , ctrl = [ ctrl0 ], \\ ctrl_bound = [ - 0.2 , 0.2 ]) QFIM # objective function: tr(WF^{-1}) com . SC ( W = [], target = \"QFIM\" , LDtype = \"SLD\" ) CFIM # objective function: tr(WI^{-1}) com . SC ( W = [], M = M , target = \"CFIM\" ) HCRB # objective function: HCRB com . SC ( W = [], target = \"HCRB\" ) PSO # comprehensive optimization algorithm: PSO PSO_paras = { \"p_num\" : 10 , \"psi0\" :[], \"ctrl0\" :[], \\ \"measurement0\" :[], \"max_episode\" :[ 1000 , 100 ], \"c0\" : 1.0 , \\ \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } com = ComprehensiveOpt ( savefile = False , method = \"PSO\" , ** PSO_paras ) com . dynamics ( tspan , H0 , dH , Hc = Hc , decay = decay , ctrl = [ ctrl0 ], \\ ctrl_bound = [ - 0.2 , 0.2 ]) QFIM # objective function: tr(WF^{-1}) com . SC ( W = [], target = \"QFIM\" , LDtype = \"SLD\" ) CFIM # objective function: tr(WI^{-1}) com . SC ( W = [], M = M , target = \"CFIM\" ) HCRB # objective function: HCRB com . SC ( W = [], target = \"HCRB\" ) AD # comprehensive optimization algorithm: AD AD_paras = { \"Adam\" : False , \"psi0\" :[], \"ctrl0\" :[], \"measurement0\" :[], \\ \"max_episode\" : 300 , \"epsilon\" : 0.01 , \"beta1\" : 0.90 , \"beta2\" : 0.99 } com = ComprehensiveOpt ( savefile = False , method = \"AD\" , ** AD_paras ) com . dynamics ( tspan , H0 , dH , Hc = Hc , decay = decay , ctrl = [ ctrl0 ], \\ ctrl_bound = [ - 0.2 , 0.2 ]) QFIM # objective function: tr(WF^{-1}) com . SC ( W = [], target = \"QFIM\" , LDtype = \"SLD\" ) CFIM # objective function: tr(WI^{-1}) com . SC ( W = [], M = M , target = \"CFIM\" ) CM DE # comprehensive optimization algorithm: DE DE_paras = { \"p_num\" : 10 , \"psi0\" :[], \"ctrl0\" :[], \"measurement0\" :[], \\ \"max_episode\" : 100 , \"c\" : 1.0 , \"cr\" : 0.5 , \"seed\" : 1234 } com = ComprehensiveOpt ( savefile = False , method = \"DE\" , ** DE_paras ) com . dynamics ( tspan , H0 , dH , Hc = Hc , decay = decay , ctrl_bound = [ - 0.2 , 0.2 ]) com . CM ( rho0 ) PSO # comprehensive optimization algorithm: PSO PSO_paras = { \"p_num\" : 10 , \"psi0\" :[], \"ctrl0\" :[], \\ \"measurement0\" :[], \"max_episode\" :[ 1000 , 100 ], \"c0\" : 1.0 , \\ \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } com = ComprehensiveOpt ( savefile = False , method = \"PSO\" , ** PSO_paras ) com . dynamics ( tspan , H0 , dH , Hc = Hc , decay = decay , ctrl_bound = [ - 0.2 , 0.2 ]) com . CM ( rho0 ) SCM DE # comprehensive optimization algorithm: DE DE_paras = { \"p_num\" : 10 , \"psi0\" :[], \"ctrl0\" :[], \"measurement0\" :[], \\ \"max_episode\" : 100 , \"c\" : 1.0 , \"cr\" : 0.5 , \"seed\" : 1234 } com = ComprehensiveOpt ( savefile = False , method = \"DE\" , ** DE_paras ) com . dynamics ( tspan , H0 , dH , Hc = Hc , decay = decay , ctrl_bound = [ - 0.2 , 0.2 ]) com . SCM () PSO # comprehensive optimization algorithm: PSO PSO_paras = { \"p_num\" : 10 , \"psi0\" :[], \"ctrl0\" :[], \\ \"measurement0\" :[], \"max_episode\" :[ 1000 , 100 ], \"c0\" : 1.0 , \\ \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } com = ComprehensiveOpt ( savefile = False , method = \"PSO\" , ** PSO_paras ) com . dynamics ( tspan , H0 , dH , Hc = Hc , decay = decay , ctrl_bound = [ - 0.2 , 0.2 ]) com . SCM () Julia using QuanEstimation using LinearAlgebra # initial state rho0 = zeros ( ComplexF64 , 6 , 6 ) rho0 [ 1 : 4 : 5 , 1 : 4 : 5 ] .= 0.5 # free Hamiltonian sx = [ 0. 1. ; 1. 0. ] sy = [ 0. - im ; im 0. ] sz = [ 1. 0. ; 0. - 1. ] s1 = [ 0. 1. 0. ; 1. 0. 1. ; 0. 1. 0. ] / sqrt ( 2 ) s2 = [ 0. - im 0. ; im 0. - im ; 0. im 0. ] / sqrt ( 2 ) s3 = [ 1. 0. 0. ; 0. 0. 0. ; 0. 0. - 1. ] Is = I1 , I2 , I3 = [ kron ( I ( 3 ), sx ), kron ( I ( 3 ), sy ), kron ( I ( 3 ), sz )] S = S1 , S2 , S3 = [ kron ( s1 , I ( 2 )), kron ( s2 , I ( 2 )), kron ( s3 , I ( 2 ))] B = B1 , B2 , B3 = [ 5.0e-4 , 5.0e-4 , 5.0e-4 ] # All numbers are divided by 100 in this example # for better calculation accurancy cons = 100 D = ( 2 pi * 2.87 * 1000 ) / cons gS = ( 2 pi * 28.03 * 1000 ) / cons gI = ( 2 pi * 4.32 ) / cons A1 = ( 2 pi * 3.65 ) / cons A2 = ( 2 pi * 3.03 ) / cons H0 = sum ([ D * kron ( s3 ^ 2 , I ( 2 )), sum ( gS * B .* S ), sum ( gI * B .* Is ), A1 * ( kron ( s1 , sx ) + kron ( s2 , sy )), A2 * kron ( s3 , sz )]) # derivatives of the free Hamiltonian on B1, B2 and B3 dH = gS * S + gI * Is # control Hamiltonians Hc = [ S1 , S2 , S3 ] # dissipation decay = [[ S3 , 2 pi / cons ]] # measurement dim = size ( rho0 , 1 ) M = [ QuanEstimation . basis ( dim , i ) * QuanEstimation . basis ( dim , i ) ' for i in 1 : dim ] # time length for the evolution tspan = range ( 0. , 2. , length = 4000 ) # guessed control coefficients cnum = 10 ctrl = - 0.2 * ones (( length ( Hc ), cnum )) # guessed measurements C = [ QuanEstimation . basis ( dim , i ) for i in 1 : dim ] SM opt = QuanEstimation . SMopt ( seed = 1234 ) DE # comprehensive optimization algorithm: DE alg = QuanEstimation . DE ( p_num = 10 , max_episode = 1000 , c = 1.0 , cr = 0.5 ) # input the dynamics data dynamics = QuanEstimation . Lindblad ( opt , tspan , H0 , dH , decay = decay ) # objective function: CFI obj = QuanEstimation . CFIM_obj ( M = M ) PSO # comprehensive optimization algorithm: PSO alg = QuanEstimation . PSO ( p_num = 10 , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) # input the dynamics data dynamics = QuanEstimation . Lindblad ( opt , tspan , H0 , dH , decay = decay ) # objective function: CFI obj = QuanEstimation . CFIM_obj ( M = M ) SC opt = QuanEstimation . SMopt ( ctrl = ctrl , ctrl_bound = [ - 0.2 , 0.2 ], seed = 1234 ) DE # comprehensive optimization algorithm: DE alg = QuanEstimation . DE ( p_num = 10 , max_episode = 1000 , c = 1.0 , cr = 0.5 ) # input the dynamics data dynamics = QuanEstimation . Lindblad ( opt , tspan , H0 , dH , Hc , decay = decay ) QFIM # objective function: tr(WF^{-1}) obj = QuanEstimation . QFIM_obj () CFIM # objective function: tr(WI^{-1}) obj = QuanEstimation . CFIM_obj ( M = M ) HCRB # objective function: HCRB obj = QuanEstimation . HCRB_obj () PSO # comprehensive optimization algorithm: PSO alg = QuanEstimation . PSO ( p_num = 10 , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) # input the dynamics data dynamics = QuanEstimation . Lindblad ( opt , tspan , H0 , dH , Hc , decay = decay ) QFIM # objective function: tr(WF^{-1}) obj = QuanEstimation . QFIM_obj () CFIM # objective function: tr(WI^{-1}) obj = QuanEstimation . CFIM_obj ( M = M ) HCRB # objective function: HCRB obj = QuanEstimation . HCRB_obj () AD # comprehensive optimization algorithm: AD alg = QuanEstimation . AD ( Adam = true , max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 ) # input the dynamics data dynamics = QuanEstimation . Lindblad ( opt , tspan , H0 , dH , Hc , decay = decay ) QFIM # objective function: tr(WF^{-1}) obj = QuanEstimation . QFIM_obj () CFIM # objective function: tr(WI^{-1}) obj = QuanEstimation . CFIM_obj ( M = M ) CM opt = QuanEstimation . CMopt ( seed = 1234 ) DE # comprehensive optimization algorithm: DE alg = QuanEstimation . DE ( p_num = 10 , max_episode = 1000 , c = 1.0 , cr = 0.5 ) # input the dynamics data dynamics = QuanEstimation . Lindblad ( opt , tspan , rho0 , H0 , dH , Hc , decay = decay ) # objective function: CFI obj = QuanEstimation . CFIM_obj () PSO # comprehensive optimization algorithm: PSO alg = QuanEstimation . PSO ( p_num = 10 , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) # input the dynamics data dynamics = QuanEstimation . Lindblad ( opt , tspan , rho0 , H0 , dH , Hc , decay = decay ) # objective function: CFI obj = QuanEstimation . CFIM_obj () SCM opt = QuanEstimation . SCMopt ( seed = 1234 ) DE # comprehensive optimization algorithm: DE alg = QuanEstimation . DE ( p_num = 10 , max_episode = 1000 , c = 1.0 , cr = 0.5 ) # input the dynamics data dynamics = QuanEstimation . Lindblad ( opt , tspan , H0 , dH , Hc , decay = decay ) # objective function: CFI obj = QuanEstimation . CFIM_obj () PSO # comprehensive optimization algorithm: PSO alg = QuanEstimation . PSO ( p_num = 10 , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) # input the dynamics data dynamics = QuanEstimation . Lindblad ( opt , tspan , H0 , dH , Hc , decay = decay ) # objective function: CFI obj = QuanEstimation . CFIM_obj () # run the comprehensive optimization problem QuanEstimation . run ( opt , alg , obj , dynamics ; savefile = false ) For optimization of probe state and measurement, the parameterization can also be implemented with the Kraus operators which can be realized by Python com = ComprehensiveOpt ( savefile = False , method = \"DE\" , ** kwargs ) com . Kraus ( K , dK ) com . SM ( W = []) Julia opt = SMopt ( psi = psi , M = M , seed = 1234 ) alg = DE ( kwargs ... ) dynamics = Kraus ( opt , K , dK ) obj = CFIM_obj ( W = missing ) run ( opt , alg , obj , dynamics ; savefile = false ) where K and dK are the Kraus operators and its derivatives with respect to the unknown parameters. Example 8.3 The Kraus operators for the amplitude damping channel are \\[\\begin{eqnarray} K_1 = \\left(\\begin{array}{cc} 1 & 0 \\\\ 0 & \\sqrt{1-\\gamma} \\end{array}\\right), K_2 = \\left(\\begin{array}{cc} 0 & \\sqrt{\\gamma} \\\\ 0 & 0 \\end{array}\\right), \\nonumber \\end{eqnarray}\\] where \\(\\gamma\\) is the unknown parameter to be estimated which represents the decay probability. In this example, the probe state is taken as \\(|+\\rangle\\langle+|\\) with \\(|+\\rangle=\\frac{1}{\\sqrt{2}}(|0\\rangle+|1\\rangle)\\) . Here \\(|0\\rangle\\) \\((|1\\rangle)\\) is the eigenstate of \\(\\sigma_3\\) (Pauli matrix) with respect to the eigenvalue \\(1\\) \\((-1)\\) . Python from quanestimation import * import numpy as np # initial state rho0 = 0.5 * np . array ([[ 1. , 1. ], [ 1. , 1. ]]) # Kraus operators for the amplitude damping channel gamma = 0.1 K1 = np . array ([[ 1. , 0. ], [ 0. , np . sqrt ( 1 - gamma )]]) K2 = np . array ([[ 0. , np . sqrt ( gamma )], [ 0. , 0. ]]) K = [ K1 , K2 ] # derivatives of Kraus operators on gamma dK1 = np . array ([[ 1. , 0. ], [ 0. , - 0.5 / np . sqrt ( 1 - gamma )]]) dK2 = np . array ([[ 0. , 0.5 / np . sqrt ( gamma )], [ 0. , 0. ]]) dK = [[ dK1 ], [ dK2 ]] DE # comprehensive optimization algorithm: DE DE_paras = { \"p_num\" : 10 , \"psi0\" :[], \"ctrl0\" :[], \"measurement0\" :[], \\ \"max_episode\" : 100 , \"c\" : 1.0 , \"cr\" : 0.5 , \"seed\" : 1234 } com = ComprehensiveOpt ( savefile = False , method = \"DE\" , ** DE_paras ) com . Kraus ( K , dK ) com . SM () PSO # comprehensive optimization algorithm: PSO PSO_paras = { \"p_num\" : 10 , \"psi0\" :[], \"ctrl0\" :[], \\ \"measurement0\" :[], \"max_episode\" :[ 1000 , 100 ], \"c0\" : 1.0 , \\ \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } com = ComprehensiveOpt ( savefile = False , method = \"PSO\" , ** PSO_paras ) com . Kraus ( K , dK ) com . SM () com = ComprehensiveOpt ( savefile = False , method = \"DE\" , ** kwargs ) com . SM () Julia using QuanEstimation # initial state rho0 = 0.5 * ones ( 2 , 2 ) # Kraus operators for the amplitude damping channel gamma = 0.1 K1 = [ 1. 0. ; 0. sqrt ( 1 - gamma )] K2 = [ 0. sqrt ( gamma ); 0. 0. ] K = [ K1 , K2 ] # derivatives of Kraus operators on gamma dK1 = [ 1. 0. ; 0. - 0.5 / sqrt ( 1 - gamma )] dK2 = [ 0. 0.5 / sqrt ( gamma ); 0. 0. ] dK = [[ dK1 ], [ dK2 ]] # comprehensive optimization opt = QuanEstimation . SMopt ( seed = 1234 ) DE # comprehensive optimization algorithm: DE alg = QuanEstimation . DE ( p_num = 10 , max_episode = 1000 , c = 1.0 , cr = 0.5 ) # input the dynamics data dynamics = QuanEstimation . Kraus ( opt , K , dK ) # objective function: CFI obj = QuanEstimation . CFIM_obj () PSO # comprehensive optimization algorithm: PSO alg = QuanEstimation . PSO ( p_num = 10 , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) # input the dynamics data dynamics = QuanEstimation . Kraus ( opt , K , dK ) # objective function: CFI obj = QuanEstimation . CFIM_obj () # run the comprehensive optimization problem QuanEstimation . run ( opt , alg , obj , dynamics ; savefile = false ) Bibliography \u00b6 [1] J. Kennedy and R. Eberhar, Particle swarm optimization, Proc. 1995 IEEE International Conference on Neural Networks 4 , 1942-1948 (1995). [2] R. Storn and K. Price, Differential Evolution-A Simple and Efficient Heuristic for global Optimization over Continuous Spaces, J. Global Optim. 11 , 341 (1997). [3] A. G. Baydin, B. A. Pearlmutter, A. A. Radul, and J. M. Siskind, Automatic differentiation in machine learning: a survey, J. Mach. Learn. Res. 18 , 1-43 (2018).","title":"Comprehensive optimization"},{"location":"guide/guide_Compopt/#comprehensive-optimization","text":"In order to obtain the optimal parameter estimation schemes, it is necessary to simultaneously optimize the probe state, control and measurement. The comprehensive optimization for the probe state and measurement (SM), the probe state and control (SC), the control and measurement (CM) and the probe state, control and measurement (SCM) are proposed in QuanEstiamtion. In the package, the comprehensive optimization algorithms are particle swarm optimization (PSO) [1] , differential evolution (DE) [2] , and automatic differentiation (AD) [3] . Python com = ComprehensiveOpt ( savefile = False , method = \"DE\" , ** kwargs ) com . dynamics ( tspan , H0 , dH , Hc = [], ctrl = [], decay = [], ctrl_bound = []) SM com . SM ( W = []) SC com . SC ( W = [], M = [], target = \"QFIM\" , LDtype = \"SLD\" ) CM com . CM ( rho0 , W = []) SCM com . SCM ( W = []) Here savefile means whether to save all the optimized variables (probe states, control coefficients and measurements). If set True then the optimized variables and the values of the objective function obtained in all episodes will be saved during the training, otherwise, the optimized variables in the final episode and the values of the objective function in all episodes will be saved. method represents the optimization algorithm used, options are: \"PSO\", \"DE\", and \"AD\". **kwargs is the keyword and the default value corresponding to the optimization algorithm which will be introduced in detail below. If the dynamics of the system can be described by the master equation, then the dynamics data tspan , H0 , and dH shoule be input. tspan is the time length for the evolution, H0 and dH are the free Hamiltonian and its derivatives on the unknown parameters to be estimated. H0 is a matrix when the free Hamiltonian is time-independent and a list with the length equal to tspan when it is time-dependent. dH should be input as \\([\\partial_a{H_0}, \\partial_b{H_0}, \\cdots]\\) . Hc and ctrl are two lists represent the control Hamiltonians and the corresponding control coefficients. decay contains decay operators \\((\\Gamma_1, \\Gamma_2, \\cdots)\\) and the corresponding decay rates \\((\\gamma_1, \\gamma_2, \\cdots)\\) with the input rule decay=[[ \\(\\Gamma_1\\) , \\(\\gamma_1\\) ], [ \\(\\Gamma_2\\) , \\(\\gamma_2\\) ],...]. The default values for decay , Hc and ctrl are empty which means the dynamics is unitary and only governed by the free Hamiltonian. ctrl_bound is an array with two elements representing the lower and upper bound of the control coefficients, respectively. The default value of ctrl_bound=[] which means the control coefficients are in the regime \\([-\\infty,\\infty]\\) . QuanEstimation contains four comprehensive optimizations which are com.SM() , com.SC() , com.CM() and com.SCM() . The target in com.SC() can be set as target=\"QFIM\" (default), target=\"CFIM and target=\"HCRB for the corresponding objective functions are QFI ( \\(\\mathrm{Tr}(W\\mathcal{F}^{-1})\\) ), CFI ( \\(\\mathrm{Tr}(W\\mathcal{I}^{-1})\\) ) and HCRB, respectively. Here \\(\\mathcal{F}\\) and \\(\\mathcal{I}\\) are the QFIM and CFIM, \\(W\\) corresponds to W is the weight matrix which defaults to the identity matrix. If the users set target=\"HCRB for single parameter scenario, the program will exit and print \"Program terminated. In the single-parameter scenario, the HCRB is equivalent to the QFI. Please choose 'QFIM' as the objective function\" . LDtype represents the types of the QFIM, it can be set as LDtype=\"SLD\" (default), LDtype=\"RLD\" and LDtype=\"LLD\" . For the other three scenarios, the objective function is CFI ( \\(\\mathrm{Tr}(W\\mathcal{I}^{-1})\\) ). Julia SM opt = SMopt ( psi = psi , M = M , seed = 1234 ) alg = DE ( kwargs ... ) dynamics = Lindblad ( opt , tspan , H0 , dH ; Hc = missing , ctrl = missing , decay = missing ) obj = CFIM_obj ( W = missing ) run ( opt , alg , obj , dynamics ; savefile = false ) SC opt = SCopt ( psi = psi , ctrl = ctrl , ctrl_bound = ctrl_bound , seed = 1234 ) alg = DE ( kwargs ... ) dynamics = Lindblad ( opt , tspan , H0 , dH , Hc ; decay = missing ) QFIM obj = QFIM_obj ( W = missing , LDtype = :SLD ) CFIM obj = CFIM_obj ( W = missing ) HCRB obj = HCRB_obj ( W = missing ) run ( opt , alg , obj , dynamics ; savefile = false ) CM opt = CMopt ( ctrl = ctrl , M = M , ctrl_bound = ctrl_bound , seed = 1234 ) alg = DE ( kwargs ... ) dynamics = Lindblad ( opt , tspan , H0 , dH , Hc ; decay = missing ) obj = CFIM_obj ( W = missing ) run ( opt , alg , obj , dynamics ; savefile = false ) SCM opt = SCMopt ( psi = psi , ctrl = ctrl , M = M , ctrl_bound = ctrl_bound , seed = 1234 ) alg = DE ( kwargs ... ) dynamics = Lindblad ( opt , tspan , H0 , dH , Hc ; decay = missing ) obj = CFIM_obj ( W = missing ) run ( opt , alg , obj , dynamics ; savefile = false ) QuanEstimation contains four comprehensive optimizations which are SMopt() , SCopt() , CMopt() and SCMopt() . The optimization variables including initial state, control and measurement can be input via ctrl=ctrl , psi=psi and M=M for constructing a comprehensive optimization problem. Here, ctrl is a list of arrays with the length equal to control Hamiltonians, psi is an array representing the state and M is a list of arrays with the length equal to the dimension of the system which representing the projective measurement basis. Besides, the boundary value of each control coefficients can be input via ctrl_bound=ctrl_bound when the optimized variable contains control. ctrl_bound is an array with two elements representing the lower and upper bound of the control coefficients, respectively. The default value of ctrl_bound= missing which means the control coefficients are in the regime \\([-\\infty,\\infty]\\) . seed is the random seed which can ensure the reproducibility of results. The objective function of SCopt() can be chosen as QFIM_obj() (default), CFIM_obj() and HCRB_obj() for the corresponding objective functions are QFI ( \\(\\mathrm{Tr}(W\\mathcal{F}^ {-1})\\) ), CFI ( \\(\\mathrm{Tr}(W\\mathcal{I}^{-1})\\) ) and HCRB, respectively. Here \\(\\mathcal{F}\\) and \\(\\mathcal{I}\\) are the QFIM and CFIM, \\(W\\) corresponds to W is the weight matrix which defaults to the identity matrix. If the users set HCRB_obj() for single parameter scenario, the program will exit and print \"Program terminated. In the single-parameter scenario, the HCRB is equivalent to the QFI. Please choose 'QFIM_obj()' as the objective function\" . LDtype represents the types of the QFIM, it can be set as LDtype=:SLD (default), LDtype=:RLD and LDtype=:LLD . For the other three scenarios, the objective function is CFIM_obj() . If the dynamics of the system can be described by the master equation, then the dynamics data tspan , H0 , and dH shoule be input. tspan is the time length for the evolution, H0 and dH are the free Hamiltonian and its derivatives on the unknown parameters to be estimated. H0 is a matrix when the free Hamiltonian is time-independent and a list with the length equal to tspan when it is time-dependent. dH should be input as \\([\\partial_a{H_0}, \\partial_b{H_0}, \\cdots]\\) . Hc and ctrl are two lists represent the control Hamiltonians and the corresponding control coefficients. decay contains decay operators \\((\\Gamma_1, \\Gamma_2, \\cdots)\\) and the corresponding decay rates \\((\\gamma_1, \\gamma_2, \\cdots)\\) with the input rule decay=[[ \\(\\Gamma_1\\) , \\(\\gamma_1\\) ], [ \\(\\Gamma_2\\) , \\(\\gamma_2\\) ],...]. The variable savefile means whether to save all the optimized variables (probe states, control coefficients and measurements). If set true then the optimized variables and the values of the objective function obtained in all episodes will be saved during the training, otherwise, the optimized variables in the final episode and the values of the objective function in all episodes will be saved. The algorithm used in QuanEstimation for comprehensive optimizaiton are PSO, DE and AD. kwargs... is the keywords and the default values corresponding to the optimization algorithm which will be introduced in detail below.","title":"Comprehensive optimization"},{"location":"guide/guide_Compopt/#pso","text":"The code for comprehensive optimization with PSO is as follows Python com = ComprehensiveOpt ( method = \"PSO\" , ** kwargs ) where kwargs is of the form kwargs = { \"p_num\" : 10 , \"psi0\" :[], \"ctrl0\" :[], \"measurement0\" :[], \"max_episode\" :[ 1000 , 100 ], \"c0\" : 1.0 , \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } The keywords and the default values of PSO can be seen in the following table \\(~~~~~~~~~~\\) **kwargs \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"p_num\" 10 \"psi0\" [ ] \"ctrl0\" [ ] \"measurement0\" [ ] \"max_episode\" [1000,100] \"c0\" 1.0 \"c1\" 2.0 \"c2\" 2.0 \"seed\" 1234 psi0 , ctrl0 and measurement0 in the algorithms represent the initial guesses of states, control coefficients and measurements, respectively, seed is the random seed. Here p_num is the number of particles, c0 , c1 , and c2 are the PSO parameters representing the inertia weight, cognitive learning factor and social learning factor, respectively. max_episode accepts both integers and arrays with two elements. If it is an integer, for example max_episode=1000, it means the program will continuously run 1000 episodes. However, if it is an array, for example max_episode=[1000,100], the program will run 1000 episodes in total but replace control coefficients of all the particles with global best every 100 episodes. Julia alg = PSO ( p_num = 10 , ini_particle = missing , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) The keywords and the default values of PSO can be seen in the following table \\(~~~~~~~~~~\\) keywords \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"p_num\" 10 \"ini_particle\" missing \"max_episode\" [1000,100] \"c0\" 1.0 \"c1\" 2.0 \"c2\" 2.0 ini_particle is a tuple contains psi0 , ctrl0 and measurement0 , which representing the initial guesses of states, control coefficients and measurements, respectively. The input rule of ini_particle shoule be ini_particle=(psi0, measurement0) (SM), ini_particle=(psi0, ctrl0) (SC), ini_particle=(ctrl0, measurement0) (CM) and ini_particle=(psi0, ctrl0, measurement0) (SCM). Here p_num is the number of particles, c0 , c1 , and c2 are the PSO parameters representing the inertia weight, cognitive learning factor and social learning factor, respectively. max_episode accepts both integers and arrays with two elements. If it is an integer, for example max_episode=1000, it means the program will continuously run 1000 episodes. However, if it is an array, for example max_episode=[1000,100], the program will run 1000 episodes in total but replace control coefficients of all the particles with global best every 100 episodes.","title":"PSO"},{"location":"guide/guide_Compopt/#de","text":"The code for comprehensive optimization with DE is as follows Python com = ComprehensiveOpt ( method = \"DE\" , ** kwargs ) where kwargs is of the form kwargs = { \"p_num\" : 10 , \"psi0\" :[], \"ctrl0\" :[], \"measurement0\" :[], \"max_episode\" : 1000 , \"c\" : 1.0 , \"cr\" : 0.5 , \"seed\" : 1234 } The keywords and the default values of DE can be seen in the following table \\(~~~~~~~~~~\\) **kwargs \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"p_num\" 10 \"psi0\" [ ] \"ctrl0\" [ ] \"measurement0\" [ ] \"max_episode\" 1000 \"c\" 1.0 \"cr\" 0.5 \"seed\" 1234 p_num is the number of populations. Here max_episode is an integer representing the number of episodes. c and cr are constants for mutation and crossover. Julia alg = DE ( p_num = 10 , ini_population = missing , max_episode = 1000 , c = 1.0 , cr = 0.5 ) The keywords and the default values of DE can be seen in the following table \\(~~~~~~~~~~\\) keywords \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"p_num\" 10 \"ini_population\" missing \"max_episode\" 1000 \"c\" 1.0 \"cr\" 0.5 Here max_episode is an integer representing the number of episodes. p_num represents the number of populations. c and cr are constants for mutation and crossover. ini_particle is a tuple contains psi0 , ctrl0 and measurement0 , which representing the initial guesses of states, control coefficients and measurements, respectively. The input rule of ini_particle shoule be ini_particle=(psi0, measurement0) (SM), ini_particle=(psi0, ctrl0) (SC), ini_particle=(ctrl0, measurement0) (CM) and ini_particle=(psi0, ctrl0, measurement0) (SCM).","title":"DE"},{"location":"guide/guide_Compopt/#ad","text":"The code for comprehensive optimization with AD is as follows Python com = ComprehensiveOpt ( method = \"AD\" , ** kwargs ) where kwargs is of the form kwargs = { \"Adam\" : True , \"psi0\" :[], \"ctrl0\" :[], \"measurement0\" :[], \"max_episode\" : 300 , \"epsilon\" : 0.01 , \"beta1\" : 0.90 , \"beta2\" : 0.99 } The keywords and the default values of AD can be seen in the following table \\(~~~~~~~~~~\\) **kwargs \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"Adam\" False \"psi0\" [ ] \"ctrl0\" [ ] \"measurement0\" [ ] \"max_episode\" 300 \"epsilon\" 0.01 \"beta1\" 0.90 \"beta2\" 0.99 The optimized variables will update according to the learning rate \"epsilon\" when Adam=False . However, If Adam=True , Adam algorithm will be used and the Adam parameters include learning rate, the exponential decay rate for the first moment estimates and the second moment estimates can be set by the user via epsilon , beta1 and beta2 . Julia alg = AD ( Adam = false , max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 ) The keywords and the default values of AD can be seen in the following table \\(~~~~~~~~~~\\) keywords \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"Adam\" false \"max_episode\" 300 \"epsilon\" 0.01 \"beta1\" 0.90 \"beta2\" 0.99 The optimized variables will update according to the learning rate \"epsilon\" when Adam=false . However, If Adam=true , Adam algorithm will be used and the Adam parameters include learning rate, the exponential decay rate for the first moment estimates and the second moment estimates can be set by the user via epsilon , beta1 and beta2 . Example 8.1 A single qubit system whose free evolution Hamiltonian is \\(H_0 = \\frac{1}{2}\\omega \\sigma_3\\) with \\(\\omega\\) the frequency and \\(\\sigma_3\\) a Pauli matrix. The dynamics of the system is governed by \\begin{align} \\partial_t\\rho=-i[H_0, \\rho]+ \\gamma_{+}\\left(\\sigma_{+}\\rho\\sigma_{-}-\\frac{1}{2}{\\sigma_{-}\\sigma_{+},\\rho}\\right)+ \\gamma_{-}\\left(\\sigma_{-}\\rho\\sigma_{+}-\\frac{1}{2}{\\sigma_{+}\\sigma_{-},\\rho}\\right), \\end{align} where \\(\\gamma_{+}\\) , \\(\\gamma_{-}\\) are decay rates and \\(\\sigma_{\\pm}=(\\sigma_1 \\pm \\sigma_2)/2\\) . The control Hamiltonian \\begin{align} H_\\mathrm{c}=u_1(t)\\sigma_1+u_2(t)\\sigma_2+u_3(t)\\sigma_3 \\end{align} with \\(u_i(t)\\) \\((i=1,2,3)\\) the control field. Here \\(\\sigma_{1}\\) , \\(\\sigma_{2}\\) are also Pauli matrices. In this case, we consider two types of comprehensive optimization, the first one is optimization of probe state and control (SC), and the other is optimization of probe state, control and measurement (SCM). QFI is taken as the target function for SC and CFI for SCM. Python from quanestimation import * import numpy as np # initial state rho0 = 0.5 * np . array ([[ 1. , 1. ], [ 1. , 1. ]]) # free Hamiltonian omega = 1.0 sx = np . array ([[ 0. , 1. ], [ 1. , 0. ]]) sy = np . array ([[ 0. , - 1. j ], [ 1. j , 0. ]]) sz = np . array ([[ 1. , 0. ], [ 0. , - 1. ]]) H0 = 0.5 * omega * sz # derivative of the free Hamiltonian on omega dH = [ 0.5 * sz ] # control Hamiltonians Hc = [ sx , sy , sz ] # dissipation sp = np . array ([[ 0. , 1. ], [ 0. , 0. ]]) sm = np . array ([[ 0. , 0. ], [ 1. , 0. ]]) decay = [[ sp , 0. ], [ sm , 0.1 ]] # measurement M1 = 0.5 * np . array ([[ 1. , 1. ], [ 1. , 1. ]]) M2 = 0.5 * np . array ([[ 1. , - 1. ], [ - 1. , 1. ]]) M = [ M1 , M2 ] # time length for the evolution tspan = np . linspace ( 0. , 10. , 2500 ) SM DE # comprehensive optimization algorithm: DE DE_paras = { \"p_num\" : 10 , \"psi0\" :[], \"ctrl0\" :[], \"measurement0\" :[], \\ \"max_episode\" : 1000 , \"c\" : 1.0 , \"cr\" : 0.5 , \"seed\" : 1234 } com = ComprehensiveOpt ( savefile = False , method = \"DE\" , ** DE_paras ) com . dynamics ( tspan , H0 , dH , decay = decay ) com . SM () PSO # comprehensive optimization algorithm: PSO PSO_paras = { \"p_num\" : 10 , \"psi0\" :[], \"ctrl0\" :[], \\ \"measurement0\" :[], \"max_episode\" :[ 1000 , 100 ], \"c0\" : 1.0 , \\ \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } com = ComprehensiveOpt ( savefile = False , method = \"PSO\" , ** PSO_paras ) com . dynamics ( tspan , H0 , dH , decay = decay ) com . SM () SC DE # comprehensive optimization algorithm: DE DE_paras = { \"p_num\" : 10 , \"psi0\" :[], \"ctrl0\" :[], \"measurement0\" :[], \\ \"max_episode\" : 1000 , \"c\" : 1.0 , \"cr\" : 0.5 , \"seed\" : 1234 } com = ComprehensiveOpt ( savefile = False , method = \"DE\" , ** DE_paras ) com . dynamics ( tspan , H0 , dH , Hc = Hc , decay = decay , ctrl_bound = [ - 2.0 , 2.0 ]) QFIM com . SC ( W = [], target = \"QFIM\" , LDtype = \"SLD\" ) CFIM com . SC ( W = [], M = M , target = \"CFIM\" ) PSO # comprehensive optimization algorithm: PSO PSO_paras = { \"p_num\" : 10 , \"psi0\" :[], \"ctrl0\" :[], \\ \"measurement0\" :[], \"max_episode\" :[ 1000 , 100 ], \"c0\" : 1.0 , \\ \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } com = ComprehensiveOpt ( savefile = False , method = \"PSO\" , ** PSO_paras ) com . dynamics ( tspan , H0 , dH , Hc = Hc , decay = decay , ctrl_bound = [ - 2.0 , 2.0 ]) QFIM com . SC ( W = [], target = \"QFIM\" , LDtype = \"SLD\" ) CFIM com . SC ( W = [], M = M , target = \"CFIM\" ) AD # comprehensive optimization algorithm: AD AD_paras = { \"Adam\" : False , \"psi0\" :[], \"ctrl0\" :[], \"measurement0\" :[], \\ \"max_episode\" : 300 , \"epsilon\" : 0.01 , \"beta1\" : 0.90 , \"beta2\" : 0.99 } com = ComprehensiveOpt ( savefile = False , method = \"AD\" , ** AD_paras ) com . dynamics ( tspan , H0 , dH , Hc = Hc , decay = decay ) com . SC ( W = [], target = \"QFIM\" , LDtype = \"SLD\" , ctrl_bound = [ - 2.0 , 2.0 ]) QFIM com . SC ( W = [], target = \"QFIM\" , LDtype = \"SLD\" ) CFIM com . SC ( W = [], M = M , target = \"CFIM\" ) CM DE # comprehensive optimization algorithm: DE DE_paras = { \"p_num\" : 10 , \"psi0\" :[], \"ctrl0\" :[], \"measurement0\" :[], \\ \"max_episode\" : 1000 , \"c\" : 1.0 , \"cr\" : 0.5 , \"seed\" : 1234 } com = ComprehensiveOpt ( savefile = False , method = \"DE\" , ** DE_paras ) com . dynamics ( tspan , H0 , dH , Hc = Hc , decay = decay , ctrl_bound = [ - 2.0 , 2.0 ]) com . CM ( rho0 ) PSO # comprehensive optimization algorithm: PSO PSO_paras = { \"p_num\" : 10 , \"psi0\" :[], \"ctrl0\" :[], \\ \"measurement0\" :[], \"max_episode\" :[ 1000 , 100 ], \"c0\" : 1.0 , \\ \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } com = ComprehensiveOpt ( savefile = False , method = \"PSO\" , ** PSO_paras ) com . dynamics ( tspan , H0 , dH , Hc = Hc , decay = decay , ctrl_bound = [ - 2.0 , 2.0 ]) com . CM ( rho0 ) SCM DE # comprehensive optimization algorithm: DE DE_paras = { \"p_num\" : 10 , \"psi0\" :[], \"ctrl0\" :[], \"measurement0\" :[], \\ \"max_episode\" : 1000 , \"c\" : 1.0 , \"cr\" : 0.5 , \"seed\" : 1234 } com = ComprehensiveOpt ( savefile = False , method = \"DE\" , ** DE_paras ) com . dynamics ( tspan , H0 , dH , Hc = Hc , decay = decay , ctrl_bound = [ - 2.0 , 2.0 ]) com . SCM () PSO # comprehensive optimization algorithm: PSO PSO_paras = { \"p_num\" : 10 , \"psi0\" :[], \"ctrl0\" :[], \\ \"measurement0\" :[], \"max_episode\" :[ 1000 , 100 ], \"c0\" : 1.0 , \\ \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } com = ComprehensiveOpt ( savefile = False , method = \"PSO\" , ** PSO_paras ) com . dynamics ( tspan , H0 , dH , Hc = Hc , decay = decay , ctrl_bound = [ - 2.0 , 2.0 ]) com . SCM () Julia using QuanEstimation # initial state rho0 = 0.5 * ones ( 2 , 2 ) # free Hamiltonian omega = 1.0 sx = [ 0. 1. ; 1. 0.0 im ] sy = [ 0. - im ; im 0. ] sz = [ 1. 0.0 im ; 0. - 1. ] H0 = 0.5 * omega * sz # derivative of the free Hamiltonian on omega dH = [ 0.5 * sz ] # control Hamiltonians Hc = [ sx , sy , sz ] # dissipation sp = [ 0. 1. ; 0. 0.0 im ] sm = [ 0. 0. ; 1. 0.0 im ] decay = [[ sp , 0.0 ], [ sm , 0.1 ]] # measurement M1 = 0.5 * [ 1.0 + 0.0 im 1. ; 1. 1. ] M2 = 0.5 * [ 1.0 + 0.0 im - 1. ; - 1. 1. ] M = [ M1 , M2 ] # time length for the evolution tspan = range ( 0. , 10. , length = 2500 ) SM opt = QuanEstimation . SMopt ( seed = 1234 ) DE # comprehensive optimization algorithm: DE alg = QuanEstimation . DE ( p_num = 10 , max_episode = 1000 , c = 1.0 , cr = 0.5 ) # input the dynamics data dynamics = QuanEstimation . Lindblad ( opt , tspan , H0 , dH , decay = decay ) # objective function: CFI obj = QuanEstimation . CFIM_obj ( M = M ) PSO # comprehensive optimization algorithm: PSO alg = QuanEstimation . PSO ( p_num = 10 , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) # input the dynamics data dynamics = QuanEstimation . Lindblad ( opt , tspan , H0 , dH , decay = decay ) # objective function: CFI obj = QuanEstimation . CFIM_obj ( M = M ) SC opt = QuanEstimation . SMopt ( ctrl_bound = [ - 2.0 , 2.0 ], seed = 1234 ) DE # comprehensive optimization algorithm: DE alg = QuanEstimation . DE ( p_num = 10 , max_episode = 1000 , c = 1.0 , cr = 0.5 ) # input the dynamics data dynamics = QuanEstimation . Lindblad ( opt , tspan , H0 , dH , Hc , decay = decay ) QFIM # objective function: QFI obj = QuanEstimation . QFIM_obj () CFIM # objective function: CFI obj = QuanEstimation . CFIM_obj ( M = M ) PSO # comprehensive optimization algorithm: PSO alg = QuanEstimation . PSO ( p_num = 10 , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) # input the dynamics data dynamics = QuanEstimation . Lindblad ( opt , tspan , H0 , dH , Hc , decay = decay ) QFIM # objective function: QFI obj = QuanEstimation . QFIM_obj () CFIM # objective function: CFI obj = QuanEstimation . CFIM_obj ( M = M ) AD # comprehensive optimization algorithm: AD alg = QuanEstimation . AD ( Adam = true , max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 ) # input the dynamics data dynamics = QuanEstimation . Lindblad ( opt , tspan , H0 , dH , Hc , decay = decay ) QFIM # objective function: QFI obj = QuanEstimation . QFIM_obj () CFIM # objective function: CFI obj = QuanEstimation . CFIM_obj ( M = M ) CM opt = QuanEstimation . CMopt ( ctrl_bound = [ - 2.0 , 2.0 ], seed = 1234 ) DE # comprehensive optimization algorithm: DE alg = QuanEstimation . DE ( p_num = 10 , max_episode = 1000 , c = 1.0 , cr = 0.5 ) # input the dynamics data dynamics = QuanEstimation . Lindblad ( opt , tspan , rho0 , H0 , dH , Hc , decay = decay ) # objective function: CFI obj = QuanEstimation . CFIM_obj ( M = M ) PSO # comprehensive optimization algorithm: PSO alg = QuanEstimation . PSO ( p_num = 10 , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) # input the dynamics data dynamics = QuanEstimation . Lindblad ( opt , tspan , rho0 , H0 , dH , Hc , decay = decay ) # objective function: CFI obj = QuanEstimation . CFIM_obj ( M = M ) SCM opt = QuanEstimation . SCMopt ( ctrl_bound = [ - 2.0 , 2.0 ], seed = 1234 ) DE # comprehensive optimization algorithm: DE alg = QuanEstimation . DE ( p_num = 10 , max_episode = 1000 , c = 1.0 , cr = 0.5 ) # input the dynamics data dynamics = QuanEstimation . Lindblad ( opt , tspan , H0 , dH , Hc , decay = decay ) # objective function: CFI obj = QuanEstimation . CFIM_obj ( M = M ) PSO # comprehensive optimization algorithm: PSO alg = QuanEstimation . PSO ( p_num = 10 , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) # input the dynamics data dynamics = QuanEstimation . Lindblad ( opt , tspan , H0 , dH , Hc , decay = decay ) # objective function: CFI obj = QuanEstimation . CFIM_obj ( M = M ) # run the comprehensive optimization problem QuanEstimation . run ( opt , alg , obj , dynamics ; savefile = false ) Example 8.2 The Hamiltonian of a controlled system can be written as \\begin{align} H = H_0(\\textbf{x})+\\sum_{k=1}^K u_k(t) H_k, \\end{align} where \\(H_0(\\textbf{x})\\) is the free evolution Hamiltonian with unknown parameters \\(\\textbf{x}\\) and \\(H_k\\) represents the \\(k\\) th control Hamiltonian with \\(u_k\\) the correspong control coefficient. In the multiparameter scenario, the dynamics of electron and nuclear coupling in NV \\(^{-}\\) can be expressed as \\begin{align} \\partial_t\\rho=-i[H_0+H_{\\mathrm{c}},\\rho]+\\frac{\\gamma}{2}(S_3\\rho S_3-S^2_3\\rho-\\rho S^2_3) \\end{align} with \\(\\gamma\\) the dephasing rate. And \\begin{align} H_0/\\hbar=DS^2_3+g_{\\mathrm{S}}\\vec{B}\\cdot\\vec{S}+g_{\\mathrm{I}}\\vec{B}\\cdot\\vec{I}+\\vec{S}^{\\,\\mathrm{T}}\\mathcal{A}\\vec{I} \\end{align} is the free evolution Hamiltonian, where \\(\\vec{S}=(S_1,S_2,S_3)^{\\mathrm{T}}\\) and \\(\\vec{I}=(I_1,I_2,I_3)^{\\mathrm{T}}\\) with \\(S_i=s_i\\otimes I\\) and \\(I_i=I\\otimes \\sigma_i\\) ( \\(i=1,2,3\\) ) the electron and nuclear operators. \\(\\mathcal{A}=\\mathrm{diag} (A_1,A_1,A_2)\\) is the hyperfine tensor with \\(A_1\\) and \\(A_2\\) the axial and transverse magnetic hyperfine coupling coefficients. The coefficients \\(g_{\\mathrm{S}}=g_\\mathrm{e}\\mu_\\mathrm{B}/\\hbar\\) and \\(g_{\\mathrm{I}}=g_\\mathrm{n}\\mu_\\mathrm{n}/\\hbar\\) , where \\(g_\\mathrm{e}\\) ( \\(g_\\mathrm{n}\\) ) is the \\(g\\) factor of the electron (nuclear), \\(\\mu_\\mathrm{B}\\) ( \\(\\mu_\\mathrm{n}\\) ) is the Bohr (nuclear) magneton and \\(\\hbar\\) is the Plank's constant. \\(\\vec{B}\\) is the magnetic field which be estimated. The control Hamiltonian is \\begin{align} H_{\\mathrm{c}}/\\hbar=\\sum^3_{i=1}\\Omega_i(t)S_i \\end{align} with \\(\\Omega_i(t)\\) the time-dependent Rabi frequency. In this case, the initial state is taken as \\(\\frac{1}{\\sqrt{2}}(|1\\rangle+|\\!-\\!1\\rangle)\\otimes|\\!\\!\\uparrow\\rangle\\) , where \\(\\frac{1}{\\sqrt{2}}(|1\\rangle+|\\!-\\!1\\rangle)\\) is an electron state with \\(|1\\rangle\\) \\((|\\!-\\!1\\rangle)\\) the eigenstate of \\(s_3\\) with respect to the eigenvalue \\(1\\) ( \\(-1\\) ). \\(|\\!\\!\\uparrow\\rangle\\) is a nuclear state and the eigenstate of \\(\\sigma_3\\) with respect to the eigenvalue 1. \\(W\\) is set to be identity. Python from quanestimation import * import numpy as np # initial state rho0 = np . zeros (( 6 , 6 ), dtype = np . complex128 ) rho0 [ 0 ][ 0 ], rho0 [ 0 ][ 4 ], rho0 [ 4 ][ 0 ], rho0 [ 4 ][ 4 ] = 0.5 , 0.5 , 0.5 , 0.5 # free Hamiltonian sx = np . array ([[ 0. , 1. ],[ 1. , 0. ]]) sy = np . array ([[ 0. , - 1. j ],[ 1. j , 0. ]]) sz = np . array ([[ 1. , 0. ],[ 0. , - 1. ]]) ide2 = np . array ([[ 1. , 0. ],[ 0. , 1. ]]) s1 = np . array ([[ 0. , 1. , 0. ],[ 1. , 0. , 1. ],[ 0. , 1. , 0. ]]) / np . sqrt ( 2 ) s2 = np . array ([[ 0. , - 1. j , 0. ],[ 1. j , 0. , - 1. j ],[ 0. , 1. j , 0. ]]) / np . sqrt ( 2 ) s3 = np . array ([[ 1. , 0. , 0. ],[ 0. , 0. , 0. ],[ 0. , 0. , - 1. ]]) ide3 = np . array ([[ 1. , 0. , 0. ],[ 0. , 1. , 0. ],[ 0. , 0. , 1. ]]) I1 , I2 , I3 = np . kron ( ide3 , sx ), np . kron ( ide3 , sy ), np . kron ( ide3 , sz ) S1 , S2 , S3 = np . kron ( s1 , ide2 ), np . kron ( s2 , ide2 ), np . kron ( s3 , ide2 ) B1 , B2 , B3 = 5.0e-4 , 5.0e-4 , 5.0e-4 # All numbers are divided by 100 in this example # for better calculation accurancy cons = 100 D = ( 2 * np . pi * 2.87 * 1000 ) / cons gS = ( 2 * np . pi * 28.03 * 1000 ) / cons gI = ( 2 * np . pi * 4.32 ) / cons A1 = ( 2 * np . pi * 3.65 ) / cons A2 = ( 2 * np . pi * 3.03 ) / cons H0 = D * np . kron ( np . dot ( s3 , s3 ), ide2 ) + gS * ( B1 * S1 + B2 * S2 + B3 * S3 ) \\ + gI * ( B1 * I1 + B2 * I2 + B3 * I3 ) + A1 * ( np . kron ( s1 , sx ) + np . kron ( s2 , sy )) \\ + A2 * np . kron ( s3 , sz ) # derivatives of the free Hamiltonian on B1, B2 and B3 dH = [ gS * S1 + gI * I1 , gS * S2 + gI * I2 , gS * S3 + gI * I3 ] # control Hamiltonians Hc = [ S1 , S2 , S3 ] # dissipation decay = [[ S3 , 2 * np . pi / cons ]] # measurement dim = len ( rho0 ) M = [ np . dot ( basis ( dim , i ), basis ( dim , i ) . conj () . T ) for i in range ( dim )] # time length for the evolution tspan = np . linspace ( 0. , 2. , 4000 ) # guessed control coefficients cnum = 10 ctrl0 = - 0.2 * np . ones (( len ( Hc ), cnum )) SM DE # comprehensive optimization algorithm: DE DE_paras = { \"p_num\" : 10 , \"psi0\" :[], \"ctrl0\" :[], \"measurement0\" :[], \\ \"max_episode\" : 100 , \"c\" : 1.0 , \"cr\" : 0.5 , \"seed\" : 1234 } com = ComprehensiveOpt ( savefile = False , method = \"DE\" , ** DE_paras ) com . dynamics ( tspan , H0 , dH , decay = decay ) com . SM () PSO # comprehensive optimization algorithm: PSO PSO_paras = { \"p_num\" : 10 , \"psi0\" :[], \"ctrl0\" :[], \\ \"measurement0\" :[], \"max_episode\" :[ 1000 , 100 ], \"c0\" : 1.0 , \\ \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } com = ComprehensiveOpt ( savefile = False , method = \"PSO\" , ** PSO_paras ) com . dynamics ( tspan , H0 , dH , decay = decay ) com . SM () SC DE # comprehensive optimization algorithm: DE DE_paras = { \"p_num\" : 10 , \"psi0\" :[], \"ctrl0\" :[], \"measurement0\" :[], \\ \"max_episode\" : 100 , \"c\" : 1.0 , \"cr\" : 0.5 , \"seed\" : 1234 } com = ComprehensiveOpt ( savefile = False , method = \"DE\" , ** DE_paras ) com . dynamics ( tspan , H0 , dH , Hc = Hc , decay = decay , ctrl = [ ctrl0 ], \\ ctrl_bound = [ - 0.2 , 0.2 ]) QFIM # objective function: tr(WF^{-1}) com . SC ( W = [], target = \"QFIM\" , LDtype = \"SLD\" ) CFIM # objective function: tr(WI^{-1}) com . SC ( W = [], M = M , target = \"CFIM\" ) HCRB # objective function: HCRB com . SC ( W = [], target = \"HCRB\" ) PSO # comprehensive optimization algorithm: PSO PSO_paras = { \"p_num\" : 10 , \"psi0\" :[], \"ctrl0\" :[], \\ \"measurement0\" :[], \"max_episode\" :[ 1000 , 100 ], \"c0\" : 1.0 , \\ \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } com = ComprehensiveOpt ( savefile = False , method = \"PSO\" , ** PSO_paras ) com . dynamics ( tspan , H0 , dH , Hc = Hc , decay = decay , ctrl = [ ctrl0 ], \\ ctrl_bound = [ - 0.2 , 0.2 ]) QFIM # objective function: tr(WF^{-1}) com . SC ( W = [], target = \"QFIM\" , LDtype = \"SLD\" ) CFIM # objective function: tr(WI^{-1}) com . SC ( W = [], M = M , target = \"CFIM\" ) HCRB # objective function: HCRB com . SC ( W = [], target = \"HCRB\" ) AD # comprehensive optimization algorithm: AD AD_paras = { \"Adam\" : False , \"psi0\" :[], \"ctrl0\" :[], \"measurement0\" :[], \\ \"max_episode\" : 300 , \"epsilon\" : 0.01 , \"beta1\" : 0.90 , \"beta2\" : 0.99 } com = ComprehensiveOpt ( savefile = False , method = \"AD\" , ** AD_paras ) com . dynamics ( tspan , H0 , dH , Hc = Hc , decay = decay , ctrl = [ ctrl0 ], \\ ctrl_bound = [ - 0.2 , 0.2 ]) QFIM # objective function: tr(WF^{-1}) com . SC ( W = [], target = \"QFIM\" , LDtype = \"SLD\" ) CFIM # objective function: tr(WI^{-1}) com . SC ( W = [], M = M , target = \"CFIM\" ) CM DE # comprehensive optimization algorithm: DE DE_paras = { \"p_num\" : 10 , \"psi0\" :[], \"ctrl0\" :[], \"measurement0\" :[], \\ \"max_episode\" : 100 , \"c\" : 1.0 , \"cr\" : 0.5 , \"seed\" : 1234 } com = ComprehensiveOpt ( savefile = False , method = \"DE\" , ** DE_paras ) com . dynamics ( tspan , H0 , dH , Hc = Hc , decay = decay , ctrl_bound = [ - 0.2 , 0.2 ]) com . CM ( rho0 ) PSO # comprehensive optimization algorithm: PSO PSO_paras = { \"p_num\" : 10 , \"psi0\" :[], \"ctrl0\" :[], \\ \"measurement0\" :[], \"max_episode\" :[ 1000 , 100 ], \"c0\" : 1.0 , \\ \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } com = ComprehensiveOpt ( savefile = False , method = \"PSO\" , ** PSO_paras ) com . dynamics ( tspan , H0 , dH , Hc = Hc , decay = decay , ctrl_bound = [ - 0.2 , 0.2 ]) com . CM ( rho0 ) SCM DE # comprehensive optimization algorithm: DE DE_paras = { \"p_num\" : 10 , \"psi0\" :[], \"ctrl0\" :[], \"measurement0\" :[], \\ \"max_episode\" : 100 , \"c\" : 1.0 , \"cr\" : 0.5 , \"seed\" : 1234 } com = ComprehensiveOpt ( savefile = False , method = \"DE\" , ** DE_paras ) com . dynamics ( tspan , H0 , dH , Hc = Hc , decay = decay , ctrl_bound = [ - 0.2 , 0.2 ]) com . SCM () PSO # comprehensive optimization algorithm: PSO PSO_paras = { \"p_num\" : 10 , \"psi0\" :[], \"ctrl0\" :[], \\ \"measurement0\" :[], \"max_episode\" :[ 1000 , 100 ], \"c0\" : 1.0 , \\ \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } com = ComprehensiveOpt ( savefile = False , method = \"PSO\" , ** PSO_paras ) com . dynamics ( tspan , H0 , dH , Hc = Hc , decay = decay , ctrl_bound = [ - 0.2 , 0.2 ]) com . SCM () Julia using QuanEstimation using LinearAlgebra # initial state rho0 = zeros ( ComplexF64 , 6 , 6 ) rho0 [ 1 : 4 : 5 , 1 : 4 : 5 ] .= 0.5 # free Hamiltonian sx = [ 0. 1. ; 1. 0. ] sy = [ 0. - im ; im 0. ] sz = [ 1. 0. ; 0. - 1. ] s1 = [ 0. 1. 0. ; 1. 0. 1. ; 0. 1. 0. ] / sqrt ( 2 ) s2 = [ 0. - im 0. ; im 0. - im ; 0. im 0. ] / sqrt ( 2 ) s3 = [ 1. 0. 0. ; 0. 0. 0. ; 0. 0. - 1. ] Is = I1 , I2 , I3 = [ kron ( I ( 3 ), sx ), kron ( I ( 3 ), sy ), kron ( I ( 3 ), sz )] S = S1 , S2 , S3 = [ kron ( s1 , I ( 2 )), kron ( s2 , I ( 2 )), kron ( s3 , I ( 2 ))] B = B1 , B2 , B3 = [ 5.0e-4 , 5.0e-4 , 5.0e-4 ] # All numbers are divided by 100 in this example # for better calculation accurancy cons = 100 D = ( 2 pi * 2.87 * 1000 ) / cons gS = ( 2 pi * 28.03 * 1000 ) / cons gI = ( 2 pi * 4.32 ) / cons A1 = ( 2 pi * 3.65 ) / cons A2 = ( 2 pi * 3.03 ) / cons H0 = sum ([ D * kron ( s3 ^ 2 , I ( 2 )), sum ( gS * B .* S ), sum ( gI * B .* Is ), A1 * ( kron ( s1 , sx ) + kron ( s2 , sy )), A2 * kron ( s3 , sz )]) # derivatives of the free Hamiltonian on B1, B2 and B3 dH = gS * S + gI * Is # control Hamiltonians Hc = [ S1 , S2 , S3 ] # dissipation decay = [[ S3 , 2 pi / cons ]] # measurement dim = size ( rho0 , 1 ) M = [ QuanEstimation . basis ( dim , i ) * QuanEstimation . basis ( dim , i ) ' for i in 1 : dim ] # time length for the evolution tspan = range ( 0. , 2. , length = 4000 ) # guessed control coefficients cnum = 10 ctrl = - 0.2 * ones (( length ( Hc ), cnum )) # guessed measurements C = [ QuanEstimation . basis ( dim , i ) for i in 1 : dim ] SM opt = QuanEstimation . SMopt ( seed = 1234 ) DE # comprehensive optimization algorithm: DE alg = QuanEstimation . DE ( p_num = 10 , max_episode = 1000 , c = 1.0 , cr = 0.5 ) # input the dynamics data dynamics = QuanEstimation . Lindblad ( opt , tspan , H0 , dH , decay = decay ) # objective function: CFI obj = QuanEstimation . CFIM_obj ( M = M ) PSO # comprehensive optimization algorithm: PSO alg = QuanEstimation . PSO ( p_num = 10 , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) # input the dynamics data dynamics = QuanEstimation . Lindblad ( opt , tspan , H0 , dH , decay = decay ) # objective function: CFI obj = QuanEstimation . CFIM_obj ( M = M ) SC opt = QuanEstimation . SMopt ( ctrl = ctrl , ctrl_bound = [ - 0.2 , 0.2 ], seed = 1234 ) DE # comprehensive optimization algorithm: DE alg = QuanEstimation . DE ( p_num = 10 , max_episode = 1000 , c = 1.0 , cr = 0.5 ) # input the dynamics data dynamics = QuanEstimation . Lindblad ( opt , tspan , H0 , dH , Hc , decay = decay ) QFIM # objective function: tr(WF^{-1}) obj = QuanEstimation . QFIM_obj () CFIM # objective function: tr(WI^{-1}) obj = QuanEstimation . CFIM_obj ( M = M ) HCRB # objective function: HCRB obj = QuanEstimation . HCRB_obj () PSO # comprehensive optimization algorithm: PSO alg = QuanEstimation . PSO ( p_num = 10 , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) # input the dynamics data dynamics = QuanEstimation . Lindblad ( opt , tspan , H0 , dH , Hc , decay = decay ) QFIM # objective function: tr(WF^{-1}) obj = QuanEstimation . QFIM_obj () CFIM # objective function: tr(WI^{-1}) obj = QuanEstimation . CFIM_obj ( M = M ) HCRB # objective function: HCRB obj = QuanEstimation . HCRB_obj () AD # comprehensive optimization algorithm: AD alg = QuanEstimation . AD ( Adam = true , max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 ) # input the dynamics data dynamics = QuanEstimation . Lindblad ( opt , tspan , H0 , dH , Hc , decay = decay ) QFIM # objective function: tr(WF^{-1}) obj = QuanEstimation . QFIM_obj () CFIM # objective function: tr(WI^{-1}) obj = QuanEstimation . CFIM_obj ( M = M ) CM opt = QuanEstimation . CMopt ( seed = 1234 ) DE # comprehensive optimization algorithm: DE alg = QuanEstimation . DE ( p_num = 10 , max_episode = 1000 , c = 1.0 , cr = 0.5 ) # input the dynamics data dynamics = QuanEstimation . Lindblad ( opt , tspan , rho0 , H0 , dH , Hc , decay = decay ) # objective function: CFI obj = QuanEstimation . CFIM_obj () PSO # comprehensive optimization algorithm: PSO alg = QuanEstimation . PSO ( p_num = 10 , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) # input the dynamics data dynamics = QuanEstimation . Lindblad ( opt , tspan , rho0 , H0 , dH , Hc , decay = decay ) # objective function: CFI obj = QuanEstimation . CFIM_obj () SCM opt = QuanEstimation . SCMopt ( seed = 1234 ) DE # comprehensive optimization algorithm: DE alg = QuanEstimation . DE ( p_num = 10 , max_episode = 1000 , c = 1.0 , cr = 0.5 ) # input the dynamics data dynamics = QuanEstimation . Lindblad ( opt , tspan , H0 , dH , Hc , decay = decay ) # objective function: CFI obj = QuanEstimation . CFIM_obj () PSO # comprehensive optimization algorithm: PSO alg = QuanEstimation . PSO ( p_num = 10 , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) # input the dynamics data dynamics = QuanEstimation . Lindblad ( opt , tspan , H0 , dH , Hc , decay = decay ) # objective function: CFI obj = QuanEstimation . CFIM_obj () # run the comprehensive optimization problem QuanEstimation . run ( opt , alg , obj , dynamics ; savefile = false ) For optimization of probe state and measurement, the parameterization can also be implemented with the Kraus operators which can be realized by Python com = ComprehensiveOpt ( savefile = False , method = \"DE\" , ** kwargs ) com . Kraus ( K , dK ) com . SM ( W = []) Julia opt = SMopt ( psi = psi , M = M , seed = 1234 ) alg = DE ( kwargs ... ) dynamics = Kraus ( opt , K , dK ) obj = CFIM_obj ( W = missing ) run ( opt , alg , obj , dynamics ; savefile = false ) where K and dK are the Kraus operators and its derivatives with respect to the unknown parameters. Example 8.3 The Kraus operators for the amplitude damping channel are \\[\\begin{eqnarray} K_1 = \\left(\\begin{array}{cc} 1 & 0 \\\\ 0 & \\sqrt{1-\\gamma} \\end{array}\\right), K_2 = \\left(\\begin{array}{cc} 0 & \\sqrt{\\gamma} \\\\ 0 & 0 \\end{array}\\right), \\nonumber \\end{eqnarray}\\] where \\(\\gamma\\) is the unknown parameter to be estimated which represents the decay probability. In this example, the probe state is taken as \\(|+\\rangle\\langle+|\\) with \\(|+\\rangle=\\frac{1}{\\sqrt{2}}(|0\\rangle+|1\\rangle)\\) . Here \\(|0\\rangle\\) \\((|1\\rangle)\\) is the eigenstate of \\(\\sigma_3\\) (Pauli matrix) with respect to the eigenvalue \\(1\\) \\((-1)\\) . Python from quanestimation import * import numpy as np # initial state rho0 = 0.5 * np . array ([[ 1. , 1. ], [ 1. , 1. ]]) # Kraus operators for the amplitude damping channel gamma = 0.1 K1 = np . array ([[ 1. , 0. ], [ 0. , np . sqrt ( 1 - gamma )]]) K2 = np . array ([[ 0. , np . sqrt ( gamma )], [ 0. , 0. ]]) K = [ K1 , K2 ] # derivatives of Kraus operators on gamma dK1 = np . array ([[ 1. , 0. ], [ 0. , - 0.5 / np . sqrt ( 1 - gamma )]]) dK2 = np . array ([[ 0. , 0.5 / np . sqrt ( gamma )], [ 0. , 0. ]]) dK = [[ dK1 ], [ dK2 ]] DE # comprehensive optimization algorithm: DE DE_paras = { \"p_num\" : 10 , \"psi0\" :[], \"ctrl0\" :[], \"measurement0\" :[], \\ \"max_episode\" : 100 , \"c\" : 1.0 , \"cr\" : 0.5 , \"seed\" : 1234 } com = ComprehensiveOpt ( savefile = False , method = \"DE\" , ** DE_paras ) com . Kraus ( K , dK ) com . SM () PSO # comprehensive optimization algorithm: PSO PSO_paras = { \"p_num\" : 10 , \"psi0\" :[], \"ctrl0\" :[], \\ \"measurement0\" :[], \"max_episode\" :[ 1000 , 100 ], \"c0\" : 1.0 , \\ \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } com = ComprehensiveOpt ( savefile = False , method = \"PSO\" , ** PSO_paras ) com . Kraus ( K , dK ) com . SM () com = ComprehensiveOpt ( savefile = False , method = \"DE\" , ** kwargs ) com . SM () Julia using QuanEstimation # initial state rho0 = 0.5 * ones ( 2 , 2 ) # Kraus operators for the amplitude damping channel gamma = 0.1 K1 = [ 1. 0. ; 0. sqrt ( 1 - gamma )] K2 = [ 0. sqrt ( gamma ); 0. 0. ] K = [ K1 , K2 ] # derivatives of Kraus operators on gamma dK1 = [ 1. 0. ; 0. - 0.5 / sqrt ( 1 - gamma )] dK2 = [ 0. 0.5 / sqrt ( gamma ); 0. 0. ] dK = [[ dK1 ], [ dK2 ]] # comprehensive optimization opt = QuanEstimation . SMopt ( seed = 1234 ) DE # comprehensive optimization algorithm: DE alg = QuanEstimation . DE ( p_num = 10 , max_episode = 1000 , c = 1.0 , cr = 0.5 ) # input the dynamics data dynamics = QuanEstimation . Kraus ( opt , K , dK ) # objective function: CFI obj = QuanEstimation . CFIM_obj () PSO # comprehensive optimization algorithm: PSO alg = QuanEstimation . PSO ( p_num = 10 , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) # input the dynamics data dynamics = QuanEstimation . Kraus ( opt , K , dK ) # objective function: CFI obj = QuanEstimation . CFIM_obj () # run the comprehensive optimization problem QuanEstimation . run ( opt , alg , obj , dynamics ; savefile = false )","title":"AD"},{"location":"guide/guide_Compopt/#bibliography","text":"[1] J. Kennedy and R. Eberhar, Particle swarm optimization, Proc. 1995 IEEE International Conference on Neural Networks 4 , 1942-1948 (1995). [2] R. Storn and K. Price, Differential Evolution-A Simple and Efficient Heuristic for global Optimization over Continuous Spaces, J. Global Optim. 11 , 341 (1997). [3] A. G. Baydin, B. A. Pearlmutter, A. A. Radul, and J. M. Siskind, Automatic differentiation in machine learning: a survey, J. Mach. Learn. Res. 18 , 1-43 (2018).","title":"Bibliography"},{"location":"guide/guide_Copt/","text":"Control optimization \u00b6 The Hamiltonian of a controlled system can be written as \\begin{align} H = H_0(\\textbf{x})+\\sum_{k=1}^K u_k(t) H_k, \\end{align} where \\(H_0(\\textbf{x})\\) is the free evolution Hamiltonian with unknown parameters \\(\\textbf{x}\\) and \\(H_k\\) represents the \\(k\\) th control Hamiltonian with \\(u_k\\) the corresponding control coefficients. In QuanEstimation, different algorithms are invoked to update the control coefficients. The control optimization algorithms are the gradient ascent pulse engineering (GRAPE) [1,2,3] , GRAPE algorithm based on the automatic differentiation (auto-GRAPE) [4] , particle swarm optimization (PSO) [5] , differential evolution (DE) [6] and deep deterministic policy gradients (DDPG) [7] . The codes for control optimization are Python control = ControlOpt ( savefile = False , method = \"auto-GRAPE\" , ** kwargs ) control . dynamics ( tspan , rho0 , H0 , dH , Hc , decay = [], ctrl_bound = []) QFIM control . QFIM ( W = [], LDtype = \"SLD\" ) CFIM control . CFIM ( M = [], W = []) HCRB control . HCRB ( W = []) In QuanEstimation, the optimization codes are executed in Julia and the data will be saved in the .csv file. The variable savefile indicates whether to save all the control coefficients and its default value is False which means the control coefficients for the final episode and the values of the objective function in all episodes will be saved in \"controls.csv\" and \"f.csv\", respectively. If set True then the control coefficients and the values of the objective function in all episodes will be saved during the training. The package contains five control optimization algorithms which can be set via method , **kwargs is the corresponding keyword and default value. After calling control = ControlOpt() , the dynamics parameters shoule be input. Here tspan is the time length for the evolution and rho0 represents the density matrix of the initial state. H0 and dH are the free Hamiltonian and its derivatives with respect to the unknown parameters to be estimated. H0 is a matrix when the free Hamiltonian is time-independent and a list with the length equal to tspan when it is time-dependent. dH should be input as \\([\\partial_a{H_0}, \\partial_b{H_0}, \\cdots]\\) . Hc is a list representing the control Hamiltonians. decay contains decay operators \\((\\Gamma_1, \\Gamma_2, \\cdots)\\) and the corresponding decay rates \\((\\gamma_1, \\gamma_2, \\cdots)\\) , its input rule is decay=[[ \\(\\Gamma_1\\) , \\(\\gamma_1\\) ], [ \\(\\Gamma_2\\) , \\(\\gamma_2\\) ],...]. The default value for decay is empty which means the dynamics is unitary. The package can be used to optimize bounded control problems by setting lower and upper bounds of the control coefficients via ctrl_bound , which is an array with two elements representing the lower and upper bound of each control coefficient, respectively. The default value of ctrl_bound=[] which means the control coefficients are in the regime \\([-\\infty,\\infty]\\) . The objective functions for control optimization can be set as QFI \\(\\left[\\mathrm{Tr}(W \\mathcal{F}^{-1})\\right]\\) , CFI \\(\\left[\\mathrm{Tr}(W\\mathcal{I}^{-1})\\right]\\) and HCRB, the corresponding codes for them are control.QFIM() (default), control.CFIM() and control.HCRB() . Here \\(\\mathcal{F}\\) and \\(\\mathcal{I}\\) are the QFIM and CFIM, \\(W\\) corresponds to W is the weight matrix which defaults to the identity matrix. If the users call control.HCRB() for single parameter scenario, the program will exit and print \"Program terminated. In the single-parameter scenario, the HCRB is equivalent to the QFI. Please choose 'QFIM' as the objective function\" . LDtype in control.QFIM() represents the types of the QFIM, it can be set as LDtype=\"SLD\" (default), LDtype=\"RLD\" , and LDtype=\"LLD\" . M in control.CFIM() represents a set of positive operator-valued measure (POVM) with default value [] which means a set of rank-one symmetric informationally complete POVM (SIC-POVM) is used in the calculation. Julia opt = ControlOpt ( ctrl = ctrl , ctrl_bound = ctrl_bound , seed = 1234 ) alg = autoGRAPE ( kwargs ... ) dynamics = Lindblad ( opt , tspan , rho0 , H0 , dH , Hc , decay = mising ) QFIM obj = QFIM_obj ( W = missing , LDtype = :SLD ) CFIM obj = CFIM_obj ( M = missing , W = missing ) HCRB obj = HCRB_obj ( W = missing ) run ( opt , alg , obj , dynamics ; savefile = false ) In control optimization, a set of control coefficients (optimization variable) and its boundary value can be input via ctrl=ctrl and ctrl_bound=ctrl_bound in ControlOpt() . ctrl is a list of arrays with the length equal to control Hamiltonians, ctrl_bound is an array with two elements representing the lower and upper bound of the control coefficients, respectively. The default value of ctrl_bound=missing which means the control coefficients are in the regime \\([-\\infty,\\infty]\\) . seed is the random seed which can ensure the reproducibility of results. The package can deal with the parameterization process in the form of master equation, the dynamics parameters shoule be input via Lindblad() . Here tspan is the time length for the evolution and rho0 represents the density matrix of the initial state. H0 and dH are the free Hamiltonian and its derivatives with respect to the unknown parameters to be estimated. H0 is a matrix when the free Hamiltonian is time-independent and a list with the length equal to tspan when it is time-dependent. dH should be input as \\([\\partial_a{H_0}, \\partial_b{H_0}, \\cdots]\\) . Hc is a list representing the control Hamiltonians. decay contains decay operators \\((\\Gamma_1, \\Gamma_2, \\cdots)\\) and the corresponding decay rates \\((\\gamma_1, \\gamma_2, \\cdots)\\) with the input rule decay=[[ \\(\\Gamma_1\\) , \\(\\gamma_1\\) ], [ \\(\\Gamma_2\\) , \\(\\gamma_2\\) ],...]. The default value decay is missing which means the dynamics is unitary. The objective functions for control optimization can be set as QFI \\(\\left[\\mathrm{Tr}(W \\mathcal{F}^{-1})\\right]\\) , CFI \\(\\left[\\mathrm{Tr}(W\\mathcal{I}^{-1})\\right]\\) and HCRB, the corresponding codes for them are QFIM_obj() (default), CFIM_obj() and HCRB_obj() . Here \\(\\mathcal{F}\\) and \\(\\mathcal{I}\\) are the QFIM and CFIM, \\(W\\) corresponds to W is the weight matrix which defaults to the identity matrix. If the users call HCRB_obj() for single parameter scenario, the program will exit and print \"Program terminated. In the single-parameter scenario, the HCRB is equivalent to the QFI. Please choose 'QFIM_obj' as the objective function\" . LDtype in QFIM_obj() represents the types of the QFIM, it can be set as LDtype=:SLD (default), LDtype=:RLD , and LDtype=:LLD . M in CFIM_obj() represents a set of positive operator-valued measure (POVM) with default value missing which means a set of rank-one symmetric informationally complete POVM (SIC-POVM) is used in the calculation. The variable savefile indicates whether to save all the control coefficients and its default value is false which means the control coefficients for the final episode and the values of the objective function in all episodes will be saved in \"controls.csv\" and \"f.csv\", respectively. If set true then the control coefficients and the values of the objective function in all episodes will be saved during the training. The algorithm used for optimizing the control coefficients in QuanEstimation are GRAPE, auto-GRAPE, PSO, DE and DDPG. kwargs... contains the keywords and defaults value corresponding to the optimization algorithm which will be introduced in detail below. GRAPE and auto-GRAPE \u00b6 The codes for control optimization with GRAPE and auto-GRAPE are as follows Python control = ControlOpt ( method = \"GRAPE\" , ** kwargs ) control = ControlOpt ( method = \"auto-GRAPE\" , ** kwargs ) where kwargs is of the form kwargs = { \"Adam\" : True , \"ctrl0\" :[], \"max_episode\" : 300 , \"epsilon\" : 0.01 , \\ \"beta1\" : 0.90 , \"beta2\" : 0.99 } The keywords and the default values of GRAPE and auto-GRAPE can be seen in the following table \\(~~~~~~~~~~\\) **kwargs \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"Adam\" True \"ctrl0\" [ ] \"max_episode\" 300 \"epsilon\" 0.01 \"beta1\" 0.90 \"beta2\" 0.99 Adam algorithm can be introduced to update the control coefficients when using GRAPE and auto-GRAPE for control optimization, which can be realized by setting Adam=True . In this case, the Adam parameters include learning rate, the exponential decay rate for the first moment estimates and the second moment estimates can be set by the users via epsilon , beta1 and beta2 , respectively. If Adam=False , the control coefficients will update according to the learning rate \"epsilon\" . ctrl0 is a list representing the initial guesses of control coefficients and max_episode is the number of episodes. Julia alg = GRAPE ( Adam = true , max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 ) alg = autoGRAPE ( Adam = true , max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 ) The keywords and the default values of GRAPE and auto-GRAPE can be seen in the following table \\(~~~~~~~~~~\\) keywords \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"Adam\" true \"max_episode\" 300 \"epsilon\" 0.01 \"beta1\" 0.90 \"beta2\" 0.99 Adam algorithm can be introduced to update the control coefficients when using GRAPE and auto-GRAPE for control optimization, which can be realized by setting Adam=true . In this case, the Adam parameters include learning rate, the exponential decay rate for the first moment estimates and the second moment estimates can be set by the users via epsilon , beta1 and beta2 , respectively. If Adam=false , the control coefficients will update according to the learning rate \"epsilon\" . PSO \u00b6 The code for control optimization with PSO is as follows Python control = ControlOpt ( method = \"PSO\" , ** kwargs ) where kwargs is of the form kwargs = { \"p_num\" : 10 , \"ctrl0\" :[], \"max_episode\" :[ 1000 , 100 ], \\ \"c0\" : 1.0 , \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } The keywords and the default values of PSO can be seen in the following table \\(~~~~~~~~~~\\) **kwargs \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"p_num\" 10 \"ctrl0\" [ ] \"max_episode\" [1000,100] \"c0\" 1.0 \"c1\" 2.0 \"c2\" 2.0 \"seed\" 1234 Here p_num is the number of particles. c0 , c1 and c2 are the PSO parameters representing the inertia weight, cognitive learning factor and social learning factor, respectively. max_episode accepts both integer and array with two elements. If it is an integer, for example max_episode=1000 , it means the program will continuously run 1000 episodes. However, if it is an array, for example max_episode=[1000,100] , the program will run 1000 episodes in total but replace control coefficients of all the particles with global best every 100 episodes. seed is the random seed which can ensure the reproducibility of the results. Julia alg = PSO ( p_num = 10 , ini_particle = missing , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) The keywords and the default values of PSO can be seen in the following table \\(~~~~~~~~~~\\) keywords \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"p_num\" 10 \"ini_particle\" missing \"max_episode\" [1000,100] \"c0\" 1.0 \"c1\" 2.0 \"c2\" 2.0 Here p_num is the number of particles. c0 , c1 and c2 are the PSO parameters representing the inertia weight, cognitive learning factor and social learning factor, respectively. max_episode accepts both integer and array with two elements. If it is an integer, for example max_episode=1000 , it means the program will continuously run 1000 episodes. However, if it is an array, for example max_episode=[1000,100] , the program will run 1000 episodes in total but replace control coefficients of all the particles with global best every 100 episodes. ini_particle is a tuple representing the initial guesses of control coefficients. DE \u00b6 The code for control optimization with DE is as follows Python control = ControlOpt ( method = \"DE\" , ** kwargs ) where kwargs is of the form kwargs = { \"p_num\" : 10 , \"ctrl0\" :[], \"max_episode\" : 1000 , \"c\" : 1.0 , \\ \"cr\" : 0.5 , \"seed\" : 1234 } The keywords and the default values of DE can be seen in the following table \\(~~~~~~~~~~\\) **kwargs \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"p_num\" 10 \"ctrl0\" [ ] \"max_episode\" 1000 \"c\" 1.0 \"cr\" 0.5 \"seed\" 1234 p_num and max_episode represent the number of populations and episodes. c and cr are the mutation constant and the crossover constant. Julia alg = DE ( p_num = 10 , ini_population = missing , max_episode = 1000 , c = 1.0 , cr = 0.5 ) The keywords and the default values of DE can be seen in the following table \\(~~~~~~~~~~\\) keywords \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"p_num\" 10 \"ini_population\" missing \"max_episode\" 1000 \"c\" 1.0 \"cr\" 0.5 ini_population is a tuple representing the initial guesses of control and max_episode represents the number of populations and episodes. c and cr are the mutation constant and the crossover constant. DDPG \u00b6 The code for control optimization with DDPG is as follows Python control = ControlOpt ( method = \"DDPG\" , ** kwargs ) where kwargs is of the form kwargs = { \"max_episode\" : 1000 , \"layer_num\" : 3 , \"layer_dim\" : 200 , \"seed\" : 1234 } The keywords and the default values of DDPG can be seen in the following table \\(~~~~~~~~~~\\) **kwargs \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"ctrl0\" [ ] \"max_episode\" 1000 \"layer_num\" 3 \"layer_dim\" 200 \"seed\" 1234 layer_num and layer_dim represent the number of layers (include the input and output layer) and the number of neurons in the hidden layer. Julia alg = DDPG ( max_episode = 1000 , layer_num = 3 , layer_dim = 200 , seed = 1234 ) The keywords and the default values of DE can be seen in the following table \\(~~~~~~~~~~\\) keywords \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"max_episode\" 1000 \"layer_num\" 3 \"layer_dim\" 200 \"seed\" 1234 layer_num and layer_dim represent the number of layers (include the input and output layer) and the number of neurons in the hidden layer. Example 5.1 In this example, the free evolution Hamiltonian of a single qubit system is \\(H_0=\\frac{1}{2}\\omega \\sigma_3\\) with \\(\\omega\\) the frequency and \\(\\sigma_3\\) a Pauli matrix. The dynamics of the system is governed by \\begin{align} \\partial_t\\rho=-i[H_0, \\rho]+ \\gamma_{+}\\left(\\sigma_{+}\\rho\\sigma_{-}-\\frac{1}{2}{\\sigma_{-} \\sigma_{+},\\rho}\\right)+ \\gamma_{-}\\left(\\sigma_{-}\\rho\\sigma_{+}-\\frac{1}{2}{\\sigma_{+}\\sigma_{-}, \\rho}\\right), \\end{align} where \\(\\gamma_{+}\\) , \\(\\gamma_{-}\\) are decay rates and \\(\\sigma_{\\pm}=(\\sigma_1 \\pm \\sigma_2)/2\\) . The control Hamiltonian \\begin{align} H_\\mathrm{c}=u_1(t)\\sigma_1+u_2(t)\\sigma_2+u_3(t)\\sigma_3. \\end{align} Here \\(\\sigma_{1}\\) , \\(\\sigma_{2}\\) are also Pauli matrices. The probe state is taken as \\(|+\\rangle\\) and the measurement for CFI is \\(\\{|+\\rangle\\langle+|, |-\\rangle\\langle-|\\}\\) with \\(|\\pm\\rangle:=\\frac{1}{\\sqrt{2}}(|0\\rangle\\pm|1\\rangle)\\) . \\(|0\\rangle\\) \\((|1\\rangle)\\) is the eigenstate of \\(\\sigma_3\\) with respect to the eigenvalue \\(1\\) \\((-1)\\) . Python from quanestimation import * import numpy as np # initial state rho0 = 0.5 * np . array ([[ 1. , 1. ], [ 1. , 1. ]]) # free Hamiltonian omega = 1.0 sx = np . array ([[ 0. , 1. ], [ 1. , 0. ]]) sy = np . array ([[ 0. , - 1. j ], [ 1. j , 0. ]]) sz = np . array ([[ 1. , 0. ], [ 0. , - 1. ]]) H0 = 0.5 * omega * sz # derivative of the free Hamiltonian on omega dH = [ 0.5 * sz ] # control Hamiltonians Hc = [ sx , sy , sz ] # dissipation sp = np . array ([[ 0. , 1. ], [ 0. , 0. ]]) sm = np . array ([[ 0. , 0. ], [ 1. , 0. ]]) decay = [[ sp , 0. ], [ sm , 0.1 ]] # measurement M1 = 0.5 * np . array ([[ 1. , 1. ], [ 1. , 1. ]]) M2 = 0.5 * np . array ([[ 1. , - 1. ], [ - 1. , 1. ]]) M = [ M1 , M2 ] # time length for the evolution tspan = np . linspace ( 0. , 10. , 2500 ) # guessed control coefficients cnum = len ( tspan ) - 1 ctrl0 = [ np . array ([ np . zeros ( cnum ), np . zeros ( cnum ), np . zeros ( cnum )])] auto-GRAPE # control algorithm: auto-GRAPE GRAPE_paras = { \"Adam\" : True , \"ctrl0\" : ctrl0 , \"max_episode\" : 300 , \\ \"epsilon\" : 0.01 , \"beta1\" : 0.90 , \"beta2\" : 0.99 } control = ControlOpt ( savefile = False , method = \"auto-GRAPE\" , ** GRAPE_paras ) GRAPE # control algorithm: GRAPE GRAPE_paras = { \"Adam\" : True , \"ctrl0\" : ctrl0 , \"max_episode\" : 300 , \\ \"epsilon\" : 0.01 , \"beta1\" : 0.90 , \"beta2\" : 0.99 } control = ControlOpt ( savefile = False , method = \"GRAPE\" , ** GRAPE_paras ) PSO # control algorithm: PSO PSO_paras = { \"p_num\" : 10 , \"ctrl0\" : ctrl0 , \"max_episode\" :[ 1000 , 100 ], \\ \"c0\" : 1.0 , \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } control = ControlOpt ( savefile = False , method = \"PSO\" , ** PSO_paras ) DE # control algorithm: DE DE_paras = { \"p_num\" : 10 , \"ctrl0\" : ctrl0 , \"max_episode\" : 1000 , \"c\" : 1.0 , \\ \"cr\" : 0.5 , \"seed\" : 1234 } control = ControlOpt ( savefile = False , method = \"DE\" , ** DE_paras ) DDPG # control algorithm: DDPG DDPG_paras = { \"layer_num\" : 4 , \"layer_dim\" : 220 , \"max_episode\" : 500 , \\ \"seed\" : 1234 } control = ControlOpt ( savefile = False , method = \"DDPG\" , ** DDPG_paras ) # input the dynamics data control . dynamics ( tspan , rho0 , H0 , dH , Hc , decay = decay , \\ ctrl_bound = [ - 2.0 , 2.0 ]) QFIM # objective function: QFI control . QFIM () CFIM # objective function: CFI control . CFIM ( M = M ) Julia using QuanEstimation using Random # initial state rho0 = 0.5 * ones ( 2 , 2 ) # free Hamiltonian omega = 1.0 sx = [ 0. 1. ; 1. 0.0 im ] sy = [ 0. - im ; im 0. ] sz = [ 1. 0.0 im ; 0. - 1. ] H0 = 0.5 * omega * sz # derivative of the free Hamiltonian on omega dH = [ 0.5 * sz ] # control Hamiltonians Hc = [ sx , sy , sz ] # dissipation sp = [ 0. 1. ; 0. 0.0 im ] sm = [ 0. 0. ; 1. 0.0 im ] decay = [[ sp , 0. ], [ sm , 0.1 ]] # measurement M1 = 0.5 * [ 1.0 + 0.0 im 1. ; 1. 1. ] M2 = 0.5 * [ 1.0 + 0.0 im - 1. ; - 1. 1. ] M = [ M1 , M2 ] # time length for the evolution tspan = range ( 0. , 10. , length = 2500 ) # guessed control coefficients cnum = length ( tspan ) - 1 ctrl = [ zeros ( cnum ) for _ in 1 : length ( Hc )] ctrl_bound = [ - 2. , 2. ] # set the optimization type opt = QuanEstimation . ControlOpt ( ctrl = ctrl , ctrl_bound = ctrl_bound , seed = 1234 ) auto-GRAPE # control algorithm: auto-GRAPE alg = QuanEstimation . autoGRAPE ( Adam = true , max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 ) GRAPE # control algorithm: GRAPE alg = QuanEstimation . GRAPE ( Adam = true , max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 ) PSO # control algorithm: PSO alg = QuanEstimation . PSO ( p_num = 10 , ini_particle = ([ ctrl ],), max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) DE # control algorithm: DE alg = QuanEstimation . DE ( p_num = 10 , ini_population = ([ ctrl ],), max_episode = 1000 , c = 1.0 , cr = 0.5 ) DDPG # control algorithm: DDPG alg = QuanEstimation . DDPG ( max_episode = 500 , layer_num = 4 , layer_dim = 220 ) # input the dynamics data dynamics = QuanEstimation . Lindblad ( opt , tspan , rho0 , H0 , dH , Hc , decay ) QFIM # objective function: QFI obj = QuanEstimation . QFIM_obj () CFIM # objective function: CFI obj = QuanEstimation . CFIM_obj ( M = M ) # run the control optimization problem QuanEstimation . run ( opt , alg , obj , dynamics ; savefile = false ) Example 5.2 In the multiparameter scenario, the dynamics of electron and nuclear coupling in NV \\(^{-}\\) can be expressed as \\begin{align} \\partial_t\\rho=-i[H_0,\\rho]+\\frac{\\gamma}{2}(S_3\\rho S_3-S^2_3\\rho-\\rho S^2_3) \\end{align} with \\(\\gamma\\) the dephasing rate. And \\begin{align} H_0/\\hbar=DS^2_3+g_{\\mathrm{S}}\\vec{B}\\cdot\\vec{S}+g_{\\mathrm{I}}\\vec{B}\\cdot\\vec{I}+\\vec{S}^ {\\,\\mathrm{T}}\\mathcal{A}\\vec{I} \\end{align} is the free evolution Hamiltonian, where \\(\\vec{S}=(S_1,S_2,S_3)^{\\mathrm{T}}\\) and \\(\\vec{I}=(I_1,I_2,I_3)^{\\mathrm{T}}\\) with \\(S_i=s_i\\otimes I\\) and \\(I_i=I\\otimes \\sigma_i\\) \\((i=1,2,3)\\) the electron and nuclear operators. \\(s_1, s_2, s_3\\) are spin-1 operators with \\[\\begin{eqnarray} s_1 = \\frac{1}{\\sqrt{2}}\\left(\\begin{array}{ccc} 0 & 1 & 0 \\\\ 1 & 0 & 1 \\\\ 0 & 1 & 0 \\end{array}\\right), s_2 = \\frac{1}{\\sqrt{2}}\\left(\\begin{array}{ccc} 0 & -i & 0\\\\ i & 0 & -i\\\\ 0 & i & 0 \\end{array}\\right)\\!\\!, \\nonumber \\end{eqnarray}\\] and \\(s_3=\\mathrm{diag}(1,0,-1)\\) and \\(\\sigma_i (i=1,2,3)\\) is Pauli matrix. \\(\\mathcal{A}=\\mathrm{diag} (A_1,A_1,A_2)\\) is the hyperfine tensor with \\(A_1\\) and \\(A_2\\) the axial and transverse magnetic hyperfine coupling coefficients. The coefficients \\(g_{\\mathrm{S}}=g_\\mathrm{e}\\mu_\\mathrm{B}/\\hbar\\) and \\(g_{\\mathrm{I}}=g_\\mathrm{n}\\mu_\\mathrm{n}/\\hbar\\) , where \\(g_\\mathrm{e}\\) ( \\(g_\\mathrm{n}\\) ) is the \\(g\\) factor of the electron (nuclear), \\(\\mu_\\mathrm{B}\\) ( \\(\\mu_\\mathrm{n}\\) ) is the Bohr (nuclear) magneton and \\(\\hbar\\) is the Plank's constant. \\(\\vec{B}\\) is the magnetic field which be estimated. In this case,the initial state is taken as \\(\\frac{1}{\\sqrt{2}}(|1\\rangle+|\\!-\\!1\\rangle)\\otimes |\\!\\!\\uparrow\\rangle\\) , where \\(\\frac{1}{\\sqrt{2}}(|1\\rangle+|\\!-\\!1\\rangle)\\) is an electron state with \\(|1\\rangle\\) ( \\(|\\!-\\!1\\rangle\\) ) the eigenstate of \\(s_3\\) with respect to the eigenvalue \\(1\\) ( \\(-1\\) ). \\(|\\!\\!\\uparrow\\rangle\\) is a nuclear state and the eigenstate of \\(\\sigma_3\\) with respect to the eigenvalue 1. \\(W\\) is set to be identity. Here three types of measurement optimization are considerd, projective measurement, linear combination of a given set of positive operator-valued measure (POVM) and optimal rotated measurement of an input measurement. Python from quanestimation import * import numpy as np from numpy.random import random # initial state rho0 = np . zeros (( 6 , 6 ), dtype = np . complex128 ) rho0 [ 0 ][ 0 ], rho0 [ 0 ][ 4 ], rho0 [ 4 ][ 0 ], rho0 [ 4 ][ 4 ] = 0.5 , 0.5 , 0.5 , 0.5 # free Hamiltonian sx = np . array ([[ 0. , 1. ],[ 1. , 0. ]]) sy = np . array ([[ 0. , - 1. j ],[ 1. j , 0. ]]) sz = np . array ([[ 1. , 0. ],[ 0. , - 1. ]]) ide2 = np . array ([[ 1. , 0. ],[ 0. , 1. ]]) s1 = np . array ([[ 0. , 1. , 0. ],[ 1. , 0. , 1. ],[ 0. , 1. , 0. ]]) / np . sqrt ( 2 ) s2 = np . array ([[ 0. , - 1. j , 0. ],[ 1. j , 0. , - 1. j ],[ 0. , 1. j , 0. ]]) / np . sqrt ( 2 ) s3 = np . array ([[ 1. , 0. , 0. ],[ 0. , 0. , 0. ],[ 0. , 0. , - 1. ]]) ide3 = np . array ([[ 1. , 0. , 0. ],[ 0. , 1. , 0. ],[ 0. , 0. , 1. ]]) I1 , I2 , I3 = np . kron ( ide3 , sx ), np . kron ( ide3 , sy ), np . kron ( ide3 , sz ) S1 , S2 , S3 = np . kron ( s1 , ide2 ), np . kron ( s2 , ide2 ), np . kron ( s3 , ide2 ) B1 , B2 , B3 = 5.0e-4 , 5.0e-4 , 5.0e-4 # All numbers are divided by 100 in this example # for better calculation accurancy cons = 100 D = ( 2 * np . pi * 2.87 * 1000 ) / cons gS = ( 2 * np . pi * 28.03 * 1000 ) / cons gI = ( 2 * np . pi * 4.32 ) / cons A1 = ( 2 * np . pi * 3.65 ) / cons A2 = ( 2 * np . pi * 3.03 ) / cons H0 = D * np . kron ( np . dot ( s3 , s3 ), ide2 ) + gS * ( B1 * S1 + B2 * S2 + B3 * S3 ) \\ + gI * ( B1 * I1 + B2 * I2 + B3 * I3 ) + A1 * ( np . kron ( s1 , sx ) + np . kron ( s2 , sy )) \\ + A2 * np . kron ( s3 , sz ) # derivatives of the free Hamiltonian on B1, B2 and B3 dH = [ gS * S1 + gI * I1 , gS * S2 + gI * I2 , gS * S3 + gI * I3 ] # control Hamiltonians Hc = [ S1 , S2 , S3 ] # dissipation decay = [[ S3 , 2 * np . pi / cons ]] # measurement dim = len ( rho0 ) M = [ np . dot ( basis ( dim , i ), basis ( dim , i ) . conj () . T ) for i in range ( dim )] # time length for the evolution tspan = np . linspace ( 0. , 2. , 4000 ) # guessed control coefficients cnum = 10 np . random . seed ( 1234 ) ini_1 = np . zeros (( len ( Hc ), cnum )) ini_2 = 0.2 * np . ones (( len ( Hc ), cnum )) ini_3 = - 0.2 * np . ones (( len ( Hc ), cnum )) ini_4 = np . array ([ np . linspace ( - 0.2 , 0.2 , cnum ) for i in range ( len ( Hc ))]) ini_5 = np . array ([ np . linspace ( - 0.2 , 0.0 , cnum ) for i in range ( len ( Hc ))]) ini_6 = np . array ([ np . linspace ( 0 , 0.2 , cnum ) for i in range ( len ( Hc ))]) ini_7 = - 0.2 * np . ones (( len ( Hc ), cnum )) + 0.01 * random (( len ( Hc ), cnum )) ini_8 = - 0.2 * np . ones (( len ( Hc ), cnum )) + 0.01 * random (( len ( Hc ), cnum )) ini_9 = - 0.2 * np . ones (( len ( Hc ), cnum )) + 0.05 * random (( len ( Hc ), cnum )) ini_10 = - 0.2 * np . ones (( len ( Hc ), cnum )) + 0.05 * random (( len ( Hc ), cnum )) ctrl0 = [ ini_1 , ini_2 , ini_3 , ini_4 , ini_5 , \\ ini_6 , ini_7 , ini_8 , ini_9 , ini_10 ] auto-GRAPE # control algorithm: auto-GRAPE GRAPE_paras = { \"Adam\" : True , \"ctrl0\" : ctrl0 , \"max_episode\" : 300 , \\ \"epsilon\" : 0.01 , \"beta1\" : 0.90 , \"beta2\" : 0.99 } control = ControlOpt ( savefile = False , method = \"auto-GRAPE\" , ** GRAPE_paras ) PSO # control algorithm: PSO PSO_paras = { \"p_num\" : 10 , \"ctrl0\" : ctrl0 , \"max_episode\" :[ 1000 , 100 ], \\ \"c0\" : 1.0 , \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } control = ControlOpt ( savefile = False , method = \"PSO\" , ** PSO_paras ) DE # control algorithm: DE DE_paras = { \"p_num\" : 10 , \"ctrl0\" : ctrl0 , \"max_episode\" : 1000 , \"c\" : 1.0 , \\ \"cr\" : 0.5 , \"seed\" : 1234 } control = ControlOpt ( savefile = False , method = \"DE\" , ** DE_paras ) DDPG # control algorithm: DDPG DDPG_paras = { \"layer_num\" : 4 , \"layer_dim\" : 220 , \"max_episode\" : 500 , \\ \"seed\" : 1234 } control = ControlOpt ( savefile = False , method = \"DDPG\" , ** DDPG_paras ) # input the dynamics data control . dynamics ( tspan , rho0 , H0 , dH , Hc , decay = decay , \\ ctrl_bound = [ - 0.2 , 0.2 ]) QFIM # objective function: tr(WF^{-1}) control . QFIM () CFIM # objective function: tr(WI^{-1}) control . CFIM ( M = M ) HCRB # objective function: HCRB control . HCRB () Julia using QuanEstimation using Random using LinearAlgebra # initial state rho0 = zeros ( ComplexF64 , 6 , 6 ) rho0 [ 1 : 4 : 5 , 1 : 4 : 5 ] .= 0.5 dim = size ( rho0 , 1 ) # Hamiltonian sx = [ 0. 1. ; 1. 0. ] sy = [ 0. - im ; im 0. ] sz = [ 1. 0. ; 0. - 1. ] s1 = [ 0. 1. 0. ; 1. 0. 1. ; 0. 1. 0. ] / sqrt ( 2 ) s2 = [ 0. - im 0. ; im 0. - im ; 0. im 0. ] / sqrt ( 2 ) s3 = [ 1. 0. 0. ; 0. 0. 0. ; 0. 0. - 1. ] Is = I1 , I2 , I3 = [ kron ( I ( 3 ), sx ), kron ( I ( 3 ), sy ), kron ( I ( 3 ), sz )] S = S1 , S2 , S3 = [ kron ( s1 , I ( 2 )), kron ( s2 , I ( 2 )), kron ( s3 , I ( 2 ))] B = B1 , B2 , B3 = [ 5.0e-4 , 5.0e-4 , 5.0e-4 ] # All numbers are divided by 100 in this example # for better calculation accurancy cons = 100 D = ( 2 pi * 2.87 * 1000 ) / cons gS = ( 2 pi * 28.03 * 1000 ) / cons gI = ( 2 pi * 4.32 ) / cons A1 = ( 2 pi * 3.65 ) / cons A2 = ( 2 pi * 3.03 ) / cons H0 = sum ([ D * kron ( s3 ^ 2 , I ( 2 )), sum ( gS * B .* S ), sum ( gI * B .* Is ), A1 * ( kron ( s1 , sx ) + kron ( s2 , sy )), A2 * kron ( s3 , sz )]) # derivatives of the free Hamiltonian on B1, B2 and B3 dH = gS * S + gI * Is # control Hamiltonians Hc = [ S1 , S2 , S3 ] # dissipation decay = [[ S3 , 2 * pi / cons ]] # measurement M = [ QuanEstimation . basis ( dim , i ) * QuanEstimation . basis ( dim , i ) ' \\ for i in 1 : dim ] # time length for the evolution tspan = range ( 0. , 2. , length = 4000 ) # guessed control coefficients cnum = 10 rng = MersenneTwister ( 1234 ) cnum = length ( Hc ) ini_1 = [ zeros ( cnum ) for _ in 1 : cnum ] ini_2 = 0.2 .* [ ones ( cnum ) for _ in 1 : cnum ] ini_3 = - 0.2 .* [ ones ( cnum ) for _ in 1 : cnum ] ini_4 = [[ range ( - 0.2 , 0.2 , length = cnum ) ... ] for _ in 1 : cnum ] ini_5 = [[ range ( - 0.2 , 0. , length = cnum ) ... ] for _ in 1 : cnum ] ini_6 = [[ range ( 0. , 0.2 , length = cnum ) ... ] for _ in 1 : cnum ] ini_7 = [ - 0.2 * ones ( cnum ) + 0.01 * rand ( rng , cnum ) for _ in 1 : cnum ] ini_8 = [ - 0.2 * ones ( cnum ) + 0.01 * rand ( rng , cnum ) for _ in 1 : cnum ] ini_9 = [ - 0.2 * ones ( cnum ) + 0.05 * rand ( rng , cnum ) for _ in 1 : cnum ] ini_10 = [ - 0.2 * ones ( cnum ) + 0.05 * rand ( rng , cnum ) for _ in 1 : cnum ] ctrl0 = [ Symbol ( \"ini_\" , i ) |> eval for i in 1 : 10 ] # set the optimization type opt = QuanEstimation . ControlOpt ( ctrl = ini_1 , ctrl_bound = [ - 0.2 , 0.2 ], seed = 1234 ) auto-GRAPE # control algorithm: auto-GRAPE alg = QuanEstimation . autoGRAPE ( Adam = true , max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 ) GRAPE # control algorithm: GRAPE alg = QuanEstimation . GRAPE ( Adam = true , max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 ) PSO # control algorithm: PSO alg = QuanEstimation . PSO ( p_num = 10 , ini_particle = ([ ctrl ],), max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) DE # control algorithm: DE alg = QuanEstimation . DE ( p_num = 10 , ini_population = ([ ctrl ],), max_episode = 1000 , c = 1.0 , cr = 0.5 ) DDPG # control algorithm: DDPG alg = QuanEstimation . DDPG ( max_episode = 500 , layer_num = 4 , layer_dim = 220 ) # input the dynamics data dynamics = QuanEstimation . Lindblad ( opt , tspan , rho0 , H0 , dH , Hc , decay ) QFIM # objective function: tr(WF^{-1}) obj = QuanEstimation . QFIM_obj () CFIM # objective function: tr(WI^{-1}) obj = QuanEstimation . CFIM_obj ( M = M ) HCRB # objective function: HCRB obj = QuanEstimation . HCRB_obj ( M = M ) # run the control optimization problem QuanEstimation . run ( opt , alg , obj , dynamics ; savefile = false ) Minimum parameterization time optimization \u00b6 Search of the minimum time to reach a given value of the objective function. Python control . mintime ( f , W = [], M = [], method = \"binary\" , target = \"QFIM\" , LDtype = \"SLD\" ) Julia mintime ( f , opt , alg , obj , dynamics ; method = \"binary\" , savefile = false ) f is the given value of the objective function. In the package, two methods for searching the minimum time are provided which are logarithmic search and forward search from the beginning of time. It can be realized by setting method=binary (default) and method=forward . target represents the objective function for searching the minimum time, the users can choose QFI \\(\\left[\\mathrm{Tr}(WF^{-1})\\right]\\) , CFI \\(\\left[\\mathrm{Tr}(WI^{-1})\\right]\\) and HCRB for the objective functions. If target=\"QFIM\" , the types for the logarithmic derivatives can be set via LDtype . Bibliography \u00b6 [1] N. Khaneja, T. Reiss, C. Hehlet, T. Schulte-Herbruggen, and S. J. Glaser, Optimal control of coupled spin dynamics: Design of NMR pulse sequences by gradient ascent algorithms, J. Magn. Reson. 172 , 296 (2005). [2] J. Liu and H. Yuan, Quantum parameter estimation with optimal control, Phys. Rev. A 96 , 012117 (2017). [3] J. Liu and H. Yuan, Control-enhanced multiparameter quantum estimation, Phys. Rev. A 96 , 042114 (2017). [4] A. G. Baydin, B. A. Pearlmutter, A. A. Radul, and J. M. Siskind, Automatic differentiation in machine learning: a survey, J. Mach. Learn. Res. 18 , 1-43 (2018). [5] J. Kennedy and R. Eberhar, Particle swarm optimization, Proc. 1995 IEEE International Conference on Neural Networks 4 , 1942-1948 (1995). [6] R. Storn and K. Price, Differential Evolution-A Simple and Efficient Heuristic for global Optimization over Continuous Spaces, J. Global Optim. 11 , 341 (1997). [7] T. P. Lillicrap, J. J. Hunt, A. Pritzel, N. Heess, T. Erez, Y. Tassa, D. Silver, and D. Wierstra, Continuous control with deep reinforcement learning, arXiv:1509.02971.","title":"Control optimization"},{"location":"guide/guide_Copt/#control-optimization","text":"The Hamiltonian of a controlled system can be written as \\begin{align} H = H_0(\\textbf{x})+\\sum_{k=1}^K u_k(t) H_k, \\end{align} where \\(H_0(\\textbf{x})\\) is the free evolution Hamiltonian with unknown parameters \\(\\textbf{x}\\) and \\(H_k\\) represents the \\(k\\) th control Hamiltonian with \\(u_k\\) the corresponding control coefficients. In QuanEstimation, different algorithms are invoked to update the control coefficients. The control optimization algorithms are the gradient ascent pulse engineering (GRAPE) [1,2,3] , GRAPE algorithm based on the automatic differentiation (auto-GRAPE) [4] , particle swarm optimization (PSO) [5] , differential evolution (DE) [6] and deep deterministic policy gradients (DDPG) [7] . The codes for control optimization are Python control = ControlOpt ( savefile = False , method = \"auto-GRAPE\" , ** kwargs ) control . dynamics ( tspan , rho0 , H0 , dH , Hc , decay = [], ctrl_bound = []) QFIM control . QFIM ( W = [], LDtype = \"SLD\" ) CFIM control . CFIM ( M = [], W = []) HCRB control . HCRB ( W = []) In QuanEstimation, the optimization codes are executed in Julia and the data will be saved in the .csv file. The variable savefile indicates whether to save all the control coefficients and its default value is False which means the control coefficients for the final episode and the values of the objective function in all episodes will be saved in \"controls.csv\" and \"f.csv\", respectively. If set True then the control coefficients and the values of the objective function in all episodes will be saved during the training. The package contains five control optimization algorithms which can be set via method , **kwargs is the corresponding keyword and default value. After calling control = ControlOpt() , the dynamics parameters shoule be input. Here tspan is the time length for the evolution and rho0 represents the density matrix of the initial state. H0 and dH are the free Hamiltonian and its derivatives with respect to the unknown parameters to be estimated. H0 is a matrix when the free Hamiltonian is time-independent and a list with the length equal to tspan when it is time-dependent. dH should be input as \\([\\partial_a{H_0}, \\partial_b{H_0}, \\cdots]\\) . Hc is a list representing the control Hamiltonians. decay contains decay operators \\((\\Gamma_1, \\Gamma_2, \\cdots)\\) and the corresponding decay rates \\((\\gamma_1, \\gamma_2, \\cdots)\\) , its input rule is decay=[[ \\(\\Gamma_1\\) , \\(\\gamma_1\\) ], [ \\(\\Gamma_2\\) , \\(\\gamma_2\\) ],...]. The default value for decay is empty which means the dynamics is unitary. The package can be used to optimize bounded control problems by setting lower and upper bounds of the control coefficients via ctrl_bound , which is an array with two elements representing the lower and upper bound of each control coefficient, respectively. The default value of ctrl_bound=[] which means the control coefficients are in the regime \\([-\\infty,\\infty]\\) . The objective functions for control optimization can be set as QFI \\(\\left[\\mathrm{Tr}(W \\mathcal{F}^{-1})\\right]\\) , CFI \\(\\left[\\mathrm{Tr}(W\\mathcal{I}^{-1})\\right]\\) and HCRB, the corresponding codes for them are control.QFIM() (default), control.CFIM() and control.HCRB() . Here \\(\\mathcal{F}\\) and \\(\\mathcal{I}\\) are the QFIM and CFIM, \\(W\\) corresponds to W is the weight matrix which defaults to the identity matrix. If the users call control.HCRB() for single parameter scenario, the program will exit and print \"Program terminated. In the single-parameter scenario, the HCRB is equivalent to the QFI. Please choose 'QFIM' as the objective function\" . LDtype in control.QFIM() represents the types of the QFIM, it can be set as LDtype=\"SLD\" (default), LDtype=\"RLD\" , and LDtype=\"LLD\" . M in control.CFIM() represents a set of positive operator-valued measure (POVM) with default value [] which means a set of rank-one symmetric informationally complete POVM (SIC-POVM) is used in the calculation. Julia opt = ControlOpt ( ctrl = ctrl , ctrl_bound = ctrl_bound , seed = 1234 ) alg = autoGRAPE ( kwargs ... ) dynamics = Lindblad ( opt , tspan , rho0 , H0 , dH , Hc , decay = mising ) QFIM obj = QFIM_obj ( W = missing , LDtype = :SLD ) CFIM obj = CFIM_obj ( M = missing , W = missing ) HCRB obj = HCRB_obj ( W = missing ) run ( opt , alg , obj , dynamics ; savefile = false ) In control optimization, a set of control coefficients (optimization variable) and its boundary value can be input via ctrl=ctrl and ctrl_bound=ctrl_bound in ControlOpt() . ctrl is a list of arrays with the length equal to control Hamiltonians, ctrl_bound is an array with two elements representing the lower and upper bound of the control coefficients, respectively. The default value of ctrl_bound=missing which means the control coefficients are in the regime \\([-\\infty,\\infty]\\) . seed is the random seed which can ensure the reproducibility of results. The package can deal with the parameterization process in the form of master equation, the dynamics parameters shoule be input via Lindblad() . Here tspan is the time length for the evolution and rho0 represents the density matrix of the initial state. H0 and dH are the free Hamiltonian and its derivatives with respect to the unknown parameters to be estimated. H0 is a matrix when the free Hamiltonian is time-independent and a list with the length equal to tspan when it is time-dependent. dH should be input as \\([\\partial_a{H_0}, \\partial_b{H_0}, \\cdots]\\) . Hc is a list representing the control Hamiltonians. decay contains decay operators \\((\\Gamma_1, \\Gamma_2, \\cdots)\\) and the corresponding decay rates \\((\\gamma_1, \\gamma_2, \\cdots)\\) with the input rule decay=[[ \\(\\Gamma_1\\) , \\(\\gamma_1\\) ], [ \\(\\Gamma_2\\) , \\(\\gamma_2\\) ],...]. The default value decay is missing which means the dynamics is unitary. The objective functions for control optimization can be set as QFI \\(\\left[\\mathrm{Tr}(W \\mathcal{F}^{-1})\\right]\\) , CFI \\(\\left[\\mathrm{Tr}(W\\mathcal{I}^{-1})\\right]\\) and HCRB, the corresponding codes for them are QFIM_obj() (default), CFIM_obj() and HCRB_obj() . Here \\(\\mathcal{F}\\) and \\(\\mathcal{I}\\) are the QFIM and CFIM, \\(W\\) corresponds to W is the weight matrix which defaults to the identity matrix. If the users call HCRB_obj() for single parameter scenario, the program will exit and print \"Program terminated. In the single-parameter scenario, the HCRB is equivalent to the QFI. Please choose 'QFIM_obj' as the objective function\" . LDtype in QFIM_obj() represents the types of the QFIM, it can be set as LDtype=:SLD (default), LDtype=:RLD , and LDtype=:LLD . M in CFIM_obj() represents a set of positive operator-valued measure (POVM) with default value missing which means a set of rank-one symmetric informationally complete POVM (SIC-POVM) is used in the calculation. The variable savefile indicates whether to save all the control coefficients and its default value is false which means the control coefficients for the final episode and the values of the objective function in all episodes will be saved in \"controls.csv\" and \"f.csv\", respectively. If set true then the control coefficients and the values of the objective function in all episodes will be saved during the training. The algorithm used for optimizing the control coefficients in QuanEstimation are GRAPE, auto-GRAPE, PSO, DE and DDPG. kwargs... contains the keywords and defaults value corresponding to the optimization algorithm which will be introduced in detail below.","title":"Control optimization"},{"location":"guide/guide_Copt/#grape-and-auto-grape","text":"The codes for control optimization with GRAPE and auto-GRAPE are as follows Python control = ControlOpt ( method = \"GRAPE\" , ** kwargs ) control = ControlOpt ( method = \"auto-GRAPE\" , ** kwargs ) where kwargs is of the form kwargs = { \"Adam\" : True , \"ctrl0\" :[], \"max_episode\" : 300 , \"epsilon\" : 0.01 , \\ \"beta1\" : 0.90 , \"beta2\" : 0.99 } The keywords and the default values of GRAPE and auto-GRAPE can be seen in the following table \\(~~~~~~~~~~\\) **kwargs \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"Adam\" True \"ctrl0\" [ ] \"max_episode\" 300 \"epsilon\" 0.01 \"beta1\" 0.90 \"beta2\" 0.99 Adam algorithm can be introduced to update the control coefficients when using GRAPE and auto-GRAPE for control optimization, which can be realized by setting Adam=True . In this case, the Adam parameters include learning rate, the exponential decay rate for the first moment estimates and the second moment estimates can be set by the users via epsilon , beta1 and beta2 , respectively. If Adam=False , the control coefficients will update according to the learning rate \"epsilon\" . ctrl0 is a list representing the initial guesses of control coefficients and max_episode is the number of episodes. Julia alg = GRAPE ( Adam = true , max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 ) alg = autoGRAPE ( Adam = true , max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 ) The keywords and the default values of GRAPE and auto-GRAPE can be seen in the following table \\(~~~~~~~~~~\\) keywords \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"Adam\" true \"max_episode\" 300 \"epsilon\" 0.01 \"beta1\" 0.90 \"beta2\" 0.99 Adam algorithm can be introduced to update the control coefficients when using GRAPE and auto-GRAPE for control optimization, which can be realized by setting Adam=true . In this case, the Adam parameters include learning rate, the exponential decay rate for the first moment estimates and the second moment estimates can be set by the users via epsilon , beta1 and beta2 , respectively. If Adam=false , the control coefficients will update according to the learning rate \"epsilon\" .","title":"GRAPE and auto-GRAPE"},{"location":"guide/guide_Copt/#pso","text":"The code for control optimization with PSO is as follows Python control = ControlOpt ( method = \"PSO\" , ** kwargs ) where kwargs is of the form kwargs = { \"p_num\" : 10 , \"ctrl0\" :[], \"max_episode\" :[ 1000 , 100 ], \\ \"c0\" : 1.0 , \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } The keywords and the default values of PSO can be seen in the following table \\(~~~~~~~~~~\\) **kwargs \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"p_num\" 10 \"ctrl0\" [ ] \"max_episode\" [1000,100] \"c0\" 1.0 \"c1\" 2.0 \"c2\" 2.0 \"seed\" 1234 Here p_num is the number of particles. c0 , c1 and c2 are the PSO parameters representing the inertia weight, cognitive learning factor and social learning factor, respectively. max_episode accepts both integer and array with two elements. If it is an integer, for example max_episode=1000 , it means the program will continuously run 1000 episodes. However, if it is an array, for example max_episode=[1000,100] , the program will run 1000 episodes in total but replace control coefficients of all the particles with global best every 100 episodes. seed is the random seed which can ensure the reproducibility of the results. Julia alg = PSO ( p_num = 10 , ini_particle = missing , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) The keywords and the default values of PSO can be seen in the following table \\(~~~~~~~~~~\\) keywords \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"p_num\" 10 \"ini_particle\" missing \"max_episode\" [1000,100] \"c0\" 1.0 \"c1\" 2.0 \"c2\" 2.0 Here p_num is the number of particles. c0 , c1 and c2 are the PSO parameters representing the inertia weight, cognitive learning factor and social learning factor, respectively. max_episode accepts both integer and array with two elements. If it is an integer, for example max_episode=1000 , it means the program will continuously run 1000 episodes. However, if it is an array, for example max_episode=[1000,100] , the program will run 1000 episodes in total but replace control coefficients of all the particles with global best every 100 episodes. ini_particle is a tuple representing the initial guesses of control coefficients.","title":"PSO"},{"location":"guide/guide_Copt/#de","text":"The code for control optimization with DE is as follows Python control = ControlOpt ( method = \"DE\" , ** kwargs ) where kwargs is of the form kwargs = { \"p_num\" : 10 , \"ctrl0\" :[], \"max_episode\" : 1000 , \"c\" : 1.0 , \\ \"cr\" : 0.5 , \"seed\" : 1234 } The keywords and the default values of DE can be seen in the following table \\(~~~~~~~~~~\\) **kwargs \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"p_num\" 10 \"ctrl0\" [ ] \"max_episode\" 1000 \"c\" 1.0 \"cr\" 0.5 \"seed\" 1234 p_num and max_episode represent the number of populations and episodes. c and cr are the mutation constant and the crossover constant. Julia alg = DE ( p_num = 10 , ini_population = missing , max_episode = 1000 , c = 1.0 , cr = 0.5 ) The keywords and the default values of DE can be seen in the following table \\(~~~~~~~~~~\\) keywords \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"p_num\" 10 \"ini_population\" missing \"max_episode\" 1000 \"c\" 1.0 \"cr\" 0.5 ini_population is a tuple representing the initial guesses of control and max_episode represents the number of populations and episodes. c and cr are the mutation constant and the crossover constant.","title":"DE"},{"location":"guide/guide_Copt/#ddpg","text":"The code for control optimization with DDPG is as follows Python control = ControlOpt ( method = \"DDPG\" , ** kwargs ) where kwargs is of the form kwargs = { \"max_episode\" : 1000 , \"layer_num\" : 3 , \"layer_dim\" : 200 , \"seed\" : 1234 } The keywords and the default values of DDPG can be seen in the following table \\(~~~~~~~~~~\\) **kwargs \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"ctrl0\" [ ] \"max_episode\" 1000 \"layer_num\" 3 \"layer_dim\" 200 \"seed\" 1234 layer_num and layer_dim represent the number of layers (include the input and output layer) and the number of neurons in the hidden layer. Julia alg = DDPG ( max_episode = 1000 , layer_num = 3 , layer_dim = 200 , seed = 1234 ) The keywords and the default values of DE can be seen in the following table \\(~~~~~~~~~~\\) keywords \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"max_episode\" 1000 \"layer_num\" 3 \"layer_dim\" 200 \"seed\" 1234 layer_num and layer_dim represent the number of layers (include the input and output layer) and the number of neurons in the hidden layer. Example 5.1 In this example, the free evolution Hamiltonian of a single qubit system is \\(H_0=\\frac{1}{2}\\omega \\sigma_3\\) with \\(\\omega\\) the frequency and \\(\\sigma_3\\) a Pauli matrix. The dynamics of the system is governed by \\begin{align} \\partial_t\\rho=-i[H_0, \\rho]+ \\gamma_{+}\\left(\\sigma_{+}\\rho\\sigma_{-}-\\frac{1}{2}{\\sigma_{-} \\sigma_{+},\\rho}\\right)+ \\gamma_{-}\\left(\\sigma_{-}\\rho\\sigma_{+}-\\frac{1}{2}{\\sigma_{+}\\sigma_{-}, \\rho}\\right), \\end{align} where \\(\\gamma_{+}\\) , \\(\\gamma_{-}\\) are decay rates and \\(\\sigma_{\\pm}=(\\sigma_1 \\pm \\sigma_2)/2\\) . The control Hamiltonian \\begin{align} H_\\mathrm{c}=u_1(t)\\sigma_1+u_2(t)\\sigma_2+u_3(t)\\sigma_3. \\end{align} Here \\(\\sigma_{1}\\) , \\(\\sigma_{2}\\) are also Pauli matrices. The probe state is taken as \\(|+\\rangle\\) and the measurement for CFI is \\(\\{|+\\rangle\\langle+|, |-\\rangle\\langle-|\\}\\) with \\(|\\pm\\rangle:=\\frac{1}{\\sqrt{2}}(|0\\rangle\\pm|1\\rangle)\\) . \\(|0\\rangle\\) \\((|1\\rangle)\\) is the eigenstate of \\(\\sigma_3\\) with respect to the eigenvalue \\(1\\) \\((-1)\\) . Python from quanestimation import * import numpy as np # initial state rho0 = 0.5 * np . array ([[ 1. , 1. ], [ 1. , 1. ]]) # free Hamiltonian omega = 1.0 sx = np . array ([[ 0. , 1. ], [ 1. , 0. ]]) sy = np . array ([[ 0. , - 1. j ], [ 1. j , 0. ]]) sz = np . array ([[ 1. , 0. ], [ 0. , - 1. ]]) H0 = 0.5 * omega * sz # derivative of the free Hamiltonian on omega dH = [ 0.5 * sz ] # control Hamiltonians Hc = [ sx , sy , sz ] # dissipation sp = np . array ([[ 0. , 1. ], [ 0. , 0. ]]) sm = np . array ([[ 0. , 0. ], [ 1. , 0. ]]) decay = [[ sp , 0. ], [ sm , 0.1 ]] # measurement M1 = 0.5 * np . array ([[ 1. , 1. ], [ 1. , 1. ]]) M2 = 0.5 * np . array ([[ 1. , - 1. ], [ - 1. , 1. ]]) M = [ M1 , M2 ] # time length for the evolution tspan = np . linspace ( 0. , 10. , 2500 ) # guessed control coefficients cnum = len ( tspan ) - 1 ctrl0 = [ np . array ([ np . zeros ( cnum ), np . zeros ( cnum ), np . zeros ( cnum )])] auto-GRAPE # control algorithm: auto-GRAPE GRAPE_paras = { \"Adam\" : True , \"ctrl0\" : ctrl0 , \"max_episode\" : 300 , \\ \"epsilon\" : 0.01 , \"beta1\" : 0.90 , \"beta2\" : 0.99 } control = ControlOpt ( savefile = False , method = \"auto-GRAPE\" , ** GRAPE_paras ) GRAPE # control algorithm: GRAPE GRAPE_paras = { \"Adam\" : True , \"ctrl0\" : ctrl0 , \"max_episode\" : 300 , \\ \"epsilon\" : 0.01 , \"beta1\" : 0.90 , \"beta2\" : 0.99 } control = ControlOpt ( savefile = False , method = \"GRAPE\" , ** GRAPE_paras ) PSO # control algorithm: PSO PSO_paras = { \"p_num\" : 10 , \"ctrl0\" : ctrl0 , \"max_episode\" :[ 1000 , 100 ], \\ \"c0\" : 1.0 , \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } control = ControlOpt ( savefile = False , method = \"PSO\" , ** PSO_paras ) DE # control algorithm: DE DE_paras = { \"p_num\" : 10 , \"ctrl0\" : ctrl0 , \"max_episode\" : 1000 , \"c\" : 1.0 , \\ \"cr\" : 0.5 , \"seed\" : 1234 } control = ControlOpt ( savefile = False , method = \"DE\" , ** DE_paras ) DDPG # control algorithm: DDPG DDPG_paras = { \"layer_num\" : 4 , \"layer_dim\" : 220 , \"max_episode\" : 500 , \\ \"seed\" : 1234 } control = ControlOpt ( savefile = False , method = \"DDPG\" , ** DDPG_paras ) # input the dynamics data control . dynamics ( tspan , rho0 , H0 , dH , Hc , decay = decay , \\ ctrl_bound = [ - 2.0 , 2.0 ]) QFIM # objective function: QFI control . QFIM () CFIM # objective function: CFI control . CFIM ( M = M ) Julia using QuanEstimation using Random # initial state rho0 = 0.5 * ones ( 2 , 2 ) # free Hamiltonian omega = 1.0 sx = [ 0. 1. ; 1. 0.0 im ] sy = [ 0. - im ; im 0. ] sz = [ 1. 0.0 im ; 0. - 1. ] H0 = 0.5 * omega * sz # derivative of the free Hamiltonian on omega dH = [ 0.5 * sz ] # control Hamiltonians Hc = [ sx , sy , sz ] # dissipation sp = [ 0. 1. ; 0. 0.0 im ] sm = [ 0. 0. ; 1. 0.0 im ] decay = [[ sp , 0. ], [ sm , 0.1 ]] # measurement M1 = 0.5 * [ 1.0 + 0.0 im 1. ; 1. 1. ] M2 = 0.5 * [ 1.0 + 0.0 im - 1. ; - 1. 1. ] M = [ M1 , M2 ] # time length for the evolution tspan = range ( 0. , 10. , length = 2500 ) # guessed control coefficients cnum = length ( tspan ) - 1 ctrl = [ zeros ( cnum ) for _ in 1 : length ( Hc )] ctrl_bound = [ - 2. , 2. ] # set the optimization type opt = QuanEstimation . ControlOpt ( ctrl = ctrl , ctrl_bound = ctrl_bound , seed = 1234 ) auto-GRAPE # control algorithm: auto-GRAPE alg = QuanEstimation . autoGRAPE ( Adam = true , max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 ) GRAPE # control algorithm: GRAPE alg = QuanEstimation . GRAPE ( Adam = true , max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 ) PSO # control algorithm: PSO alg = QuanEstimation . PSO ( p_num = 10 , ini_particle = ([ ctrl ],), max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) DE # control algorithm: DE alg = QuanEstimation . DE ( p_num = 10 , ini_population = ([ ctrl ],), max_episode = 1000 , c = 1.0 , cr = 0.5 ) DDPG # control algorithm: DDPG alg = QuanEstimation . DDPG ( max_episode = 500 , layer_num = 4 , layer_dim = 220 ) # input the dynamics data dynamics = QuanEstimation . Lindblad ( opt , tspan , rho0 , H0 , dH , Hc , decay ) QFIM # objective function: QFI obj = QuanEstimation . QFIM_obj () CFIM # objective function: CFI obj = QuanEstimation . CFIM_obj ( M = M ) # run the control optimization problem QuanEstimation . run ( opt , alg , obj , dynamics ; savefile = false ) Example 5.2 In the multiparameter scenario, the dynamics of electron and nuclear coupling in NV \\(^{-}\\) can be expressed as \\begin{align} \\partial_t\\rho=-i[H_0,\\rho]+\\frac{\\gamma}{2}(S_3\\rho S_3-S^2_3\\rho-\\rho S^2_3) \\end{align} with \\(\\gamma\\) the dephasing rate. And \\begin{align} H_0/\\hbar=DS^2_3+g_{\\mathrm{S}}\\vec{B}\\cdot\\vec{S}+g_{\\mathrm{I}}\\vec{B}\\cdot\\vec{I}+\\vec{S}^ {\\,\\mathrm{T}}\\mathcal{A}\\vec{I} \\end{align} is the free evolution Hamiltonian, where \\(\\vec{S}=(S_1,S_2,S_3)^{\\mathrm{T}}\\) and \\(\\vec{I}=(I_1,I_2,I_3)^{\\mathrm{T}}\\) with \\(S_i=s_i\\otimes I\\) and \\(I_i=I\\otimes \\sigma_i\\) \\((i=1,2,3)\\) the electron and nuclear operators. \\(s_1, s_2, s_3\\) are spin-1 operators with \\[\\begin{eqnarray} s_1 = \\frac{1}{\\sqrt{2}}\\left(\\begin{array}{ccc} 0 & 1 & 0 \\\\ 1 & 0 & 1 \\\\ 0 & 1 & 0 \\end{array}\\right), s_2 = \\frac{1}{\\sqrt{2}}\\left(\\begin{array}{ccc} 0 & -i & 0\\\\ i & 0 & -i\\\\ 0 & i & 0 \\end{array}\\right)\\!\\!, \\nonumber \\end{eqnarray}\\] and \\(s_3=\\mathrm{diag}(1,0,-1)\\) and \\(\\sigma_i (i=1,2,3)\\) is Pauli matrix. \\(\\mathcal{A}=\\mathrm{diag} (A_1,A_1,A_2)\\) is the hyperfine tensor with \\(A_1\\) and \\(A_2\\) the axial and transverse magnetic hyperfine coupling coefficients. The coefficients \\(g_{\\mathrm{S}}=g_\\mathrm{e}\\mu_\\mathrm{B}/\\hbar\\) and \\(g_{\\mathrm{I}}=g_\\mathrm{n}\\mu_\\mathrm{n}/\\hbar\\) , where \\(g_\\mathrm{e}\\) ( \\(g_\\mathrm{n}\\) ) is the \\(g\\) factor of the electron (nuclear), \\(\\mu_\\mathrm{B}\\) ( \\(\\mu_\\mathrm{n}\\) ) is the Bohr (nuclear) magneton and \\(\\hbar\\) is the Plank's constant. \\(\\vec{B}\\) is the magnetic field which be estimated. In this case,the initial state is taken as \\(\\frac{1}{\\sqrt{2}}(|1\\rangle+|\\!-\\!1\\rangle)\\otimes |\\!\\!\\uparrow\\rangle\\) , where \\(\\frac{1}{\\sqrt{2}}(|1\\rangle+|\\!-\\!1\\rangle)\\) is an electron state with \\(|1\\rangle\\) ( \\(|\\!-\\!1\\rangle\\) ) the eigenstate of \\(s_3\\) with respect to the eigenvalue \\(1\\) ( \\(-1\\) ). \\(|\\!\\!\\uparrow\\rangle\\) is a nuclear state and the eigenstate of \\(\\sigma_3\\) with respect to the eigenvalue 1. \\(W\\) is set to be identity. Here three types of measurement optimization are considerd, projective measurement, linear combination of a given set of positive operator-valued measure (POVM) and optimal rotated measurement of an input measurement. Python from quanestimation import * import numpy as np from numpy.random import random # initial state rho0 = np . zeros (( 6 , 6 ), dtype = np . complex128 ) rho0 [ 0 ][ 0 ], rho0 [ 0 ][ 4 ], rho0 [ 4 ][ 0 ], rho0 [ 4 ][ 4 ] = 0.5 , 0.5 , 0.5 , 0.5 # free Hamiltonian sx = np . array ([[ 0. , 1. ],[ 1. , 0. ]]) sy = np . array ([[ 0. , - 1. j ],[ 1. j , 0. ]]) sz = np . array ([[ 1. , 0. ],[ 0. , - 1. ]]) ide2 = np . array ([[ 1. , 0. ],[ 0. , 1. ]]) s1 = np . array ([[ 0. , 1. , 0. ],[ 1. , 0. , 1. ],[ 0. , 1. , 0. ]]) / np . sqrt ( 2 ) s2 = np . array ([[ 0. , - 1. j , 0. ],[ 1. j , 0. , - 1. j ],[ 0. , 1. j , 0. ]]) / np . sqrt ( 2 ) s3 = np . array ([[ 1. , 0. , 0. ],[ 0. , 0. , 0. ],[ 0. , 0. , - 1. ]]) ide3 = np . array ([[ 1. , 0. , 0. ],[ 0. , 1. , 0. ],[ 0. , 0. , 1. ]]) I1 , I2 , I3 = np . kron ( ide3 , sx ), np . kron ( ide3 , sy ), np . kron ( ide3 , sz ) S1 , S2 , S3 = np . kron ( s1 , ide2 ), np . kron ( s2 , ide2 ), np . kron ( s3 , ide2 ) B1 , B2 , B3 = 5.0e-4 , 5.0e-4 , 5.0e-4 # All numbers are divided by 100 in this example # for better calculation accurancy cons = 100 D = ( 2 * np . pi * 2.87 * 1000 ) / cons gS = ( 2 * np . pi * 28.03 * 1000 ) / cons gI = ( 2 * np . pi * 4.32 ) / cons A1 = ( 2 * np . pi * 3.65 ) / cons A2 = ( 2 * np . pi * 3.03 ) / cons H0 = D * np . kron ( np . dot ( s3 , s3 ), ide2 ) + gS * ( B1 * S1 + B2 * S2 + B3 * S3 ) \\ + gI * ( B1 * I1 + B2 * I2 + B3 * I3 ) + A1 * ( np . kron ( s1 , sx ) + np . kron ( s2 , sy )) \\ + A2 * np . kron ( s3 , sz ) # derivatives of the free Hamiltonian on B1, B2 and B3 dH = [ gS * S1 + gI * I1 , gS * S2 + gI * I2 , gS * S3 + gI * I3 ] # control Hamiltonians Hc = [ S1 , S2 , S3 ] # dissipation decay = [[ S3 , 2 * np . pi / cons ]] # measurement dim = len ( rho0 ) M = [ np . dot ( basis ( dim , i ), basis ( dim , i ) . conj () . T ) for i in range ( dim )] # time length for the evolution tspan = np . linspace ( 0. , 2. , 4000 ) # guessed control coefficients cnum = 10 np . random . seed ( 1234 ) ini_1 = np . zeros (( len ( Hc ), cnum )) ini_2 = 0.2 * np . ones (( len ( Hc ), cnum )) ini_3 = - 0.2 * np . ones (( len ( Hc ), cnum )) ini_4 = np . array ([ np . linspace ( - 0.2 , 0.2 , cnum ) for i in range ( len ( Hc ))]) ini_5 = np . array ([ np . linspace ( - 0.2 , 0.0 , cnum ) for i in range ( len ( Hc ))]) ini_6 = np . array ([ np . linspace ( 0 , 0.2 , cnum ) for i in range ( len ( Hc ))]) ini_7 = - 0.2 * np . ones (( len ( Hc ), cnum )) + 0.01 * random (( len ( Hc ), cnum )) ini_8 = - 0.2 * np . ones (( len ( Hc ), cnum )) + 0.01 * random (( len ( Hc ), cnum )) ini_9 = - 0.2 * np . ones (( len ( Hc ), cnum )) + 0.05 * random (( len ( Hc ), cnum )) ini_10 = - 0.2 * np . ones (( len ( Hc ), cnum )) + 0.05 * random (( len ( Hc ), cnum )) ctrl0 = [ ini_1 , ini_2 , ini_3 , ini_4 , ini_5 , \\ ini_6 , ini_7 , ini_8 , ini_9 , ini_10 ] auto-GRAPE # control algorithm: auto-GRAPE GRAPE_paras = { \"Adam\" : True , \"ctrl0\" : ctrl0 , \"max_episode\" : 300 , \\ \"epsilon\" : 0.01 , \"beta1\" : 0.90 , \"beta2\" : 0.99 } control = ControlOpt ( savefile = False , method = \"auto-GRAPE\" , ** GRAPE_paras ) PSO # control algorithm: PSO PSO_paras = { \"p_num\" : 10 , \"ctrl0\" : ctrl0 , \"max_episode\" :[ 1000 , 100 ], \\ \"c0\" : 1.0 , \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } control = ControlOpt ( savefile = False , method = \"PSO\" , ** PSO_paras ) DE # control algorithm: DE DE_paras = { \"p_num\" : 10 , \"ctrl0\" : ctrl0 , \"max_episode\" : 1000 , \"c\" : 1.0 , \\ \"cr\" : 0.5 , \"seed\" : 1234 } control = ControlOpt ( savefile = False , method = \"DE\" , ** DE_paras ) DDPG # control algorithm: DDPG DDPG_paras = { \"layer_num\" : 4 , \"layer_dim\" : 220 , \"max_episode\" : 500 , \\ \"seed\" : 1234 } control = ControlOpt ( savefile = False , method = \"DDPG\" , ** DDPG_paras ) # input the dynamics data control . dynamics ( tspan , rho0 , H0 , dH , Hc , decay = decay , \\ ctrl_bound = [ - 0.2 , 0.2 ]) QFIM # objective function: tr(WF^{-1}) control . QFIM () CFIM # objective function: tr(WI^{-1}) control . CFIM ( M = M ) HCRB # objective function: HCRB control . HCRB () Julia using QuanEstimation using Random using LinearAlgebra # initial state rho0 = zeros ( ComplexF64 , 6 , 6 ) rho0 [ 1 : 4 : 5 , 1 : 4 : 5 ] .= 0.5 dim = size ( rho0 , 1 ) # Hamiltonian sx = [ 0. 1. ; 1. 0. ] sy = [ 0. - im ; im 0. ] sz = [ 1. 0. ; 0. - 1. ] s1 = [ 0. 1. 0. ; 1. 0. 1. ; 0. 1. 0. ] / sqrt ( 2 ) s2 = [ 0. - im 0. ; im 0. - im ; 0. im 0. ] / sqrt ( 2 ) s3 = [ 1. 0. 0. ; 0. 0. 0. ; 0. 0. - 1. ] Is = I1 , I2 , I3 = [ kron ( I ( 3 ), sx ), kron ( I ( 3 ), sy ), kron ( I ( 3 ), sz )] S = S1 , S2 , S3 = [ kron ( s1 , I ( 2 )), kron ( s2 , I ( 2 )), kron ( s3 , I ( 2 ))] B = B1 , B2 , B3 = [ 5.0e-4 , 5.0e-4 , 5.0e-4 ] # All numbers are divided by 100 in this example # for better calculation accurancy cons = 100 D = ( 2 pi * 2.87 * 1000 ) / cons gS = ( 2 pi * 28.03 * 1000 ) / cons gI = ( 2 pi * 4.32 ) / cons A1 = ( 2 pi * 3.65 ) / cons A2 = ( 2 pi * 3.03 ) / cons H0 = sum ([ D * kron ( s3 ^ 2 , I ( 2 )), sum ( gS * B .* S ), sum ( gI * B .* Is ), A1 * ( kron ( s1 , sx ) + kron ( s2 , sy )), A2 * kron ( s3 , sz )]) # derivatives of the free Hamiltonian on B1, B2 and B3 dH = gS * S + gI * Is # control Hamiltonians Hc = [ S1 , S2 , S3 ] # dissipation decay = [[ S3 , 2 * pi / cons ]] # measurement M = [ QuanEstimation . basis ( dim , i ) * QuanEstimation . basis ( dim , i ) ' \\ for i in 1 : dim ] # time length for the evolution tspan = range ( 0. , 2. , length = 4000 ) # guessed control coefficients cnum = 10 rng = MersenneTwister ( 1234 ) cnum = length ( Hc ) ini_1 = [ zeros ( cnum ) for _ in 1 : cnum ] ini_2 = 0.2 .* [ ones ( cnum ) for _ in 1 : cnum ] ini_3 = - 0.2 .* [ ones ( cnum ) for _ in 1 : cnum ] ini_4 = [[ range ( - 0.2 , 0.2 , length = cnum ) ... ] for _ in 1 : cnum ] ini_5 = [[ range ( - 0.2 , 0. , length = cnum ) ... ] for _ in 1 : cnum ] ini_6 = [[ range ( 0. , 0.2 , length = cnum ) ... ] for _ in 1 : cnum ] ini_7 = [ - 0.2 * ones ( cnum ) + 0.01 * rand ( rng , cnum ) for _ in 1 : cnum ] ini_8 = [ - 0.2 * ones ( cnum ) + 0.01 * rand ( rng , cnum ) for _ in 1 : cnum ] ini_9 = [ - 0.2 * ones ( cnum ) + 0.05 * rand ( rng , cnum ) for _ in 1 : cnum ] ini_10 = [ - 0.2 * ones ( cnum ) + 0.05 * rand ( rng , cnum ) for _ in 1 : cnum ] ctrl0 = [ Symbol ( \"ini_\" , i ) |> eval for i in 1 : 10 ] # set the optimization type opt = QuanEstimation . ControlOpt ( ctrl = ini_1 , ctrl_bound = [ - 0.2 , 0.2 ], seed = 1234 ) auto-GRAPE # control algorithm: auto-GRAPE alg = QuanEstimation . autoGRAPE ( Adam = true , max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 ) GRAPE # control algorithm: GRAPE alg = QuanEstimation . GRAPE ( Adam = true , max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 ) PSO # control algorithm: PSO alg = QuanEstimation . PSO ( p_num = 10 , ini_particle = ([ ctrl ],), max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) DE # control algorithm: DE alg = QuanEstimation . DE ( p_num = 10 , ini_population = ([ ctrl ],), max_episode = 1000 , c = 1.0 , cr = 0.5 ) DDPG # control algorithm: DDPG alg = QuanEstimation . DDPG ( max_episode = 500 , layer_num = 4 , layer_dim = 220 ) # input the dynamics data dynamics = QuanEstimation . Lindblad ( opt , tspan , rho0 , H0 , dH , Hc , decay ) QFIM # objective function: tr(WF^{-1}) obj = QuanEstimation . QFIM_obj () CFIM # objective function: tr(WI^{-1}) obj = QuanEstimation . CFIM_obj ( M = M ) HCRB # objective function: HCRB obj = QuanEstimation . HCRB_obj ( M = M ) # run the control optimization problem QuanEstimation . run ( opt , alg , obj , dynamics ; savefile = false )","title":"DDPG"},{"location":"guide/guide_Copt/#minimum-parameterization-time-optimization","text":"Search of the minimum time to reach a given value of the objective function. Python control . mintime ( f , W = [], M = [], method = \"binary\" , target = \"QFIM\" , LDtype = \"SLD\" ) Julia mintime ( f , opt , alg , obj , dynamics ; method = \"binary\" , savefile = false ) f is the given value of the objective function. In the package, two methods for searching the minimum time are provided which are logarithmic search and forward search from the beginning of time. It can be realized by setting method=binary (default) and method=forward . target represents the objective function for searching the minimum time, the users can choose QFI \\(\\left[\\mathrm{Tr}(WF^{-1})\\right]\\) , CFI \\(\\left[\\mathrm{Tr}(WI^{-1})\\right]\\) and HCRB for the objective functions. If target=\"QFIM\" , the types for the logarithmic derivatives can be set via LDtype .","title":"Minimum parameterization time optimization"},{"location":"guide/guide_Copt/#bibliography","text":"[1] N. Khaneja, T. Reiss, C. Hehlet, T. Schulte-Herbruggen, and S. J. Glaser, Optimal control of coupled spin dynamics: Design of NMR pulse sequences by gradient ascent algorithms, J. Magn. Reson. 172 , 296 (2005). [2] J. Liu and H. Yuan, Quantum parameter estimation with optimal control, Phys. Rev. A 96 , 012117 (2017). [3] J. Liu and H. Yuan, Control-enhanced multiparameter quantum estimation, Phys. Rev. A 96 , 042114 (2017). [4] A. G. Baydin, B. A. Pearlmutter, A. A. Radul, and J. M. Siskind, Automatic differentiation in machine learning: a survey, J. Mach. Learn. Res. 18 , 1-43 (2018). [5] J. Kennedy and R. Eberhar, Particle swarm optimization, Proc. 1995 IEEE International Conference on Neural Networks 4 , 1942-1948 (1995). [6] R. Storn and K. Price, Differential Evolution-A Simple and Efficient Heuristic for global Optimization over Continuous Spaces, J. Global Optim. 11 , 341 (1997). [7] T. P. Lillicrap, J. J. Hunt, A. Pritzel, N. Heess, T. Erez, Y. Tassa, D. Silver, and D. Wierstra, Continuous control with deep reinforcement learning, arXiv:1509.02971.","title":"Bibliography"},{"location":"guide/guide_Mopt/","text":"Measurement optimization \u00b6 In QuanEstimation, three measurement optimization scenarios are considered. The first one is to optimize a set of rank-one projective measurement, it can be written in a specific basis \\(\\{|\\phi_i\\rangle\\}\\) with \\(|\\phi_i\\rangle=\\sum_j C_{ij}|j\\rangle\\) in the Hilbert space as \\(\\{|\\phi_i\\rangle\\langle\\phi_i|\\}\\) . In this case, the goal is to search a set of optimal coefficients \\(C_{ij}\\) . The second scenario is to find the optimal linear combination of an input measurement \\(\\{\\Pi_j\\}\\) . The third scenario is to find the optimal rotated measurement of an input measurement. After rotation, the new measurement is \\(\\{U\\Pi_i U^{\\dagger}\\}\\) , where \\(U=\\prod_k \\exp(i s_k\\lambda_k)\\) with \\(\\lambda_k\\) a SU( \\(N\\) ) generator and \\(s_k\\) a real number in the regime \\([0,2\\pi]\\) . In this scenario, the goal is to search a set of optimal coefficients \\(s_k\\) . Here different algorithms are invoked to search the optimal measurement include particle swarm optimization (PSO) [1] , differential evolution (DE) [2] , and automatic differentiation (AD) [3] . The codes for execute measurement optimization are Python m = MeasurementOpt ( mtype = \"projection\" , minput = [], savefile = False , method = \"DE\" , ** kwargs ) m . dynamics ( tspan , rho0 , H0 , dH , Hc = [], ctrl = [], decay = []) m . CFIM ( W = []) mtype represents the type of measurement optimization which defaults to \"projection\" . In this setting, rank-one projective measurement optimization will be performed minput will keep empty in this scenario. For the other two measurement optimization scenarios mtype=\"input\" . If the users want to find the optimal linear combination of an input measurement, the variable minput should be input as minput=[\"LC\", [Pi1,Pi2,...], m] with [Pi1,Pi2,...] a set of POVM and m the number of operators of the output measurement. For finding the optimal linear combination of an input measurement, the variable minput becomes minput=[\"rotation\", [Pi1,Pi2,...]] . savefile means whether to save all the measurements. If set False the measurements in the final episode and the values of the objective function in all episodes will be saved, if savefile=True the measurements and the values of the objective function obtained in all episodes will be saved during the training. method represents the algorithm used to optimize the measurements, options are: \"PSO\", \"DE\" and \"AD\". **kwargs is the keyword and default value corresponding to the optimization algorithm which will be introduced in detail below. If the dynamics of the system can be described by the master equation, then the dynamics data tspan , rho0 , H0 and dH shoule be input. tspan is the time length for the evolution, rho0 represents the density matrix of the initial state, H0 and dH are the free Hamiltonian and its derivatives on the unknown parameters to be estimated. H0 is a matrix when the free Hamiltonian is time-independent and a list with the length equal to tspan when it is time-dependent. dH should be input as \\([\\partial_a{H_0}, \\partial_b{H_0}, \\cdots]\\) . Hc and ctrl are two lists represent the control Hamiltonians and the corresponding control coefficients. decay contains decay operators \\((\\Gamma_1,\\Gamma_2, \\cdots)\\) and the corresponding decay rates \\((\\gamma_1, \\gamma_2, \\cdots)\\) with the input rule decay=[[ \\(\\Gamma_1\\) , \\(\\gamma_1\\) ], [ \\(\\Gamma_2\\) , \\(\\gamma_2\\) ],...]. The default values for decay , Hc and ctrl are empty which means the dynamics is unitary and only governed by the free Hamiltonian. The objective function for measurement optimization are CFI and \\(\\mathrm{Tr}(W\\mathcal{I}^ {-1})\\) with \\(\\mathcal{I}\\) the CFIM. \\(W\\) corresponds to W in the objective function is the weight matrix which defaults to the identity matrix. Julia opt = MeasurementOpt ( mtype = :Projection , seed = 1234 ) alg = DE ( kwargs ... ) dynamics = Lindblad ( opt , tspan , rho0 , H0 , dH ; Hc = missing , ctrl = missing , decay = missing ) obj = CFIM_obj ( W = missing ) run ( opt , alg , obj , dynamics ; savefile = false ) mtype represents the type of measurement optimization which defaults to \"Projection\" . In this setting, rank-one projective measurement optimization will be performed. For the other two measurement optimization scenarios this variable becomes mtype=\"LC\" and mtype=\"Rotation\" . If the users want to find the optimal linear combination of an input measurement, the input rule of opt is MeasurementOpt(mtype=:LC,POVM_basis=[Pi1,Pi2,...],M_num=m) with [Pi1,Pi2,...] a set of POVM and m the number of operators of the output measurement. For finding the optimal linear combination of an input measurement, the code opt is MeasurementOpt(mtype=:LC,POVM_basis=[Pi1,Pi2,...]) . seed is the random seed which can ensure the reproducibility of results. If the dynamics of the system can be described by the master equation, then the dynamics data tspan , rho0 , H0 and dH shoule be input. tspan is the time length for the evolution, rho0 represents the density matrix of the initial state, H0 and dH are the free Hamiltonian and its derivatives on the unknown parameters to be estimated. H0 is a matrix when the free Hamiltonian is time-independent and a list with the length equal to tspan when it is time-dependent. dH should be input as \\([\\partial_a{H_0}, \\partial_b{H_0}, \\cdots]\\) . Hc and ctrl are two lists represent the control Hamiltonians and the corresponding control coefficients. decay contains decay operators \\((\\Gamma_1,\\Gamma_2, \\cdots)\\) and the corresponding decay rates \\((\\gamma_1, \\gamma_2, \\cdots)\\) with the input rule decay=[[ \\(\\Gamma_1\\) , \\(\\gamma_1\\) ], [ \\(\\Gamma_2\\) , \\(\\gamma_2\\) ],...]. The default values for decay , Hc and ctrl are missing which means the dynamics is unitary and only governed by the free Hamiltonian. The objective function for measurement optimization are CFI and \\(\\mathrm{Tr}(W\\mathcal{I}^ {-1})\\) with \\(\\mathcal{I}\\) the CFIM. \\(W\\) corresponds to W in the objective function is the weight matrix which defaults to the identity matrix. The variable savefile means whether to save all the measurements. If set false the measurements in the final episode and the values of the objective function in all episodes will be saved, if savefile=true the measurements and the values of the objective function obtained in all episodes will be saved during the training. The algorithm used for optimizing the measurements are PSO, DE and AD. kwargs... is the keywords and default values corresponding to the optimization algorithm which will be introduced in detail below. PSO \u00b6 The code for measurement optimization with PSO is as follows Python m = MeasurementOpt ( method = \"PSO\" , ** kwargs ) where kwargs is of the form kwargs = { \"p_num\" : 10 , \"measurement0\" :[], \"max_episode\" :[ 1000 , 100 ], \\ \"c0\" : 1.0 , \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } The keywords and the default values of PSO can be seen in the following table \\(~~~~~~~~~~\\) **kwargs \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"p_num\" 10 \"measurement0\" [ ] \"max_episode\" [1000,100] \"c0\" 1.0 \"c1\" 2.0 \"c2\" 2.0 \"seed\" 1234 p_num is the number of particles, c0 , c1 and c2 are the PSO parameters representing the inertia weight, cognitive learning factor and social learning factor, respectively. max_episode accepts both integers and arrays with two elements. If it is an integer, for example max_episode=1000 , it means the program will continuously run 1000 episodes. However, if it is an array, for example max_episode=[1000,100] , the program will run 1000 episodes in total but replace control coefficients of all the particles with global best every 100 episodes. seed is the random seed which can ensure the reproducibility of the results. measurement0 in the algorithm is a list representing the initial guesses of measurements. In the case of projective measurement optimization, the entry of measurement0 is a list of arrays with the length equal to the dimension of the system. In the cases of finding the optimal linear combination and the optimal rotation of a given set of measurement, the entry of measurement0 is a 2D-array and array, respectively. Here, an example of generating measurement0 is given as follows Example 7.1 projection from quanestimation import * from numpy import * # the dimension of the system dim = 6 # generation of the entry of `measurement0` C = [[] for i in range ( dim )] for i in range ( dim ): r_ini = 2 * np . random . random ( dim ) - np . ones ( dim ) r = r_ini / np . linalg . norm ( r_ini ) phi = 2 * np . pi * np . random . random ( dim ) C [ i ] = [ r [ j ] * np . exp ( 1.0 j * phi [ j ]) for j in range ( dim )] C = np . array ( gramschmidt ( C )) measurement0 = [ C ] LC from quanestimation import * from numpy import * # the dimension of the system dim = 6 # a given set of measurement POVM_basis = SIC ( dim ) # the number of operators of the output measurement m = 4 # generation of the entry of `measurement0` B = np . array ([ np . random . random ( len ( POVM_basis )) for i in range ( m )]) measurement0 = [ B ] rotation from quanestimation import * from numpy import * # the dimension of the system dim = 6 # a given set of measurement POVM_basis = SIC ( dim ) # generation of the entry of `measurement0` s = np . random . random ( dim ** 2 ) measurement0 = [ s ] In this algorithm, the length of measurement0 should be less than or equal to p_num . Julia alg = PSO ( p_num = 10 , ini_particle = missing , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) The keywords and the default values of PSO can be seen in the following table \\(~~~~~~~~~~\\) keywords \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"p_num\" 10 \"ini_particle\" missing \"max_episode\" [1000,100] \"c0\" 1.0 \"c1\" 2.0 \"c2\" 2.0 p_num is the number of particles, c0 , c1 and c2 are the PSO parameters representing the inertia weight, cognitive learning factor and social learning factor, respectively. max_episode accepts both integers and arrays with two elements. If it is an integer, for example max_episode=1000 , it means the program will continuously run 1000 episodes. However, if it is an array, for example max_episode=[1000,100] , the program will run 1000 episodes in total but replace control coefficients of all the particles with global best every 100 episodes. ini_particle in the algorithm is a list representing the initial guesses of measurements, In the case of projective measurement optimization, the entry of ini_particle is a list of arrays with the length equal to the dimension of the system. In the cases of finding the optimal linear combination and the optimal rotation of a given set of measurement, the entry of ini_particle is a 2D-array and array, respectively. Here, an example of generating ini_particle is given as follows Example 7.1 Projection using QuanEstimation # the dimension of the system dim = 6 # generation of the entry of `measurement0` C = [ ComplexF64 [] for _ in 1 : dim ] for i in 1 : dim r_ini = 2 * rand ( dim ) - ones ( dim ) r = r_ini / norm ( r_ini ) \u03d5 = 2 pi * rand ( dim ) C [ i ] = [ r * exp ( im * \u03d5 ) for ( r , \u03d5 ) in zip ( r , \u03d5 )] end C = QuanEstimation . gramschmidt ( C ) measurement0 = ([ C ],) LC using QuanEstimation # the dimension of the system dim = 6 # a given set of measurement POVM_basis = QuanEstimation . SIC ( dim ) # the number of operators of the output measurement m = 4 # generation of the entry of `measurement0` B = [ rand ( length ( POVM_basis )) for _ in 1 : m ] measurement0 = ([ B ],) Rotation using QuanEstimation # the dimension of the system dim = 6 # a given set of measurement POVM_basis = QuanEstimation . SIC ( dim ) # generation of the entry of `measurement0` s = rand ( dim ^ 2 ) measurement0 = ([ s ],) In this algorithm, the length of measurement0 should be less than or equal to p_num . DE \u00b6 The code for measurement optimization with DE is as follows Python m = MeasurementOpt ( method = \"DE\" , ** kwargs ) where kwargs is of the form kwargs = { \"p_num\" : 10 , \"measurement0\" :[], \"max_episode\" : 1000 , \\ \"c\" : 1.0 , \"cr\" : 0.5 , \"seed\" : 1234 } The keywords and the default values of DE can be seen in the following table \\(~~~~~~~~~~\\) **kwargs \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"p_num\" 10 \"measurement0\" [ ] \"max_episode\" 1000 \"c\" 1.0 \"cr\" 0.5 \"seed\" 1234 p_num represents the number of populations, c and cr are the mutation constant and the crossover constant. Here max_episode is an integer representing the number of episodes, the variable measurement0 is the same with measurement0 in PSO. Julia alg = DE ( p_num = 10 , ini_population = missing , max_episode = 1000 , c = 1.0 , cr = 0.5 ) The keywords and the default values of DE can be seen in the following table \\(~~~~~~~~~~\\) keywords \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"p_num\" 10 \"ini_population\" [ ] \"max_episode\" 1000 \"c\" 1.0 \"cr\" 0.5 p_num represents the number of populations, c and cr are the mutation constant and the crossover constant. Here max_episode is an integer representing the number of episodes, the variable ini_population is the same with ini_particle in PSO. AD \u00b6 The code for measurement optimization with AD is as follows Python com = MeasurementOpt ( method = \"AD\" , ** kwargs ) where kwargs is of the form kwargs = { \"Adam\" : False , \"measurement0\" :[], \"max_episode\" : 300 , \\ \"epsilon\" : 0.01 , \"beta1\" : 0.90 , \"beta2\" : 0.99 } The keywords and the default values of AD can be seen in the following table \\(~~~~~~~~~~\\) **kwargs \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"Adam\" False \"measurement0\" [ ] \"max_episode\" 300 \"epsilon\" 0.01 \"beta1\" 0.90 \"beta2\" 0.99 The measurements will update according to the learning rate \"epsilon\" for Adam=False , However, Adam algorithm can be introduced to update the measurements which can be realized by setting Adam=True . In this case, the Adam parameters include learning rate, the exponential decay rate for the first moment estimates and the second moment estimates can be set by the user via epsilon , beta1 and beta2 . The input rule of measurement0 is the same with that in PSO, but the length of measurement0 is equal to one. Julia alg = AD ( Adam = false , max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 ) The keywords and the default values of AD can be seen in the following table \\(~~~~~~~~~~\\) keywords \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"Adam\" false \"max_episode\" 300 \"epsilon\" 0.01 \"beta1\" 0.90 \"beta2\" 0.99 The measurements will update according to the learning rate \"epsilon\" for Adam=False , However, Adam algorithm can be introduced to update the measurements which can be realized by setting Adam=true . In this case, the Adam parameters include learning rate, the exponential decay rate for the first moment estimates and the second moment estimates can be set by the user via epsilon , beta1 and beta2 . Example 7.2 A single qubit system whose dynamics is governed by \\begin{align} \\partial_t\\rho=-i[H, \\rho]+ \\gamma_{+}\\left(\\sigma_{+}\\rho\\sigma_{-}-\\frac{1}{2}{\\sigma_{-} \\sigma_{+},\\rho}\\right)+ \\gamma_{-}\\left(\\sigma_{-}\\rho\\sigma_{+}-\\frac{1}{2}{\\sigma_{+} \\sigma_{-},\\rho}\\right), \\end{align} where \\(H = \\frac{1}{2}\\omega \\sigma_3\\) is the free Hamiltonian with \\(\\omega\\) the frequency, \\(\\sigma_{\\pm}=(\\sigma_1 \\pm \\sigma_2)/2\\) and \\(\\gamma_{+}\\) , \\(\\gamma_{-}\\) are decay rates. Here \\(\\sigma_{i}\\) for \\((i=1,2,3)\\) is the Pauli matrix. In this case, the probe state is taken as \\(\\frac{1}{\\sqrt{2}}(|0\\rangle +|1\\rangle)\\) , \\(|0\\rangle\\) \\((|1\\rangle)\\) is the eigenstate of \\(\\sigma_3\\) with respect to the eigenvalue \\(1\\) \\((-1)\\) . Python from quanestimation import * import numpy as np # initial state rho0 = 0.5 * np . array ([[ 1. , 1. ], [ 1. , 1. ]]) # free Hamiltonian omega = 1.0 sx = np . array ([[ 0. , 1. ], [ 1. , 0. ]]) sy = np . array ([[ 0. , - 1. j ], [ 1. j , 0. ]]) sz = np . array ([[ 1. , 0. ], [ 0. , - 1. ]]) H0 = 0.5 * omega * sz # derivative of the free Hamiltonian on omega dH = [ 0.5 * sz ] # dissipation sp = np . array ([[ 0. , 1. ], [ 0. , 0. ]]) sm = np . array ([[ 0. , 0. ], [ 1. , 0. ]]) decay = [[ sp , 0. ], [ sm , 0.1 ]] # generation of a set of POVM basis dim = np . shape ( rho0 )[ 0 ] POVM_basis = SIC ( dim ) # time length for the evolution tspan = np . linspace ( 0. , 10. , 2500 ) projection DE # measurement optimization algorithm: DE DE_paras = { \"p_num\" : 10 , \"measurement0\" :[], \"max_episode\" : 1000 , \\ \"c\" : 1.0 , \"cr\" : 0.5 , \"seed\" : 1234 } m = MeasurementOpt ( mtype = \"projection\" , minput = [], savefile = False , \\ method = \"DE\" , ** DE_paras ) PSO # measurement optimization algorithm: PSO PSO_paras = { \"p_num\" : 10 , \"measurement0\" :[], \\ \"max_episode\" :[ 1000 , 100 ], \"c0\" : 1.0 , \\ \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } m = MeasurementOpt ( mtype = \"projection\" , minput = [], savefile = False , \\ method = \"PSO\" , ** PSO_paras ) LC DE # measurement optimization algorithm: DE DE_paras = { \"p_num\" : 10 , \"measurement0\" :[], \"max_episode\" : 1000 , \\ \"c\" : 1.0 , \"cr\" : 0.5 , \"seed\" : 1234 } m = MeasurementOpt ( mtype = \"input\" , minput = [ \"LC\" , POVM_basis , 4 ], \\ savefile = False , method = \"DE\" , ** DE_paras ) PSO # measurement optimization algorithm: PSO PSO_paras = { \"p_num\" : 10 , \"measurement0\" :[], \"max_episode\" :[ 1000 , 100 ], \\ \"c0\" : 1.0 , \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } m = MeasurementOpt ( mtype = \"input\" , minput = [ \"LC\" , POVM_basis , 4 ], \\ savefile = False , method = \"PSO\" , ** PSO_paras ) AD # measurement optimization algorithm: AD AD_paras = { \"Adam\" : False , \"measurement0\" :[], \"max_episode\" : 300 , \\ \"epsilon\" : 0.01 , \"beta1\" : 0.90 , \"beta2\" : 0.99 } m = MeasurementOpt ( mtype = \"input\" , minput = [ \"LC\" , POVM_basis , 4 ], \\ savefile = False , method = \"AD\" , ** AD_paras ) rotation DE # measurement optimization algorithm: DE DE_paras = { \"p_num\" : 10 , \"measurement0\" :[], \"max_episode\" : 1000 , \\ \"c\" : 1.0 , \"cr\" : 0.5 , \"seed\" : 1234 } m = MeasurementOpt ( mtype = \"input\" , minput = [ \"rotation\" , POVM_basis ], \\ savefile = False , method = \"DE\" , ** DE_paras ) PSO # measurement optimization algorithm: PSO PSO_paras = { \"p_num\" : 10 , \"measurement0\" :[], \\ \"max_episode\" :[ 1000 , 100 ], \"c0\" : 1.0 , \\ \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } m = MeasurementOpt ( mtype = \"input\" , minput = [ \"rotation\" , POVM_basis ], \\ savefile = False , method = \"PSO\" , ** PSO_paras ) AD # measurement optimization algorithm: AD AD_paras = { \"Adam\" : False , \"measurement0\" :[], \"max_episode\" : 300 , \\ \"epsilon\" : 0.01 , \"beta1\" : 0.90 , \"beta2\" : 0.99 } m = MeasurementOpt ( mtype = \"input\" , minput = [ \"rotation\" , POVM_basis ], \\ savefile = False , method = \"AD\" , ** AD_paras ) # input the dynamics data m . dynamics ( tspan , rho0 , H0 , dH , decay = decay ) # objective function: CFI m . CFIM () Julia using QuanEstimation using Random using StableRNGs using LinearAlgebra # initial state rho0 = 0.5 * ones ( 2 , 2 ) # free Hamiltonian omega = 1.0 sx = [ 0. 1. ; 1. 0.0 im ] sy = [ 0. - im ; im 0. ] sz = [ 1. 0.0 im ; 0. - 1. ] H0 = 0.5 * omega * sz # derivative of the free Hamiltonian on omega dH = [ 0.5 * sz ] # dissipation sp = [ 0. 1. ; 0. 0.0 im ] sm = [ 0. 0. ; 1. 0.0 im ] decay = [[ sp , 0. ], [ sm , 0.1 ]] # generation of a set of POVM basis dim = size ( rho0 , 1 ) POVM_basis = QuanEstimation . SIC ( dim ) # time length for the evolution tspan = range ( 0. , 10. , length = 2500 ) Projection opt = QuanEstimation . MeasurementOpt ( method = :Projection , seed = 1234 ) DE # measurement optimization algorithm: DE alg = QuanEstimation . DE ( p_num = 10 , ini_population = missing , max_episode = 1000 , c = 1.0 , cr = 0.5 ) PSO # measurement optimization algorithm: PSO alg = QuanEstimation . PSO ( p_num = 10 , ini_particle = missing , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) LC opt = QuanEstimation . MeasurementOpt ( method = :LC , POVM_basis = POVM_basis , M_num = 2 , seed = 1234 ) DE # measurement optimization algorithm: DE alg = QuanEstimation . DE ( p_num = 10 , ini_population = missing , max_episode = 1000 , c = 1.0 , cr = 0.5 ) PSO # measurement optimization algorithm: PSO alg = QuanEstimation . PSO ( p_num = 10 , ini_particle = missing , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) AD # measurement optimization algorithm: AD alg = QuanEstimation . AD ( Adam = true , max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 ) Rotation opt = QuanEstimation . MeasurementOpt ( method = :Rotation , POVM_basis = POVM_basis , seed = 1234 ) DE # measurement optimization algorithm: DE alg = QuanEstimation . DE ( p_num = 10 , ini_population = missing , max_episode = 1000 , c = 1.0 , cr = 0.5 ) PSO # measurement optimization algorithm: PSO alg = QuanEstimation . PSO ( p_num = 10 , ini_particle = missing , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) AD # measurement optimization algorithm: AD alg = QuanEstimation . AD ( Adam = true , max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 ) # input the dynamics data dynamics = QuanEstimation . Lindblad ( opt , tspan , rho0 , H0 , dH , decay = decay ) # objective function: CFI obj = QuanEstimation . CFIM_obj () # run the measurement optimization problem QuanEstimation . run ( opt , alg , obj , dynamics ; savefile = false ) Example 7.3 In the multiparameter scenario, the dynamics of electron and nuclear coupling in NV \\(^{-}\\) can be expressed as \\begin{align} \\partial_t\\rho=-i[H_0,\\rho]+\\frac{\\gamma}{2}(S_3\\rho S_3-S^2_3\\rho-\\rho S^2_3) \\end{align} with \\(\\gamma\\) the dephasing rate. And \\begin{align} H_0/\\hbar=DS^2_3+g_{\\mathrm{S}}\\vec{B}\\cdot\\vec{S}+g_{\\mathrm{I}}\\vec{B}\\cdot\\vec{I}+\\vec{S}^{\\,\\mathrm{T}}\\mathcal{A}\\vec{I} \\end{align} is the free evolution Hamiltonian, where \\(\\vec{S}=(S_1,S_2,S_3)^{\\mathrm{T}}\\) and \\(\\vec{I}=(I_1,I_2,I_3)^{\\mathrm{T}}\\) with \\(S_i=s_i\\otimes I\\) and \\(I_i=I\\otimes \\sigma_i\\) \\((i=1,2,3)\\) the electron and nuclear operators. \\(s_1, s_2, s_3\\) are spin-1 operators with \\[\\begin{eqnarray} s_1 = \\frac{1}{\\sqrt{2}}\\left(\\begin{array}{ccc} 0 & 1 & 0 \\\\ 1 & 0 & 1 \\\\ 0 & 1 & 0 \\end{array}\\right), s_2 = \\frac{1}{\\sqrt{2}}\\left(\\begin{array}{ccc} 0 & -i & 0\\\\ i & 0 & -i\\\\ 0 & i & 0 \\end{array}\\right)\\!\\!, \\nonumber \\end{eqnarray}\\] and \\(s_3=\\mathrm{diag}(1,0,-1)\\) and \\(\\sigma_i (i=1,2,3)\\) is Pauli matrix. \\(\\mathcal{A}=\\mathrm{diag} (A_1,A_1,A_2)\\) is the hyperfine tensor with \\(A_1\\) and \\(A_2\\) the axial and transverse magnetic hyperfine coupling coefficients. The coefficients \\(g_{\\mathrm{S}}=g_\\mathrm{e}\\mu_\\mathrm{B}/\\hbar\\) and \\(g_{\\mathrm{I}}=g_\\mathrm{n}\\mu_\\mathrm{n}/\\hbar\\) , where \\(g_\\mathrm{e}\\) ( \\(g_\\mathrm{n}\\) ) is the \\(g\\) factor of the electron (nuclear), \\(\\mu_\\mathrm{B}\\) ( \\(\\mu_\\mathrm{n}\\) ) is the Bohr (nuclear) magneton and \\(\\hbar\\) is the Plank's constant. \\(\\vec{B}\\) is the magnetic field which be estimated. In this case,the initial state is taken as \\(\\frac{1}{\\sqrt{2}}(|1\\rangle+|\\!-\\!1\\rangle)\\otimes|\\!\\!\\uparrow\\rangle\\) , where \\(\\frac{1}{\\sqrt{2}}(|1\\rangle+|\\!-\\!1\\rangle)\\) is an electron state with \\(|1\\rangle\\) ( \\(|\\!-\\!1\\rangle\\) ) the eigenstate of \\(s_3\\) with respect to the eigenvalue \\(1\\) ( \\(-1\\) ). \\(|\\!\\!\\uparrow\\rangle\\) is a nuclear state and the eigenstate of \\(\\sigma_3\\) with respect to the eigenvalue 1. \\(W\\) is set to be \\(I\\) . Here three types of measurement optimization are considerd, projective measurement, linear combination of a given set of positive operator-valued measure (POVM) and optimal rotated measurement of an input measurement. Python from quanestimation import * import numpy as np # initial state rho0 = np . zeros (( 6 , 6 ), dtype = np . complex128 ) rho0 [ 0 ][ 0 ], rho0 [ 0 ][ 4 ], rho0 [ 4 ][ 0 ], rho0 [ 4 ][ 4 ] = 0.5 , 0.5 , 0.5 , 0.5 # free Hamiltonian sx = np . array ([[ 0. , 1. ],[ 1. , 0. ]]) sy = np . array ([[ 0. , - 1. j ],[ 1. j , 0. ]]) sz = np . array ([[ 1. , 0. ],[ 0. , - 1. ]]) ide2 = np . array ([[ 1. , 0. ],[ 0. , 1. ]]) s1 = np . array ([[ 0. , 1. , 0. ],[ 1. , 0. , 1. ],[ 0. , 1. , 0. ]]) / np . sqrt ( 2 ) s2 = np . array ([[ 0. , - 1. j , 0. ],[ 1. j , 0. , - 1. j ],[ 0. , 1. j , 0. ]]) / np . sqrt ( 2 ) s3 = np . array ([[ 1. , 0. , 0. ],[ 0. , 0. , 0. ],[ 0. , 0. , - 1. ]]) ide3 = np . array ([[ 1. , 0. , 0. ],[ 0. , 1. , 0. ],[ 0. , 0. , 1. ]]) I1 , I2 , I3 = np . kron ( ide3 , sx ), np . kron ( ide3 , sy ), np . kron ( ide3 , sz ) S1 , S2 , S3 = np . kron ( s1 , ide2 ), np . kron ( s2 , ide2 ), np . kron ( s3 , ide2 ) B1 , B2 , B3 = 5.0e-4 , 5.0e-4 , 5.0e-4 # All numbers are divided by 100 in this example # for better calculation accurancy cons = 100 D = ( 2 * np . pi * 2.87 * 1000 ) / cons gS = ( 2 * np . pi * 28.03 * 1000 ) / cons gI = ( 2 * np . pi * 4.32 ) / cons A1 = ( 2 * np . pi * 3.65 ) / cons A2 = ( 2 * np . pi * 3.03 ) / cons H0 = D * np . kron ( np . dot ( s3 , s3 ), ide2 ) + gS * ( B1 * S1 + B2 * S2 + B3 * S3 ) \\ + gI * ( B1 * I1 + B2 * I2 + B3 * I3 ) + A1 * ( np . kron ( s1 , sx ) + np . kron ( s2 , sy )) \\ + A2 * np . kron ( s3 , sz ) # derivatives of the free Hamiltonian on B1, B2 and B3 dH = [ gS * S1 + gI * I1 , gS * S2 + gI * I2 , gS * S3 + gI * I3 ] # control Hamiltonians Hc = [ S1 , S2 , S3 ] # dissipation decay = [[ S3 , 2 * np . pi / cons ]] # generation of a set of POVM basis dim = len ( rho0 ) POVM_basis = [ np . dot ( basis ( dim , i ), basis ( dim , i ) . conj () . T ) \\ for i in range ( dim )] # time length for the evolution tspan = np . linspace ( 0. , 2. , 4000 ) projection DE # measurement optimization algorithm: DE DE_paras = { \"p_num\" : 10 , \"measurement0\" :[], \"max_episode\" : 1000 , \\ \"c\" : 1.0 , \"cr\" : 0.5 , \"seed\" : 1234 } m = MeasurementOpt ( mtype = \"projection\" , minput = [], savefile = False , \\ method = \"DE\" , ** DE_paras ) PSO # measurement optimization algorithm: PSO PSO_paras = { \"p_num\" : 10 , \"measurement0\" :[], \\ \"max_episode\" :[ 1000 , 100 ], \"c0\" : 1.0 , \\ \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } m = MeasurementOpt ( mtype = \"projection\" , minput = [], savefile = False , \\ method = \"PSO\" , ** PSO_paras ) LC DE # measurement optimization algorithm: DE DE_paras = { \"p_num\" : 10 , \"measurement0\" :[], \"max_episode\" : 1000 , \\ \"c\" : 1.0 , \"cr\" : 0.5 , \"seed\" : 1234 } m = MeasurementOpt ( mtype = \"input\" , minput = [ \"LC\" , POVM_basis , 4 ], \\ savefile = False , method = \"DE\" , ** DE_paras ) PSO # measurement optimization algorithm: PSO PSO_paras = { \"p_num\" : 10 , \"measurement0\" :[], \"max_episode\" :[ 1000 , 100 ], \\ \"c0\" : 1.0 , \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } m = MeasurementOpt ( mtype = \"input\" , minput = [ \"LC\" , POVM_basis , 4 ], \\ savefile = False , method = \"PSO\" , ** PSO_paras ) AD # measurement optimization algorithm: AD AD_paras = { \"Adam\" : False , \"measurement0\" :[], \"max_episode\" : 300 , \\ \"epsilon\" : 0.01 , \"beta1\" : 0.90 , \"beta2\" : 0.99 } m = MeasurementOpt ( mtype = \"input\" , minput = [ \"LC\" , POVM_basis , 4 ], \\ savefile = False , method = \"AD\" , ** AD_paras ) rotation DE # measurement optimization algorithm: DE DE_paras = { \"p_num\" : 10 , \"measurement0\" :[], \"max_episode\" : 1000 , \\ \"c\" : 1.0 , \"cr\" : 0.5 , \"seed\" : 1234 } m = MeasurementOpt ( mtype = \"input\" , minput = [ \"rotation\" , POVM_basis ], \\ savefile = False , method = \"DE\" , ** DE_paras ) PSO # measurement optimization algorithm: PSO PSO_paras = { \"p_num\" : 10 , \"measurement0\" :[], \\ \"max_episode\" :[ 1000 , 100 ], \"c0\" : 1.0 , \\ \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } m = MeasurementOpt ( mtype = \"input\" , minput = [ \"rotation\" , POVM_basis ], \\ savefile = False , method = \"PSO\" , ** PSO_paras ) AD # measurement optimization algorithm: AD AD_paras = { \"Adam\" : False , \"measurement0\" :[], \"max_episode\" : 300 , \\ \"epsilon\" : 0.01 , \"beta1\" : 0.90 , \"beta2\" : 0.99 } m = MeasurementOpt ( mtype = \"input\" , minput = [ \"rotation\" , POVM_basis ], \\ savefile = False , method = \"AD\" , ** AD_paras ) # input the dynamics data m . dynamics ( tspan , rho0 , H0 , dH , decay = decay ) # objective function: tr(WI^{-1}) m . CFIM () Julia using QuanEstimation using Random using LinearAlgebra # initial state rho0 = zeros ( ComplexF64 , 6 , 6 ) rho0 [ 1 : 4 : 5 , 1 : 4 : 5 ] .= 0.5 # Hamiltonian sx = [ 0. 1. ; 1. 0. ] sy = [ 0. - im ; im 0. ] sz = [ 1. 0. ; 0. - 1. ] s1 = [ 0. 1. 0. ; 1. 0. 1. ; 0. 1. 0. ] / sqrt ( 2 ) s2 = [ 0. - im 0. ; im 0. - im ; 0. im 0. ] / sqrt ( 2 ) s3 = [ 1. 0. 0. ; 0. 0. 0. ; 0. 0. - 1. ] Is = I1 , I2 , I3 = [ kron ( I ( 3 ), sx ), kron ( I ( 3 ), sy ), kron ( I ( 3 ), sz )] S = S1 , S2 , S3 = [ kron ( s1 , I ( 2 )), kron ( s2 , I ( 2 )), kron ( s3 , I ( 2 ))] B = B1 , B2 , B3 = [ 5.0e-4 , 5.0e-4 , 5.0e-4 ] # All numbers are divided by 100 in this example # for better calculation accurancy cons = 100 D = ( 2 pi * 2.87 * 1000 ) / cons gS = ( 2 pi * 28.03 * 1000 ) / cons gI = ( 2 pi * 4.32 ) / cons A1 = ( 2 pi * 3.65 ) / cons A2 = ( 2 pi * 3.03 ) / cons H0 = sum ([ D * kron ( s3 ^ 2 , I ( 2 )), sum ( gS * B .* S ), sum ( gI * B .* Is ), A1 * ( kron ( s1 , sx ) + kron ( s2 , sy )), A2 * kron ( s3 , sz )]) # derivatives of the free Hamiltonian on B1, B2 and B3 dH = gS * S + gI * Is # control Hamiltonians Hc = [ S1 , S2 , S3 ] # dissipation decay = [[ S3 , 2 pi / cons ]] # generation of a set of POVM basis dim = size ( rho0 , 1 ) POVM_basis = [ QuanEstimation . basis ( dim , i ) * QuanEstimation . basis ( dim , i ) ' for i in 1 : dim ] # time length for the evolution tspan = range ( 0. , 2. , length = 4000 ) Projection opt = QuanEstimation . MeasurementOpt ( method = :Projection , seed = 1234 ) DE # measurement optimization algorithm: DE alg = QuanEstimation . DE ( p_num = 10 , ini_population = missing , max_episode = 1000 , c = 1.0 , cr = 0.5 ) PSO # measurement optimization algorithm: PSO alg = QuanEstimation . PSO ( p_num = 10 , ini_particle = missing , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) LC opt = QuanEstimation . MeasurementOpt ( method = :LC , POVM_basis = POVM_basis , M_num = 4 , seed = 1234 ) DE # measurement optimization algorithm: DE alg = QuanEstimation . DE ( p_num = 10 , ini_population = missing , max_episode = 1000 , c = 1.0 , cr = 0.5 ) PSO # measurement optimization algorithm: PSO alg = QuanEstimation . PSO ( p_num = 10 , ini_particle = missing , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) AD # measurement optimization algorithm: AD alg = QuanEstimation . AD ( Adam = true , max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 ) Rotation opt = QuanEstimation . MeasurementOpt ( method = :Rotation , POVM_basis = POVM_basis , seed = 1234 ) DE # measurement optimization algorithm: DE alg = QuanEstimation . DE ( p_num = 10 , ini_population = missing , max_episode = 1000 , c = 1.0 , cr = 0.5 ) PSO # measurement optimization algorithm: PSO alg = QuanEstimation . PSO ( p_num = 10 , ini_particle = missing , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) AD # measurement optimization algorithm: AD alg = QuanEstimation . AD ( Adam = true , max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 ) # input the dynamics data dynamics = QuanEstimation . Lindblad ( opt , tspan , rho0 , H0 , dH , decay = decay ) # objective function: CFI obj = QuanEstimation . CFIM_obj () # run the measurement optimization problem QuanEstimation . run ( opt , alg , obj , dynamics ; savefile = false ) If the parameterization process is implemented with the Kraus operators, then the corresponding parameters should be input via Python m = MeasurementOpt ( mtype = \"projection\" , minput = [], savefile = False , method = \"DE\" , ** kwargs ) m . Kraus ( K , dK ) m . CFIM ( W = []) Julia opt = MeasurementOpt ( mtype = :Projection , seed = 1234 ) alg = DE ( kwargs ... ) dynamics = Kraus ( opt , K , dK ) obj = CFIM_obj ( W = missing ) run ( opt , alg , obj , dynamics ; savefile = false ) where K and dK are the Kraus operators and its derivatives with respect to the unknown parameters. Example 7.4 The Kraus operators for the amplitude damping channel are \\[\\begin{eqnarray} K_1 = \\left(\\begin{array}{cc} 1 & 0 \\\\ 0 & \\sqrt{1-\\gamma} \\end{array}\\right), K_2 = \\left(\\begin{array}{cc} 0 & \\sqrt{\\gamma} \\\\ 0 & 0 \\end{array}\\right), \\nonumber \\end{eqnarray}\\] where \\(\\gamma\\) is the unknown parameter to be estimated which represents the decay probability. In this example, the probe state is taken as \\(|+\\rangle\\langle+|\\) with \\(|+\\rangle=\\frac{1}{\\sqrt{2}}(|0\\rangle+|1\\rangle)\\) . Here \\(|0\\rangle\\) \\((|1\\rangle)\\) is the eigenstate of \\(\\sigma_3\\) (Pauli matrix) with respect to the eigenvalue \\(1\\) \\((-1)\\) . Python from quanestimation import * import numpy as np # initial state rho0 = 0.5 * np . array ([[ 1. , 1. ], [ 1. , 1. ]]) # Kraus operators for the amplitude damping channel gamma = 0.1 K1 = np . array ([[ 1. , 0. ], [ 0. , np . sqrt ( 1 - gamma )]]) K2 = np . array ([[ 0. , np . sqrt ( gamma )], [ 0. , 0. ]]) K = [ K1 , K2 ] # derivatives of Kraus operators on gamma dK1 = np . array ([[ 1. , 0. ], [ 0.0 , - 0.5 / np . sqrt ( 1 - gamma )]]) dK2 = np . array ([[ 0. , 0.5 / np . sqrt ( gamma )], [ 0. , 0. ]]) dK = [[ dK1 ], [ dK2 ]] === \"projection\" === \"DE\" # measurement optimization algorithm: DE DE_paras = { \"p_num\" : 10 , \"measurement0\" :[], \"max_episode\" : 1000 , \\ \"c\" : 1.0 , \"cr\" : 0.5 , \"seed\" : 1234 } m = MeasurementOpt ( mtype = \"projection\" , minput = [], savefile = False , \\ method = \"DE\" , ** DE_paras ) === \"PSO\" # measurement optimization algorithm: PSO PSO_paras = { \"p_num\" : 10 , \"measurement0\" :[], \\ \"max_episode\" :[ 1000 , 100 ], \"c0\" : 1.0 , \\ \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } m = MeasurementOpt ( mtype = \"projection\" , minput = [], savefile = False , \\ method = \"PSO\" , ** PSO_paras ) LC DE # measurement optimization algorithm: DE DE_paras = { \"p_num\" : 10 , \"measurement0\" :[], \"max_episode\" : 1000 , \\ \"c\" : 1.0 , \"cr\" : 0.5 , \"seed\" : 1234 } m = MeasurementOpt ( mtype = \"input\" , minput = [ \"LC\" , POVM_basis , 4 ], \\ savefile = False , method = \"DE\" , ** DE_paras ) PSO # measurement optimization algorithm: PSO PSO_paras = { \"p_num\" : 10 , \"measurement0\" :[], \"max_episode\" :[ 1000 , 100 ], \\ \"c0\" : 1.0 , \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } m = MeasurementOpt ( mtype = \"input\" , minput = [ \"LC\" , POVM_basis , 4 ], \\ savefile = False , method = \"PSO\" , ** PSO_paras ) AD # measurement optimization algorithm: AD AD_paras = { \"Adam\" : False , \"measurement0\" :[], \"max_episode\" : 300 , \\ \"epsilon\" : 0.01 , \"beta1\" : 0.90 , \"beta2\" : 0.99 } m = MeasurementOpt ( mtype = \"input\" , minput = [ \"LC\" , POVM_basis , 4 ], \\ savefile = False , method = \"AD\" , ** AD_paras ) rotation DE # measurement optimization algorithm: DE DE_paras = { \"p_num\" : 10 , \"measurement0\" :[], \"max_episode\" : 1000 , \\ \"c\" : 1.0 , \"cr\" : 0.5 , \"seed\" : 1234 } m = MeasurementOpt ( mtype = \"input\" , minput = [ \"rotation\" , POVM_basis ], \\ savefile = False , method = \"DE\" , ** DE_paras ) PSO # measurement optimization algorithm: PSO PSO_paras = { \"p_num\" : 10 , \"measurement0\" :[], \\ \"max_episode\" :[ 1000 , 100 ], \"c0\" : 1.0 , \\ \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } m = MeasurementOpt ( mtype = \"input\" , minput = [ \"rotation\" , POVM_basis ], \\ savefile = False , method = \"PSO\" , ** PSO_paras ) AD # measurement optimization algorithm: AD AD_paras = { \"Adam\" : False , \"measurement0\" :[], \"max_episode\" : 300 , \\ \"epsilon\" : 0.01 , \"beta1\" : 0.90 , \"beta2\" : 0.99 } m = MeasurementOpt ( mtype = \"input\" , minput = [ \"rotation\" , POVM_basis ], \\ savefile = False , method = \"AD\" , ** AD_paras ) # input the dynamics data m . Kraus ( rho0 , K , dK ) # objective function: CFI m . CFIM () Julia using QuanEstimation # initial state rho0 = 0.5 * ones ( 2 , 2 ) # Kraus operators for the amplitude damping channel gamma = 0.1 K1 = [ 1. 0. ; 0. sqrt ( 1 - gamma )] K2 = [ 0. sqrt ( gamma ); 0. 0. ] K = [ K1 , K2 ] # derivatives of Kraus operators on gamma dK1 = [ 1. 0. ; 0. - 0.5 / sqrt ( 1 - gamma )] dK2 = [ 0. 0.5 / sqrt ( gamma ); 0. 0. ] dK = [[ dK1 ], [ dK2 ]] Projection opt = QuanEstimation . MeasurementOpt ( method = :Projection , seed = 1234 ) DE # measurement optimization algorithm: DE alg = QuanEstimation . DE ( p_num = 10 , ini_population = missing , max_episode = 1000 , c = 1.0 , cr = 0.5 ) PSO # measurement optimization algorithm: PSO alg = QuanEstimation . PSO ( p_num = 10 , ini_particle = missing , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) LC opt = QuanEstimation . MeasurementOpt ( method = :LC , POVM_basis = POVM_basis , M_num = 2 , seed = 1234 ) DE # measurement optimization algorithm: DE alg = QuanEstimation . DE ( p_num = 10 , ini_population = missing , max_episode = 1000 , c = 1.0 , cr = 0.5 ) PSO # measurement optimization algorithm: PSO alg = QuanEstimation . PSO ( p_num = 10 , ini_particle = missing , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) AD # measurement optimization algorithm: AD alg = QuanEstimation . AD ( Adam = true , max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 ) Rotation opt = QuanEstimation . MeasurementOpt ( method = :Rotation , POVM_basis = POVM_basis , seed = 1234 ) DE # measurement optimization algorithm: DE alg = QuanEstimation . DE ( p_num = 10 , ini_population = missing , max_episode = 1000 , c = 1.0 , cr = 0.5 ) PSO # measurement optimization algorithm: PSO alg = QuanEstimation . PSO ( p_num = 10 , ini_particle = missing , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) AD # measurement optimization algorithm: AD alg = QuanEstimation . AD ( Adam = true , max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 ) # input the dynamics data dynamics = QuanEstimation . Kraus ( opt , rho0 , K , dK ) # objective function: CFI obj = QuanEstimation . CFIM_obj () # run the measurement optimization problem QuanEstimation . run ( opt , alg , obj , dynamics ; savefile = false ) Bibliography \u00b6 [1] J. Kennedy and R. Eberhar, Particle swarm optimization, Proc. 1995 IEEE International Conference on Neural Networks 4 , 1942-1948 (1995). [2] R. Storn and K. Price, Differential Evolution-A Simple and Efficient Heuristic for global Optimization over Continuous Spaces, J. Global Optim. 11 , 341 (1997). [3] A. G. Baydin, B. A. Pearlmutter, A. A. Radul, and J. M. Siskind, Automatic differentiation in machine learning: a survey, J. Mach. Learn. Res. 18 , 1-43 (2018).","title":"Measurement optimization"},{"location":"guide/guide_Mopt/#measurement-optimization","text":"In QuanEstimation, three measurement optimization scenarios are considered. The first one is to optimize a set of rank-one projective measurement, it can be written in a specific basis \\(\\{|\\phi_i\\rangle\\}\\) with \\(|\\phi_i\\rangle=\\sum_j C_{ij}|j\\rangle\\) in the Hilbert space as \\(\\{|\\phi_i\\rangle\\langle\\phi_i|\\}\\) . In this case, the goal is to search a set of optimal coefficients \\(C_{ij}\\) . The second scenario is to find the optimal linear combination of an input measurement \\(\\{\\Pi_j\\}\\) . The third scenario is to find the optimal rotated measurement of an input measurement. After rotation, the new measurement is \\(\\{U\\Pi_i U^{\\dagger}\\}\\) , where \\(U=\\prod_k \\exp(i s_k\\lambda_k)\\) with \\(\\lambda_k\\) a SU( \\(N\\) ) generator and \\(s_k\\) a real number in the regime \\([0,2\\pi]\\) . In this scenario, the goal is to search a set of optimal coefficients \\(s_k\\) . Here different algorithms are invoked to search the optimal measurement include particle swarm optimization (PSO) [1] , differential evolution (DE) [2] , and automatic differentiation (AD) [3] . The codes for execute measurement optimization are Python m = MeasurementOpt ( mtype = \"projection\" , minput = [], savefile = False , method = \"DE\" , ** kwargs ) m . dynamics ( tspan , rho0 , H0 , dH , Hc = [], ctrl = [], decay = []) m . CFIM ( W = []) mtype represents the type of measurement optimization which defaults to \"projection\" . In this setting, rank-one projective measurement optimization will be performed minput will keep empty in this scenario. For the other two measurement optimization scenarios mtype=\"input\" . If the users want to find the optimal linear combination of an input measurement, the variable minput should be input as minput=[\"LC\", [Pi1,Pi2,...], m] with [Pi1,Pi2,...] a set of POVM and m the number of operators of the output measurement. For finding the optimal linear combination of an input measurement, the variable minput becomes minput=[\"rotation\", [Pi1,Pi2,...]] . savefile means whether to save all the measurements. If set False the measurements in the final episode and the values of the objective function in all episodes will be saved, if savefile=True the measurements and the values of the objective function obtained in all episodes will be saved during the training. method represents the algorithm used to optimize the measurements, options are: \"PSO\", \"DE\" and \"AD\". **kwargs is the keyword and default value corresponding to the optimization algorithm which will be introduced in detail below. If the dynamics of the system can be described by the master equation, then the dynamics data tspan , rho0 , H0 and dH shoule be input. tspan is the time length for the evolution, rho0 represents the density matrix of the initial state, H0 and dH are the free Hamiltonian and its derivatives on the unknown parameters to be estimated. H0 is a matrix when the free Hamiltonian is time-independent and a list with the length equal to tspan when it is time-dependent. dH should be input as \\([\\partial_a{H_0}, \\partial_b{H_0}, \\cdots]\\) . Hc and ctrl are two lists represent the control Hamiltonians and the corresponding control coefficients. decay contains decay operators \\((\\Gamma_1,\\Gamma_2, \\cdots)\\) and the corresponding decay rates \\((\\gamma_1, \\gamma_2, \\cdots)\\) with the input rule decay=[[ \\(\\Gamma_1\\) , \\(\\gamma_1\\) ], [ \\(\\Gamma_2\\) , \\(\\gamma_2\\) ],...]. The default values for decay , Hc and ctrl are empty which means the dynamics is unitary and only governed by the free Hamiltonian. The objective function for measurement optimization are CFI and \\(\\mathrm{Tr}(W\\mathcal{I}^ {-1})\\) with \\(\\mathcal{I}\\) the CFIM. \\(W\\) corresponds to W in the objective function is the weight matrix which defaults to the identity matrix. Julia opt = MeasurementOpt ( mtype = :Projection , seed = 1234 ) alg = DE ( kwargs ... ) dynamics = Lindblad ( opt , tspan , rho0 , H0 , dH ; Hc = missing , ctrl = missing , decay = missing ) obj = CFIM_obj ( W = missing ) run ( opt , alg , obj , dynamics ; savefile = false ) mtype represents the type of measurement optimization which defaults to \"Projection\" . In this setting, rank-one projective measurement optimization will be performed. For the other two measurement optimization scenarios this variable becomes mtype=\"LC\" and mtype=\"Rotation\" . If the users want to find the optimal linear combination of an input measurement, the input rule of opt is MeasurementOpt(mtype=:LC,POVM_basis=[Pi1,Pi2,...],M_num=m) with [Pi1,Pi2,...] a set of POVM and m the number of operators of the output measurement. For finding the optimal linear combination of an input measurement, the code opt is MeasurementOpt(mtype=:LC,POVM_basis=[Pi1,Pi2,...]) . seed is the random seed which can ensure the reproducibility of results. If the dynamics of the system can be described by the master equation, then the dynamics data tspan , rho0 , H0 and dH shoule be input. tspan is the time length for the evolution, rho0 represents the density matrix of the initial state, H0 and dH are the free Hamiltonian and its derivatives on the unknown parameters to be estimated. H0 is a matrix when the free Hamiltonian is time-independent and a list with the length equal to tspan when it is time-dependent. dH should be input as \\([\\partial_a{H_0}, \\partial_b{H_0}, \\cdots]\\) . Hc and ctrl are two lists represent the control Hamiltonians and the corresponding control coefficients. decay contains decay operators \\((\\Gamma_1,\\Gamma_2, \\cdots)\\) and the corresponding decay rates \\((\\gamma_1, \\gamma_2, \\cdots)\\) with the input rule decay=[[ \\(\\Gamma_1\\) , \\(\\gamma_1\\) ], [ \\(\\Gamma_2\\) , \\(\\gamma_2\\) ],...]. The default values for decay , Hc and ctrl are missing which means the dynamics is unitary and only governed by the free Hamiltonian. The objective function for measurement optimization are CFI and \\(\\mathrm{Tr}(W\\mathcal{I}^ {-1})\\) with \\(\\mathcal{I}\\) the CFIM. \\(W\\) corresponds to W in the objective function is the weight matrix which defaults to the identity matrix. The variable savefile means whether to save all the measurements. If set false the measurements in the final episode and the values of the objective function in all episodes will be saved, if savefile=true the measurements and the values of the objective function obtained in all episodes will be saved during the training. The algorithm used for optimizing the measurements are PSO, DE and AD. kwargs... is the keywords and default values corresponding to the optimization algorithm which will be introduced in detail below.","title":"Measurement optimization"},{"location":"guide/guide_Mopt/#pso","text":"The code for measurement optimization with PSO is as follows Python m = MeasurementOpt ( method = \"PSO\" , ** kwargs ) where kwargs is of the form kwargs = { \"p_num\" : 10 , \"measurement0\" :[], \"max_episode\" :[ 1000 , 100 ], \\ \"c0\" : 1.0 , \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } The keywords and the default values of PSO can be seen in the following table \\(~~~~~~~~~~\\) **kwargs \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"p_num\" 10 \"measurement0\" [ ] \"max_episode\" [1000,100] \"c0\" 1.0 \"c1\" 2.0 \"c2\" 2.0 \"seed\" 1234 p_num is the number of particles, c0 , c1 and c2 are the PSO parameters representing the inertia weight, cognitive learning factor and social learning factor, respectively. max_episode accepts both integers and arrays with two elements. If it is an integer, for example max_episode=1000 , it means the program will continuously run 1000 episodes. However, if it is an array, for example max_episode=[1000,100] , the program will run 1000 episodes in total but replace control coefficients of all the particles with global best every 100 episodes. seed is the random seed which can ensure the reproducibility of the results. measurement0 in the algorithm is a list representing the initial guesses of measurements. In the case of projective measurement optimization, the entry of measurement0 is a list of arrays with the length equal to the dimension of the system. In the cases of finding the optimal linear combination and the optimal rotation of a given set of measurement, the entry of measurement0 is a 2D-array and array, respectively. Here, an example of generating measurement0 is given as follows Example 7.1 projection from quanestimation import * from numpy import * # the dimension of the system dim = 6 # generation of the entry of `measurement0` C = [[] for i in range ( dim )] for i in range ( dim ): r_ini = 2 * np . random . random ( dim ) - np . ones ( dim ) r = r_ini / np . linalg . norm ( r_ini ) phi = 2 * np . pi * np . random . random ( dim ) C [ i ] = [ r [ j ] * np . exp ( 1.0 j * phi [ j ]) for j in range ( dim )] C = np . array ( gramschmidt ( C )) measurement0 = [ C ] LC from quanestimation import * from numpy import * # the dimension of the system dim = 6 # a given set of measurement POVM_basis = SIC ( dim ) # the number of operators of the output measurement m = 4 # generation of the entry of `measurement0` B = np . array ([ np . random . random ( len ( POVM_basis )) for i in range ( m )]) measurement0 = [ B ] rotation from quanestimation import * from numpy import * # the dimension of the system dim = 6 # a given set of measurement POVM_basis = SIC ( dim ) # generation of the entry of `measurement0` s = np . random . random ( dim ** 2 ) measurement0 = [ s ] In this algorithm, the length of measurement0 should be less than or equal to p_num . Julia alg = PSO ( p_num = 10 , ini_particle = missing , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) The keywords and the default values of PSO can be seen in the following table \\(~~~~~~~~~~\\) keywords \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"p_num\" 10 \"ini_particle\" missing \"max_episode\" [1000,100] \"c0\" 1.0 \"c1\" 2.0 \"c2\" 2.0 p_num is the number of particles, c0 , c1 and c2 are the PSO parameters representing the inertia weight, cognitive learning factor and social learning factor, respectively. max_episode accepts both integers and arrays with two elements. If it is an integer, for example max_episode=1000 , it means the program will continuously run 1000 episodes. However, if it is an array, for example max_episode=[1000,100] , the program will run 1000 episodes in total but replace control coefficients of all the particles with global best every 100 episodes. ini_particle in the algorithm is a list representing the initial guesses of measurements, In the case of projective measurement optimization, the entry of ini_particle is a list of arrays with the length equal to the dimension of the system. In the cases of finding the optimal linear combination and the optimal rotation of a given set of measurement, the entry of ini_particle is a 2D-array and array, respectively. Here, an example of generating ini_particle is given as follows Example 7.1 Projection using QuanEstimation # the dimension of the system dim = 6 # generation of the entry of `measurement0` C = [ ComplexF64 [] for _ in 1 : dim ] for i in 1 : dim r_ini = 2 * rand ( dim ) - ones ( dim ) r = r_ini / norm ( r_ini ) \u03d5 = 2 pi * rand ( dim ) C [ i ] = [ r * exp ( im * \u03d5 ) for ( r , \u03d5 ) in zip ( r , \u03d5 )] end C = QuanEstimation . gramschmidt ( C ) measurement0 = ([ C ],) LC using QuanEstimation # the dimension of the system dim = 6 # a given set of measurement POVM_basis = QuanEstimation . SIC ( dim ) # the number of operators of the output measurement m = 4 # generation of the entry of `measurement0` B = [ rand ( length ( POVM_basis )) for _ in 1 : m ] measurement0 = ([ B ],) Rotation using QuanEstimation # the dimension of the system dim = 6 # a given set of measurement POVM_basis = QuanEstimation . SIC ( dim ) # generation of the entry of `measurement0` s = rand ( dim ^ 2 ) measurement0 = ([ s ],) In this algorithm, the length of measurement0 should be less than or equal to p_num .","title":"PSO"},{"location":"guide/guide_Mopt/#de","text":"The code for measurement optimization with DE is as follows Python m = MeasurementOpt ( method = \"DE\" , ** kwargs ) where kwargs is of the form kwargs = { \"p_num\" : 10 , \"measurement0\" :[], \"max_episode\" : 1000 , \\ \"c\" : 1.0 , \"cr\" : 0.5 , \"seed\" : 1234 } The keywords and the default values of DE can be seen in the following table \\(~~~~~~~~~~\\) **kwargs \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"p_num\" 10 \"measurement0\" [ ] \"max_episode\" 1000 \"c\" 1.0 \"cr\" 0.5 \"seed\" 1234 p_num represents the number of populations, c and cr are the mutation constant and the crossover constant. Here max_episode is an integer representing the number of episodes, the variable measurement0 is the same with measurement0 in PSO. Julia alg = DE ( p_num = 10 , ini_population = missing , max_episode = 1000 , c = 1.0 , cr = 0.5 ) The keywords and the default values of DE can be seen in the following table \\(~~~~~~~~~~\\) keywords \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"p_num\" 10 \"ini_population\" [ ] \"max_episode\" 1000 \"c\" 1.0 \"cr\" 0.5 p_num represents the number of populations, c and cr are the mutation constant and the crossover constant. Here max_episode is an integer representing the number of episodes, the variable ini_population is the same with ini_particle in PSO.","title":"DE"},{"location":"guide/guide_Mopt/#ad","text":"The code for measurement optimization with AD is as follows Python com = MeasurementOpt ( method = \"AD\" , ** kwargs ) where kwargs is of the form kwargs = { \"Adam\" : False , \"measurement0\" :[], \"max_episode\" : 300 , \\ \"epsilon\" : 0.01 , \"beta1\" : 0.90 , \"beta2\" : 0.99 } The keywords and the default values of AD can be seen in the following table \\(~~~~~~~~~~\\) **kwargs \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"Adam\" False \"measurement0\" [ ] \"max_episode\" 300 \"epsilon\" 0.01 \"beta1\" 0.90 \"beta2\" 0.99 The measurements will update according to the learning rate \"epsilon\" for Adam=False , However, Adam algorithm can be introduced to update the measurements which can be realized by setting Adam=True . In this case, the Adam parameters include learning rate, the exponential decay rate for the first moment estimates and the second moment estimates can be set by the user via epsilon , beta1 and beta2 . The input rule of measurement0 is the same with that in PSO, but the length of measurement0 is equal to one. Julia alg = AD ( Adam = false , max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 ) The keywords and the default values of AD can be seen in the following table \\(~~~~~~~~~~\\) keywords \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"Adam\" false \"max_episode\" 300 \"epsilon\" 0.01 \"beta1\" 0.90 \"beta2\" 0.99 The measurements will update according to the learning rate \"epsilon\" for Adam=False , However, Adam algorithm can be introduced to update the measurements which can be realized by setting Adam=true . In this case, the Adam parameters include learning rate, the exponential decay rate for the first moment estimates and the second moment estimates can be set by the user via epsilon , beta1 and beta2 . Example 7.2 A single qubit system whose dynamics is governed by \\begin{align} \\partial_t\\rho=-i[H, \\rho]+ \\gamma_{+}\\left(\\sigma_{+}\\rho\\sigma_{-}-\\frac{1}{2}{\\sigma_{-} \\sigma_{+},\\rho}\\right)+ \\gamma_{-}\\left(\\sigma_{-}\\rho\\sigma_{+}-\\frac{1}{2}{\\sigma_{+} \\sigma_{-},\\rho}\\right), \\end{align} where \\(H = \\frac{1}{2}\\omega \\sigma_3\\) is the free Hamiltonian with \\(\\omega\\) the frequency, \\(\\sigma_{\\pm}=(\\sigma_1 \\pm \\sigma_2)/2\\) and \\(\\gamma_{+}\\) , \\(\\gamma_{-}\\) are decay rates. Here \\(\\sigma_{i}\\) for \\((i=1,2,3)\\) is the Pauli matrix. In this case, the probe state is taken as \\(\\frac{1}{\\sqrt{2}}(|0\\rangle +|1\\rangle)\\) , \\(|0\\rangle\\) \\((|1\\rangle)\\) is the eigenstate of \\(\\sigma_3\\) with respect to the eigenvalue \\(1\\) \\((-1)\\) . Python from quanestimation import * import numpy as np # initial state rho0 = 0.5 * np . array ([[ 1. , 1. ], [ 1. , 1. ]]) # free Hamiltonian omega = 1.0 sx = np . array ([[ 0. , 1. ], [ 1. , 0. ]]) sy = np . array ([[ 0. , - 1. j ], [ 1. j , 0. ]]) sz = np . array ([[ 1. , 0. ], [ 0. , - 1. ]]) H0 = 0.5 * omega * sz # derivative of the free Hamiltonian on omega dH = [ 0.5 * sz ] # dissipation sp = np . array ([[ 0. , 1. ], [ 0. , 0. ]]) sm = np . array ([[ 0. , 0. ], [ 1. , 0. ]]) decay = [[ sp , 0. ], [ sm , 0.1 ]] # generation of a set of POVM basis dim = np . shape ( rho0 )[ 0 ] POVM_basis = SIC ( dim ) # time length for the evolution tspan = np . linspace ( 0. , 10. , 2500 ) projection DE # measurement optimization algorithm: DE DE_paras = { \"p_num\" : 10 , \"measurement0\" :[], \"max_episode\" : 1000 , \\ \"c\" : 1.0 , \"cr\" : 0.5 , \"seed\" : 1234 } m = MeasurementOpt ( mtype = \"projection\" , minput = [], savefile = False , \\ method = \"DE\" , ** DE_paras ) PSO # measurement optimization algorithm: PSO PSO_paras = { \"p_num\" : 10 , \"measurement0\" :[], \\ \"max_episode\" :[ 1000 , 100 ], \"c0\" : 1.0 , \\ \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } m = MeasurementOpt ( mtype = \"projection\" , minput = [], savefile = False , \\ method = \"PSO\" , ** PSO_paras ) LC DE # measurement optimization algorithm: DE DE_paras = { \"p_num\" : 10 , \"measurement0\" :[], \"max_episode\" : 1000 , \\ \"c\" : 1.0 , \"cr\" : 0.5 , \"seed\" : 1234 } m = MeasurementOpt ( mtype = \"input\" , minput = [ \"LC\" , POVM_basis , 4 ], \\ savefile = False , method = \"DE\" , ** DE_paras ) PSO # measurement optimization algorithm: PSO PSO_paras = { \"p_num\" : 10 , \"measurement0\" :[], \"max_episode\" :[ 1000 , 100 ], \\ \"c0\" : 1.0 , \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } m = MeasurementOpt ( mtype = \"input\" , minput = [ \"LC\" , POVM_basis , 4 ], \\ savefile = False , method = \"PSO\" , ** PSO_paras ) AD # measurement optimization algorithm: AD AD_paras = { \"Adam\" : False , \"measurement0\" :[], \"max_episode\" : 300 , \\ \"epsilon\" : 0.01 , \"beta1\" : 0.90 , \"beta2\" : 0.99 } m = MeasurementOpt ( mtype = \"input\" , minput = [ \"LC\" , POVM_basis , 4 ], \\ savefile = False , method = \"AD\" , ** AD_paras ) rotation DE # measurement optimization algorithm: DE DE_paras = { \"p_num\" : 10 , \"measurement0\" :[], \"max_episode\" : 1000 , \\ \"c\" : 1.0 , \"cr\" : 0.5 , \"seed\" : 1234 } m = MeasurementOpt ( mtype = \"input\" , minput = [ \"rotation\" , POVM_basis ], \\ savefile = False , method = \"DE\" , ** DE_paras ) PSO # measurement optimization algorithm: PSO PSO_paras = { \"p_num\" : 10 , \"measurement0\" :[], \\ \"max_episode\" :[ 1000 , 100 ], \"c0\" : 1.0 , \\ \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } m = MeasurementOpt ( mtype = \"input\" , minput = [ \"rotation\" , POVM_basis ], \\ savefile = False , method = \"PSO\" , ** PSO_paras ) AD # measurement optimization algorithm: AD AD_paras = { \"Adam\" : False , \"measurement0\" :[], \"max_episode\" : 300 , \\ \"epsilon\" : 0.01 , \"beta1\" : 0.90 , \"beta2\" : 0.99 } m = MeasurementOpt ( mtype = \"input\" , minput = [ \"rotation\" , POVM_basis ], \\ savefile = False , method = \"AD\" , ** AD_paras ) # input the dynamics data m . dynamics ( tspan , rho0 , H0 , dH , decay = decay ) # objective function: CFI m . CFIM () Julia using QuanEstimation using Random using StableRNGs using LinearAlgebra # initial state rho0 = 0.5 * ones ( 2 , 2 ) # free Hamiltonian omega = 1.0 sx = [ 0. 1. ; 1. 0.0 im ] sy = [ 0. - im ; im 0. ] sz = [ 1. 0.0 im ; 0. - 1. ] H0 = 0.5 * omega * sz # derivative of the free Hamiltonian on omega dH = [ 0.5 * sz ] # dissipation sp = [ 0. 1. ; 0. 0.0 im ] sm = [ 0. 0. ; 1. 0.0 im ] decay = [[ sp , 0. ], [ sm , 0.1 ]] # generation of a set of POVM basis dim = size ( rho0 , 1 ) POVM_basis = QuanEstimation . SIC ( dim ) # time length for the evolution tspan = range ( 0. , 10. , length = 2500 ) Projection opt = QuanEstimation . MeasurementOpt ( method = :Projection , seed = 1234 ) DE # measurement optimization algorithm: DE alg = QuanEstimation . DE ( p_num = 10 , ini_population = missing , max_episode = 1000 , c = 1.0 , cr = 0.5 ) PSO # measurement optimization algorithm: PSO alg = QuanEstimation . PSO ( p_num = 10 , ini_particle = missing , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) LC opt = QuanEstimation . MeasurementOpt ( method = :LC , POVM_basis = POVM_basis , M_num = 2 , seed = 1234 ) DE # measurement optimization algorithm: DE alg = QuanEstimation . DE ( p_num = 10 , ini_population = missing , max_episode = 1000 , c = 1.0 , cr = 0.5 ) PSO # measurement optimization algorithm: PSO alg = QuanEstimation . PSO ( p_num = 10 , ini_particle = missing , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) AD # measurement optimization algorithm: AD alg = QuanEstimation . AD ( Adam = true , max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 ) Rotation opt = QuanEstimation . MeasurementOpt ( method = :Rotation , POVM_basis = POVM_basis , seed = 1234 ) DE # measurement optimization algorithm: DE alg = QuanEstimation . DE ( p_num = 10 , ini_population = missing , max_episode = 1000 , c = 1.0 , cr = 0.5 ) PSO # measurement optimization algorithm: PSO alg = QuanEstimation . PSO ( p_num = 10 , ini_particle = missing , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) AD # measurement optimization algorithm: AD alg = QuanEstimation . AD ( Adam = true , max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 ) # input the dynamics data dynamics = QuanEstimation . Lindblad ( opt , tspan , rho0 , H0 , dH , decay = decay ) # objective function: CFI obj = QuanEstimation . CFIM_obj () # run the measurement optimization problem QuanEstimation . run ( opt , alg , obj , dynamics ; savefile = false ) Example 7.3 In the multiparameter scenario, the dynamics of electron and nuclear coupling in NV \\(^{-}\\) can be expressed as \\begin{align} \\partial_t\\rho=-i[H_0,\\rho]+\\frac{\\gamma}{2}(S_3\\rho S_3-S^2_3\\rho-\\rho S^2_3) \\end{align} with \\(\\gamma\\) the dephasing rate. And \\begin{align} H_0/\\hbar=DS^2_3+g_{\\mathrm{S}}\\vec{B}\\cdot\\vec{S}+g_{\\mathrm{I}}\\vec{B}\\cdot\\vec{I}+\\vec{S}^{\\,\\mathrm{T}}\\mathcal{A}\\vec{I} \\end{align} is the free evolution Hamiltonian, where \\(\\vec{S}=(S_1,S_2,S_3)^{\\mathrm{T}}\\) and \\(\\vec{I}=(I_1,I_2,I_3)^{\\mathrm{T}}\\) with \\(S_i=s_i\\otimes I\\) and \\(I_i=I\\otimes \\sigma_i\\) \\((i=1,2,3)\\) the electron and nuclear operators. \\(s_1, s_2, s_3\\) are spin-1 operators with \\[\\begin{eqnarray} s_1 = \\frac{1}{\\sqrt{2}}\\left(\\begin{array}{ccc} 0 & 1 & 0 \\\\ 1 & 0 & 1 \\\\ 0 & 1 & 0 \\end{array}\\right), s_2 = \\frac{1}{\\sqrt{2}}\\left(\\begin{array}{ccc} 0 & -i & 0\\\\ i & 0 & -i\\\\ 0 & i & 0 \\end{array}\\right)\\!\\!, \\nonumber \\end{eqnarray}\\] and \\(s_3=\\mathrm{diag}(1,0,-1)\\) and \\(\\sigma_i (i=1,2,3)\\) is Pauli matrix. \\(\\mathcal{A}=\\mathrm{diag} (A_1,A_1,A_2)\\) is the hyperfine tensor with \\(A_1\\) and \\(A_2\\) the axial and transverse magnetic hyperfine coupling coefficients. The coefficients \\(g_{\\mathrm{S}}=g_\\mathrm{e}\\mu_\\mathrm{B}/\\hbar\\) and \\(g_{\\mathrm{I}}=g_\\mathrm{n}\\mu_\\mathrm{n}/\\hbar\\) , where \\(g_\\mathrm{e}\\) ( \\(g_\\mathrm{n}\\) ) is the \\(g\\) factor of the electron (nuclear), \\(\\mu_\\mathrm{B}\\) ( \\(\\mu_\\mathrm{n}\\) ) is the Bohr (nuclear) magneton and \\(\\hbar\\) is the Plank's constant. \\(\\vec{B}\\) is the magnetic field which be estimated. In this case,the initial state is taken as \\(\\frac{1}{\\sqrt{2}}(|1\\rangle+|\\!-\\!1\\rangle)\\otimes|\\!\\!\\uparrow\\rangle\\) , where \\(\\frac{1}{\\sqrt{2}}(|1\\rangle+|\\!-\\!1\\rangle)\\) is an electron state with \\(|1\\rangle\\) ( \\(|\\!-\\!1\\rangle\\) ) the eigenstate of \\(s_3\\) with respect to the eigenvalue \\(1\\) ( \\(-1\\) ). \\(|\\!\\!\\uparrow\\rangle\\) is a nuclear state and the eigenstate of \\(\\sigma_3\\) with respect to the eigenvalue 1. \\(W\\) is set to be \\(I\\) . Here three types of measurement optimization are considerd, projective measurement, linear combination of a given set of positive operator-valued measure (POVM) and optimal rotated measurement of an input measurement. Python from quanestimation import * import numpy as np # initial state rho0 = np . zeros (( 6 , 6 ), dtype = np . complex128 ) rho0 [ 0 ][ 0 ], rho0 [ 0 ][ 4 ], rho0 [ 4 ][ 0 ], rho0 [ 4 ][ 4 ] = 0.5 , 0.5 , 0.5 , 0.5 # free Hamiltonian sx = np . array ([[ 0. , 1. ],[ 1. , 0. ]]) sy = np . array ([[ 0. , - 1. j ],[ 1. j , 0. ]]) sz = np . array ([[ 1. , 0. ],[ 0. , - 1. ]]) ide2 = np . array ([[ 1. , 0. ],[ 0. , 1. ]]) s1 = np . array ([[ 0. , 1. , 0. ],[ 1. , 0. , 1. ],[ 0. , 1. , 0. ]]) / np . sqrt ( 2 ) s2 = np . array ([[ 0. , - 1. j , 0. ],[ 1. j , 0. , - 1. j ],[ 0. , 1. j , 0. ]]) / np . sqrt ( 2 ) s3 = np . array ([[ 1. , 0. , 0. ],[ 0. , 0. , 0. ],[ 0. , 0. , - 1. ]]) ide3 = np . array ([[ 1. , 0. , 0. ],[ 0. , 1. , 0. ],[ 0. , 0. , 1. ]]) I1 , I2 , I3 = np . kron ( ide3 , sx ), np . kron ( ide3 , sy ), np . kron ( ide3 , sz ) S1 , S2 , S3 = np . kron ( s1 , ide2 ), np . kron ( s2 , ide2 ), np . kron ( s3 , ide2 ) B1 , B2 , B3 = 5.0e-4 , 5.0e-4 , 5.0e-4 # All numbers are divided by 100 in this example # for better calculation accurancy cons = 100 D = ( 2 * np . pi * 2.87 * 1000 ) / cons gS = ( 2 * np . pi * 28.03 * 1000 ) / cons gI = ( 2 * np . pi * 4.32 ) / cons A1 = ( 2 * np . pi * 3.65 ) / cons A2 = ( 2 * np . pi * 3.03 ) / cons H0 = D * np . kron ( np . dot ( s3 , s3 ), ide2 ) + gS * ( B1 * S1 + B2 * S2 + B3 * S3 ) \\ + gI * ( B1 * I1 + B2 * I2 + B3 * I3 ) + A1 * ( np . kron ( s1 , sx ) + np . kron ( s2 , sy )) \\ + A2 * np . kron ( s3 , sz ) # derivatives of the free Hamiltonian on B1, B2 and B3 dH = [ gS * S1 + gI * I1 , gS * S2 + gI * I2 , gS * S3 + gI * I3 ] # control Hamiltonians Hc = [ S1 , S2 , S3 ] # dissipation decay = [[ S3 , 2 * np . pi / cons ]] # generation of a set of POVM basis dim = len ( rho0 ) POVM_basis = [ np . dot ( basis ( dim , i ), basis ( dim , i ) . conj () . T ) \\ for i in range ( dim )] # time length for the evolution tspan = np . linspace ( 0. , 2. , 4000 ) projection DE # measurement optimization algorithm: DE DE_paras = { \"p_num\" : 10 , \"measurement0\" :[], \"max_episode\" : 1000 , \\ \"c\" : 1.0 , \"cr\" : 0.5 , \"seed\" : 1234 } m = MeasurementOpt ( mtype = \"projection\" , minput = [], savefile = False , \\ method = \"DE\" , ** DE_paras ) PSO # measurement optimization algorithm: PSO PSO_paras = { \"p_num\" : 10 , \"measurement0\" :[], \\ \"max_episode\" :[ 1000 , 100 ], \"c0\" : 1.0 , \\ \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } m = MeasurementOpt ( mtype = \"projection\" , minput = [], savefile = False , \\ method = \"PSO\" , ** PSO_paras ) LC DE # measurement optimization algorithm: DE DE_paras = { \"p_num\" : 10 , \"measurement0\" :[], \"max_episode\" : 1000 , \\ \"c\" : 1.0 , \"cr\" : 0.5 , \"seed\" : 1234 } m = MeasurementOpt ( mtype = \"input\" , minput = [ \"LC\" , POVM_basis , 4 ], \\ savefile = False , method = \"DE\" , ** DE_paras ) PSO # measurement optimization algorithm: PSO PSO_paras = { \"p_num\" : 10 , \"measurement0\" :[], \"max_episode\" :[ 1000 , 100 ], \\ \"c0\" : 1.0 , \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } m = MeasurementOpt ( mtype = \"input\" , minput = [ \"LC\" , POVM_basis , 4 ], \\ savefile = False , method = \"PSO\" , ** PSO_paras ) AD # measurement optimization algorithm: AD AD_paras = { \"Adam\" : False , \"measurement0\" :[], \"max_episode\" : 300 , \\ \"epsilon\" : 0.01 , \"beta1\" : 0.90 , \"beta2\" : 0.99 } m = MeasurementOpt ( mtype = \"input\" , minput = [ \"LC\" , POVM_basis , 4 ], \\ savefile = False , method = \"AD\" , ** AD_paras ) rotation DE # measurement optimization algorithm: DE DE_paras = { \"p_num\" : 10 , \"measurement0\" :[], \"max_episode\" : 1000 , \\ \"c\" : 1.0 , \"cr\" : 0.5 , \"seed\" : 1234 } m = MeasurementOpt ( mtype = \"input\" , minput = [ \"rotation\" , POVM_basis ], \\ savefile = False , method = \"DE\" , ** DE_paras ) PSO # measurement optimization algorithm: PSO PSO_paras = { \"p_num\" : 10 , \"measurement0\" :[], \\ \"max_episode\" :[ 1000 , 100 ], \"c0\" : 1.0 , \\ \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } m = MeasurementOpt ( mtype = \"input\" , minput = [ \"rotation\" , POVM_basis ], \\ savefile = False , method = \"PSO\" , ** PSO_paras ) AD # measurement optimization algorithm: AD AD_paras = { \"Adam\" : False , \"measurement0\" :[], \"max_episode\" : 300 , \\ \"epsilon\" : 0.01 , \"beta1\" : 0.90 , \"beta2\" : 0.99 } m = MeasurementOpt ( mtype = \"input\" , minput = [ \"rotation\" , POVM_basis ], \\ savefile = False , method = \"AD\" , ** AD_paras ) # input the dynamics data m . dynamics ( tspan , rho0 , H0 , dH , decay = decay ) # objective function: tr(WI^{-1}) m . CFIM () Julia using QuanEstimation using Random using LinearAlgebra # initial state rho0 = zeros ( ComplexF64 , 6 , 6 ) rho0 [ 1 : 4 : 5 , 1 : 4 : 5 ] .= 0.5 # Hamiltonian sx = [ 0. 1. ; 1. 0. ] sy = [ 0. - im ; im 0. ] sz = [ 1. 0. ; 0. - 1. ] s1 = [ 0. 1. 0. ; 1. 0. 1. ; 0. 1. 0. ] / sqrt ( 2 ) s2 = [ 0. - im 0. ; im 0. - im ; 0. im 0. ] / sqrt ( 2 ) s3 = [ 1. 0. 0. ; 0. 0. 0. ; 0. 0. - 1. ] Is = I1 , I2 , I3 = [ kron ( I ( 3 ), sx ), kron ( I ( 3 ), sy ), kron ( I ( 3 ), sz )] S = S1 , S2 , S3 = [ kron ( s1 , I ( 2 )), kron ( s2 , I ( 2 )), kron ( s3 , I ( 2 ))] B = B1 , B2 , B3 = [ 5.0e-4 , 5.0e-4 , 5.0e-4 ] # All numbers are divided by 100 in this example # for better calculation accurancy cons = 100 D = ( 2 pi * 2.87 * 1000 ) / cons gS = ( 2 pi * 28.03 * 1000 ) / cons gI = ( 2 pi * 4.32 ) / cons A1 = ( 2 pi * 3.65 ) / cons A2 = ( 2 pi * 3.03 ) / cons H0 = sum ([ D * kron ( s3 ^ 2 , I ( 2 )), sum ( gS * B .* S ), sum ( gI * B .* Is ), A1 * ( kron ( s1 , sx ) + kron ( s2 , sy )), A2 * kron ( s3 , sz )]) # derivatives of the free Hamiltonian on B1, B2 and B3 dH = gS * S + gI * Is # control Hamiltonians Hc = [ S1 , S2 , S3 ] # dissipation decay = [[ S3 , 2 pi / cons ]] # generation of a set of POVM basis dim = size ( rho0 , 1 ) POVM_basis = [ QuanEstimation . basis ( dim , i ) * QuanEstimation . basis ( dim , i ) ' for i in 1 : dim ] # time length for the evolution tspan = range ( 0. , 2. , length = 4000 ) Projection opt = QuanEstimation . MeasurementOpt ( method = :Projection , seed = 1234 ) DE # measurement optimization algorithm: DE alg = QuanEstimation . DE ( p_num = 10 , ini_population = missing , max_episode = 1000 , c = 1.0 , cr = 0.5 ) PSO # measurement optimization algorithm: PSO alg = QuanEstimation . PSO ( p_num = 10 , ini_particle = missing , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) LC opt = QuanEstimation . MeasurementOpt ( method = :LC , POVM_basis = POVM_basis , M_num = 4 , seed = 1234 ) DE # measurement optimization algorithm: DE alg = QuanEstimation . DE ( p_num = 10 , ini_population = missing , max_episode = 1000 , c = 1.0 , cr = 0.5 ) PSO # measurement optimization algorithm: PSO alg = QuanEstimation . PSO ( p_num = 10 , ini_particle = missing , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) AD # measurement optimization algorithm: AD alg = QuanEstimation . AD ( Adam = true , max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 ) Rotation opt = QuanEstimation . MeasurementOpt ( method = :Rotation , POVM_basis = POVM_basis , seed = 1234 ) DE # measurement optimization algorithm: DE alg = QuanEstimation . DE ( p_num = 10 , ini_population = missing , max_episode = 1000 , c = 1.0 , cr = 0.5 ) PSO # measurement optimization algorithm: PSO alg = QuanEstimation . PSO ( p_num = 10 , ini_particle = missing , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) AD # measurement optimization algorithm: AD alg = QuanEstimation . AD ( Adam = true , max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 ) # input the dynamics data dynamics = QuanEstimation . Lindblad ( opt , tspan , rho0 , H0 , dH , decay = decay ) # objective function: CFI obj = QuanEstimation . CFIM_obj () # run the measurement optimization problem QuanEstimation . run ( opt , alg , obj , dynamics ; savefile = false ) If the parameterization process is implemented with the Kraus operators, then the corresponding parameters should be input via Python m = MeasurementOpt ( mtype = \"projection\" , minput = [], savefile = False , method = \"DE\" , ** kwargs ) m . Kraus ( K , dK ) m . CFIM ( W = []) Julia opt = MeasurementOpt ( mtype = :Projection , seed = 1234 ) alg = DE ( kwargs ... ) dynamics = Kraus ( opt , K , dK ) obj = CFIM_obj ( W = missing ) run ( opt , alg , obj , dynamics ; savefile = false ) where K and dK are the Kraus operators and its derivatives with respect to the unknown parameters. Example 7.4 The Kraus operators for the amplitude damping channel are \\[\\begin{eqnarray} K_1 = \\left(\\begin{array}{cc} 1 & 0 \\\\ 0 & \\sqrt{1-\\gamma} \\end{array}\\right), K_2 = \\left(\\begin{array}{cc} 0 & \\sqrt{\\gamma} \\\\ 0 & 0 \\end{array}\\right), \\nonumber \\end{eqnarray}\\] where \\(\\gamma\\) is the unknown parameter to be estimated which represents the decay probability. In this example, the probe state is taken as \\(|+\\rangle\\langle+|\\) with \\(|+\\rangle=\\frac{1}{\\sqrt{2}}(|0\\rangle+|1\\rangle)\\) . Here \\(|0\\rangle\\) \\((|1\\rangle)\\) is the eigenstate of \\(\\sigma_3\\) (Pauli matrix) with respect to the eigenvalue \\(1\\) \\((-1)\\) . Python from quanestimation import * import numpy as np # initial state rho0 = 0.5 * np . array ([[ 1. , 1. ], [ 1. , 1. ]]) # Kraus operators for the amplitude damping channel gamma = 0.1 K1 = np . array ([[ 1. , 0. ], [ 0. , np . sqrt ( 1 - gamma )]]) K2 = np . array ([[ 0. , np . sqrt ( gamma )], [ 0. , 0. ]]) K = [ K1 , K2 ] # derivatives of Kraus operators on gamma dK1 = np . array ([[ 1. , 0. ], [ 0.0 , - 0.5 / np . sqrt ( 1 - gamma )]]) dK2 = np . array ([[ 0. , 0.5 / np . sqrt ( gamma )], [ 0. , 0. ]]) dK = [[ dK1 ], [ dK2 ]] === \"projection\" === \"DE\" # measurement optimization algorithm: DE DE_paras = { \"p_num\" : 10 , \"measurement0\" :[], \"max_episode\" : 1000 , \\ \"c\" : 1.0 , \"cr\" : 0.5 , \"seed\" : 1234 } m = MeasurementOpt ( mtype = \"projection\" , minput = [], savefile = False , \\ method = \"DE\" , ** DE_paras ) === \"PSO\" # measurement optimization algorithm: PSO PSO_paras = { \"p_num\" : 10 , \"measurement0\" :[], \\ \"max_episode\" :[ 1000 , 100 ], \"c0\" : 1.0 , \\ \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } m = MeasurementOpt ( mtype = \"projection\" , minput = [], savefile = False , \\ method = \"PSO\" , ** PSO_paras ) LC DE # measurement optimization algorithm: DE DE_paras = { \"p_num\" : 10 , \"measurement0\" :[], \"max_episode\" : 1000 , \\ \"c\" : 1.0 , \"cr\" : 0.5 , \"seed\" : 1234 } m = MeasurementOpt ( mtype = \"input\" , minput = [ \"LC\" , POVM_basis , 4 ], \\ savefile = False , method = \"DE\" , ** DE_paras ) PSO # measurement optimization algorithm: PSO PSO_paras = { \"p_num\" : 10 , \"measurement0\" :[], \"max_episode\" :[ 1000 , 100 ], \\ \"c0\" : 1.0 , \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } m = MeasurementOpt ( mtype = \"input\" , minput = [ \"LC\" , POVM_basis , 4 ], \\ savefile = False , method = \"PSO\" , ** PSO_paras ) AD # measurement optimization algorithm: AD AD_paras = { \"Adam\" : False , \"measurement0\" :[], \"max_episode\" : 300 , \\ \"epsilon\" : 0.01 , \"beta1\" : 0.90 , \"beta2\" : 0.99 } m = MeasurementOpt ( mtype = \"input\" , minput = [ \"LC\" , POVM_basis , 4 ], \\ savefile = False , method = \"AD\" , ** AD_paras ) rotation DE # measurement optimization algorithm: DE DE_paras = { \"p_num\" : 10 , \"measurement0\" :[], \"max_episode\" : 1000 , \\ \"c\" : 1.0 , \"cr\" : 0.5 , \"seed\" : 1234 } m = MeasurementOpt ( mtype = \"input\" , minput = [ \"rotation\" , POVM_basis ], \\ savefile = False , method = \"DE\" , ** DE_paras ) PSO # measurement optimization algorithm: PSO PSO_paras = { \"p_num\" : 10 , \"measurement0\" :[], \\ \"max_episode\" :[ 1000 , 100 ], \"c0\" : 1.0 , \\ \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } m = MeasurementOpt ( mtype = \"input\" , minput = [ \"rotation\" , POVM_basis ], \\ savefile = False , method = \"PSO\" , ** PSO_paras ) AD # measurement optimization algorithm: AD AD_paras = { \"Adam\" : False , \"measurement0\" :[], \"max_episode\" : 300 , \\ \"epsilon\" : 0.01 , \"beta1\" : 0.90 , \"beta2\" : 0.99 } m = MeasurementOpt ( mtype = \"input\" , minput = [ \"rotation\" , POVM_basis ], \\ savefile = False , method = \"AD\" , ** AD_paras ) # input the dynamics data m . Kraus ( rho0 , K , dK ) # objective function: CFI m . CFIM () Julia using QuanEstimation # initial state rho0 = 0.5 * ones ( 2 , 2 ) # Kraus operators for the amplitude damping channel gamma = 0.1 K1 = [ 1. 0. ; 0. sqrt ( 1 - gamma )] K2 = [ 0. sqrt ( gamma ); 0. 0. ] K = [ K1 , K2 ] # derivatives of Kraus operators on gamma dK1 = [ 1. 0. ; 0. - 0.5 / sqrt ( 1 - gamma )] dK2 = [ 0. 0.5 / sqrt ( gamma ); 0. 0. ] dK = [[ dK1 ], [ dK2 ]] Projection opt = QuanEstimation . MeasurementOpt ( method = :Projection , seed = 1234 ) DE # measurement optimization algorithm: DE alg = QuanEstimation . DE ( p_num = 10 , ini_population = missing , max_episode = 1000 , c = 1.0 , cr = 0.5 ) PSO # measurement optimization algorithm: PSO alg = QuanEstimation . PSO ( p_num = 10 , ini_particle = missing , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) LC opt = QuanEstimation . MeasurementOpt ( method = :LC , POVM_basis = POVM_basis , M_num = 2 , seed = 1234 ) DE # measurement optimization algorithm: DE alg = QuanEstimation . DE ( p_num = 10 , ini_population = missing , max_episode = 1000 , c = 1.0 , cr = 0.5 ) PSO # measurement optimization algorithm: PSO alg = QuanEstimation . PSO ( p_num = 10 , ini_particle = missing , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) AD # measurement optimization algorithm: AD alg = QuanEstimation . AD ( Adam = true , max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 ) Rotation opt = QuanEstimation . MeasurementOpt ( method = :Rotation , POVM_basis = POVM_basis , seed = 1234 ) DE # measurement optimization algorithm: DE alg = QuanEstimation . DE ( p_num = 10 , ini_population = missing , max_episode = 1000 , c = 1.0 , cr = 0.5 ) PSO # measurement optimization algorithm: PSO alg = QuanEstimation . PSO ( p_num = 10 , ini_particle = missing , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) AD # measurement optimization algorithm: AD alg = QuanEstimation . AD ( Adam = true , max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 ) # input the dynamics data dynamics = QuanEstimation . Kraus ( opt , rho0 , K , dK ) # objective function: CFI obj = QuanEstimation . CFIM_obj () # run the measurement optimization problem QuanEstimation . run ( opt , alg , obj , dynamics ; savefile = false )","title":"AD"},{"location":"guide/guide_Mopt/#bibliography","text":"[1] J. Kennedy and R. Eberhar, Particle swarm optimization, Proc. 1995 IEEE International Conference on Neural Networks 4 , 1942-1948 (1995). [2] R. Storn and K. Price, Differential Evolution-A Simple and Efficient Heuristic for global Optimization over Continuous Spaces, J. Global Optim. 11 , 341 (1997). [3] A. G. Baydin, B. A. Pearlmutter, A. A. Radul, and J. M. Siskind, Automatic differentiation in machine learning: a survey, J. Mach. Learn. Res. 18 , 1-43 (2018).","title":"Bibliography"},{"location":"guide/guide_Sopt/","text":"State optimization \u00b6 For state optimization in QuanEstimation, the probe state is expanded as \\(|\\psi\\rangle=\\sum_i c_i|i\\rangle\\) in a specific basis \\(\\{|i\\rangle\\}\\) . Thus, search of the optimal probe states is equal to search of the normalized complex coefficients \\(\\{c_i\\}\\) . In QuanEstimation, the state optimization algorithms are the automatic differentiation (AD) [1] , reverse iterative (RI) [2] algorithm, particle swarm optimization (PSO) [3] , differential evolution (DE) [4] , Nelder-Mead (NM) [5] , and deep deterministic policy gradients (DDPG) [6] . Call the following codes to perform state optimizaiton Python state = StateOpt ( savefile = False , method = \"AD\" , ** kwargs ) state . dynamics ( tspan , H0 , dH , Hc = [], ctrl = [], decay = []) QFIM state . QFIM ( W = [], LDtype = \"SLD\" ) CFIM state . CFIM ( M = [], W = []) HCRB state . HCRB ( W = []) The variable savefile means whether to save all the states. If set False (default) the states in the final episode and the values of the objective function in all episodes will be saved. If set True then the states and the values of the objective function obtained in all episodes will be saved during the training. method represents the algorithm used to optimize the states, options are: \"AD\", \"PSO\", \"DE\", \"DDPG\" and \"NM\". **kwargs contains the keywords and default values corresponding to the optimization algorithm which will be introduced in detail below. tspan is the time length for the evolution, H0 and dH are the free Hamiltonian and its derivatives with respect to the unknown parameters to be estimated. H0 accepts both matrix (time-independent evolution) and list (time-dependent evolution) with the length equal to tspan . dH should be input as \\([\\partial_a{H_0}, \\partial_b{H_0}, \\cdots]\\) . Hc and ctrl are two lists represent the control Hamiltonians and the corresponding control coefficients. decay contains decay operators \\((\\Gamma_1, \\Gamma_2, \\cdots)\\) and the corresponding decay rates \\((\\gamma_1, \\gamma_2, \\cdots)\\) with the input rule decay=[[ \\(\\Gamma_1\\) , \\(\\gamma_1\\) ], [ \\(\\Gamma_2\\) , \\(\\gamma_2\\) ],...]. The default values for decay , Hc and ctrl are empty which means the dynamics is unitary and only governed by the free Hamiltonian. The objective functions for state optimization can be chosen as QFI \\(\\left[\\mathrm{Tr} (W\\mathcal{F}^{-1})\\right]\\) , CFI \\(\\left[\\mathrm{Tr}(W\\mathcal{I}^{-1})\\right]\\) and HCRB, the corresponding codes for them are state.QFIM() (default), state.CFIM() and state.HCRB() . Here \\(\\mathcal{F}\\) and \\(\\mathcal{I}\\) are the QFIM and CFIM, \\(W\\) corresponds to W represents the weight matrix, the default value for W is the identity matrix. If the users call state.HCRB() for single parameter scenario, the program will exit and print \"Program terminated. In the single-parameter scenario, the HCRB is equivalent to the QFI. Please choose 'QFIM' as the objective function\" . LDtype in state.QFIM() represents the types of the QFIM, it can be set as LDtype=\"SLD\" (default), LDtype=\"RLD\" and LDtype=\"LLD\" . M represents a set of positive operator-valued measure (POVM) with default value [] . In the package, a set of rank-one symmetric informationally complete POVM (SIC-POVM) is used when M=[] . Julia opt = StateOpt ( psi = psi , seed = 1234 ) alg = AD ( kwargs ... ) dynamics = Lindblad ( opt , tspan , H0 , dH ; Hc = missing , ctrl = missing , decay = missing ) QFIM obj = QFIM_obj ( W = missing , LDtype = :SLD ) CFIM obj = CFIM_obj ( M = missing , W = missing ) HCRB obj = HCRB_obj ( W = missing ) run ( opt , alg , obj , dynamics ; savefile = false ) The initial state (optimization variable) can be input via psi=psi in StateOpt() for constructing a state optimization problem. psi is an array representing the state. Lindblad accepts the dynamics parameters. tspan is the time length for the evolution, H0 and dH are the free Hamiltonian and its derivatives with respect to the unknown parameters to be estimated. H0 accepts both matrix (time-independent evolution) and list (time-dependent evolution) with the length equal to tspan . dH should be input as \\([\\partial_a{H_0}, \\partial_b{H_0}, \\cdots]\\) . Hc and ctrl are two lists represent the control Hamiltonians and the corresponding control coefficients. decay contains decay operators \\((\\Gamma_1, \\Gamma_2, \\cdots)\\) and the corresponding decay rates \\((\\gamma_1, \\gamma_2, \\cdots)\\) with the input rule decay=[[ \\(\\Gamma_1\\) , \\(\\gamma_1\\) ], [ \\(\\Gamma_2\\) , \\(\\gamma_2\\) ],...]. The default values for decay , Hc and ctrl are missing which means the dynamics is unitary and only governed by the free Hamiltonian. seed is the random seed which can ensure the reproducibility of results. The objective functions for state optimization can be set as QFI ( \\(\\mathrm{Tr}(W\\mathcal{F}^ {-1})\\) ), CFI ( \\(\\mathrm{Tr}(W\\mathcal{I}^{-1})\\) ) and HCRB, the corresponding codes for them are QFIM_obj() (default), CFIM_obj() and HCRB_obj() . Here \\(\\mathcal{F}\\) and \\(\\mathcal{I}\\) are the QFIM and CFIM, \\(W\\) corresponds to W is the weight matrix which defaults to the identity matrix. If the users call HCRB_obj() for single parameter scenario, the program will exit and print \"Program terminated. In the single-parameter scenario, the HCRB is equivalent to the QFI. Please choose 'QFIM_obj()' as the objective function\" . LDtype in QFIM_obj() represents the types of the QFIM, it can be set as LDtype=:SLD (default), LDtype=:RLD and LDtype=:LLD . M represents a set of positive operator-valued measure (POVM) with default value missing . In the package, a set of rank-one symmetric informationally complete POVM (SIC-POVM) is used when M=missing . savefile means whether to save all the states. If set false (default) the states in the final episode and the values of the objective function in all episodes will be saved. If set true then the states and the values of the objective function obtained in all episodes will be saved during the training. The algorithm used to optimize the states in QuanEstimation are AD, PSO, DE, DDPG and NM. kwargs... contains the keywords and default values corresponding to the optimization algorithm which will be introduced in detail below. AD \u00b6 The code for state optimization with AD is as follows Python state = StateOpt ( method = \"GRAPE\" , ** kwargs ) where kwargs is of the form kwargs = { \"Adam\" : False , \"psi0\" :[], \"max_episode\" : 300 , \"epsilon\" : 0.01 , \"beta1\" : 0.90 , \"beta2\" : 0.99 } The keywords and the default values of AD can be seen in the following table \\(~~~~~~~~~~\\) **kwargs \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"Adam\" False \"psi0\" [ ] \"max_episode\" 300 \"epsilon\" 0.01 \"beta1\" 0.90 \"beta2\" 0.99 In state optimization, the state will update according to the learning rate \"epsilon\" . However, Adam algorithm can be introduced to update the states which can be realized by setting Adam=True . In this case, the Adam parameters include learning rate, the exponential decay rate for the first moment estimates and the second moment estimates can be set by the user via epsilon , beta1 and beta2 . psi0 is a list representing the initial guesses of states and max_episode is the number of episodes. Julia alg = AD ( Adam = false , max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 ) The keywords and the default values of AD can be seen in the following table \\(~~~~~~~~~~\\) keywords \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"Adam\" false \"max_episode\" 300 \"epsilon\" 0.01 \"beta1\" 0.90 \"beta2\" 0.99 In state optimization, the state will update according to the learning rate \"epsilon\" . However, Adam algorithm can be introduced to update the states which can be realized by setting Adam=true . In this case, the Adam parameters include learning rate, the exponential decay rate for the first moment estimates and the second moment estimates can be set by the user via epsilon , beta1 and beta2 . RI \u00b6 The code for state optimization with RI is as follows Python state = StateOpt ( method = \"RI\" , ** kwargs ) where kwargs is of the form kwargs = { \"psi0\" :[], \"max_episode\" : 300 , \"seed\" : 1234 } The keywords and the default values of RI can be seen in the following table \\(~~~~~~~~~~\\) **kwargs \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"psi0\" [ ] \"max_episode\" 300 \"seed\" 1234 psi0 is a list representing the initial guesses of states and max_episode is the number of episodes. seed is the random seed. Julia alg = RI ( max_episode = 300 ) The keywords and the default values of RI can be seen in the following table \\(~~~~~~~~~~\\) keywords \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"max_episode\" 300 max_episode is the number of episodes. PSO \u00b6 The code for state optimization with PSO is as follows Python state = StateOpt ( method = \"PSO\" , ** kwargs ) where kwargs is of the form kwargs = { \"p_num\" : 10 , \"psi0\" :[], \"max_episode\" :[ 1000 , 100 ], \"c0\" : 1.0 , \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } The keywords and the default values of PSO can be seen in the following table \\(~~~~~~~~~~\\) **kwargs \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"p_num\" 10 \"psi0\" [ ] \"max_episode\" [1000,100] \"c0\" 1.0 \"c1\" 2.0 \"c2\" 2.0 \"seed\" 1234 p_num is the number of particles. Here max_episode accepts both integers and arrays with two elements. If it is an integer, for example max_episode=1000 , it means the program will continuously run 1000 episodes. However, if it is an array, for example max_episode=[1000,100] , the program will run 1000 episodes in total but replace states of all the particles with global best every 100 episodes. c0 , c1 , and c2 are the PSO parameters representing the inertia weight, cognitive learning factor and social learning factor, respectively. seed is the random seed. Julia alg = PSO ( p_num = 10 , ini_particle = missing , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) The keywords and the default values of PSO can be seen in the following table \\(~~~~~~~~~~\\) keywords \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"p_num\" 10 \"ini_particle\" missing \"max_episode\" [1000,100] \"c0\" 1.0 \"c1\" 2.0 \"c2\" 2.0 p_num is the number of particles. ini_particle is a tuple representing the initial guesses of states and max_episode is the number of episodes. Here max_episode accepts both integers and arrays with two elements. If it is an integer, for example max_episode=1000 , it means the program will continuously run 1000 episodes. However, if it is an array, for example max_episode=[1000,100] , the program will run 1000 episodes in total but replace states of all the particles with global best every 100 episodes. c0 , c1 , and c2 are the PSO parameters representing the inertia weight, cognitive learning factor and social learning factor, respectively. DE \u00b6 The code for state optimization with DE is as follows Python state = StateOpt ( method = \"DE\" , ** kwargs ) where kwargs is of the form kwargs = { \"p_num\" : 10 , \"psi0\" :[], \"max_episode\" : 1000 , \"c\" : 1.0 , \"cr\" : 0.5 , \"seed\" : 1234 } The keywords and the default values of DE can be seen in the following table \\(~~~~~~~~~~\\) **kwargs \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"p_num\" 10 \"psi0\" [ ] \"max_episode\" 1000 \"c\" 1.0 \"cr\" 0.5 \"seed\" 1234 p_num represents the number of populations. c and cr are the mutation constant and crossover constant. Julia alg = DE ( p_num = 10 , ini_population = missing , max_episode = 1000 , c = 1.0 , cr = 0.5 ) The keywords and the default values of DE can be seen in the following table \\(~~~~~~~~~~\\) keywords \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"p_num\" 10 \"ini_population\" missing \"max_episode\" 1000 \"c\" 1.0 \"cr\" 0.5 ini_population is a tuple representing the initial guesses of states , c and cr are the mutation constant and crossover constant. NM \u00b6 The code for state optimization with NM is as follows Python state = StateOpt ( method = \"NM\" , ** kwargs ) where kwargs is of the form kwargs = { \"p_num\" : 10 , \"psi0\" : psi0 , \"max_episode\" : 1000 , \"ar\" : 1.0 , \"ae\" : 2.0 , \"ac\" : 0.5 , \"as0\" : 0.5 , \"seed\" : 1234 } The keywords and the default values of NM can be seen in the following table \\(~~~~~~~~~~\\) **kwargs \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"p_num\" 10 \"psi0\" [ ] \"max_episode\" 1000 \"ar\" 1.0 \"ae\" 2.0 \"ac\" 0.5 \"as0\" 0.5 \"seed\" 1234 p_num represents the number of initial states. ar , ae , ac , and as0 are constants for reflection, expansion, constraction, and shrink, respectively. Julia alg = NM ( p_num = 10 , ini_state = missing , max_episode = 1000 , ar = 1.0 , ae = 2.0 , ac = 0.5 , as0 = 0.5 ) The keywords and the default values of NM can be seen in the following table \\(~~~~~~~~~~\\) keywords \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"p_num\" 10 \"ini_state\" missing \"max_episode\" 1000 \"ar\" 1.0 \"ae\" 2.0 \"ac\" 0.5 \"as0\" 0.5 ini_state represents the number of initial states. ar , ae , ac , and as0 are constants for reflection, expansion, constraction, and shrink, respectively. DDPG \u00b6 The code for state optimization with DDPG is as follows Python state = StateOpt ( method = \"DDPG\" , ** kwargs ) where kwargs is of the form kwargs = { \"layer_num\" : 3 , \"layer_dim\" : 200 , \"max_episode\" : 1000 , \"seed\" : 1234 } The keywords and the default values of DDPG can be seen in the following table \\(~~~~~~~~~~\\) **kwargs \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"psi0\" [ ] \"max_episode\" 1000 \"layer_num\" 3 \"layer_dim\" 200 \"seed\" 1234 layer_num and layer_dim represent the number of layers (include the input and output layer) and the number of neurons in the hidden layer. Julia alg = DDPG ( max_episode = 500 , layer_num = 3 , layer_dim = 200 , seed = 1234 ) The keywords and the default values of DDPG can be seen in the following table \\(~~~~~~~~~~\\) keywords \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"max_episode\" 1000 \"layer_num\" 3 \"layer_dim\" 200 \"seed\" 1234 layer_num and layer_dim represent the number of layers (include the input and output layer) and the number of neurons in the hidden layer. Example 6.1 The Hamiltonian of the Lipkin\u2013Meshkov\u2013Glick (LMG) model is \\begin{align} H_{\\mathrm{LMG}}=-\\frac{\\lambda}{N}(J_1^2+gJ_2^2)-hJ_3, \\end{align} where \\(N\\) is the number of spins of the system, \\(\\lambda\\) is the spin\u2013spin interaction strength, \\(h\\) is the strength of the external field and \\(g\\) is the anisotropic parameter. \\(J_i=\\frac{1}{2}\\sum_{j=1}^N \\sigma_i^{(j)}\\) ( \\(i=1,2,3\\) ) is the collective spin operator with \\(\\sigma_i^{(j)}\\) the \\(i\\) th Pauli matrix for the \\(j\\) th spin. In single-parameter scenario, we take \\(g\\) as the unknown parameter to be estimated. The states are expanded as \\(|\\psi\\rangle=\\sum^J_{m=-J}c_m|J,m\\rangle\\) with \\(|J,m\\rangle\\) the Dicke state and \\(c_m\\) a complex coefficient. Here we fixed \\(J=N/2\\) . In this example, the probe state is optimized for both noiseless scenario and collective dephasing noise. The dynamics under collective dephasing can be expressed as \\(\\partial_t\\rho = -i[H_{\\mathrm{LMG}},\\rho]+\\gamma \\left(J_3\\rho J_3-\\frac{1}{2}\\left\\{\\rho, J^2_3\\right\\}\\right)\\) with \\(\\gamma\\) the decay rate. In this case, all searches with different algorithms start from the coherent spin state defined by \\(|\\theta=\\frac{\\pi}{2},\\phi=\\frac{\\pi}{2}\\rangle=\\exp(-\\frac{\\theta}{2}e^{-i\\phi}J_{+}+\\frac{\\theta}{2}e^{i\\phi}J_{-})|J,J\\rangle\\) with \\(J_{\\pm}=J_1{\\pm}iJ_2\\) . Here, QuTip [6,7] is applied for generation of the spin coherent state. Python from quanestimation import * import numpy as np from qutip import * # the dimension of the system N = 8 # generation of the coherent spin state psi_css = spin_coherent ( 0.5 * N , 0.5 * np . pi , 0.5 * np . pi , type = \"ket\" ) . full () psi_css = psi_css . reshape ( 1 , - 1 )[ 0 ] # guessed state psi0 = [ psi_css ] # free Hamiltonian Lambda , g , h = 1.0 , 0.5 , 0.1 Jx , Jy , Jz = jmat ( 0.5 * N ) Jx , Jy , Jz = Jx . full (), Jy . full (), Jz . full () H0 = - Lambda * ( np . dot ( Jx , Jx ) + g * np . dot ( Jy , Jy )) / N - h * Jz # derivative of the free Hamiltonian on g dH = [ - Lambda * np . dot ( Jy , Jy ) / N ] # dissipation decay = [[ Jz , 0.1 ]] # time length for the evolution tspan = np . linspace ( 0. , 10. , 2500 ) AD # state optimization algorithm: AD AD_paras = { \"Adam\" : False , \"psi0\" : psi0 , \"max_episode\" : 300 , \\ \"epsilon\" : 0.01 , \"beta1\" : 0.90 , \"beta2\" : 0.99 } state = StateOpt ( savefile = False , method = \"AD\" , ** AD_paras ) PSO # state optimization algorithm: PSO PSO_paras = { \"p_num\" : 10 , \"psi0\" : psi0 , \"max_episode\" :[ 1000 , 100 ], \\ \"c0\" : 1.0 , \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } state = StateOpt ( savefile = False , method = \"PSO\" , ** PSO_paras ) DE # state optimization algorithm: DE DE_paras = { \"p_num\" : 10 , \"psi0\" : psi0 , \"max_episode\" : 1000 , \"c\" : 1.0 , \\ \"cr\" : 0.5 , \"seed\" : 1234 } state = StateOpt ( savefile = False , method = \"DE\" , ** DE_paras ) NM # state optimization algorithm: NM NM_paras = { \"p_num\" : 20 , \"psi0\" : psi0 , \"max_episode\" : 1000 , \\ \"ar\" : 1.0 , \"ae\" : 2.0 , \"ac\" : 0.5 , \"as0\" : 0.5 , \"seed\" : 1234 } state = StateOpt ( savefile = False , method = \"NM\" , ** NM_paras ) DDPG # state optimization algorithm: DDPG DDPG_paras = { \"layer_num\" : 4 , \"layer_dim\" : 250 , \"max_episode\" : 500 , \\ \"seed\" : 1234 } state = StateOpt ( savefile = False , method = \"DDPG\" , ** DDPG_paras ) # input the dynamics data state . dynamics ( tspan , H0 , dH , decay = decay ) QFIM # objective function: QFI state . QFIM () CFIM # objective function: CFI state . CFIM () Julia using QuanEstimation using Random using StableRNGs using LinearAlgebra using SparseArrays # the dimension of the system N = 8 # generation of the coherent spin state j , theta , phi = N\u00f72 , 0.5 pi , 0.5 pi Jp = Matrix ( spdiagm ( 1 => [ sqrt ( j * ( j + 1 ) - m * ( m + 1 )) for m in j :- 1 :- j ][ 2 : end ])) Jm = Jp ' psi0 = exp ( 0.5 * theta * exp ( im * phi ) * Jm - 0.5 * theta * exp ( - im * phi ) * Jp ) * QuanEstimation . basis ( Int ( 2 * j + 1 ), 1 ) dim = length ( psi0 ) # free Hamiltonian lambda , g , h = 1.0 , 0.5 , 0.1 Jx = 0.5 * ( Jp + Jm ) Jy = - 0.5 im * ( Jp - Jm ) Jz = spdiagm ( j :- 1 :- j ) H0 = - lambda * ( Jx * Jx + g * Jy * Jy ) / N - h * Jz # derivative of the free Hamiltonian on g dH = [ - lambda * Jy * Jy / N ] # dissipation decay = [[ Jz , 0.1 ]] # time length for the evolution tspan = range ( 0. , 10. , length = 2500 ) # set the optimization type opt = QuanEstimation . StateOpt ( psi = psi0 , seed = 1234 ) AD # state optimization algorithm: AD alg = QuanEstimation . AD ( Adam = false , max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 ) PSO # state optimization algorithm: PSO alg = QuanEstimation . PSO ( p_num = 10 , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) DE # state optimization algorithm: DE alg = QuanEstimation . DE ( p_num = 10 , max_episode = 1000 , c = 1.0 , cr = 0.5 ) NM # state optimization algorithm: NM alg = QuanEstimation . NM ( p_num = 10 , max_episode = 1000 , ar = 1.0 , ae = 2.0 , ac = 0.5 , as0 = 0.5 ) DDPG # state optimization algorithm: DDPG alg = QuanEstimation . DDPG ( max_episode = 500 , layer_num = 3 , layer_dim = 200 ) # input the dynamics data dynamics = QuanEstimation . Lindblad ( opt , tspan , H0 , dH , decay = decay ) QFIM # objective function: QFI obj = QuanEstimation . QFIM_obj () CFIM # objective function: CFI obj = QuanEstimation . CFIM_obj () # run the state optimization problem QuanEstimation . run ( opt , alg , obj , dynamics ; savefile = false ) Example 6.2 In the multiparameter scenario, \\(g\\) and \\(h\\) are chooen to be the unknown parameters to be estimated. Python from quanestimation import * import numpy as np from qutip import * # the dimension of the system N = 8 # generation of coherent spin state psi_css = spin_coherent ( 0.5 * N , 0.5 * np . pi , 0.5 * np . pi , type = \"ket\" ) . full () psi_css = psi_css . reshape ( 1 , - 1 )[ 0 ] # guessed state psi0 = [ psi_css ] # free Hamiltonian Lambda , g , h = 1.0 , 0.5 , 0.1 Jx , Jy , Jz = jmat ( 0.5 * N ) Jx , Jy , Jz = Jx . full (), Jy . full (), Jz . full () H0 = - Lambda * ( np . dot ( Jx , Jx ) + g * np . dot ( Jy , Jy )) / N - h * Jz # derivatives of the free Hamiltonian on the g and h dH = [ - Lambda * np . dot ( Jy , Jy ) / N , - Jz ] # dissipation decay = [[ Jz , 0.1 ]] # time length for the evolution tspan = np . linspace ( 0. , 10. , 2500 ) # weight matrix W = np . array ([[ 1 / 3 , 0. ], [ 0. , 2 / 3 ]]) AD # state optimization algorithm: AD AD_paras = { \"Adam\" : False , \"psi0\" : psi0 , \"max_episode\" : 300 , \\ \"epsilon\" : 0.01 , \"beta1\" : 0.90 , \"beta2\" : 0.99 } state = StateOpt ( savefile = False , method = \"AD\" , ** AD_paras ) PSO # state optimization algorithm: PSO PSO_paras = { \"p_num\" : 10 , \"psi0\" : psi0 , \"max_episode\" :[ 1000 , 100 ], \\ \"c0\" : 1.0 , \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } state = StateOpt ( savefile = False , method = \"PSO\" , ** PSO_paras ) DE # state optimization algorithm: DE DE_paras = { \"p_num\" : 10 , \"psi0\" : psi0 , \"max_episode\" : 1000 , \"c\" : 1.0 , \\ \"cr\" : 0.5 , \"seed\" : 1234 } state = StateOpt ( savefile = False , method = \"DE\" , ** DE_paras ) NM # state optimization algorithm: NM NM_paras = { \"p_num\" : 20 , \"psi0\" : psi0 , \"max_episode\" : 1000 , \\ \"ar\" : 1.0 , \"ae\" : 2.0 , \"ac\" : 0.5 , \"as0\" : 0.5 , \"seed\" : 1234 } state = StateOpt ( savefile = False , method = \"NM\" , ** NM_paras ) DDPG # state optimization algorithm: DDPG DDPG_paras = { \"layer_num\" : 4 , \"layer_dim\" : 250 , \"max_episode\" : 500 , \\ \"seed\" : 1234 } state = StateOpt ( savefile = False , method = \"DDPG\" , ** DDPG_paras ) # input the dynamics data state . dynamics ( tspan , H0 , dH , decay = decay ) QFIM # objective function: tr(WF^{-1}) state . QFIM () CFIM # objective function: tr(WI^{-1}) state . CFIM () HCRB # objective function: HCRB state . HCRB () Julia using QuanEstimation using Random using StableRNGs using LinearAlgebra using SparseArrays # the dimension of the system N = 8 # generation of the coherent spin state j , theta , phi = N\u00f72 , 0.5 pi , 0.5 pi Jp = Matrix ( spdiagm ( 1 => [ sqrt ( j * ( j + 1 ) - m * ( m + 1 )) for m in j :- 1 :- j ][ 2 : end ])) Jm = Jp ' psi0 = exp ( 0.5 * theta * exp ( im * phi ) * Jm - 0.5 * theta * exp ( - im * phi ) * Jp ) * QuanEstimation . basis ( Int ( 2 * j + 1 ), 1 ) dim = length ( psi0 ) # free Hamiltonian lambda , g , h = 1.0 , 0.5 , 0.1 Jx = 0.5 * ( Jp + Jm ) Jy = - 0.5 im * ( Jp - Jm ) Jz = spdiagm ( j :- 1 :- j ) H0 = - lambda * ( Jx * Jx + g * Jy * Jy ) / N + g * Jy ^ 2 / N - h * Jz # derivative of the free Hamiltonian on g dH = [ - lambda * Jy * Jy / N , - Jz ] # dissipation decay = [[ Jz , 0.1 ]] # time length for the evolution tspan = range ( 0. , 10. , length = 2500 ) # weight matrix W = [ 1 / 3 0. ; 0. 2 / 3 ] # set the optimization type opt = QuanEstimation . StateOpt ( psi = psi0 , seed = 1234 ) AD # state optimization algorithm: AD alg = QuanEstimation . AD ( Adam = false , max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 ) PSO # state optimization algorithm: PSO alg = QuanEstimation . PSO ( p_num = 10 , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) DE # state optimization algorithm: DE alg = QuanEstimation . DE ( p_num = 10 , max_episode = 1000 , c = 1.0 , cr = 0.5 ) NM # state optimization algorithm: NM alg = QuanEstimation . NM ( p_num = 10 , max_episode = 1000 , ar = 1.0 , ae = 2.0 , ac = 0.5 , as0 = 0.5 ) DDPG # state optimization algorithm: DDPG alg = QuanEstimation . DDPG ( max_episode = 500 , layer_num = 3 , layer_dim = 200 ) # input the dynamics data dynamics = QuanEstimation . Lindblad ( opt , tspan , H0 , dH , decay = decay ) QFIM # objective function: tr(WF^{-1}) obj = QuanEstimation . QFIM_obj () CFIM # objective function: tr(WI^{-1}) obj = QuanEstimation . CFIM_obj () HCRB # objective function: HCRB obj = QuanEstimation . HCRB_obj () # run the state optimization problem QuanEstimation . run ( opt , alg , obj , dynamics ; savefile = false ) If the parameterization process is implemented with the Kraus operators, then the corresponding codes are Python state = StateOpt ( savefile = False , method = \"AD\" , ** kwargs ) state . state . Kraus ( K , dK ) QFIM state . QFIM ( W = [], LDtype = \"SLD\" ) CFIM state . CFIM ( M = [], W = []) HCRB state . HCRB ( W = []) Julia opt = StateOpt ( psi = psi , seed = 1234 ) alg = AD ( kwargs ... ) dynamics = Kraus ( opt , K , dK ) QFIM obj = QFIM_obj ( W = missing , LDtype = :SLD ) CFIM obj = CFIM_obj ( M = missing , W = missing ) HCRB obj = HCRB_obj ( W = missing ) run ( opt , alg , obj , dynamics ; savefile = false ) where K and dK are the Kraus operators and its derivatives with respect to the unknown parameters. Example 6.3 The Kraus operators for the amplitude damping channel are \\[\\begin{eqnarray} K_1 = \\left(\\begin{array}{cc} 1 & 0 \\\\ 0 & \\sqrt{1-\\gamma} \\end{array}\\right), K_2 = \\left(\\begin{array}{cc} 0 & \\sqrt{\\gamma} \\\\ 0 & 0 \\end{array}\\right), \\nonumber \\end{eqnarray}\\] where \\(\\gamma\\) is the unknown parameter to be estimated which represents the decay probability. Python from quanestimation import * import numpy as np # initial state rho0 = 0.5 * np . array ([[ 1. , 1. ], [ 1. , 1. ]]) # Kraus operators for the amplitude damping channel gamma = 0.1 K1 = np . array ([[ 1. , 0. ], [ 0. , np . sqrt ( 1 - gamma )]]) K2 = np . array ([[ 0. , np . sqrt ( gamma )], [ 0. , 0. ]]) K = [ K1 , K2 ] # derivatives of Kraus operators on gamma dK1 = np . array ([[ 1. , 0. ], [ 0. , - 0.5 / np . sqrt ( 1 - gamma )]]) dK2 = np . array ([[ 0. , 0.5 / np . sqrt ( gamma )], [ 0. , 0. ]]) dK = [[ dK1 ], [ dK2 ]] AD # state optimization algorithm: AD AD_paras = { \"Adam\" : False , \"psi0\" : psi0 , \"max_episode\" : 300 , \\ \"epsilon\" : 0.01 , \"beta1\" : 0.90 , \"beta2\" : 0.99 } state = StateOpt ( savefile = False , method = \"AD\" , ** AD_paras ) RI # state optimization algorithm: RI RI_paras = { \"psi0\" : psi0 , \"max_episode\" : 300 , \"seed\" : 0.01 } state = StateOpt ( savefile = False , method = \"RI\" , ** RI_paras ) PSO # state optimization algorithm: PSO PSO_paras = { \"p_num\" : 10 , \"psi0\" : psi0 , \"max_episode\" :[ 1000 , 100 ], \\ \"c0\" : 1.0 , \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } state = StateOpt ( savefile = False , method = \"PSO\" , ** PSO_paras ) DE # state optimization algorithm: DE DE_paras = { \"p_num\" : 10 , \"psi0\" : psi0 , \"max_episode\" : 1000 , \"c\" : 1.0 , \\ \"cr\" : 0.5 , \"seed\" : 1234 } state = StateOpt ( savefile = False , method = \"DE\" , ** DE_paras ) NM # state optimization algorithm: NM NM_paras = { \"p_num\" : 20 , \"psi0\" : psi0 , \"max_episode\" : 1000 , \\ \"ar\" : 1.0 , \"ae\" : 2.0 , \"ac\" : 0.5 , \"as0\" : 0.5 , \"seed\" : 1234 } state = StateOpt ( savefile = False , method = \"NM\" , ** NM_paras ) DDPG # state optimization algorithm: DDPG DDPG_paras = { \"layer_num\" : 4 , \"layer_dim\" : 250 , \"max_episode\" : 500 , \\ \"seed\" : 1234 } state = StateOpt ( savefile = False , method = \"DDPG\" , ** DDPG_paras ) # input the dynamics data state . Kraus ( K , dK ) QFIM # objective function: QFI state . QFIM () CFIM # objective function: CFI state . CFIM () HCRB # objective function: HCRB state . HCRB () Julia using QuanEstimation # initial state rho0 = 0.5 * ones ( 2 , 2 ) # Kraus operators for the amplitude damping channel gamma = 0.1 K1 = [ 1. 0. ; 0. sqrt ( 1 - gamma )] K2 = [ 0. sqrt ( gamma ); 0. 0. ] K = [ K1 , K2 ] # derivatives of Kraus operators on gamma dK1 = [ 1. 0. ; 0. - 0.5 / sqrt ( 1 - gamma )] dK2 = [ 0. 0.5 / sqrt ( gamma ); 0. 0. ] dK = [[ dK1 ], [ dK2 ]] AD # state optimization algorithm: AD alg = QuanEstimation . AD ( Adam = false , max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 ) RI # state optimization algorithm: RI alg = QuanEstimation . RI ( max_episode = 300 ) PSO # state optimization algorithm: PSO alg = QuanEstimation . PSO ( p_num = 10 , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) DE # state optimization algorithm: DE alg = QuanEstimation . DE ( p_num = 10 , max_episode = 1000 , c = 1.0 , cr = 0.5 ) NM # state optimization algorithm: NM alg = QuanEstimation . NM ( p_num = 10 , max_episode = 1000 , ar = 1.0 , ae = 2.0 , ac = 0.5 , as0 = 0.5 ) DDPG # state optimization algorithm: DDPG alg = QuanEstimation . DDPG ( max_episode = 500 , layer_num = 3 , layer_dim = 200 ) # input the dynamics data dynamics = QuanEstimation . Kraus ( opt , K , dK ) QFIM # objective function: QFI obj = QuanEstimation . QFIM_obj () CFIM # objective function: CFI obj = QuanEstimation . CFIM_obj () HCRB # objective function: HCRB obj = QuanEstimation . HCRB_obj () # run the state optimization problem QuanEstimation . run ( opt , alg , obj , dynamics ; savefile = false ) Bibliography \u00b6 [1] A. G. Baydin, B. A. Pearlmutter, A. A. Radul, and J. M. Siskind, Automatic differentiation in machine learning: a survey, J. Mach. Learn. Res. 18 , 1-43 (2018). [2] R. Demkowicz-Dobrza\u0144ski, Optimal phase estimation with arbitrary a priori knowledge, Phys. Rev. A 83 , 061802(R) (2011). [3] J. Kennedy and R. Eberhar, Particle swarm optimization, Proc. 1995 IEEE International Conference on Neural Networks 4 , 1942-1948 (1995). [4] R. Storn and K. Price, Differential Evolution-A Simple and Efficient Heuristic for global Optimization over Continuous Spaces, J. Global Optim. 11 , 341 (1997). [5] J. A. Nelder and R. Mead, A Simplex Method for Function Minimization, Comput. J. 7 , 308\u2013313 (1965). [6] T. P. Lillicrap, J. J. Hunt, A. Pritzel, N. Heess, T. Erez, Y. Tassa, D. Silver, and D. Wierstra, Continuous control with deep reinforcement learning, arXiv:1509.02971. [7] J. R. Johansson, P. D. Nation, and F. Nori, QuTiP: An open-source Python framework for the dynamics of open quantum systems, Comp. Phys. Comm. 183 , 1760 (2012). [8] J. R. Johansson, P. D. Nation, and F. Nori, QuTiP 2: A Python framework for the dynamics of open quantum systems, Comp. Phys. Comm. 184 , 1234 (2013).","title":"State optimization"},{"location":"guide/guide_Sopt/#state-optimization","text":"For state optimization in QuanEstimation, the probe state is expanded as \\(|\\psi\\rangle=\\sum_i c_i|i\\rangle\\) in a specific basis \\(\\{|i\\rangle\\}\\) . Thus, search of the optimal probe states is equal to search of the normalized complex coefficients \\(\\{c_i\\}\\) . In QuanEstimation, the state optimization algorithms are the automatic differentiation (AD) [1] , reverse iterative (RI) [2] algorithm, particle swarm optimization (PSO) [3] , differential evolution (DE) [4] , Nelder-Mead (NM) [5] , and deep deterministic policy gradients (DDPG) [6] . Call the following codes to perform state optimizaiton Python state = StateOpt ( savefile = False , method = \"AD\" , ** kwargs ) state . dynamics ( tspan , H0 , dH , Hc = [], ctrl = [], decay = []) QFIM state . QFIM ( W = [], LDtype = \"SLD\" ) CFIM state . CFIM ( M = [], W = []) HCRB state . HCRB ( W = []) The variable savefile means whether to save all the states. If set False (default) the states in the final episode and the values of the objective function in all episodes will be saved. If set True then the states and the values of the objective function obtained in all episodes will be saved during the training. method represents the algorithm used to optimize the states, options are: \"AD\", \"PSO\", \"DE\", \"DDPG\" and \"NM\". **kwargs contains the keywords and default values corresponding to the optimization algorithm which will be introduced in detail below. tspan is the time length for the evolution, H0 and dH are the free Hamiltonian and its derivatives with respect to the unknown parameters to be estimated. H0 accepts both matrix (time-independent evolution) and list (time-dependent evolution) with the length equal to tspan . dH should be input as \\([\\partial_a{H_0}, \\partial_b{H_0}, \\cdots]\\) . Hc and ctrl are two lists represent the control Hamiltonians and the corresponding control coefficients. decay contains decay operators \\((\\Gamma_1, \\Gamma_2, \\cdots)\\) and the corresponding decay rates \\((\\gamma_1, \\gamma_2, \\cdots)\\) with the input rule decay=[[ \\(\\Gamma_1\\) , \\(\\gamma_1\\) ], [ \\(\\Gamma_2\\) , \\(\\gamma_2\\) ],...]. The default values for decay , Hc and ctrl are empty which means the dynamics is unitary and only governed by the free Hamiltonian. The objective functions for state optimization can be chosen as QFI \\(\\left[\\mathrm{Tr} (W\\mathcal{F}^{-1})\\right]\\) , CFI \\(\\left[\\mathrm{Tr}(W\\mathcal{I}^{-1})\\right]\\) and HCRB, the corresponding codes for them are state.QFIM() (default), state.CFIM() and state.HCRB() . Here \\(\\mathcal{F}\\) and \\(\\mathcal{I}\\) are the QFIM and CFIM, \\(W\\) corresponds to W represents the weight matrix, the default value for W is the identity matrix. If the users call state.HCRB() for single parameter scenario, the program will exit and print \"Program terminated. In the single-parameter scenario, the HCRB is equivalent to the QFI. Please choose 'QFIM' as the objective function\" . LDtype in state.QFIM() represents the types of the QFIM, it can be set as LDtype=\"SLD\" (default), LDtype=\"RLD\" and LDtype=\"LLD\" . M represents a set of positive operator-valued measure (POVM) with default value [] . In the package, a set of rank-one symmetric informationally complete POVM (SIC-POVM) is used when M=[] . Julia opt = StateOpt ( psi = psi , seed = 1234 ) alg = AD ( kwargs ... ) dynamics = Lindblad ( opt , tspan , H0 , dH ; Hc = missing , ctrl = missing , decay = missing ) QFIM obj = QFIM_obj ( W = missing , LDtype = :SLD ) CFIM obj = CFIM_obj ( M = missing , W = missing ) HCRB obj = HCRB_obj ( W = missing ) run ( opt , alg , obj , dynamics ; savefile = false ) The initial state (optimization variable) can be input via psi=psi in StateOpt() for constructing a state optimization problem. psi is an array representing the state. Lindblad accepts the dynamics parameters. tspan is the time length for the evolution, H0 and dH are the free Hamiltonian and its derivatives with respect to the unknown parameters to be estimated. H0 accepts both matrix (time-independent evolution) and list (time-dependent evolution) with the length equal to tspan . dH should be input as \\([\\partial_a{H_0}, \\partial_b{H_0}, \\cdots]\\) . Hc and ctrl are two lists represent the control Hamiltonians and the corresponding control coefficients. decay contains decay operators \\((\\Gamma_1, \\Gamma_2, \\cdots)\\) and the corresponding decay rates \\((\\gamma_1, \\gamma_2, \\cdots)\\) with the input rule decay=[[ \\(\\Gamma_1\\) , \\(\\gamma_1\\) ], [ \\(\\Gamma_2\\) , \\(\\gamma_2\\) ],...]. The default values for decay , Hc and ctrl are missing which means the dynamics is unitary and only governed by the free Hamiltonian. seed is the random seed which can ensure the reproducibility of results. The objective functions for state optimization can be set as QFI ( \\(\\mathrm{Tr}(W\\mathcal{F}^ {-1})\\) ), CFI ( \\(\\mathrm{Tr}(W\\mathcal{I}^{-1})\\) ) and HCRB, the corresponding codes for them are QFIM_obj() (default), CFIM_obj() and HCRB_obj() . Here \\(\\mathcal{F}\\) and \\(\\mathcal{I}\\) are the QFIM and CFIM, \\(W\\) corresponds to W is the weight matrix which defaults to the identity matrix. If the users call HCRB_obj() for single parameter scenario, the program will exit and print \"Program terminated. In the single-parameter scenario, the HCRB is equivalent to the QFI. Please choose 'QFIM_obj()' as the objective function\" . LDtype in QFIM_obj() represents the types of the QFIM, it can be set as LDtype=:SLD (default), LDtype=:RLD and LDtype=:LLD . M represents a set of positive operator-valued measure (POVM) with default value missing . In the package, a set of rank-one symmetric informationally complete POVM (SIC-POVM) is used when M=missing . savefile means whether to save all the states. If set false (default) the states in the final episode and the values of the objective function in all episodes will be saved. If set true then the states and the values of the objective function obtained in all episodes will be saved during the training. The algorithm used to optimize the states in QuanEstimation are AD, PSO, DE, DDPG and NM. kwargs... contains the keywords and default values corresponding to the optimization algorithm which will be introduced in detail below.","title":"State optimization"},{"location":"guide/guide_Sopt/#ad","text":"The code for state optimization with AD is as follows Python state = StateOpt ( method = \"GRAPE\" , ** kwargs ) where kwargs is of the form kwargs = { \"Adam\" : False , \"psi0\" :[], \"max_episode\" : 300 , \"epsilon\" : 0.01 , \"beta1\" : 0.90 , \"beta2\" : 0.99 } The keywords and the default values of AD can be seen in the following table \\(~~~~~~~~~~\\) **kwargs \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"Adam\" False \"psi0\" [ ] \"max_episode\" 300 \"epsilon\" 0.01 \"beta1\" 0.90 \"beta2\" 0.99 In state optimization, the state will update according to the learning rate \"epsilon\" . However, Adam algorithm can be introduced to update the states which can be realized by setting Adam=True . In this case, the Adam parameters include learning rate, the exponential decay rate for the first moment estimates and the second moment estimates can be set by the user via epsilon , beta1 and beta2 . psi0 is a list representing the initial guesses of states and max_episode is the number of episodes. Julia alg = AD ( Adam = false , max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 ) The keywords and the default values of AD can be seen in the following table \\(~~~~~~~~~~\\) keywords \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"Adam\" false \"max_episode\" 300 \"epsilon\" 0.01 \"beta1\" 0.90 \"beta2\" 0.99 In state optimization, the state will update according to the learning rate \"epsilon\" . However, Adam algorithm can be introduced to update the states which can be realized by setting Adam=true . In this case, the Adam parameters include learning rate, the exponential decay rate for the first moment estimates and the second moment estimates can be set by the user via epsilon , beta1 and beta2 .","title":"AD"},{"location":"guide/guide_Sopt/#ri","text":"The code for state optimization with RI is as follows Python state = StateOpt ( method = \"RI\" , ** kwargs ) where kwargs is of the form kwargs = { \"psi0\" :[], \"max_episode\" : 300 , \"seed\" : 1234 } The keywords and the default values of RI can be seen in the following table \\(~~~~~~~~~~\\) **kwargs \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"psi0\" [ ] \"max_episode\" 300 \"seed\" 1234 psi0 is a list representing the initial guesses of states and max_episode is the number of episodes. seed is the random seed. Julia alg = RI ( max_episode = 300 ) The keywords and the default values of RI can be seen in the following table \\(~~~~~~~~~~\\) keywords \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"max_episode\" 300 max_episode is the number of episodes.","title":"RI"},{"location":"guide/guide_Sopt/#pso","text":"The code for state optimization with PSO is as follows Python state = StateOpt ( method = \"PSO\" , ** kwargs ) where kwargs is of the form kwargs = { \"p_num\" : 10 , \"psi0\" :[], \"max_episode\" :[ 1000 , 100 ], \"c0\" : 1.0 , \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } The keywords and the default values of PSO can be seen in the following table \\(~~~~~~~~~~\\) **kwargs \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"p_num\" 10 \"psi0\" [ ] \"max_episode\" [1000,100] \"c0\" 1.0 \"c1\" 2.0 \"c2\" 2.0 \"seed\" 1234 p_num is the number of particles. Here max_episode accepts both integers and arrays with two elements. If it is an integer, for example max_episode=1000 , it means the program will continuously run 1000 episodes. However, if it is an array, for example max_episode=[1000,100] , the program will run 1000 episodes in total but replace states of all the particles with global best every 100 episodes. c0 , c1 , and c2 are the PSO parameters representing the inertia weight, cognitive learning factor and social learning factor, respectively. seed is the random seed. Julia alg = PSO ( p_num = 10 , ini_particle = missing , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) The keywords and the default values of PSO can be seen in the following table \\(~~~~~~~~~~\\) keywords \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"p_num\" 10 \"ini_particle\" missing \"max_episode\" [1000,100] \"c0\" 1.0 \"c1\" 2.0 \"c2\" 2.0 p_num is the number of particles. ini_particle is a tuple representing the initial guesses of states and max_episode is the number of episodes. Here max_episode accepts both integers and arrays with two elements. If it is an integer, for example max_episode=1000 , it means the program will continuously run 1000 episodes. However, if it is an array, for example max_episode=[1000,100] , the program will run 1000 episodes in total but replace states of all the particles with global best every 100 episodes. c0 , c1 , and c2 are the PSO parameters representing the inertia weight, cognitive learning factor and social learning factor, respectively.","title":"PSO"},{"location":"guide/guide_Sopt/#de","text":"The code for state optimization with DE is as follows Python state = StateOpt ( method = \"DE\" , ** kwargs ) where kwargs is of the form kwargs = { \"p_num\" : 10 , \"psi0\" :[], \"max_episode\" : 1000 , \"c\" : 1.0 , \"cr\" : 0.5 , \"seed\" : 1234 } The keywords and the default values of DE can be seen in the following table \\(~~~~~~~~~~\\) **kwargs \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"p_num\" 10 \"psi0\" [ ] \"max_episode\" 1000 \"c\" 1.0 \"cr\" 0.5 \"seed\" 1234 p_num represents the number of populations. c and cr are the mutation constant and crossover constant. Julia alg = DE ( p_num = 10 , ini_population = missing , max_episode = 1000 , c = 1.0 , cr = 0.5 ) The keywords and the default values of DE can be seen in the following table \\(~~~~~~~~~~\\) keywords \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"p_num\" 10 \"ini_population\" missing \"max_episode\" 1000 \"c\" 1.0 \"cr\" 0.5 ini_population is a tuple representing the initial guesses of states , c and cr are the mutation constant and crossover constant.","title":"DE"},{"location":"guide/guide_Sopt/#nm","text":"The code for state optimization with NM is as follows Python state = StateOpt ( method = \"NM\" , ** kwargs ) where kwargs is of the form kwargs = { \"p_num\" : 10 , \"psi0\" : psi0 , \"max_episode\" : 1000 , \"ar\" : 1.0 , \"ae\" : 2.0 , \"ac\" : 0.5 , \"as0\" : 0.5 , \"seed\" : 1234 } The keywords and the default values of NM can be seen in the following table \\(~~~~~~~~~~\\) **kwargs \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"p_num\" 10 \"psi0\" [ ] \"max_episode\" 1000 \"ar\" 1.0 \"ae\" 2.0 \"ac\" 0.5 \"as0\" 0.5 \"seed\" 1234 p_num represents the number of initial states. ar , ae , ac , and as0 are constants for reflection, expansion, constraction, and shrink, respectively. Julia alg = NM ( p_num = 10 , ini_state = missing , max_episode = 1000 , ar = 1.0 , ae = 2.0 , ac = 0.5 , as0 = 0.5 ) The keywords and the default values of NM can be seen in the following table \\(~~~~~~~~~~\\) keywords \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"p_num\" 10 \"ini_state\" missing \"max_episode\" 1000 \"ar\" 1.0 \"ae\" 2.0 \"ac\" 0.5 \"as0\" 0.5 ini_state represents the number of initial states. ar , ae , ac , and as0 are constants for reflection, expansion, constraction, and shrink, respectively.","title":"NM"},{"location":"guide/guide_Sopt/#ddpg","text":"The code for state optimization with DDPG is as follows Python state = StateOpt ( method = \"DDPG\" , ** kwargs ) where kwargs is of the form kwargs = { \"layer_num\" : 3 , \"layer_dim\" : 200 , \"max_episode\" : 1000 , \"seed\" : 1234 } The keywords and the default values of DDPG can be seen in the following table \\(~~~~~~~~~~\\) **kwargs \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"psi0\" [ ] \"max_episode\" 1000 \"layer_num\" 3 \"layer_dim\" 200 \"seed\" 1234 layer_num and layer_dim represent the number of layers (include the input and output layer) and the number of neurons in the hidden layer. Julia alg = DDPG ( max_episode = 500 , layer_num = 3 , layer_dim = 200 , seed = 1234 ) The keywords and the default values of DDPG can be seen in the following table \\(~~~~~~~~~~\\) keywords \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"max_episode\" 1000 \"layer_num\" 3 \"layer_dim\" 200 \"seed\" 1234 layer_num and layer_dim represent the number of layers (include the input and output layer) and the number of neurons in the hidden layer. Example 6.1 The Hamiltonian of the Lipkin\u2013Meshkov\u2013Glick (LMG) model is \\begin{align} H_{\\mathrm{LMG}}=-\\frac{\\lambda}{N}(J_1^2+gJ_2^2)-hJ_3, \\end{align} where \\(N\\) is the number of spins of the system, \\(\\lambda\\) is the spin\u2013spin interaction strength, \\(h\\) is the strength of the external field and \\(g\\) is the anisotropic parameter. \\(J_i=\\frac{1}{2}\\sum_{j=1}^N \\sigma_i^{(j)}\\) ( \\(i=1,2,3\\) ) is the collective spin operator with \\(\\sigma_i^{(j)}\\) the \\(i\\) th Pauli matrix for the \\(j\\) th spin. In single-parameter scenario, we take \\(g\\) as the unknown parameter to be estimated. The states are expanded as \\(|\\psi\\rangle=\\sum^J_{m=-J}c_m|J,m\\rangle\\) with \\(|J,m\\rangle\\) the Dicke state and \\(c_m\\) a complex coefficient. Here we fixed \\(J=N/2\\) . In this example, the probe state is optimized for both noiseless scenario and collective dephasing noise. The dynamics under collective dephasing can be expressed as \\(\\partial_t\\rho = -i[H_{\\mathrm{LMG}},\\rho]+\\gamma \\left(J_3\\rho J_3-\\frac{1}{2}\\left\\{\\rho, J^2_3\\right\\}\\right)\\) with \\(\\gamma\\) the decay rate. In this case, all searches with different algorithms start from the coherent spin state defined by \\(|\\theta=\\frac{\\pi}{2},\\phi=\\frac{\\pi}{2}\\rangle=\\exp(-\\frac{\\theta}{2}e^{-i\\phi}J_{+}+\\frac{\\theta}{2}e^{i\\phi}J_{-})|J,J\\rangle\\) with \\(J_{\\pm}=J_1{\\pm}iJ_2\\) . Here, QuTip [6,7] is applied for generation of the spin coherent state. Python from quanestimation import * import numpy as np from qutip import * # the dimension of the system N = 8 # generation of the coherent spin state psi_css = spin_coherent ( 0.5 * N , 0.5 * np . pi , 0.5 * np . pi , type = \"ket\" ) . full () psi_css = psi_css . reshape ( 1 , - 1 )[ 0 ] # guessed state psi0 = [ psi_css ] # free Hamiltonian Lambda , g , h = 1.0 , 0.5 , 0.1 Jx , Jy , Jz = jmat ( 0.5 * N ) Jx , Jy , Jz = Jx . full (), Jy . full (), Jz . full () H0 = - Lambda * ( np . dot ( Jx , Jx ) + g * np . dot ( Jy , Jy )) / N - h * Jz # derivative of the free Hamiltonian on g dH = [ - Lambda * np . dot ( Jy , Jy ) / N ] # dissipation decay = [[ Jz , 0.1 ]] # time length for the evolution tspan = np . linspace ( 0. , 10. , 2500 ) AD # state optimization algorithm: AD AD_paras = { \"Adam\" : False , \"psi0\" : psi0 , \"max_episode\" : 300 , \\ \"epsilon\" : 0.01 , \"beta1\" : 0.90 , \"beta2\" : 0.99 } state = StateOpt ( savefile = False , method = \"AD\" , ** AD_paras ) PSO # state optimization algorithm: PSO PSO_paras = { \"p_num\" : 10 , \"psi0\" : psi0 , \"max_episode\" :[ 1000 , 100 ], \\ \"c0\" : 1.0 , \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } state = StateOpt ( savefile = False , method = \"PSO\" , ** PSO_paras ) DE # state optimization algorithm: DE DE_paras = { \"p_num\" : 10 , \"psi0\" : psi0 , \"max_episode\" : 1000 , \"c\" : 1.0 , \\ \"cr\" : 0.5 , \"seed\" : 1234 } state = StateOpt ( savefile = False , method = \"DE\" , ** DE_paras ) NM # state optimization algorithm: NM NM_paras = { \"p_num\" : 20 , \"psi0\" : psi0 , \"max_episode\" : 1000 , \\ \"ar\" : 1.0 , \"ae\" : 2.0 , \"ac\" : 0.5 , \"as0\" : 0.5 , \"seed\" : 1234 } state = StateOpt ( savefile = False , method = \"NM\" , ** NM_paras ) DDPG # state optimization algorithm: DDPG DDPG_paras = { \"layer_num\" : 4 , \"layer_dim\" : 250 , \"max_episode\" : 500 , \\ \"seed\" : 1234 } state = StateOpt ( savefile = False , method = \"DDPG\" , ** DDPG_paras ) # input the dynamics data state . dynamics ( tspan , H0 , dH , decay = decay ) QFIM # objective function: QFI state . QFIM () CFIM # objective function: CFI state . CFIM () Julia using QuanEstimation using Random using StableRNGs using LinearAlgebra using SparseArrays # the dimension of the system N = 8 # generation of the coherent spin state j , theta , phi = N\u00f72 , 0.5 pi , 0.5 pi Jp = Matrix ( spdiagm ( 1 => [ sqrt ( j * ( j + 1 ) - m * ( m + 1 )) for m in j :- 1 :- j ][ 2 : end ])) Jm = Jp ' psi0 = exp ( 0.5 * theta * exp ( im * phi ) * Jm - 0.5 * theta * exp ( - im * phi ) * Jp ) * QuanEstimation . basis ( Int ( 2 * j + 1 ), 1 ) dim = length ( psi0 ) # free Hamiltonian lambda , g , h = 1.0 , 0.5 , 0.1 Jx = 0.5 * ( Jp + Jm ) Jy = - 0.5 im * ( Jp - Jm ) Jz = spdiagm ( j :- 1 :- j ) H0 = - lambda * ( Jx * Jx + g * Jy * Jy ) / N - h * Jz # derivative of the free Hamiltonian on g dH = [ - lambda * Jy * Jy / N ] # dissipation decay = [[ Jz , 0.1 ]] # time length for the evolution tspan = range ( 0. , 10. , length = 2500 ) # set the optimization type opt = QuanEstimation . StateOpt ( psi = psi0 , seed = 1234 ) AD # state optimization algorithm: AD alg = QuanEstimation . AD ( Adam = false , max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 ) PSO # state optimization algorithm: PSO alg = QuanEstimation . PSO ( p_num = 10 , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) DE # state optimization algorithm: DE alg = QuanEstimation . DE ( p_num = 10 , max_episode = 1000 , c = 1.0 , cr = 0.5 ) NM # state optimization algorithm: NM alg = QuanEstimation . NM ( p_num = 10 , max_episode = 1000 , ar = 1.0 , ae = 2.0 , ac = 0.5 , as0 = 0.5 ) DDPG # state optimization algorithm: DDPG alg = QuanEstimation . DDPG ( max_episode = 500 , layer_num = 3 , layer_dim = 200 ) # input the dynamics data dynamics = QuanEstimation . Lindblad ( opt , tspan , H0 , dH , decay = decay ) QFIM # objective function: QFI obj = QuanEstimation . QFIM_obj () CFIM # objective function: CFI obj = QuanEstimation . CFIM_obj () # run the state optimization problem QuanEstimation . run ( opt , alg , obj , dynamics ; savefile = false ) Example 6.2 In the multiparameter scenario, \\(g\\) and \\(h\\) are chooen to be the unknown parameters to be estimated. Python from quanestimation import * import numpy as np from qutip import * # the dimension of the system N = 8 # generation of coherent spin state psi_css = spin_coherent ( 0.5 * N , 0.5 * np . pi , 0.5 * np . pi , type = \"ket\" ) . full () psi_css = psi_css . reshape ( 1 , - 1 )[ 0 ] # guessed state psi0 = [ psi_css ] # free Hamiltonian Lambda , g , h = 1.0 , 0.5 , 0.1 Jx , Jy , Jz = jmat ( 0.5 * N ) Jx , Jy , Jz = Jx . full (), Jy . full (), Jz . full () H0 = - Lambda * ( np . dot ( Jx , Jx ) + g * np . dot ( Jy , Jy )) / N - h * Jz # derivatives of the free Hamiltonian on the g and h dH = [ - Lambda * np . dot ( Jy , Jy ) / N , - Jz ] # dissipation decay = [[ Jz , 0.1 ]] # time length for the evolution tspan = np . linspace ( 0. , 10. , 2500 ) # weight matrix W = np . array ([[ 1 / 3 , 0. ], [ 0. , 2 / 3 ]]) AD # state optimization algorithm: AD AD_paras = { \"Adam\" : False , \"psi0\" : psi0 , \"max_episode\" : 300 , \\ \"epsilon\" : 0.01 , \"beta1\" : 0.90 , \"beta2\" : 0.99 } state = StateOpt ( savefile = False , method = \"AD\" , ** AD_paras ) PSO # state optimization algorithm: PSO PSO_paras = { \"p_num\" : 10 , \"psi0\" : psi0 , \"max_episode\" :[ 1000 , 100 ], \\ \"c0\" : 1.0 , \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } state = StateOpt ( savefile = False , method = \"PSO\" , ** PSO_paras ) DE # state optimization algorithm: DE DE_paras = { \"p_num\" : 10 , \"psi0\" : psi0 , \"max_episode\" : 1000 , \"c\" : 1.0 , \\ \"cr\" : 0.5 , \"seed\" : 1234 } state = StateOpt ( savefile = False , method = \"DE\" , ** DE_paras ) NM # state optimization algorithm: NM NM_paras = { \"p_num\" : 20 , \"psi0\" : psi0 , \"max_episode\" : 1000 , \\ \"ar\" : 1.0 , \"ae\" : 2.0 , \"ac\" : 0.5 , \"as0\" : 0.5 , \"seed\" : 1234 } state = StateOpt ( savefile = False , method = \"NM\" , ** NM_paras ) DDPG # state optimization algorithm: DDPG DDPG_paras = { \"layer_num\" : 4 , \"layer_dim\" : 250 , \"max_episode\" : 500 , \\ \"seed\" : 1234 } state = StateOpt ( savefile = False , method = \"DDPG\" , ** DDPG_paras ) # input the dynamics data state . dynamics ( tspan , H0 , dH , decay = decay ) QFIM # objective function: tr(WF^{-1}) state . QFIM () CFIM # objective function: tr(WI^{-1}) state . CFIM () HCRB # objective function: HCRB state . HCRB () Julia using QuanEstimation using Random using StableRNGs using LinearAlgebra using SparseArrays # the dimension of the system N = 8 # generation of the coherent spin state j , theta , phi = N\u00f72 , 0.5 pi , 0.5 pi Jp = Matrix ( spdiagm ( 1 => [ sqrt ( j * ( j + 1 ) - m * ( m + 1 )) for m in j :- 1 :- j ][ 2 : end ])) Jm = Jp ' psi0 = exp ( 0.5 * theta * exp ( im * phi ) * Jm - 0.5 * theta * exp ( - im * phi ) * Jp ) * QuanEstimation . basis ( Int ( 2 * j + 1 ), 1 ) dim = length ( psi0 ) # free Hamiltonian lambda , g , h = 1.0 , 0.5 , 0.1 Jx = 0.5 * ( Jp + Jm ) Jy = - 0.5 im * ( Jp - Jm ) Jz = spdiagm ( j :- 1 :- j ) H0 = - lambda * ( Jx * Jx + g * Jy * Jy ) / N + g * Jy ^ 2 / N - h * Jz # derivative of the free Hamiltonian on g dH = [ - lambda * Jy * Jy / N , - Jz ] # dissipation decay = [[ Jz , 0.1 ]] # time length for the evolution tspan = range ( 0. , 10. , length = 2500 ) # weight matrix W = [ 1 / 3 0. ; 0. 2 / 3 ] # set the optimization type opt = QuanEstimation . StateOpt ( psi = psi0 , seed = 1234 ) AD # state optimization algorithm: AD alg = QuanEstimation . AD ( Adam = false , max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 ) PSO # state optimization algorithm: PSO alg = QuanEstimation . PSO ( p_num = 10 , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) DE # state optimization algorithm: DE alg = QuanEstimation . DE ( p_num = 10 , max_episode = 1000 , c = 1.0 , cr = 0.5 ) NM # state optimization algorithm: NM alg = QuanEstimation . NM ( p_num = 10 , max_episode = 1000 , ar = 1.0 , ae = 2.0 , ac = 0.5 , as0 = 0.5 ) DDPG # state optimization algorithm: DDPG alg = QuanEstimation . DDPG ( max_episode = 500 , layer_num = 3 , layer_dim = 200 ) # input the dynamics data dynamics = QuanEstimation . Lindblad ( opt , tspan , H0 , dH , decay = decay ) QFIM # objective function: tr(WF^{-1}) obj = QuanEstimation . QFIM_obj () CFIM # objective function: tr(WI^{-1}) obj = QuanEstimation . CFIM_obj () HCRB # objective function: HCRB obj = QuanEstimation . HCRB_obj () # run the state optimization problem QuanEstimation . run ( opt , alg , obj , dynamics ; savefile = false ) If the parameterization process is implemented with the Kraus operators, then the corresponding codes are Python state = StateOpt ( savefile = False , method = \"AD\" , ** kwargs ) state . state . Kraus ( K , dK ) QFIM state . QFIM ( W = [], LDtype = \"SLD\" ) CFIM state . CFIM ( M = [], W = []) HCRB state . HCRB ( W = []) Julia opt = StateOpt ( psi = psi , seed = 1234 ) alg = AD ( kwargs ... ) dynamics = Kraus ( opt , K , dK ) QFIM obj = QFIM_obj ( W = missing , LDtype = :SLD ) CFIM obj = CFIM_obj ( M = missing , W = missing ) HCRB obj = HCRB_obj ( W = missing ) run ( opt , alg , obj , dynamics ; savefile = false ) where K and dK are the Kraus operators and its derivatives with respect to the unknown parameters. Example 6.3 The Kraus operators for the amplitude damping channel are \\[\\begin{eqnarray} K_1 = \\left(\\begin{array}{cc} 1 & 0 \\\\ 0 & \\sqrt{1-\\gamma} \\end{array}\\right), K_2 = \\left(\\begin{array}{cc} 0 & \\sqrt{\\gamma} \\\\ 0 & 0 \\end{array}\\right), \\nonumber \\end{eqnarray}\\] where \\(\\gamma\\) is the unknown parameter to be estimated which represents the decay probability. Python from quanestimation import * import numpy as np # initial state rho0 = 0.5 * np . array ([[ 1. , 1. ], [ 1. , 1. ]]) # Kraus operators for the amplitude damping channel gamma = 0.1 K1 = np . array ([[ 1. , 0. ], [ 0. , np . sqrt ( 1 - gamma )]]) K2 = np . array ([[ 0. , np . sqrt ( gamma )], [ 0. , 0. ]]) K = [ K1 , K2 ] # derivatives of Kraus operators on gamma dK1 = np . array ([[ 1. , 0. ], [ 0. , - 0.5 / np . sqrt ( 1 - gamma )]]) dK2 = np . array ([[ 0. , 0.5 / np . sqrt ( gamma )], [ 0. , 0. ]]) dK = [[ dK1 ], [ dK2 ]] AD # state optimization algorithm: AD AD_paras = { \"Adam\" : False , \"psi0\" : psi0 , \"max_episode\" : 300 , \\ \"epsilon\" : 0.01 , \"beta1\" : 0.90 , \"beta2\" : 0.99 } state = StateOpt ( savefile = False , method = \"AD\" , ** AD_paras ) RI # state optimization algorithm: RI RI_paras = { \"psi0\" : psi0 , \"max_episode\" : 300 , \"seed\" : 0.01 } state = StateOpt ( savefile = False , method = \"RI\" , ** RI_paras ) PSO # state optimization algorithm: PSO PSO_paras = { \"p_num\" : 10 , \"psi0\" : psi0 , \"max_episode\" :[ 1000 , 100 ], \\ \"c0\" : 1.0 , \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } state = StateOpt ( savefile = False , method = \"PSO\" , ** PSO_paras ) DE # state optimization algorithm: DE DE_paras = { \"p_num\" : 10 , \"psi0\" : psi0 , \"max_episode\" : 1000 , \"c\" : 1.0 , \\ \"cr\" : 0.5 , \"seed\" : 1234 } state = StateOpt ( savefile = False , method = \"DE\" , ** DE_paras ) NM # state optimization algorithm: NM NM_paras = { \"p_num\" : 20 , \"psi0\" : psi0 , \"max_episode\" : 1000 , \\ \"ar\" : 1.0 , \"ae\" : 2.0 , \"ac\" : 0.5 , \"as0\" : 0.5 , \"seed\" : 1234 } state = StateOpt ( savefile = False , method = \"NM\" , ** NM_paras ) DDPG # state optimization algorithm: DDPG DDPG_paras = { \"layer_num\" : 4 , \"layer_dim\" : 250 , \"max_episode\" : 500 , \\ \"seed\" : 1234 } state = StateOpt ( savefile = False , method = \"DDPG\" , ** DDPG_paras ) # input the dynamics data state . Kraus ( K , dK ) QFIM # objective function: QFI state . QFIM () CFIM # objective function: CFI state . CFIM () HCRB # objective function: HCRB state . HCRB () Julia using QuanEstimation # initial state rho0 = 0.5 * ones ( 2 , 2 ) # Kraus operators for the amplitude damping channel gamma = 0.1 K1 = [ 1. 0. ; 0. sqrt ( 1 - gamma )] K2 = [ 0. sqrt ( gamma ); 0. 0. ] K = [ K1 , K2 ] # derivatives of Kraus operators on gamma dK1 = [ 1. 0. ; 0. - 0.5 / sqrt ( 1 - gamma )] dK2 = [ 0. 0.5 / sqrt ( gamma ); 0. 0. ] dK = [[ dK1 ], [ dK2 ]] AD # state optimization algorithm: AD alg = QuanEstimation . AD ( Adam = false , max_episode = 300 , epsilon = 0.01 , beta1 = 0.90 , beta2 = 0.99 ) RI # state optimization algorithm: RI alg = QuanEstimation . RI ( max_episode = 300 ) PSO # state optimization algorithm: PSO alg = QuanEstimation . PSO ( p_num = 10 , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) DE # state optimization algorithm: DE alg = QuanEstimation . DE ( p_num = 10 , max_episode = 1000 , c = 1.0 , cr = 0.5 ) NM # state optimization algorithm: NM alg = QuanEstimation . NM ( p_num = 10 , max_episode = 1000 , ar = 1.0 , ae = 2.0 , ac = 0.5 , as0 = 0.5 ) DDPG # state optimization algorithm: DDPG alg = QuanEstimation . DDPG ( max_episode = 500 , layer_num = 3 , layer_dim = 200 ) # input the dynamics data dynamics = QuanEstimation . Kraus ( opt , K , dK ) QFIM # objective function: QFI obj = QuanEstimation . QFIM_obj () CFIM # objective function: CFI obj = QuanEstimation . CFIM_obj () HCRB # objective function: HCRB obj = QuanEstimation . HCRB_obj () # run the state optimization problem QuanEstimation . run ( opt , alg , obj , dynamics ; savefile = false )","title":"DDPG"},{"location":"guide/guide_Sopt/#bibliography","text":"[1] A. G. Baydin, B. A. Pearlmutter, A. A. Radul, and J. M. Siskind, Automatic differentiation in machine learning: a survey, J. Mach. Learn. Res. 18 , 1-43 (2018). [2] R. Demkowicz-Dobrza\u0144ski, Optimal phase estimation with arbitrary a priori knowledge, Phys. Rev. A 83 , 061802(R) (2011). [3] J. Kennedy and R. Eberhar, Particle swarm optimization, Proc. 1995 IEEE International Conference on Neural Networks 4 , 1942-1948 (1995). [4] R. Storn and K. Price, Differential Evolution-A Simple and Efficient Heuristic for global Optimization over Continuous Spaces, J. Global Optim. 11 , 341 (1997). [5] J. A. Nelder and R. Mead, A Simplex Method for Function Minimization, Comput. J. 7 , 308\u2013313 (1965). [6] T. P. Lillicrap, J. J. Hunt, A. Pritzel, N. Heess, T. Erez, Y. Tassa, D. Silver, and D. Wierstra, Continuous control with deep reinforcement learning, arXiv:1509.02971. [7] J. R. Johansson, P. D. Nation, and F. Nori, QuTiP: An open-source Python framework for the dynamics of open quantum systems, Comp. Phys. Comm. 183 , 1760 (2012). [8] J. R. Johansson, P. D. Nation, and F. Nori, QuTiP 2: A Python framework for the dynamics of open quantum systems, Comp. Phys. Comm. 184 , 1234 (2013).","title":"Bibliography"},{"location":"guide/guide_adaptive/","text":"Adaptive measurement schemes \u00b6 In QuanEstimation, the Hamiltonian of the adaptive system should be written as \\(H(\\textbf{x}+\\textbf{u})\\) with \\(\\textbf{x}\\) the unknown parameters and \\(\\textbf{u}\\) the tunable parameters. The tunable parameters \\(\\textbf{u}\\) are used to let the Hamiltonian work at the optimal point \\(\\textbf{x}_{\\mathrm{opt}}\\) . In this scenario, the adaptive estimation can be excuted through Python apt = Adaptive ( x , p , rho0 , savefile = False , max_episode = 1000 , eps = 1e-8 ) apt . dynamics ( tspan , H , dH , Hc = [], ctrl = [], decay = []) apt . CFIM ( M = [], W = []) where x is a list of arrays representing the regime of the parameters for the integral, p is an array representing the prior distribution, it is multidimensional for multiparameter estimation. rho0 is the density matrix of the probe state. The number of iterations can be set via max_episode with the default value 1000. eps represents the machine epsilon which defaults to \\(10^{-8}\\) . At the end of the program, three files \"pout.npy\", \"xout.npy\", and \"y.npy\" including the posterior distributions, the estimated values and the experimental results will be generated. If savefile=True , these files will be generated during the training and \"pout.npy\" will save all the posterior distributions, otherwise, the posterior distribution in the final iteration will be saved. Julia Adaptive ( x , p , rho0 , tspan , H , dH ; savefile = false , max_episode = 1000 , eps = 1e-8 , Hc = missing , ctrl = missing , decay = missing , M = missing , W = missing ) where x is a list of arrays representing the regime of the parameters for the integral, p is an array representing the prior distribution, it is multidimensional for multiparameter estimation. rho0 is the density matrix of the probe state. The number of iterations can be set via max_episode with the default value 1000. eps represents the machine epsilon which defaults to \\(10^{-8}\\) . At the end of the program, three files \"pout.csv\", \"xout.csv\", and \"y.csv\" including the posterior distributions, the estimated values and the experimental results will be generated. If savefile=true , these files will be generated during the training and \"pout.csv\" will save all the posterior distributions, otherwise, the posterior distribution in the final iteration will be saved. If the dynamics of the system can be described by the master equation, then the dynamics data tspan , H , and dH shoule be input. tspan is the time length for the evolution, H and dH are multidimensional lists representing the Hamiltonian and its derivatives with respect to the unknown parameters to be estimated, they can be generated via Python H , dH = BayesInput ( x , func , dfunc , channel = \"dynamics\" ) Julia H , dH = BayesInput ( x , func , dfunc ; channel = \"dynamics\" ) Here func and dfunc are the functions defined by the users which return H and dH , respectively. Futhermore, for the systems with noise and controls, the variables decay , Hc and ctrl should be input. Here Hc and ctrl are two lists representing the control Hamiltonians and the corresponding control coefficients. decay contains decay operators \\((\\Gamma_1, \\Gamma_2, \\cdots)\\) and the corresponding decay rates \\((\\gamma_1, \\gamma_2, \\cdots)\\) with the input rule decay=[[ \\(\\Gamma_1\\) , \\(\\gamma_1\\) ], [ \\(\\Gamma_2\\) , \\(\\gamma_2\\) ],...]. The objective function for adaptive measurement are CFI and \\(\\mathrm{Tr}(W\\mathcal{I}^ {-1})\\) with \\(\\mathcal{I}\\) the CFIM. W is the weight matrix which defaults to the identity matrix. If the parameterization is implemented with the Kraus operators, the codes become Python apt = Adaptive ( x , p , rho0 , savefile = False , max_episode = 1000 , eps = 1e-8 ) apt . Kraus ( K , dK ) apt . CFIM ( M = [], W = []) Julia Adaptive ( x , p , rho0 , K , dK ; savefile = false , max_episode = 1000 , eps = 1e-8 , Hc = missing , ctrl = missing , decay = missing , M = missing , W = missing ) and Python K , dK = BayesInput ( x , func , dfunc , channel = \"Kraus\" ) Julia K , dK = BayesInput ( x , func , dfunc ; channel = \"Kraus\" ) where K and dK are the Kraus operators and its derivatives with respect to the unknown parameters. Example 9.1 The Hamiltonian of a qubit system is \\begin{align} H=\\frac{B\\omega_0}{2}(\\sigma_1\\cos{x}+\\sigma_3\\sin{x}), \\end{align} where \\(B\\) is the magnetic field in the XZ plane, \\(x\\) is the unknown parameter and \\(\\sigma_{1}\\) , \\(\\sigma_{3}\\) are the Pauli matrices. The probe state is taken as \\(|\\pm\\rangle\\) . The measurement is \\(\\{|\\!+\\rangle\\langle+\\!|,|\\!-\\rangle\\langle-\\!|\\}\\) . Here \\(|\\pm\\rangle:=\\frac{1}{\\sqrt{2}}(|0\\rangle\\pm|1\\rangle)\\) with \\(|0\\rangle\\) \\((|1\\rangle)\\) the eigenstate of \\(\\sigma_3\\) with respect to the eigenvalue \\(1\\) \\((-1)\\) . In this example, the prior distribution \\(p(x)\\) is uniform. Python from quanestimation import * import numpy as np import random # initial state rho0 = 0.5 * np . array ([[ 1. , 1. ], [ 1. , 1. ]]) # free Hamiltonian B , omega0 = 0.5 * np . pi , 1.0 sx = np . array ([[ 0. , 1. ], [ 1. , 0. ]]) sy = np . array ([[ 0. , - 1. j ], [ 1. j , 0. ]]) sz = np . array ([[ 1. , 0. ], [ 0. , - 1. ]]) H0_func = lambda x : 0.5 * B * omega0 * ( sx * np . cos ( x [ 0 ]) + sz * np . sin ( x [ 0 ])) # derivative of free Hamiltonian in x dH_func = lambda x : [ 0.5 * B * omega0 * ( - sx * np . sin ( x [ 0 ]) + sz * np . cos ( x [ 0 ]))] # measurement M1 = 0.5 * np . array ([[ 1. , 1. ], [ 1. , 1. ]]) M2 = 0.5 * np . array ([[ 1. , - 1. ], [ - 1. , 1. ]]) M = [ M1 , M2 ] # time length for the evolution tspan = np . linspace ( 0. , 1. , 1000 ) # prior distribution x = np . linspace ( - 0.25 * np . pi + 0.1 , 3.0 * np . pi / 4.0 - 0.1 , 100 ) p = ( 1.0 / ( x [ - 1 ] - x [ 0 ])) * np . ones ( len ( x )) # dynamics rho = [ np . zeros (( len ( rho0 ), len ( rho0 )), dtype = np . complex128 ) for \\ i in range ( len ( x ))] for xi in range ( len ( x )): H_tp = H0_func ([ x [ xi ]]) dH_tp = dH_func ([ x [ xi ]]) dynamics = Lindblad ( tspan , rho0 , H_tp , dH_tp ) rho_tp , drho_tp = dynamics . expm () rho [ xi ] = rho_tp [ - 1 ] # Bayesian estimation np . random . seed ( 1234 ) y = [ 0 for i in range ( 500 )] res_rand = random . sample ( range ( 0 , len ( y )), 125 ) for i in range ( len ( res_rand )): y [ res_rand [ i ]] = 1 pout , xout = Bayes ([ x ], p , rho , y , M = M , estimator = \"MAP\" , savefile = False ) # generation of H and dH H , dH = BayesInput ([ x ], H0_func , dH_func , channel = \"dynamics\" ) # adaptive measurement apt = Adaptive ([ x ], pout , rho0 , savefile = False , max_episode = 1000 , eps = 1e-8 ) apt . dynamics ( tspan , H , dH ) apt . CFIM ( M = M , W = []) Julia using QuanEstimation using Random using StatsBase # free Hamiltonian function H0_func ( x ) return 0.5 * B * omega0 * ( sx * cos ( x [ 1 ]) + sz * sin ( x [ 1 ])) end # derivative of free Hamiltonian in x function dH_func ( x ) return [ 0.5 * B * omega0 * ( - sx * sin ( x [ 1 ]) + sz * cos ( x [ 1 ]))] end B , omega0 = pi / 2.0 , 1.0 sx = [ 0. 1. ; 1. 0.0 im ] sy = [ 0. - im ; im 0. ] sz = [ 1. 0.0 im ; 0. - 1. ] # initial state rho0 = 0.5 * ones ( 2 , 2 ) # measurement M1 = 0.5 * [ 1.0 + 0.0 im 1. ; 1. 1. ] M2 = 0.5 * [ 1.0 + 0.0 im - 1. ; - 1. 1. ] M = [ M1 , M2 ] # time length for the evolution tspan = range ( 0. , stop = 1. , length = 1000 ) |> Vector # prior distribution x = range ( - 0.25 * pi + 0.1 , stop = 3.0 * pi / 4.0 - 0.1 , length = 100 ) |> Vector p = ( 1.0 / ( x [ end ] - x [ 1 ])) * ones ( length ( x )) # dynamics rho = Vector { Matrix { ComplexF64 }}( undef , length ( x )) for i = 1 : length ( x ) H0_tp = H0_func ( x [ i ]) dH_tp = dH_func ( x [ i ]) rho_tp , drho_tp = QuanEstimation . expm ( tspan , rho0 , H0_tp , dH_tp ) rho [ i ] = rho_tp [ end ] end # Bayesian estimation Random . seed! ( 1234 ) y = [ 0 for i in 1 : 500 ] res_rand = sample ( 1 : length ( y ), 125 , replace = false ) for i in 1 : length ( res_rand ) y [ res_rand [ i ]] = 1 end pout , xout = QuanEstimation . Bayes ([ x ], p , rho , y , M = M , estimator = \"MAP\" , savefile = false ) # generation of H and dH H , dH = QuanEstimation . BayesInput ([ x ], H0_func , dH_func ; channel = \"dynamics\" ) # adaptive measurement QuanEstimation . Adaptive ([ x ], pout , rho0 , tspan , H , dH ; M = M , max_episode = 1000 ) Berry et al. [1,2] introduced a famous adaptive scheme in phase estimation. The phase for the \\((n+1)\\) th round is updated via \\(\\Phi_{n+1}=\\Phi_{n}-(-1)^{y^{(n)}}\\Delta \\Phi_{n+1}\\) with \\(y^{(n)}\\) the experimental result in the \\(n\\) th round and \\(\\Delta\\Phi_{n+1}\\) the phase difference generated by the proper algorithms. This adaptive scheme can be performed in QuanEstimation via Python apt = Adapt_MZI ( x , p , rho0 ) apt . general () apt . online ( output = \"phi\" ) Here x , p , and rho0 are the same with adaptive . The output can be set through output=\"phi\" (default) and output=\"dphi\" representing the phase and phase difference, respectively. Online and offline strategies are both available in the package and the code for calling offline stratege becomes apt.offline(method=\"DE\", **kwargs) or apt.offline(method=\"PSO\", **kwargs) . Julia apt = Adapt_MZI ( x , p , rho0 ) online ( apt , output = \"phi\" ) Here x , p , and rho0 are the same with adaptive . The output can be set through output=\"phi\" (default) and output=\"dphi\" representing the phase and phase difference, respectively. Online and offline strategies are both available in the package and the code for calling offline stratege becomes alg = QuanEstimation.DE(kwargs...) ( alg = QuanEstimation.PSO(kwargs...) ) and offline(apt, alg, seed=seed) . seed is the random seed which can ensure the reproducibility of results. If the optimization algorithm is PSO, the keywords and the default values are Python kwargs = { \"p_num\" : 10 , \"deltaphi0\" :[], \"max_episode\" :[ 1000 , 100 ], \"c0\" : 1.0 , \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } The keywords and the default values of PSO can be seen in the following table \\(~~~~~~~~~~\\) **kwargs \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"p_num\" 10 \"deltaphi0\" [ ] \"max_episode\" [1000,100] \"c0\" 1.0 \"c1\" 2.0 \"c2\" 2.0 \"seed\" 1234 Here p_num is the number of particles, deltaphi0 represents the initial guesses of phase difference. max_episode accepts both integer and array with two elements. If it is an integer, for example max_episode=1000 , it means the program will continuously run 1000 episodes. However, if it is an array, for example max_episode=[1000,100] , the program will run 1000 episodes in total but replace the data of all the particles with global best every 100 episodes. c0 , c1 and c2 are the PSO parameters representing the inertia weight, cognitive learning factor and social learning factor, respectively. Julia alg = PSO ( p_num = 10 , ini_particle = missing , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) The keywords and the default values of PSO can be seen in the following table \\(~~~~~~~~~~\\) keywords \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"p_num\" 10 \"ini_particle\" missing \"max_episode\" [1000,100] \"c0\" 1.0 \"c1\" 2.0 \"c2\" 2.0 Here p_num is the number of particles, ini_particle represents the initial guesses of phase difference. max_episode accepts both integer and array with two elements. If it is an integer, for example max_episode=1000 , it means the program will continuously run 1000 episodes. However, if it is an array, for example max_episode=[1000,100] , the program will run 1000 episodes in total but replace the data of all the particles with global best every 100 episodes. c0 , c1 and c2 are the PSO parameters representing the inertia weight, cognitive learning factor and social learning factor, respectively. If the optimization algorithm is DE, the keywords and the default values are Python kwargs = { \"p_num\" : 10 , \"deltaphi0\" :[], \"max_episode\" : 1000 , \"c\" : 1.0 , \"cr\" : 0.5 , \"seed\" : 1234 } The keywords and the default values of DE can be seen in the following table \\(~~~~~~~~~~\\) **kwargs \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"p_num\" 10 \"deltaphi0\" [ ] \"max_episode\" 1000 \"c\" 1.0 \"cr\" 0.5 \"seed\" 1234 p_num and max_episode are the number of populations and training episodes. c and cr are DE parameters representing the mutation and crossover constants, seed is the random seed which can ensure the reproducibility of results. Julia alg = DE ( p_num = 10 , ini_population = missing , max_episode = 1000 , c = 1.0 , cr = 0.5 ) The keywords and the default values of DE can be seen in the following table \\(~~~~~~~~~~\\) keywords \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"p_num\" 10 \"ini_population\" missing \"max_episode\" 1000 \"c\" 1.0 \"cr\" 0.5 ini_population represents the initial guesses of phase difference. p_num and max_episode are the number of populations and training episodes. c and cr are DE parameters representing the mutation and crossover constants. Example 9.2 In this example, the adaptive measurement shceme is design for the MZI [3,4] . The input state is \\begin{align} \\sqrt{\\frac{2}{N+2}}\\sum^{N/2}_{m=-N/2}\\sin\\left(\\frac{(2m+N+2)\\pi}{2(N+2)}\\right)|m\\rangle, \\end{align} where \\(N\\) is the number of photon, \\(|m\\rangle\\) is the eigenstate of \\(J_y\\) with the eigenvalue \\(m\\) . Python from quanestimation import * import numpy as np # the number of photons N = 8 # probe state psi = np . zeros (( N + 1 ) ** 2 ) . reshape ( - 1 , 1 ) for k in range ( N + 1 ): psi += np . sin (( k + 1 ) * np . pi / ( N + 2 )) * \\ np . kron ( basis ( N + 1 , k ), basis ( N + 1 , N - k )) psi = np . sqrt ( 2 / ( 2 + N )) * psi rho0 = np . dot ( psi , psi . conj () . T ) # prior distribution x = np . linspace ( - np . pi , np . pi , 100 ) p = ( 1.0 / ( x [ - 1 ] - x [ 0 ])) * np . ones ( len ( x )) apt = Adapt_MZI ( x , p , rho0 ) apt . general () online apt . online ( output = \"phi\" ) offline DE DE_para = { \"p_num\" : 10 , \"deltaphi0\" :[], \"max_episode\" : 1000 , \"c\" : 1.0 , \"cr\" : 0.5 , \"seed\" : 1234 } apt . offline ( method = \"DE\" , ** DE_para ) PSO PSO_para = { \"p_num\" : 10 , \"deltaphi0\" :[], \"max_episode\" :[ 1000 , 100 ], \"c0\" : 1.0 , \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } apt . offline ( method = \"PSO\" , ** PSO_para ) Julia using QuanEstimation # the number of photons N = 8 # probe state psi = sum ([ sin ( k * pi / ( N + 2 )) * kron ( QuanEstimation . basis ( N + 1 , k ), QuanEstimation . basis ( N + 1 , N - k + 2 )) for k in 1 : ( N + 1 )]) |> sparse psi = psi * sqrt ( 2 / ( 2 + N )) rho0 = psi * psi ' # prior distribution x = range ( - pi , pi , length = 100 ) p = ( 1.0 / ( x [ end ] - x [ 1 ])) * ones ( length ( x )) apt = QuanEstimation . Adapt_MZI ( x , p , rho0 ) online QuanEstimation . online ( apt , output = \"phi\" ) offline DE alg = QuanEstimation . DE ( p_num = 10 , ini_population = missing , max_episode = 1000 , c = 1.0 , cr = 0.5 ) QuanEstimation . offline ( apt , alg , seed = 1234 ) PSO alg = QuanEstimation . PSO ( p_num = 10 , ini_particle = missing , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) QuanEstimation . offline ( apt , alg , seed = 1234 ) Bibliography \u00b6 [1] D. W. Berry and H. M. Wiseman, Optimal States and Almost Optimal Adaptive Measurements for Quantum Interferometry, Phys. Rev. Lett. 85 , 5098 (2000). [2] D. W. Berry, H. M. Wiseman, and J. K. Breslin, Optimal input states and feedback for interferometric phase estimation, Phys. Rev. A 63 , 053804 (2001). [3] A. Hentschel and B. C. Sanders, Machine Learning for Precise Quantum Measurement, Phys. Rev. Lett. 104 , 063603 (2010). [4] A. Hentschel and B. C. Sanders, Efficient Algorithm for Optimizing Adaptive Quantum Metrology Processes, Phys. Rev. Lett. 104 , 063603 (2011).","title":"Adaptive measurement schemes"},{"location":"guide/guide_adaptive/#adaptive-measurement-schemes","text":"In QuanEstimation, the Hamiltonian of the adaptive system should be written as \\(H(\\textbf{x}+\\textbf{u})\\) with \\(\\textbf{x}\\) the unknown parameters and \\(\\textbf{u}\\) the tunable parameters. The tunable parameters \\(\\textbf{u}\\) are used to let the Hamiltonian work at the optimal point \\(\\textbf{x}_{\\mathrm{opt}}\\) . In this scenario, the adaptive estimation can be excuted through Python apt = Adaptive ( x , p , rho0 , savefile = False , max_episode = 1000 , eps = 1e-8 ) apt . dynamics ( tspan , H , dH , Hc = [], ctrl = [], decay = []) apt . CFIM ( M = [], W = []) where x is a list of arrays representing the regime of the parameters for the integral, p is an array representing the prior distribution, it is multidimensional for multiparameter estimation. rho0 is the density matrix of the probe state. The number of iterations can be set via max_episode with the default value 1000. eps represents the machine epsilon which defaults to \\(10^{-8}\\) . At the end of the program, three files \"pout.npy\", \"xout.npy\", and \"y.npy\" including the posterior distributions, the estimated values and the experimental results will be generated. If savefile=True , these files will be generated during the training and \"pout.npy\" will save all the posterior distributions, otherwise, the posterior distribution in the final iteration will be saved. Julia Adaptive ( x , p , rho0 , tspan , H , dH ; savefile = false , max_episode = 1000 , eps = 1e-8 , Hc = missing , ctrl = missing , decay = missing , M = missing , W = missing ) where x is a list of arrays representing the regime of the parameters for the integral, p is an array representing the prior distribution, it is multidimensional for multiparameter estimation. rho0 is the density matrix of the probe state. The number of iterations can be set via max_episode with the default value 1000. eps represents the machine epsilon which defaults to \\(10^{-8}\\) . At the end of the program, three files \"pout.csv\", \"xout.csv\", and \"y.csv\" including the posterior distributions, the estimated values and the experimental results will be generated. If savefile=true , these files will be generated during the training and \"pout.csv\" will save all the posterior distributions, otherwise, the posterior distribution in the final iteration will be saved. If the dynamics of the system can be described by the master equation, then the dynamics data tspan , H , and dH shoule be input. tspan is the time length for the evolution, H and dH are multidimensional lists representing the Hamiltonian and its derivatives with respect to the unknown parameters to be estimated, they can be generated via Python H , dH = BayesInput ( x , func , dfunc , channel = \"dynamics\" ) Julia H , dH = BayesInput ( x , func , dfunc ; channel = \"dynamics\" ) Here func and dfunc are the functions defined by the users which return H and dH , respectively. Futhermore, for the systems with noise and controls, the variables decay , Hc and ctrl should be input. Here Hc and ctrl are two lists representing the control Hamiltonians and the corresponding control coefficients. decay contains decay operators \\((\\Gamma_1, \\Gamma_2, \\cdots)\\) and the corresponding decay rates \\((\\gamma_1, \\gamma_2, \\cdots)\\) with the input rule decay=[[ \\(\\Gamma_1\\) , \\(\\gamma_1\\) ], [ \\(\\Gamma_2\\) , \\(\\gamma_2\\) ],...]. The objective function for adaptive measurement are CFI and \\(\\mathrm{Tr}(W\\mathcal{I}^ {-1})\\) with \\(\\mathcal{I}\\) the CFIM. W is the weight matrix which defaults to the identity matrix. If the parameterization is implemented with the Kraus operators, the codes become Python apt = Adaptive ( x , p , rho0 , savefile = False , max_episode = 1000 , eps = 1e-8 ) apt . Kraus ( K , dK ) apt . CFIM ( M = [], W = []) Julia Adaptive ( x , p , rho0 , K , dK ; savefile = false , max_episode = 1000 , eps = 1e-8 , Hc = missing , ctrl = missing , decay = missing , M = missing , W = missing ) and Python K , dK = BayesInput ( x , func , dfunc , channel = \"Kraus\" ) Julia K , dK = BayesInput ( x , func , dfunc ; channel = \"Kraus\" ) where K and dK are the Kraus operators and its derivatives with respect to the unknown parameters. Example 9.1 The Hamiltonian of a qubit system is \\begin{align} H=\\frac{B\\omega_0}{2}(\\sigma_1\\cos{x}+\\sigma_3\\sin{x}), \\end{align} where \\(B\\) is the magnetic field in the XZ plane, \\(x\\) is the unknown parameter and \\(\\sigma_{1}\\) , \\(\\sigma_{3}\\) are the Pauli matrices. The probe state is taken as \\(|\\pm\\rangle\\) . The measurement is \\(\\{|\\!+\\rangle\\langle+\\!|,|\\!-\\rangle\\langle-\\!|\\}\\) . Here \\(|\\pm\\rangle:=\\frac{1}{\\sqrt{2}}(|0\\rangle\\pm|1\\rangle)\\) with \\(|0\\rangle\\) \\((|1\\rangle)\\) the eigenstate of \\(\\sigma_3\\) with respect to the eigenvalue \\(1\\) \\((-1)\\) . In this example, the prior distribution \\(p(x)\\) is uniform. Python from quanestimation import * import numpy as np import random # initial state rho0 = 0.5 * np . array ([[ 1. , 1. ], [ 1. , 1. ]]) # free Hamiltonian B , omega0 = 0.5 * np . pi , 1.0 sx = np . array ([[ 0. , 1. ], [ 1. , 0. ]]) sy = np . array ([[ 0. , - 1. j ], [ 1. j , 0. ]]) sz = np . array ([[ 1. , 0. ], [ 0. , - 1. ]]) H0_func = lambda x : 0.5 * B * omega0 * ( sx * np . cos ( x [ 0 ]) + sz * np . sin ( x [ 0 ])) # derivative of free Hamiltonian in x dH_func = lambda x : [ 0.5 * B * omega0 * ( - sx * np . sin ( x [ 0 ]) + sz * np . cos ( x [ 0 ]))] # measurement M1 = 0.5 * np . array ([[ 1. , 1. ], [ 1. , 1. ]]) M2 = 0.5 * np . array ([[ 1. , - 1. ], [ - 1. , 1. ]]) M = [ M1 , M2 ] # time length for the evolution tspan = np . linspace ( 0. , 1. , 1000 ) # prior distribution x = np . linspace ( - 0.25 * np . pi + 0.1 , 3.0 * np . pi / 4.0 - 0.1 , 100 ) p = ( 1.0 / ( x [ - 1 ] - x [ 0 ])) * np . ones ( len ( x )) # dynamics rho = [ np . zeros (( len ( rho0 ), len ( rho0 )), dtype = np . complex128 ) for \\ i in range ( len ( x ))] for xi in range ( len ( x )): H_tp = H0_func ([ x [ xi ]]) dH_tp = dH_func ([ x [ xi ]]) dynamics = Lindblad ( tspan , rho0 , H_tp , dH_tp ) rho_tp , drho_tp = dynamics . expm () rho [ xi ] = rho_tp [ - 1 ] # Bayesian estimation np . random . seed ( 1234 ) y = [ 0 for i in range ( 500 )] res_rand = random . sample ( range ( 0 , len ( y )), 125 ) for i in range ( len ( res_rand )): y [ res_rand [ i ]] = 1 pout , xout = Bayes ([ x ], p , rho , y , M = M , estimator = \"MAP\" , savefile = False ) # generation of H and dH H , dH = BayesInput ([ x ], H0_func , dH_func , channel = \"dynamics\" ) # adaptive measurement apt = Adaptive ([ x ], pout , rho0 , savefile = False , max_episode = 1000 , eps = 1e-8 ) apt . dynamics ( tspan , H , dH ) apt . CFIM ( M = M , W = []) Julia using QuanEstimation using Random using StatsBase # free Hamiltonian function H0_func ( x ) return 0.5 * B * omega0 * ( sx * cos ( x [ 1 ]) + sz * sin ( x [ 1 ])) end # derivative of free Hamiltonian in x function dH_func ( x ) return [ 0.5 * B * omega0 * ( - sx * sin ( x [ 1 ]) + sz * cos ( x [ 1 ]))] end B , omega0 = pi / 2.0 , 1.0 sx = [ 0. 1. ; 1. 0.0 im ] sy = [ 0. - im ; im 0. ] sz = [ 1. 0.0 im ; 0. - 1. ] # initial state rho0 = 0.5 * ones ( 2 , 2 ) # measurement M1 = 0.5 * [ 1.0 + 0.0 im 1. ; 1. 1. ] M2 = 0.5 * [ 1.0 + 0.0 im - 1. ; - 1. 1. ] M = [ M1 , M2 ] # time length for the evolution tspan = range ( 0. , stop = 1. , length = 1000 ) |> Vector # prior distribution x = range ( - 0.25 * pi + 0.1 , stop = 3.0 * pi / 4.0 - 0.1 , length = 100 ) |> Vector p = ( 1.0 / ( x [ end ] - x [ 1 ])) * ones ( length ( x )) # dynamics rho = Vector { Matrix { ComplexF64 }}( undef , length ( x )) for i = 1 : length ( x ) H0_tp = H0_func ( x [ i ]) dH_tp = dH_func ( x [ i ]) rho_tp , drho_tp = QuanEstimation . expm ( tspan , rho0 , H0_tp , dH_tp ) rho [ i ] = rho_tp [ end ] end # Bayesian estimation Random . seed! ( 1234 ) y = [ 0 for i in 1 : 500 ] res_rand = sample ( 1 : length ( y ), 125 , replace = false ) for i in 1 : length ( res_rand ) y [ res_rand [ i ]] = 1 end pout , xout = QuanEstimation . Bayes ([ x ], p , rho , y , M = M , estimator = \"MAP\" , savefile = false ) # generation of H and dH H , dH = QuanEstimation . BayesInput ([ x ], H0_func , dH_func ; channel = \"dynamics\" ) # adaptive measurement QuanEstimation . Adaptive ([ x ], pout , rho0 , tspan , H , dH ; M = M , max_episode = 1000 ) Berry et al. [1,2] introduced a famous adaptive scheme in phase estimation. The phase for the \\((n+1)\\) th round is updated via \\(\\Phi_{n+1}=\\Phi_{n}-(-1)^{y^{(n)}}\\Delta \\Phi_{n+1}\\) with \\(y^{(n)}\\) the experimental result in the \\(n\\) th round and \\(\\Delta\\Phi_{n+1}\\) the phase difference generated by the proper algorithms. This adaptive scheme can be performed in QuanEstimation via Python apt = Adapt_MZI ( x , p , rho0 ) apt . general () apt . online ( output = \"phi\" ) Here x , p , and rho0 are the same with adaptive . The output can be set through output=\"phi\" (default) and output=\"dphi\" representing the phase and phase difference, respectively. Online and offline strategies are both available in the package and the code for calling offline stratege becomes apt.offline(method=\"DE\", **kwargs) or apt.offline(method=\"PSO\", **kwargs) . Julia apt = Adapt_MZI ( x , p , rho0 ) online ( apt , output = \"phi\" ) Here x , p , and rho0 are the same with adaptive . The output can be set through output=\"phi\" (default) and output=\"dphi\" representing the phase and phase difference, respectively. Online and offline strategies are both available in the package and the code for calling offline stratege becomes alg = QuanEstimation.DE(kwargs...) ( alg = QuanEstimation.PSO(kwargs...) ) and offline(apt, alg, seed=seed) . seed is the random seed which can ensure the reproducibility of results. If the optimization algorithm is PSO, the keywords and the default values are Python kwargs = { \"p_num\" : 10 , \"deltaphi0\" :[], \"max_episode\" :[ 1000 , 100 ], \"c0\" : 1.0 , \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } The keywords and the default values of PSO can be seen in the following table \\(~~~~~~~~~~\\) **kwargs \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"p_num\" 10 \"deltaphi0\" [ ] \"max_episode\" [1000,100] \"c0\" 1.0 \"c1\" 2.0 \"c2\" 2.0 \"seed\" 1234 Here p_num is the number of particles, deltaphi0 represents the initial guesses of phase difference. max_episode accepts both integer and array with two elements. If it is an integer, for example max_episode=1000 , it means the program will continuously run 1000 episodes. However, if it is an array, for example max_episode=[1000,100] , the program will run 1000 episodes in total but replace the data of all the particles with global best every 100 episodes. c0 , c1 and c2 are the PSO parameters representing the inertia weight, cognitive learning factor and social learning factor, respectively. Julia alg = PSO ( p_num = 10 , ini_particle = missing , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) The keywords and the default values of PSO can be seen in the following table \\(~~~~~~~~~~\\) keywords \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"p_num\" 10 \"ini_particle\" missing \"max_episode\" [1000,100] \"c0\" 1.0 \"c1\" 2.0 \"c2\" 2.0 Here p_num is the number of particles, ini_particle represents the initial guesses of phase difference. max_episode accepts both integer and array with two elements. If it is an integer, for example max_episode=1000 , it means the program will continuously run 1000 episodes. However, if it is an array, for example max_episode=[1000,100] , the program will run 1000 episodes in total but replace the data of all the particles with global best every 100 episodes. c0 , c1 and c2 are the PSO parameters representing the inertia weight, cognitive learning factor and social learning factor, respectively. If the optimization algorithm is DE, the keywords and the default values are Python kwargs = { \"p_num\" : 10 , \"deltaphi0\" :[], \"max_episode\" : 1000 , \"c\" : 1.0 , \"cr\" : 0.5 , \"seed\" : 1234 } The keywords and the default values of DE can be seen in the following table \\(~~~~~~~~~~\\) **kwargs \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"p_num\" 10 \"deltaphi0\" [ ] \"max_episode\" 1000 \"c\" 1.0 \"cr\" 0.5 \"seed\" 1234 p_num and max_episode are the number of populations and training episodes. c and cr are DE parameters representing the mutation and crossover constants, seed is the random seed which can ensure the reproducibility of results. Julia alg = DE ( p_num = 10 , ini_population = missing , max_episode = 1000 , c = 1.0 , cr = 0.5 ) The keywords and the default values of DE can be seen in the following table \\(~~~~~~~~~~\\) keywords \\(~~~~~~~~~~\\) \\(~~~~\\) default values \\(~~~~\\) \"p_num\" 10 \"ini_population\" missing \"max_episode\" 1000 \"c\" 1.0 \"cr\" 0.5 ini_population represents the initial guesses of phase difference. p_num and max_episode are the number of populations and training episodes. c and cr are DE parameters representing the mutation and crossover constants. Example 9.2 In this example, the adaptive measurement shceme is design for the MZI [3,4] . The input state is \\begin{align} \\sqrt{\\frac{2}{N+2}}\\sum^{N/2}_{m=-N/2}\\sin\\left(\\frac{(2m+N+2)\\pi}{2(N+2)}\\right)|m\\rangle, \\end{align} where \\(N\\) is the number of photon, \\(|m\\rangle\\) is the eigenstate of \\(J_y\\) with the eigenvalue \\(m\\) . Python from quanestimation import * import numpy as np # the number of photons N = 8 # probe state psi = np . zeros (( N + 1 ) ** 2 ) . reshape ( - 1 , 1 ) for k in range ( N + 1 ): psi += np . sin (( k + 1 ) * np . pi / ( N + 2 )) * \\ np . kron ( basis ( N + 1 , k ), basis ( N + 1 , N - k )) psi = np . sqrt ( 2 / ( 2 + N )) * psi rho0 = np . dot ( psi , psi . conj () . T ) # prior distribution x = np . linspace ( - np . pi , np . pi , 100 ) p = ( 1.0 / ( x [ - 1 ] - x [ 0 ])) * np . ones ( len ( x )) apt = Adapt_MZI ( x , p , rho0 ) apt . general () online apt . online ( output = \"phi\" ) offline DE DE_para = { \"p_num\" : 10 , \"deltaphi0\" :[], \"max_episode\" : 1000 , \"c\" : 1.0 , \"cr\" : 0.5 , \"seed\" : 1234 } apt . offline ( method = \"DE\" , ** DE_para ) PSO PSO_para = { \"p_num\" : 10 , \"deltaphi0\" :[], \"max_episode\" :[ 1000 , 100 ], \"c0\" : 1.0 , \"c1\" : 2.0 , \"c2\" : 2.0 , \"seed\" : 1234 } apt . offline ( method = \"PSO\" , ** PSO_para ) Julia using QuanEstimation # the number of photons N = 8 # probe state psi = sum ([ sin ( k * pi / ( N + 2 )) * kron ( QuanEstimation . basis ( N + 1 , k ), QuanEstimation . basis ( N + 1 , N - k + 2 )) for k in 1 : ( N + 1 )]) |> sparse psi = psi * sqrt ( 2 / ( 2 + N )) rho0 = psi * psi ' # prior distribution x = range ( - pi , pi , length = 100 ) p = ( 1.0 / ( x [ end ] - x [ 1 ])) * ones ( length ( x )) apt = QuanEstimation . Adapt_MZI ( x , p , rho0 ) online QuanEstimation . online ( apt , output = \"phi\" ) offline DE alg = QuanEstimation . DE ( p_num = 10 , ini_population = missing , max_episode = 1000 , c = 1.0 , cr = 0.5 ) QuanEstimation . offline ( apt , alg , seed = 1234 ) PSO alg = QuanEstimation . PSO ( p_num = 10 , ini_particle = missing , max_episode = [ 1000 , 100 ], c0 = 1.0 , c1 = 2.0 , c2 = 2.0 ) QuanEstimation . offline ( apt , alg , seed = 1234 )","title":"Adaptive measurement schemes"},{"location":"guide/guide_adaptive/#bibliography","text":"[1] D. W. Berry and H. M. Wiseman, Optimal States and Almost Optimal Adaptive Measurements for Quantum Interferometry, Phys. Rev. Lett. 85 , 5098 (2000). [2] D. W. Berry, H. M. Wiseman, and J. K. Breslin, Optimal input states and feedback for interferometric phase estimation, Phys. Rev. A 63 , 053804 (2001). [3] A. Hentschel and B. C. Sanders, Machine Learning for Precise Quantum Measurement, Phys. Rev. Lett. 104 , 063603 (2010). [4] A. Hentschel and B. C. Sanders, Efficient Algorithm for Optimizing Adaptive Quantum Metrology Processes, Phys. Rev. Lett. 104 , 063603 (2011).","title":"Bibliography"},{"location":"guide/guide_bounds/","text":"Quantum metrological tools \u00b6 QuanEstimation can be used to calculate several well-used metrological tools including Quantum Cram\u00e9r-Rao bounds, Holevo Cram\u00e9r-Rao bound, Bayesian Cram\u00e9r-Rao bounds, Quantum Ziv-Zakai bound and perform Bayesian estimation. Quantum Cram\u00e9r-Rao bounds \u00b6 In quantum metrology, quantum Cram\u00e9r-Rao bounds are well used metrological tools for parameter estimation. It can be expressed as [1,2,3] \\begin{align} \\mathrm{cov}\\left(\\hat{\\textbf{x}}, {\\Pi_y}\\right) \\geq \\frac{1}{n}\\mathcal{I}^{-1} \\left({\\Pi_y}\\right) \\geq \\frac{1}{n} \\mathcal{F}^{-1}, \\end{align} where \\(\\mathrm{cov}(\\hat{\\textbf{x}},\\{\\Pi_y\\})=\\sum_y\\mathrm{Tr}(\\rho\\Pi_y)(\\hat{\\textbf{x}} -\\textbf{x})(\\hat{\\textbf{x}}-\\textbf{x})^{\\mathrm{T}}\\) is the covariance matrix for the unknown parameters \\(\\hat{\\textbf{x}}=(\\hat{x}_0,\\hat{x}_1,\\dots)^{\\mathrm{T}}\\) to be estimated. \\(\\{\\Pi_y\\}\\) is a set of positive operator-valued measure (POVM) and \\(\\rho\\) represents the parameterized density matrix. \\(n\\) is the repetition of the experiment, \\(\\mathcal{I}\\) and \\(\\mathcal{F}\\) are the classical Fisher information matrix (CFIM) and quantum Fisher information matrix (QFIM), respectively. The \\(ab\\) th entry of CFIM is defined as \\begin{align} \\mathcal{I}_{ab}=\\sum_y\\frac{1}{p(y|\\textbf{x})}[\\partial_a p(y|\\textbf{x})][\\partial_b p(y|\\textbf{x})] \\end{align} with \\(p(y|\\textbf{x})=\\mathrm{Tr}(\\rho\\Pi_y)\\) . The most well-used type of the QFIM is SLD-based QFIM of the form \\begin{align} \\mathcal{F}_{ab}=\\frac{1}{2}\\mathrm{Tr}[\\rho (L_aL_b+ L_bL_a)] \\end{align} with \\(\\mathcal{F}_{ab}\\) the \\(ab\\) th entry of \\(\\mathcal{F}\\) and \\(L_{a}(L_{b})\\) the symmetric logarithmic derivative (SLD) operator for \\(x_{a}(x_b)\\) . The SLD operator is determined by \\begin{align} \\partial_{a}\\rho=\\frac{1}{2}(\\rho L_{a}+L_{a}\\rho). \\end{align} The \\(ij\\) th entry of SLD can be calculated by \\begin{align} \\langle\\lambda_i|L_{a}|\\lambda_j\\rangle=\\frac{2\\langle\\lambda_i| \\partial_{a}\\rho |\\lambda_j\\rangle} {\\lambda_i+\\lambda_j}, ~~\\lambda_i (\\lambda_j)\\neq 0 . \\end{align} For \\(\\lambda_i (\\lambda_j)=0\\) , the above equation is set to be zero. Besides, there are right logarithmic derivative (RLD) and left logarithmic derivative (LLD) defined by \\(\\partial_{a}\\rho=\\rho \\mathcal{R}_a\\) and \\(\\partial_{a}\\rho=\\mathcal{R}_a^{\\dagger} \\rho\\) with the corresponding QFIM \\(\\mathcal{F}_{ab}=\\mathrm{Tr}(\\rho \\mathcal{R}_a \\mathcal{R}^{\\dagger}_b)\\) . The RLD and LLD operators are calculated via \\[\\begin{align} \\langle\\lambda_i| \\mathcal{R}_{a} |\\lambda_j\\rangle &= \\frac{1}{\\lambda_i}\\langle\\lambda_i| \\partial_{a}\\rho |\\lambda_j\\rangle,~~\\lambda_i\\neq 0; \\\\ \\langle\\lambda_i| \\mathcal{R}_{a}^{\\dagger} |\\lambda_j\\rangle &= \\frac{1}{\\lambda_j}\\langle\\lambda_i| \\partial_{a}\\rho |\\lambda_j\\rangle,~~\\lambda_j\\neq 0. \\end{align}\\] In QuanEstimation, three types of the logarithmic derivatives can be solved by calling the codes Python SLD ( rho , drho , rep = \"original\" , eps = 1e-8 ) RLD ( rho , drho , rep = \"original\" , eps = 1e-8 ) LLD ( rho , drho , rep = \"original\" , eps = 1e-8 ) Julia SLD ( rho , drho ; rep = \"original\" , eps = 1e-8 ) RLD ( rho , drho ; rep = \"original\" , eps = 1e-8 ) LLD ( rho , drho ; rep = \"original\" , eps = 1e-8 ) where rho and drho are the density matrix of the state and its derivatives with respect to the unknown parameters to be estimated. drho should be input as \\([\\partial_a{\\rho}, \\partial_b{\\rho}, \\cdots]\\) . For single parameter estimation (the length of drho is equal to one), the output is a matrix and for multiparameter estimation (the length of drho is more than one), it returns a list. There are two output choices for the logarithmic derivatives basis which can be setting through rep . The default basis ( rep=\"original\" ) of the logarithmic derivatives is the same with rho and the users can also request the logarithmic derivatives written in the eigenspace of rho by rep=\"eigen\" . eps represents the machine epsilon which defaults to \\(10^{-8}\\) . In QuanEstimation, the QFI and QFIM can be calculated via the following function Python QFIM ( rho , drho , LDtype = \"SLD\" , exportLD = False , eps = 1e-8 ) LDtype represents the types of QFI (QFIM) can be set. Options are LDtype=SLD (default), LDtype=RLD and LDtype=LLD . This function will return QFI (QFIM) if exportLD=False , however, if the users set exportLD=True , it will return logarithmic derivatives apart from QFI (QFIM). Julia QFIM ( rho , drho ; LDtype = :SLD , exportLD = false , eps = 1e-8 ) LDtype represents the types of QFI (QFIM) can be set. Options are LDtype=SLD (default), LDtype=RLD and LDtype=LLD . This function will return QFI (QFIM) if exportLD=false , however, if the users set exportLD=true , it will return logarithmic derivatives apart from QFI (QFIM). Example 3.1 The Hamiltonian of a single qubit system is \\(H=\\frac{1}{2}\\omega \\sigma_3\\) with \\(\\omega\\) the frequency and \\(\\sigma_3\\) a Pauli matrix. The dynamics of the system is governed by \\begin{align} \\partial_t\\rho=-i[H, \\rho]+ \\gamma_{+}\\left(\\sigma_{+}\\rho\\sigma_{-}-\\frac{1}{2}{\\sigma_{-} \\sigma_{+},\\rho}\\right)+ \\gamma_{-}\\left(\\sigma_{-}\\rho\\sigma_{+}-\\frac{1}{2}{\\sigma_{+} \\sigma_{-},\\rho}\\right), \\end{align} where \\(\\sigma_{\\pm}=\\frac{1}{2}(\\sigma_1 \\pm \\sigma_2)\\) with \\(\\sigma_{1}\\) , \\(\\sigma_{2}\\) Pauli matrices and \\(\\gamma_{+}\\) , \\(\\gamma_{-}\\) are decay rates. The probe state is taken as \\(|+\\rangle\\) with \\(|+\\rangle=\\frac{1}{\\sqrt{2}}(|0\\rangle+|1\\rangle)\\) . Here \\(|0\\rangle\\) and \\(|1\\rangle\\) are the eigenstates of \\(\\sigma_3\\) with respect to the eigenvalues \\(1\\) and \\(-1\\) . Python from quanestimation import * import numpy as np # initial state rho0 = 0.5 * np . array ([[ 1. , 1. ], [ 1. , 1. ]]) # free Hamiltonian omega = 1.0 sz = np . array ([[ 1. , 0. ], [ 0. , - 1. ]]) H0 = 0.5 * omega * sz # derivative of the free Hamiltonian on omega dH = [ 0.5 * sz ] # dissipation sp = np . array ([[ 0. , 1. ], [ 0. , 0. ]]) sm = np . array ([[ 0. , 0. ], [ 1. , 0. ]]) decay = [[ sp , 0.0 ], [ sm , 0.1 ]] # time length for the evolution tspan = np . linspace ( 0. , 50. , 2000 ) # dynamics dynamics = Lindblad ( tspan , rho0 , H0 , dH , decay ) rho , drho = dynamics . expm () # calculation of the QFI F = [] for ti in range ( 1 , 2000 ): # QFI F_tp = QFIM ( rho [ ti ], drho [ ti ]) F . append ( F_tp ) Julia using QuanEstimation # initial state rho0 = 0.5 * ones ( 2 , 2 ) # free Hamiltonian omega = 1.0 sx = [ 0. 1. ; 1. 0.0 im ] sy = [ 0. - im ; im 0. ] sz = [ 1. 0.0 im ; 0. - 1. ] H0 = 0.5 * omega * sz # derivative of the free Hamiltonian on omega dH = [ 0.5 * sz ] # dissipation sp = [ 0. 1. ; 0. 0.0 im ] sm = [ 0. 0. ; 1. 0.0 im ] decay = [[ sp , 0.0 ], [ sm , 0.1 ]] # time length for the evolution tspan = range ( 0. , 50. , length = 2000 ) # dynamics rho , drho = QuanEstimation . expm ( tspan , rho0 , H0 , dH , decay ) # calculation of the QFI F = Float64 [] for ti in 2 : length ( tspan ) # QFI F_tp = QuanEstimation . QFIM ( rho [ ti ], drho [ ti ]) append! ( F , F_tp ) end If the parameterization process is excuted via the Kraus operators, the QFI (QFIM) can be calculated by calling the function Python QFIM_Kraus ( rho0 , K , dK , LDtype = \"SLD\" , exportLD = False , eps = 1e-8 ) Julia QFIM_Kraus ( rho0 , K , dK ; LDtype = :SLD , exportLD = false , eps = 1e-8 ) where K and dK are the Kraus operators and the derivatives with respect to the unknown parameters to be estimated. Example 3.2 The Kraus operators for the amplitude damping channel are \\[\\begin{eqnarray} K_1 = \\left(\\begin{array}{cc} 1 & 0 \\\\ 0 & \\sqrt{1-\\gamma} \\end{array}\\right), K_2 = \\left(\\begin{array}{cc} 0 & \\sqrt{\\gamma} \\\\ 0 & 0 \\end{array}\\right), \\nonumber \\end{eqnarray}\\] where \\(\\gamma\\) is unknown parameter to be estimated which represents the decay probability. In this example, the probe state is taken as \\(|+\\rangle\\langle+|\\) with \\(|+\\rangle:=\\frac{1} {\\sqrt{2}}(|0\\rangle+|1\\rangle)\\) . \\(|0\\rangle\\) \\((|1\\rangle)\\) is the eigenstate of \\(\\sigma_3\\) (Pauli matrix) with respect to the eigenvalue \\(1\\) \\((-1)\\) . Python from quanestimation import * import numpy as np # initial state rho0 = 0.5 * np . array ([[ 1. , 1. ], [ 1. , 1. ]]) # Kraus operators for the amplitude damping channel gamma = 0.1 K1 = np . array ([[ 1. , 0. ], [ 0. , np . sqrt ( 1 - gamma )]]) K2 = np . array ([[ 0. , np . sqrt ( gamma )], [ 0. , 0. ]]) K = [ K1 , K2 ] # derivatives of Kraus operators on gamma dK1 = np . array ([[ 1. , 0. ], [ 0. , - 0.5 / np . sqrt ( 1 - gamma )]]) dK2 = np . array ([[ 0. , 0.5 / np . sqrt ( gamma )], [ 0. , 0. ]]) dK = [[ dK1 ], [ dK2 ]] F = QFIM_Kraus ( rho0 , K , dK ) Julia using QuanEstimation # initial state rho0 = [ 0.5 + 0 im 0.5 ; 0.5 0.5 ] # Kraus operators for the amplitude damping channel gamma = 0.1 K1 = [ 1. 0. ; 0. sqrt ( 1 - gamma )] K2 = [ 0. sqrt ( gamma ); 0. 0. ] K = [ K1 , K2 ] # derivatives of Kraus operators on gamma dK1 = [ 1. 0. ; 0. - 0.5 / sqrt ( 1 - gamma )] dK2 = [ 0. 0.5 / sqrt ( gamma ); 0. 0. ] dK = [[ dK1 ], [ dK2 ]] F = QuanEstimation . QFIM_Kraus ( rho0 , K , dK ) The FI (FIM) for a set of the probabilities p can be calculated by Python FIM ( p , dp , eps = 1e-8 ) Julia FIM ( p , dp ; eps = 1e-8 ) where dp is a list representing the derivatives of the probabilities p with respect to the unknown parameters. Example 3.3 Python from quanestimation import * p = [ 0.54 , 0.46 ] dp = [[ 0.54 ], [ - 0.54 ]] F = FIM ( p , dp ) Julia using QuanEstimation p = [ 0.54 , 0.46 ] dp = [[ 0.54 ], [ - 0.54 ]] F = QuanEstimation . FIM ( p , dp ) In quantum metrology, the CFI (CFIM) are solved by Python CFIM ( rho , drho , M = [], eps = 1e-8 ) Here M represents a set of positive operator-valued measure (POVM) with default value [] . In this function, a set of rank-one symmetric informationally complete POVM (SIC-POVM) is used when M=[] . SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from here . Julia CFIM ( rho , drho ; M = missing , eps = 1e-8 ) Here M represents a set of positive operator-valued measure (POVM) with default value missing . In this function, a set of rank-one symmetric informationally complete POVM (SIC-POVM) is used when M=missing . SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from here . Example 3.4 The Hamiltonian of a single qubit system is \\(H=\\frac{1}{2}\\omega \\sigma_3\\) with \\(\\omega\\) the frequency and \\(\\sigma_3\\) a Pauli matrix. The dynamics of the system is governed by \\begin{align} \\partial_t\\rho=-i[H, \\rho]+ \\gamma_{+}\\left(\\sigma_{+}\\rho\\sigma_{-}-\\frac{1}{2}{\\sigma_{-} \\sigma_{+}, \\rho}\\right)+ \\gamma_{-}\\left(\\sigma_{-}\\rho\\sigma_{+}-\\frac{1}{2}{\\sigma_{+} \\sigma_{-},\\rho}\\right), \\end{align} where \\(\\sigma_{\\pm}=\\frac{1}{2}(\\sigma_1 \\pm \\sigma_2)\\) with \\(\\sigma_{1}\\) , \\(\\sigma_{2}\\) Pauli matrices and \\(\\gamma_{+}\\) , \\(\\gamma_{-}\\) are decay rates. The probe state is taken as \\(|+\\rangle\\) and the measurement for CFI is \\(\\{|+\\rangle\\langle+|, |-\\rangle\\langle-|\\}\\) with \\(|\\pm\\rangle=\\frac{1}{\\sqrt{2}}(|0\\rangle\\pm|1\\rangle)\\) . Here \\(|0\\rangle\\) and \\(|1\\rangle\\) are the eigenstates of \\(\\sigma_3\\) with respect to the eigenvalues \\(1\\) and \\(-1\\) . Python from quanestimation import * import numpy as np # initial state rho0 = 0.5 * np . array ([[ 1. , 1. ], [ 1. , 1. ]]) # free Hamiltonian omega = 1.0 sz = np . array ([[ 1. , 0. ], [ 0. , - 1. ]]) H0 = 0.5 * omega * sz # derivative of the free Hamiltonian on omega dH = [ 0.5 * sz ] # dissipation sp = np . array ([[ 0. , 1. ], [ 0. , 0. ]]) sm = np . array ([[ 0. , 0. ], [ 1. , 0. ]]) decay = [[ sp , 0.0 ], [ sm , 0.1 ]] # measurement M1 = 0.5 * np . array ([[ 1. , 1. ], [ 1. , 1. ]]) M2 = 0.5 * np . array ([[ 1. , - 1. ], [ - 1. , 1. ]]) M = [ M1 , M2 ] # time length for the evolution tspan = np . linspace ( 0. , 50. , 2000 ) # dynamics dynamics = Lindblad ( tspan , rho0 , H0 , dH , decay ) rho , drho = dynamics . expm () # calculation of the CFI I = [] for ti in range ( 1 , 2000 ): # CFI I_tp = CFIM ( rho [ ti ], drho [ ti ], M = M ) I . append ( I_tp ) Julia using QuanEstimation # initial state rho0 = 0.5 * ones ( 2 , 2 ) # free Hamiltonian omega = 1.0 sx = [ 0. 1. ; 1. 0.0 im ] sy = [ 0. - im ; im 0. ] sz = [ 1. 0.0 im ; 0. - 1. ] H0 = 0.5 * omega * sz # derivative of the free Hamiltonian on omega dH = [ 0.5 * sz ] # dissipation sp = [ 0. 1. ; 0. 0.0 im ] sm = [ 0. 0. ; 1. 0.0 im ] decay = [[ sp , 0.0 ], [ sm , 0.1 ]] # measurement M1 = 0.5 * [ 1.0 + 0.0 im 1. ; 1. 1. ] M2 = 0.5 * [ 1.0 + 0.0 im - 1. ; - 1. 1. ] M = [ M1 , M2 ] # time length for the evolution tspan = range ( 0. , 50. , length = 2000 ) # dynamics rho , drho = QuanEstimation . expm ( tspan , rho0 , H0 , dH , decay ) # calculation of the CFI Im = Float64 [] for ti in 2 : length ( tspan ) # CFI I_tp = QuanEstimation . CFIM ( rho [ ti ], drho [ ti ], M ) append! ( Im , I_tp ) end In Bloch representation, the SLD based QFI (QFIM) is calculated by Python QFIM_Bloch ( r , dr , eps = 1e-8 ) Julia QFIM_Bloch ( r , dr ; eps = 1e-8 ) r and dr are the parameterized Bloch vector and its derivatives of with respect to the unknown parameters to be estimated. Example 3.5 The arbitrary single-qubit state can be written as \\begin{align} |\\psi\\rangle=\\cos\\frac{\\theta}{2}|0\\rangle+e^{i\\phi}\\sin\\frac{\\theta}{2}|1\\rangle \\end{align} with \\(\\theta\\) and \\(\\phi\\) the parameters to be estimated. The Bloch vector for this state is \\(r=(\\sin\\theta\\cos\\phi, \\sin\\theta\\sin\\phi, \\cos\\theta)^{\\mathrm{T}}\\) and the derivatives with respect to \\(\\theta\\) and \\(\\phi\\) are \\(\\partial_\\theta r=(\\cos\\theta\\cos\\phi, \\cos\\theta\\sin\\phi, -\\sin\\theta)^{\\mathrm{T}}\\) and \\(\\partial_\\phi r=(-\\sin\\theta\\sin\\phi, \\sin\\theta\\cos\\phi, 0)^{\\mathrm{T}}\\) Python from quanestimation import * import numpy as np theta , phi = 0.25 * np . pi , 0.25 * np . pi r = np . array ([ np . sin ( theta ) * np . cos ( phi ), \\ np . sin ( theta ) * np . sin ( phi ), \\ np . cos ( theta )]) dr_theta = np . array ([ np . cos ( theta ) * np . cos ( phi ), \\ np . cos ( theta ) * np . sin ( phi ), \\ - np . sin ( theta )]) dr_phi = np . array ([ - np . sin ( theta ) * np . sin ( phi ), \\ np . sin ( theta ) * np . cos ( phi ), \\ 0. ]) dr = [ dr_theta , dr_phi ] F = QFIM_Bloch ( r , dr ) Julia using QuanEstimation using LinearAlgebra theta , phi = 0.25 * pi , 0.25 * pi r = [ sin ( theta ) * cos ( phi ), sin ( theta ) * sin ( phi ), cos ( theta )] dr_theta = [ cos ( theta ) * cos ( phi ), cos ( theta ) * sin ( phi ), - sin ( theta )] dr_phi = [ - sin ( theta ) * sin ( phi ), sin ( theta ) * cos ( phi ), 0. ] dr = [ dr_theta , dr_phi ] F = QuanEstimation . QFIM_Bloch ( r , dr ) The package can also calculte the SLD based QFI (QFIM) with Gaussian states. Python QFIM_Gauss ( R , dR , D , dD ) Julia QFIM_Gauss ( R , dR , D , dD ) The variable R is the expected value \\(\\left(\\langle[\\textbf{R}]_i\\rangle\\right)\\) of \\(\\textbf{R}\\) with respect to \\(\\rho\\) , it is an array representing the first-order moment. Here \\(\\textbf{R}=(q_1,p_1,q_2,p_2,\\dots)^{\\mathrm{T}}\\) with \\(q_i=\\frac{1}{\\sqrt{2}} (a_i+a^{\\dagger}_i)\\) and \\(p_i=\\frac{1}{i\\sqrt{2}}(a_i-a^{\\dagger}_i)\\) represents a vector of quadrature operators. dR is a list of derivatives of R with respect to the unknown parameters. The \\(i\\) th entry of dR is \\(\\partial_{\\textbf{x}} \\langle[\\textbf{R}]_i\\rangle\\) . D and dD represent the second-order moment matrix with the \\(ij\\) th entry \\(D_{ij}=\\langle [\\textbf{R}]_i [\\textbf{R}]_j+[\\textbf{R}]_j [\\textbf{R}]_i\\rangle/2\\) and its derivatives with respect tp the unknown parameters. Example 3.6 The first and second moments [10] are \\[\\begin{eqnarray} \\langle[\\textbf{R}]_i\\rangle = \\left(\\begin{array}{cc} 0 \\\\ 0 \\end{array}\\right), D = \\lambda\\left(\\begin{array}{cc} \\cosh 2r & -\\sinh 2r \\\\ -\\sinh 2r & -\\sinh 2r \\end{array}\\right), \\nonumber \\end{eqnarray}\\] where \\(\\lambda=\\coth\\frac{\\beta}{2}\\) . \\(r\\) and \\(\\beta\\) are the parameters to be estimated. Python from quanestimation import * import numpy as np dim = 2 r , beta = 0.2 , 1.0 Lambda = np . cosh ( 0.5 * beta ) / np . sinh ( 0.5 * beta ) # the first-order moment R = np . zeros ( dim ) dR = [ np . zeros ( dim ), np . zeros ( dim )] # the second-order moment D = Lambda * np . array ([[ np . cosh ( 2 * r ), - np . sinh ( 2 * r )], \\ [ - np . sinh ( 2 * r ), np . cosh ( 2 * r )]]) dD_r = 2 * Lambda * np . array ([[ np . sinh ( 2 * r ), - np . cosh ( 2 * r )], \\ [ - np . cosh ( 2 * r ), np . sinh ( 2 * r )]]) dD_Lambda = 0.5 * ( Lambda ** 2 - 1 ) * np . array ([[ - np . cosh ( 2 * r ), np . sinh ( 2 * r )], \\ [ np . sinh ( 2 * r ), - np . cosh ( 2 * r )]]) dD = np . array ([ dD_r , dD_Lambda ]) F = QFIM_Gauss ( R , dR , D , dD ) Julia using QuanEstimation dim = 2 r , beta = 0.2 , 1.0 Lambda = coth ( 0.5 * beta ) # the first-order moment R = zeros ( dim ) dR = [ zeros ( dim ), zeros ( dim )] D = Lambda * [ cosh ( 2 * r ) - sinh ( 2 * r ); - sinh ( 2 * r ) cosh ( 2 * r )] dD_r = 2 * Lambda * [ sinh ( 2 * r ) - cosh ( 2 * r ); - cosh ( 2 * r ) sinh ( 2 * r )] dD_Lambda = 0.5 * ( Lambda ^ 2 - 1 ) * [ - cosh ( 2 * r ) sinh ( 2 * r ); sinh ( 2 * r ) - cosh ( 2 * r )] dD = [ dD_r , dD_Lambda ] F = QuanEstimation . QFIM_Gauss ( R , dR , D , dD ) Holevo Cram\u00e9r-Rao bound \u00b6 Holevo Cram\u00e9r-Rao bound (HCRB) is of the form [4,5] \\begin{align} \\mathrm{Tr}(W\\mathrm{cov}(\\hat{\\textbf{x}},{\\Pi_y}))\\geq \\min_{\\textbf{X},V} \\mathrm{Tr}(WV), \\end{align} where \\(W\\) is the weight matrix and \\(V\\geq Z(\\textbf{X})\\) with \\([Z(\\textbf{X})]_{ab}=\\mathrm{Tr} (\\rho X_a X_b)\\) . \\(\\textbf{X}=[X_0,X_1,\\cdots]\\) with \\(X_i:=\\sum_y (\\hat{x}_i(y)-x_i)\\Pi_y\\) . The HCRB can be calculated via semidefinite programming as \\[\\begin{align} & \\min_{\\textbf{X},V}~\\mathrm{Tr}(WV), \\nonumber \\\\ & \\mathrm{subject}~\\mathrm{to} \\begin{cases} \\left(\\begin{array}{cc} V & \\Lambda^{\\mathrm{T}}R^{\\dagger} \\\\ R\\Lambda & I\\\\ \\end{array}\\right)\\geq 0, \\\\ \\sum_i[\\Lambda]_{ai}\\mathrm{Tr}(\\lambda_i\\partial_b\\rho)=\\delta_{ab}. \\end{cases} \\end{align}\\] Here \\(X_i\\) is expanded in a specific basis \\(\\{\\lambda_i\\}\\) as \\(X_i=\\sum_j [\\Lambda]_{ij}\\lambda_j\\) , the Hermitian matrix \\(Z(\\textbf{X})\\) satisfies \\(Z(\\textbf{X})=\\Lambda^{\\mathrm{T}}R^{\\dagger} R\\Lambda\\) . In QuanEstimation, the HCRB can be solved by Python HCRB ( rho , drho , W , eps = 1e-8 ) Julia HCRB ( rho , drho , W ; eps = 1e-8 ) where rho and drho are the density matrix of the state and its derivatives with respect to the unknown parameters to be estimated, respectively. W represents the weight matrix defaults to identity matrix and eps is the machine epsilon with default value \\(10^{-8}\\) . Example 3.7 The Hamiltonian of a two-qubit system with \\(XX\\) coupling is \\begin{align} H=\\omega_1\\sigma_3^{(1)}+\\omega_2\\sigma_3^{(2)}+g\\sigma_1^{(1)}\\sigma_1^{(2)}, \\end{align} where \\(\\omega_1\\) , \\(\\omega_2\\) are the frequencies of the first and second qubit, \\(\\sigma_i^{(1)} =\\sigma_i\\otimes I\\) and \\(\\sigma_i^{(2)}=I\\otimes\\sigma_i\\) for \\(i=1,2,3\\) . \\(\\sigma_1\\) , \\(\\sigma_2\\) , \\(\\sigma_3\\) are Pauli matrices and \\(I\\) denotes the identity matrix. The dynamics is described by the master equation \\begin{align} \\partial_t\\rho=-i[H, \\rho]+\\sum_{i=1,2}\\gamma_i\\left(\\sigma_3^{(i)}\\rho\\sigma_3^{(i)}-\\rho\\right) \\end{align} with \\(\\gamma_i\\) the decay rate for the \\(i\\) th qubit. The probe state is taken as \\(\\frac{1}{\\sqrt{2}}(|00\\rangle+|11\\rangle)\\) and the weight matrix is set to be identity. The measurement for \\(\\mathrm{Tr}(W\\mathcal{I^{-1}})\\) is \\(\\{\\Pi_1\\) , \\(\\Pi_2\\) , \\(I-\\Pi_1-\\Pi_2\\}\\) with \\(\\Pi_1=0.85|00\\rangle\\langle 00|\\) and \\(\\Pi_2=0.1|\\!+ \\!+\\rangle\\langle+\\!+\\!|\\) . Here \\(|\\pm\\rangle:=\\frac{1}{\\sqrt{2}}(|0\\rangle\\pm|1\\rangle)\\) with \\(|0\\rangle\\) \\((|1\\rangle)\\) the eigenstate of \\(\\sigma_3\\) with respect to the eigenvalue \\(1\\) ( \\(-1\\) ). Python from quanestimation import * import numpy as np # initial state psi0 = np . array ([ 1. , 0. , 0. , 1. ]) / np . sqrt ( 2 ) rho0 = np . dot ( psi0 . reshape ( - 1 , 1 ), psi0 . reshape ( 1 , - 1 ) . conj ()) # free Hamiltonian omega1 , omega2 , g = 1.0 , 1.0 , 0.1 sx = np . array ([[ 0. , 1. ], [ 1. , 0. ]]) sy = np . array ([[ 0. , - 1. j ], [ 1. j , 0. ]]) sz = np . array ([[ 1. , 0. ], [ 0. , - 1. ]]) ide = np . array ([[ 1. , 0. ], [ 0. , 1. ]]) H0 = omega1 * np . kron ( sz , ide ) + omega2 * np . kron ( ide , sz ) + g * np . kron ( sx , sx ) # derivatives of the free Hamiltonian on omega2 and g dH = [ np . kron ( ide , sz ), np . kron ( sx , sx )] # dissipation decay = [[ np . kron ( sz , ide ), 0.05 ], [ np . kron ( ide , sz ), 0.05 ]] # measurement m1 = np . array ([ 1. , 0. , 0. , 0. ]) M1 = 0.85 * np . dot ( m1 . reshape ( - 1 , 1 ), m1 . reshape ( 1 , - 1 ) . conj ()) M2 = 0.1 * np . ones (( 4 , 4 )) M = [ M1 , M2 , np . identity ( 4 ) - M1 - M2 ] # time length for the evolution tspan = np . linspace ( 0. , 10. , 1000 ) # dynamics dynamics = Lindblad ( tspan , rho0 , H0 , dH , decay ) rho , drho = dynamics . expm () # weight matrix W = np . identity ( 2 ) # calculation of the CFIM, QFIM and HCRB F , I , f = [], [], [] for ti in range ( 1 , 1000 ): # CFIM I_tp = CFIM ( rho [ ti ], drho [ ti ], M = M ) I . append ( I_tp ) # QFIM F_tp = QFIM ( rho [ ti ], drho [ ti ]) F . append ( F_tp ) # HCRB f_tp = HCRB ( rho [ ti ], drho [ ti ], W , eps = 1e-6 ) f . append ( f_tp ) Julia using QuanEstimation using LinearAlgebra # initial state psi0 = [ 1. , 0. , 0. , 1. ] / sqrt ( 2 ) rho0 = psi0 * psi0 ' # free Hamiltonian omega1 , omega2 , g = 1.0 , 1.0 , 0.1 sx = [ 0. 1. ; 1. 0.0 im ] sy = [ 0. - im ; im 0. ] sz = [ 1. 0.0 im ; 0. - 1. ] H0 = omega1 * kron ( sz , I ( 2 )) + omega2 * kron ( I ( 2 ), sz ) + g * kron ( sx , sx ) # derivatives of the free Hamiltonian with respect to omega2 and g dH = [ kron ( I ( 2 ), sz ), kron ( sx , sx )] # dissipation decay = [[ kron ( sz , I ( 2 )), 0.05 ], [ kron ( I ( 2 ), sz ), 0.05 ]] # measurement m1 = [ 1. , 0. , 0. , 0. ] M1 = 0.85 * m1 * m1 ' M2 = 0.1 * ones ( 4 , 4 ) M = [ M1 , M2 , I ( 4 ) - M1 - M2 ] # time length for the evolution tspan = range ( 0. , 10. , length = 1000 ) # dynamics rho , drho = QuanEstimation . expm ( tspan , rho0 , H0 , dH , decay ) # weight matrix W = one ( zeros ( 2 , 2 )) # calculation of the CFIM, QFIM and HCRB Im , F , f = [], [], Float64 [] for ti in 2 : length ( tspan ) # CFIM I_tp = QuanEstimation . CFIM ( rho [ ti ], drho [ ti ], M ) append! ( Im , [ I_tp ]) # QFIM F_tp = QuanEstimation . QFIM ( rho [ ti ], drho [ ti ]) append! ( F , [ F_tp ]) # HCRB f_tp = QuanEstimation . HCRB ( rho [ ti ], drho [ ti ], W ) append! ( f , f_tp ) end Bayesian Cram\u00e9r-Rao bounds \u00b6 The Bayesion version of the classical Fisher information (matrix) and quantum Fisher information (matrix) can be calculated by \\(\\mathcal{I}_{\\mathrm{Bayes}}=\\int p(\\textbf{x})\\mathcal{I}\\mathrm{d}\\textbf{x}\\) and \\(\\mathcal{F}_{\\mathrm{Bayes}}=\\int p(\\textbf{x})\\mathcal{F}\\mathrm{d}\\textbf{x},\\) where \\(p(\\textbf{x})\\) is the prior distribution, \\(\\mathcal{I}\\) and \\(\\mathcal{F}\\) are CFI (CFIM) and QFI (QFIM) of all types, respectively. In QuanEstimation, BCFI (BCFIM) and BQFI (BQFIM) can be solved via Python BCFIM ( x , p , rho , drho , M = [], eps = 1e-8 ) BQFIM ( x , p , rho , drho , LDtype = \"SLD\" , eps = 1e-8 ) where x represents the regimes of the parameters for the integral, it should be input as a list of arrays. p is an array representing the prior distribution. The input varibles rho and drho are two multidimensional lists with the dimensions as x . For example, for three parameter ( \\(x_0, x_1, x_2\\) ) estimation, the \\(ijk\\) th entry of rho and drho are \\(\\rho\\) and \\([\\partial_0\\rho, \\partial_1\\rho, \\partial_2\\rho]\\) with respect to the values \\([x_0]_i\\) , \\([x_1]_j\\) and \\([x_2]_k\\) , respectively. LDtype represents the types of QFI (QFIM) can be set, options are LDtype=SLD (default), LDtype=RLD and LDtype=LLD . M represents a set of positive operator-valued measure (POVM) with default value [] . In QuanEstimation, a set of rank-one symmetric informationally complete POVM (SIC-POVM) is load when M=[] . SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from here . Julia BCFIM ( x , p , rho , drho ; M = missing , eps = 1e-8 ) BQFIM ( x , p , rho , drho ; LDtype = :SLD , eps = 1e-8 ) where x represents the regimes of the parameters for the integral, it should be input as a list of arrays. p is an array representing the prior distribution. The input varibles rho and drho are two multidimensional lists with the dimensions as x . For example, for three parameter ( \\(x_0, x_1, x_2\\) ) estimation, the \\(ijk\\) th entry of rho and drho are \\(\\rho\\) and \\([\\partial_0\\rho, \\partial_1\\rho, \\partial_2\\rho]\\) with respect to the values \\([x_0]_i\\) , \\([x_1]_j\\) and \\([x_2]_k\\) , respectively. LDtype represents the types of QFI (QFIM) can be set, options are LDtype=SLD (default), LDtype=RLD and LDtype=LLD . M represents a set of positive operator-valued measure (POVM) with default value missing . In QuanEstimation, a set of rank-one symmetric informationally complete POVM (SIC-POVM) is load when M=missing . SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from here . In the Bayesian scenarios, the covariance matrix with a prior distribution \\(p(\\textbf{x})\\) is defined as \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},{\\Pi_y})=\\int p(\\textbf{x})\\sum_y\\mathrm{Tr}(\\rho\\Pi_y) (\\hat{\\textbf{x}}-\\textbf{x})(\\hat{\\textbf{x}}-\\textbf{x})^{\\mathrm{T}}\\mathrm{d}\\textbf{x}, \\end{align} where \\(\\textbf{x}=(x_0,x_1,\\dots)^{\\mathrm{T}}\\) are the unknown parameters to be estimated and the integral \\(\\int\\mathrm{d}\\textbf{x}:=\\int\\mathrm{d}x_0\\int\\mathrm{d}x_1\\cdots\\) . \\(\\{\\Pi_y\\}\\) is a set of POVM and \\(\\rho\\) represents the parameterized density matrix. Two types of Bayesian Cram\u00e9r-Rao bound (BCRB) are calculated in this package, the first one is \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},{\\Pi_y})\\geq \\int p(\\textbf{x})\\left(B\\mathcal{I}^{-1}B +\\textbf{b}\\textbf{b}^{\\mathrm{T}}\\right)\\mathrm{d}\\textbf{x}, \\end{align} where \\(\\textbf{b}\\) and \\(\\textbf{b}'\\) are the vectors of biase and its derivatives with respect to \\(\\textbf{x}\\) . \\(B\\) is a diagonal matrix with the \\(i\\) th entry \\(B_{ii}=1+[\\textbf{b}']_{i}\\) and \\(\\mathcal{I}\\) is the CFIM. The second one is \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},{\\Pi_y})\\geq \\mathcal{B}\\,\\mathcal{I}_{\\mathrm{Bayes}}^{-1}\\, \\mathcal{B}+\\int p(\\textbf{x})\\textbf{b}\\textbf{b}^{\\mathrm{T}}\\mathrm{d}\\textbf{x}, \\end{align} where \\(\\mathcal{B}=\\int p(\\textbf{x})B\\mathrm{d}\\textbf{x}\\) is the average of \\(B\\) and \\(\\mathcal{I}_{\\mathrm{Bayes}}\\) is the average of the CFIM. The third one is \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},{\\Pi_y})\\geq \\int p(\\textbf{x}) \\mathcal{G}\\left(\\mathcal{I}_p+\\mathcal{I}\\right)^{-1}\\mathcal{G}^{\\mathrm{T}}\\mathrm{d}\\textbf{x} \\end{align} with \\([\\mathcal{I}_{p}]_{ab}:=[\\partial_a \\ln p(\\textbf{x})][\\partial_b \\ln p(\\textbf{x})]\\) and \\(\\mathcal{G}_{ab}:=[\\partial_b\\ln p(\\textbf{x})][\\textbf{b}]_a+B_{aa}\\delta_{ab}\\) . Three types of Bayesian Quantum Cram\u00e9r-Rao bound (BCRB) are calculated, the first one is \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},{\\Pi_y})\\geq\\int p(\\textbf{x})\\left(B\\mathcal{F}^{-1}B +\\textbf{b}\\textbf{b}^{\\mathrm{T}}\\right)\\mathrm{d}\\textbf{x} \\end{align} with \\(\\mathcal{F}\\) the QFIM for all types. The second one is \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},{\\Pi_y})\\geq \\mathcal{B}\\,\\mathcal{F}_{\\mathrm{Bayes}}^{-1}\\, \\mathcal{B}+\\int p(\\textbf{x})\\textbf{b}\\textbf{b}^{\\mathrm{T}}\\mathrm{d}\\textbf{x} \\end{align} with \\(\\mathcal{F}_{\\mathrm{Bayes}}\\) the average of the QFIM. The third one is \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},{\\Pi_y})\\geq \\int p(\\textbf{x}) \\mathcal{G}\\left(\\mathcal{I}_p+\\mathcal{F}\\right)^{-1}\\mathcal{G}^{\\mathrm{T}}\\mathrm{d}\\textbf{x}. \\end{align} In QuanEstimation, the BCRB and BQCRB are calculated via Python BCRB ( x , p , dp , rho , drho , M = [], b = [], db = [], btype = 1 , eps = 1e-8 ) BQCRB ( x , p , dp , rho , drho , b = [], db = [], btype = 1 , LDtype = \"SLD\" , eps = 1e-8 ) where b and db are the vectors of biases and its derivatives on the unknown parameters. For unbiased estimates, b=[] and db=[] . In QuanEstimation, the users can set the types of BCRB and BQCRB via the variable btype . Julia BCRB ( x , p , dp , rho , drho ; M = missing , b = missing , db = missing , btype = 1 , eps = 1e-8 ) BQCRB ( x , p , dp , rho , drho ; b = missing , db = missing , btype = 1 , LDtype = :SLD , eps = 1e-8 ) where b and db are the vectors of biases and its derivatives on the unknown parameters. For unbiased estimates, b=missing and db=missing . In QuanEstimation, the users can set the types of BCRB and BQCRB via the variable btype . For single parameter estimation, Ref [6] calculates the optimal biased bound based on the first type of the BQCRB, it can be realized numerically via Python OBB ( x , p , dp , rho , drho , d2rho , LDtype = \"SLD\" , eps = 1e-8 ) Julia OBB ( x , p , dp , rho , drho , d2rho ; LDtype = :SLD , eps = 1e-8 ) d2rho is a list representing the second order derivatives of rho on x . Van Trees in 1968 [7] provides a well used Bayesian version of Cram\u00e9r-Rao bound known as Van Trees bound (VTB). \\(\\mathrm{cov}(\\hat{\\textbf{x}},\\{\\Pi_y\\})\\geq \\left(\\mathcal{I}_{\\mathrm{prior}} +\\mathcal{I}_{\\mathrm{Bayes}}\\right)^{-1},\\) where \\(\\mathcal{I}_{\\mathrm{prior}}=\\int p(\\textbf{x})\\mathcal{I}_{p}\\mathrm{d}\\textbf{x}\\) is the CFIM for \\(p(\\textbf{x})\\) and \\(\\mathcal{I}_{\\mathrm{Bayes}}\\) is the average of the CFIM. The quantum version (QVTB) provided by Tsang, Wiseman and Caves [9] . \\(\\mathrm{cov}(\\hat{\\textbf{x}},\\{\\Pi_y\\})\\geq \\left(\\mathcal{I}_{\\mathrm{prior}} +\\mathcal{F}_{\\mathrm{Bayes}}\\right)^{-1}\\) with \\(\\mathcal{F}_{\\mathrm{Bayes}}\\) the average of the QFIM of all types. The functions to calculate the VTB and QVTB are Python VTB ( x , p , dp , rho , drho , M = [], eps = 1e-8 ) QVTB ( x , p , dp , rho , drho , LDtype = \"SLD\" , eps = 1e-8 ) Julia VTB ( x , p , dp , rho , drho ; M = missing , eps = 1e-8 ) QVTB ( x , p , dp , rho , drho ; LDtype = :SLD , eps = 1e-8 ) Here the variables in the codes are the same with BCRB and BQCRB . Quantum Ziv-Zakai bound \u00b6 The expression of Quantum Ziv-Zakai bound (QZZB) with a prior distribution \\(p(x)\\) in a finite regime \\([\\alpha,\\beta]\\) is \\[\\begin{eqnarray} \\mathrm{var}(\\hat{x},\\{\\Pi_y\\}) &\\geq & \\frac{1}{2}\\int_0^\\infty \\mathrm{d}\\tau\\tau \\mathcal{V}\\int_{-\\infty}^{\\infty} \\mathrm{d}x\\min\\!\\left\\{p(x), p(x+\\tau)\\right\\} \\nonumber \\\\ & & \\times\\left(1-\\frac{1}{2}||\\rho(x)-\\rho(x+\\tau)||\\right), \\end{eqnarray}\\] where \\(||\\cdot||\\) represents the trace norm and \\(\\mathcal{V}\\) is the \"valley-filling\" operator satisfying \\(\\mathcal{V}f(\\tau)=\\max_{h\\geq 0}f(\\tau+h)\\) . \\(\\rho(x)\\) is the parameterized density matrix. In QuanEstimation, the QZZB can be calculated via the function: Python QZZB ( x , p , rho , eps = 1e-8 ) Julia QZZB ( x , p , rho ; eps = 1e-8 ) where x is a list of array representing the regime of the parameter for the integral, p is an array representing the prior distribution and rho is a multidimensional list representing the density matrix. eps is the machine epsilon with default value \\(10^{-8}\\) . Example 3.8 The Hamiltonian of a qubit system under a magnetic field \\(B\\) in the XZ plane is \\begin{align} H=\\frac{B\\omega_0}{2}(\\sigma_1\\cos{x}+\\sigma_3\\sin{x}) \\end{align} with \\(x\\) the unknown parameter and \\(\\sigma_{1}\\) , \\(\\sigma_{3}\\) Pauli matrices. The probe state is taken as \\(\\frac{1}{\\sqrt{2}}(|0\\rangle+|1\\rangle)\\) with \\(|0\\rangle\\) ( \\(|1\\rangle\\) ) the eigenvstates of \\(\\sigma_3\\) with respect to the eigenvalues \\(1\\) ( \\(-1\\) ). The measurement for classical bounds is a set of rank-one symmetric informationally complete positive operator-valued measure (SIC-POVM). Take the Gaussian prior distribution \\(p(x)=\\frac{1}{c\\eta\\sqrt{2\\pi}}\\exp\\left({-\\frac{(x-\\mu)^2} {2\\eta^2}}\\right)\\) on \\([-\\pi/2, \\pi/2]\\) with \\(\\mu\\) and \\(\\eta\\) the expectation and standard deviation, respectively. Here \\(c=\\frac{1}{2}\\big[\\mathrm{erf}(\\frac{\\pi-2\\mu}{2\\sqrt{2}\\eta}) +\\mathrm{erf}(\\frac{\\pi+2\\mu}{2\\sqrt{2}\\eta})\\big]\\) is the normalized coefficient with \\(\\mathrm{erf}(x):=\\frac{2}{\\sqrt{\\pi}}\\int^x_0 e^{-t^2}\\mathrm{d}t\\) the error function. Python from quanestimation import * import numpy as np from scipy.integrate import simps # initial state rho0 = 0.5 * np . array ([[ 1. , 1. ], [ 1. , 1. ]]) # free Hamiltonian B , omega0 = 0.5 * np . pi , 1.0 sx = np . array ([[ 0. , 1. ], [ 1. , 0. ]]) sy = np . array ([[ 0. , - 1. j ], [ 1. j , 0. ]]) sz = np . array ([[ 1. , 0. ], [ 0. , - 1. ]]) H0_func = lambda x : 0.5 * B * omega0 * ( sx * np . cos ( x ) + sz * np . sin ( x )) # derivative of the free Hamiltonian on x dH_func = lambda x : [ 0.5 * B * omega0 * ( - sx * np . sin ( x ) + sz * np . cos ( x ))] # prior distribution x = np . linspace ( - 0.5 * np . pi , 0.5 * np . pi , 100 ) mu , eta = 0.0 , 0.2 p_func = lambda x , mu , eta : np . exp ( - ( x - mu ) ** 2 / ( 2 * eta ** 2 )) \\ / ( eta * np . sqrt ( 2 * np . pi )) dp_func = lambda x , mu , eta : - ( x - mu ) * np . exp ( - ( x - mu ) ** 2 / ( 2 * eta ** 2 )) \\ / ( eta ** 3 * np . sqrt ( 2 * np . pi )) p_tp = [ p_func ( x [ i ], mu , eta ) for i in range ( len ( x ))] dp_tp = [ dp_func ( x [ i ], mu , eta ) for i in range ( len ( x ))] # normalization of the distribution c = simps ( p_tp , x ) p , dp = p_tp / c , dp_tp / c # time length for the evolution tspan = np . linspace ( 0. , 1. , 1000 ) # dynamics rho = [ np . zeros (( len ( rho0 ), len ( rho0 )), dtype = np . complex128 ) \\ for i in range ( len ( x ))] drho = [[ np . zeros (( len ( rho0 ), len ( rho0 )), dtype = np . complex128 )] \\ for i in range ( len ( x ))] for i in range ( len ( x )): H0_tp = H0_func ( x [ i ]) dH_tp = dH_func ( x [ i ]) dynamics = Lindblad ( tspan , rho0 , H0_tp , dH_tp ) rho_tp , drho_tp = dynamics . expm () rho [ i ] = rho_tp [ - 1 ] drho [ i ] = drho_tp [ - 1 ] # Classical Bayesian bounds f_BCRB1 = BCRB ([ x ], p , [], rho , drho , M = [], btype = 1 ) f_BCRB2 = BCRB ([ x ], p , [], rho , drho , M = [], btype = 2 ) f_BCRB3 = BCRB ([ x ], p , dp , rho , drho , M = [], btype = 3 ) f_VTB = VTB ([ x ], p , dp , rho , drho , M = []) # Quantum Bayesian bounds f_BQCRB1 = BQCRB ([ x ], p , [], rho , drho , btype = 1 ) f_BQCRB2 = BQCRB ([ x ], p , [], rho , drho , btype = 2 ) f_BQCRB3 = BQCRB ([ x ], p , dp , rho , drho , btype = 3 ) f_QVTB = QVTB ([ x ], p , dp , rho , drho ) f_QZZB = QZZB ([ x ], p , rho ) Julia using QuanEstimation using Trapz # free Hamiltonian function H0_func ( x ) return 0.5 * B * omega0 * ( sx * cos ( x ) + sz * sin ( x )) end # derivative of the free Hamiltonian on x function dH_func ( x ) return [ 0.5 * B * omega0 * ( - sx * sin ( x ) + sz * cos ( x ))] end # prior distribution function p_func ( x , mu , eta ) return exp ( - ( x - mu ) ^ 2 / ( 2 * eta ^ 2 )) / ( eta * sqrt ( 2 * pi )) end function dp_func ( x , mu , eta ) return - ( x - mu ) * exp ( - ( x - mu ) ^ 2 / ( 2 * eta ^ 2 )) / ( eta ^ 3 * sqrt ( 2 * pi )) end B , omega0 = 0.5 * pi , 1.0 sx = [ 0. 1. ; 1. 0.0 im ] sy = [ 0. - im ; im 0. ] sz = [ 1. 0.0 im ; 0. - 1. ] # initial state rho0 = 0.5 * ones ( 2 , 2 ) # prior distribution x = range ( - 0.5 * pi , stop = 0.5 * pi , length = 100 ) |> Vector mu , eta = 0.0 , 0.2 p_tp = [ p_func ( x [ i ], mu , eta ) for i in 1 : length ( x )] dp_tp = [ dp_func ( x [ i ], mu , eta ) for i in 1 : length ( x )] # normalization of the distribution c = trapz ( x , p_tp ) p = p_tp / c dp = dp_tp / c # time length for the evolution tspan = range ( 0. , stop = 1. , length = 1000 ) # dynamics rho = Vector { Matrix { ComplexF64 }}( undef , length ( x )) drho = Vector { Vector { Matrix { ComplexF64 }}}( undef , length ( x )) for i = 1 : length ( x ) H0_tp = H0_func ( x [ i ]) dH_tp = dH_func ( x [ i ]) rho_tp , drho_tp = QuanEstimation . expm ( tspan , rho0 , H0_tp , dH_tp ) rho [ i ], drho [ i ] = rho_tp [ end ], drho_tp [ end ] end # Classical Bayesian bounds f_BCRB1 = QuanEstimation . BCRB ([ x ], p , dp , rho , drho ; btype = 1 ) f_BCRB2 = QuanEstimation . BCRB ([ x ], p , dp , rho , drho ; btype = 2 ) f_BCRB3 = QuanEstimation . BCRB ([ x ], p , dp , rho , drho ; btype = 3 ) f_VTB = QuanEstimation . VTB ([ x ], p , dp , rho , drho ) # Quantum Bayesian bounds f_BQCRB1 = QuanEstimation . BQCRB ([ x ], p , dp , rho , drho , btype = 1 ) f_BQCRB2 = QuanEstimation . BQCRB ([ x ], p , dp , rho , drho , btype = 2 ) f_BQCRB3 = QuanEstimation . BQCRB ([ x ], p , dp , rho , drho , btype = 3 ) f_QVTB = QuanEstimation . QVTB ([ x ], p , dp , rho , drho ) f_QZZB = QuanEstimation . QZZB ([ x ], p , rho ) Bayesian estimation \u00b6 In QuanEstimation, two types of Bayesian estimation are considered including maximum a posteriori estimation (MAP) and maximum likelihood estimation (MLE). In Bayesian estimation, the prior distribution is updated as \\begin{align} p(\\textbf{x}|y)=\\frac{p(y|\\textbf{x})p(\\textbf{x})}{\\int p(y|\\textbf{x})p(\\textbf{x}) \\mathrm{d}\\textbf{x}} \\end{align} with \\(p(\\textbf{x})\\) the current prior distribution and \\(y\\) the outcome of the experiment. In practice, the prior distribution is replaced with \\(p(\\textbf{x}|y)\\) and the estimated value of \\(\\textbf{x}\\) can be evaluated by Python Bayes ( x , p , rho , y , M = [], estimator = \"mean\" , savefile = False ) MLE ( x , rho , y , M = [], savefile = False ) where x is a list of arrays representing the regimes of the parameters for the integral and p is an array representing the prior distribution. For multiparameter estimation, p is multidimensional. The input varible rho is a multidimensional list with the dimensions as x representing the parameterized density matrix. M contains a set of positive operator-valued measure (POVM). In QuanEstimation, a set of rank-one symmetric informationally complete POVM (SIC-POVM) is used when M=[] . SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from here . eatimator in Bayes() representing the estimators which is defaulted by the mean value of the paramters. Also, it can be set as MAP . The posterior distributions (likelihood function) in the final iteration and the estimated values in all iterations will be saved in \"pout.npy\" (\"Lout.npy\") and \"xout.npy\" if savefile=False . However, if the users want to save all the posterior distributions (likelihood function) and the estimated values in all iterations, the variable savefile needs to be set to True . Julia Bayes ( x , p , rho , y ; M = missing , estimator = \"mean\" , savefile = false ) MLE ( x , rho , y ; M = missing , savefile = false ) where x is a list of arrays representing the regimes of the parameters for the integral and p is an array representing the prior distribution. For multiparameter estimation, p is multidimensional. The input varible rho is a multidimensional list with the dimensions as x representing the parameterized density matrix. M contains a set of positive operator-valued measure (POVM). In QuanEstimation, a set of rank-one symmetric informationally complete POVM (SIC-POVM) is used when M=missing . SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from here . eatimator in Bayes() representing the estimators which is defaulted by the mean value of the paramters. Also, it can be set as MAP . The posterior distributions (likelihood function) in the final iteration and the estimated values in all iterations will be saved in \"pout.csv\" (\"Lout.csv\") and \"xout.csv\" if savefile=false . However, if the users want to save all the posterior distributions (likelihood function) and the estimated values in all iterations, the variable savefile needs to be set to true . Example 3.9 The Hamiltonian of a qubit system is \\begin{align} H=\\frac{B\\omega_0}{2}(\\sigma_1\\cos{x}+\\sigma_3\\sin{x}), \\end{align} where \\(B\\) is the magnetic field in the XZ plane, \\(x\\) is the unknown parameter and \\(\\sigma_{1}\\) , \\(\\sigma_{3}\\) are the Pauli matrices. The probe state is taken as \\(|\\pm\\rangle\\) . The measurement is \\(\\{|\\!+\\rangle\\langle+\\!|,|\\!-\\rangle\\langle-\\!|\\}\\) . Here \\(|\\pm\\rangle:=\\frac{1}{\\sqrt{2}} (|0\\rangle\\pm|1\\rangle)\\) with \\(|0\\rangle\\) \\((|1\\rangle)\\) the eigenstate of \\(\\sigma_3\\) with respect to the eigenvalue \\(1\\) \\((-1)\\) . In this example, the prior distribution \\(p(x)\\) is uniform on \\([0, \\pi/2]\\) . Python from quanestimation import * import numpy as np import random # initial state rho0 = 0.5 * np . array ([[ 1. , 1. ], [ 1. , 1. ]]) # free Hamiltonian B , omega0 = np . pi / 2.0 , 1.0 sx = np . array ([[ 0. , 1. ], [ 1. , 0. ]]) sy = np . array ([[ 0. , - 1. j ], [ 1. j , 0. ]]) sz = np . array ([[ 1. , 0. ], [ 0. , - 1. ]]) H0_func = lambda x : 0.5 * B * omega0 * ( sx * np . cos ( x ) + sz * np . sin ( x )) # derivative of the free Hamiltonian on x dH_func = lambda x : [ 0.5 * B * omega0 * ( - sx * np . sin ( x ) + sz * np . cos ( x ))] # measurement M1 = 0.5 * np . array ([[ 1. , 1. ], [ 1. , 1. ]]) M2 = 0.5 * np . array ([[ 1. , - 1. ], [ - 1. , 1. ]]) M = [ M1 , M2 ] # prior distribution x = np . linspace ( 0. , 0.5 * np . pi , 1000 ) p = ( 1.0 / ( x [ - 1 ] - x [ 0 ])) * np . ones ( len ( x )) # time length for the evolution tspan = np . linspace ( 0. , 1. , 1000 ) # dynamics rho = [ np . zeros (( len ( rho0 ), len ( rho0 )), dtype = np . complex128 ) \\ for i in range ( len ( x ))] for i in range ( len ( x )): H0 = H0_func ( x [ i ]) dH = dH_func ( x [ i ]) dynamics = Lindblad ( tspan , rho0 , H0 , dH ) rho_tp , drho_tp = dynamics . expm () rho [ i ] = rho_tp [ - 1 ] # Generation of the experimental results y = [ 0 for i in range ( 500 )] res_rand = random . sample ( range ( 0 , len ( y )), 125 ) for i in range ( len ( res_rand )): y [ res_rand [ i ]] = 1 # Maximum a posteriori estimation pout , xout = Bayes ([ x ], p , rho , y , M = M , estimator = \"MAP\" , \\ savefile = False ) # Maximum likelihood estimation Lout , xout = MLE ([ x ], rho , y , M = M , savefile = False ) Julia using QuanEstimation using Random using StatsBase # free Hamiltonian function H0_func ( x ) return 0.5 * B * omega0 * ( sx * cos ( x ) + sz * sin ( x )) end # derivative of the free Hamiltonian on x function dH_func ( x ) return [ 0.5 * B * omega0 * ( - sx * sin ( x ) + sz * cos ( x ))] end B , omega0 = pi / 2.0 , 1.0 sx = [ 0. 1. ; 1. 0.0 im ] sy = [ 0. - im ; im 0. ] sz = [ 1. 0.0 im ; 0. - 1. ] # initial state rho0 = 0.5 * ones ( 2 , 2 ) # measurement M1 = 0.5 * [ 1.0 + 0.0 im 1. ; 1. 1. ] M2 = 0.5 * [ 1.0 + 0.0 im - 1. ; - 1. 1. ] M = [ M1 , M2 ] # prior distribution x = range ( 0. , stop = 0.5 * pi , length = 100 ) |> Vector p = ( 1.0 / ( x [ end ] - x [ 1 ])) * ones ( length ( x )) # time length for the evolution tspan = range ( 0. , stop = 1. , length = 1000 ) # dynamics rho = Vector { Matrix { ComplexF64 }}( undef , length ( x )) for i = 1 : length ( x ) H0_tp = H0_func ( x [ i ]) dH_tp = dH_func ( x [ i ]) rho_tp , drho_tp = QuanEstimation . expm ( tspan , rho0 , H0_tp , dH_tp ) rho [ i ] = rho_tp [ end ] end # Generation of the experimental results Random . seed! ( 1234 ) y = [ 0 for i in 1 : 500 ] res_rand = sample ( 1 : length ( y ), 125 , replace = false ) for i in 1 : length ( res_rand ) y [ res_rand [ i ]] = 1 end # Maximum a posteriori estimation pout , xout = QuanEstimation . Bayes ([ x ], p , rho , y ; M = M , estimator = \"MAP\" , savefile = false ) # Maximum likelihood estimation Lout , xout = QuanEstimation . MLE ([ x ], rho , y , M = M ; savefile = false ) The average Bayesian cost [11] for a quadratic cost function can be calculated via \\begin{equation} \\bar{C}:=\\int p(\\textbf{x})\\sum_y p(y|\\textbf{x})(\\textbf{x}-\\hat{\\textbf{x}})^{\\mathrm{T}} W(\\textbf{x}-\\hat{\\textbf{x}})\\,\\mathrm{d}\\textbf{x} \\end{equation} In QuanEstimation, this can be realized by calling Python BayesCost ( x , p , xest , rho , y , M , W = [], eps = 1e-8 ) Julia BayesCost ( x , p , xest , rho , y , M ; W = missing , eps = 1e-8 ) xest represents the estimators for the parameters. Besides, the average Bayesian cost bounded by [5] \\begin{equation} \\bar{C}\\geq\\int p(\\textbf{x})\\left(\\textbf{x}^{\\mathrm{T}}W\\textbf{x}\\right)\\mathrm{d}\\textbf{x} -\\sum_{ab}W_{ab}\\mathrm{Tr}\\left(\\bar{\\rho}\\bar{L}_a \\bar{L}_b\\right), \\label{eq:BCB} \\end{equation} and for single-parameter scenario, this inequality reduces to \\begin{equation} \\bar{C}\\geq \\int p(x) x^2\\,\\mathrm{d}x-\\mathrm{Tr}(\\bar{\\rho}\\bar{L}^2). \\end{equation} The function for calculating the Bayesian cost bound (BCB) is Python BCB ( x , p , rho , W = [], eps = 1e-8 ) Julia BCB ( x , p , rho ; W = missing , eps = 1e-8 ) Example 3.10 The Hamiltonian of a qubit system is \\begin{align} H=\\frac{B\\omega_0}{2}(\\sigma_1\\cos{x}+\\sigma_3\\sin{x}), \\end{align} where \\(B\\) is the magnetic field in the XZ plane, \\(x\\) is the unknown parameter and \\(\\sigma_{1}\\) , \\(\\sigma_{3}\\) are the Pauli matrices. The probe state is taken as \\(|\\pm\\rangle\\) . The measurement is \\(\\{|\\!+\\rangle\\langle+\\!|,|\\!-\\rangle\\langle-\\!|\\}\\) . Here \\(|\\pm\\rangle:=\\frac{1}{\\sqrt{2}} (|0\\rangle\\pm|1\\rangle)\\) with \\(|0\\rangle\\) \\((|1\\rangle)\\) the eigenstate of \\(\\sigma_3\\) with respect to the eigenvalue \\(1\\) \\((-1)\\) . In this example, the prior distribution \\(p(x)\\) is uniform on \\([0, \\pi/2]\\) . Python from quanestimation import * import numpy as np import random # initial state rho0 = 0.5 * np . array ([[ 1. , 1. ], [ 1. , 1. ]]) # free Hamiltonian B , omega0 = np . pi / 2.0 , 1.0 sx = np . array ([[ 0. , 1. ], [ 1. , 0. ]]) sy = np . array ([[ 0. , - 1. j ], [ 1. j , 0. ]]) sz = np . array ([[ 1. , 0. ], [ 0. , - 1. ]]) H0_func = lambda x : 0.5 * B * omega0 * ( sx * np . cos ( x ) + sz * np . sin ( x )) # derivative of the free Hamiltonian on x dH_func = lambda x : [ 0.5 * B * omega0 * ( - sx * np . sin ( x ) + sz * np . cos ( x ))] # measurement M1 = 0.5 * np . array ([[ 1. , 1. ], [ 1. , 1. ]]) M2 = 0.5 * np . array ([[ 1. , - 1. ], [ - 1. , 1. ]]) M = [ M1 , M2 ] # prior distribution x = np . linspace ( 0. , 0.5 * np . pi , 1000 ) p = ( 1.0 / ( x [ - 1 ] - x [ 0 ])) * np . ones ( len ( x )) # time length for the evolution tspan = np . linspace ( 0. , 1. , 1000 ) # dynamics rho = [ np . zeros (( len ( rho0 ), len ( rho0 )), dtype = np . complex128 ) \\ for i in range ( len ( x ))] for i in range ( len ( x )): H0 = H0_func ( x [ i ]) dH = dH_func ( x [ i ]) dynamics = Lindblad ( tspan , rho0 , H0 , dH ) rho_tp , drho_tp = dynamics . expm () rho [ i ] = rho_tp [ - 1 ] # average Bayesian cost M = SIC ( 2 ) xest = [ np . array ([ 0.8 ]), np . array ([ 0.9 ]), np . array ([ 1.0 ]), np . array ([ 1.2 ])] C = BayesCost ([ x ], p , xest , rho , M , eps = 1e-8 ) # Bayesian cost Bound C = BCB ([ x ], p , rho , eps = 1e-8 ) Julia using QuanEstimation using Random using StatsBase # free Hamiltonian function H0_func ( x ) return 0.5 * B * omega0 * ( sx * cos ( x ) + sz * sin ( x )) end # derivative of the free Hamiltonian on x function dH_func ( x ) return [ 0.5 * B * omega0 * ( - sx * sin ( x ) + sz * cos ( x ))] end B , omega0 = pi / 2.0 , 1.0 sx = [ 0. 1. ; 1. 0.0 im ] sy = [ 0. - im ; im 0. ] sz = [ 1. 0.0 im ; 0. - 1. ] # initial state rho0 = 0.5 * ones ( 2 , 2 ) # measurement M1 = 0.5 * [ 1.0 + 0.0 im 1. ; 1. 1. ] M2 = 0.5 * [ 1.0 + 0.0 im - 1. ; - 1. 1. ] M = [ M1 , M2 ] # prior distribution x = range ( 0. , stop = 0.5 * pi , length = 100 ) |> Vector p = ( 1.0 / ( x [ end ] - x [ 1 ])) * ones ( length ( x )) # time length for the evolution tspan = range ( 0. , stop = 1. , length = 1000 ) # dynamics rho = Vector { Matrix { ComplexF64 }}( undef , length ( x )) for i = 1 : length ( x ) H0_tp = H0_func ( x [ i ]) dH_tp = dH_func ( x [ i ]) rho_tp , drho_tp = QuanEstimation . expm ( tspan , rho0 , H0_tp , dH_tp ) rho [ i ] = rho_tp [ end ] end # average Bayesian cost M = QuanEstimation . SIC ( 2 ) xest = [[ 0.8 ], [ 0.9 ], [ 1.0 ], [ 1.2 ]] C = QuanEstimation . BayesCost ([ x ], p , xest , rho , M , eps = 1e-8 ) # Bayesian cost Bound C = QuanEstimation . BCB ([ x ], p , rho , eps = 1e-8 ) Bibliography \u00b6 [1] C. W. Helstrom, Quantum Detection and Estimation Theory (New York: Academic, 1976). [2] A. S. Holevo, Probabilistic and Statistical Aspects of Quantum Theory (Amsterdam: North-Holland, 1982). [3] J. Liu, H. Yuan, X.-M. Lu, and X. Wang, Quantum Fisher information matrix and multiparameter estimation, J. Phys. A: Math. Theor. 53 , 023001 (2020). [4] A. S Holevo, Statistical decision theory for quantum systems, J. Multivariate Anal. 3 , 337-394 (1973). [5] R. Demkowicz-Dobrza\u0144ski, W. G\u00f3recki, and M. Gu\u0163\u0103, Multi-parameter estimation beyond Quantum Fisher Information, J. Phys. A: Math. Theor. 53 , 363001 (2020). [6] J. Liu and H. Yuan, Valid lower bound for all estimators in quantum parameter estimation, New J. Phys. 18 , 093009 (2016). [7] H. L. Van Trees, Detection, estimation, and modulation theory: Part I (Wiley, New York, 1968). [8] W. Zhong, Z. Sun, J. Ma, X. Wang, and F. Nori, Fisher information under decoherence in Bloch representation, Phys. Rev. A 87 , 022337 (2013). [9] M. Tsang, H. M. Wiseman, and C. M. Caves, Fundamental quantum limit to waveform estimation, Phys. Rev. Lett. 106 , 090401 (2011). [10] D. \u0160afr\u00e1nek, Estimation of Gaussian quantum states, J. Phys. A: Math. Theor. 52 , 035304 (2019). [11] C. P. Robert, The Bayesian Choice (Berlin: Springer, 2007).","title":"Quantum metrological tools"},{"location":"guide/guide_bounds/#quantum-metrological-tools","text":"QuanEstimation can be used to calculate several well-used metrological tools including Quantum Cram\u00e9r-Rao bounds, Holevo Cram\u00e9r-Rao bound, Bayesian Cram\u00e9r-Rao bounds, Quantum Ziv-Zakai bound and perform Bayesian estimation.","title":"Quantum metrological tools"},{"location":"guide/guide_bounds/#quantum-cramer-rao-bounds","text":"In quantum metrology, quantum Cram\u00e9r-Rao bounds are well used metrological tools for parameter estimation. It can be expressed as [1,2,3] \\begin{align} \\mathrm{cov}\\left(\\hat{\\textbf{x}}, {\\Pi_y}\\right) \\geq \\frac{1}{n}\\mathcal{I}^{-1} \\left({\\Pi_y}\\right) \\geq \\frac{1}{n} \\mathcal{F}^{-1}, \\end{align} where \\(\\mathrm{cov}(\\hat{\\textbf{x}},\\{\\Pi_y\\})=\\sum_y\\mathrm{Tr}(\\rho\\Pi_y)(\\hat{\\textbf{x}} -\\textbf{x})(\\hat{\\textbf{x}}-\\textbf{x})^{\\mathrm{T}}\\) is the covariance matrix for the unknown parameters \\(\\hat{\\textbf{x}}=(\\hat{x}_0,\\hat{x}_1,\\dots)^{\\mathrm{T}}\\) to be estimated. \\(\\{\\Pi_y\\}\\) is a set of positive operator-valued measure (POVM) and \\(\\rho\\) represents the parameterized density matrix. \\(n\\) is the repetition of the experiment, \\(\\mathcal{I}\\) and \\(\\mathcal{F}\\) are the classical Fisher information matrix (CFIM) and quantum Fisher information matrix (QFIM), respectively. The \\(ab\\) th entry of CFIM is defined as \\begin{align} \\mathcal{I}_{ab}=\\sum_y\\frac{1}{p(y|\\textbf{x})}[\\partial_a p(y|\\textbf{x})][\\partial_b p(y|\\textbf{x})] \\end{align} with \\(p(y|\\textbf{x})=\\mathrm{Tr}(\\rho\\Pi_y)\\) . The most well-used type of the QFIM is SLD-based QFIM of the form \\begin{align} \\mathcal{F}_{ab}=\\frac{1}{2}\\mathrm{Tr}[\\rho (L_aL_b+ L_bL_a)] \\end{align} with \\(\\mathcal{F}_{ab}\\) the \\(ab\\) th entry of \\(\\mathcal{F}\\) and \\(L_{a}(L_{b})\\) the symmetric logarithmic derivative (SLD) operator for \\(x_{a}(x_b)\\) . The SLD operator is determined by \\begin{align} \\partial_{a}\\rho=\\frac{1}{2}(\\rho L_{a}+L_{a}\\rho). \\end{align} The \\(ij\\) th entry of SLD can be calculated by \\begin{align} \\langle\\lambda_i|L_{a}|\\lambda_j\\rangle=\\frac{2\\langle\\lambda_i| \\partial_{a}\\rho |\\lambda_j\\rangle} {\\lambda_i+\\lambda_j}, ~~\\lambda_i (\\lambda_j)\\neq 0 . \\end{align} For \\(\\lambda_i (\\lambda_j)=0\\) , the above equation is set to be zero. Besides, there are right logarithmic derivative (RLD) and left logarithmic derivative (LLD) defined by \\(\\partial_{a}\\rho=\\rho \\mathcal{R}_a\\) and \\(\\partial_{a}\\rho=\\mathcal{R}_a^{\\dagger} \\rho\\) with the corresponding QFIM \\(\\mathcal{F}_{ab}=\\mathrm{Tr}(\\rho \\mathcal{R}_a \\mathcal{R}^{\\dagger}_b)\\) . The RLD and LLD operators are calculated via \\[\\begin{align} \\langle\\lambda_i| \\mathcal{R}_{a} |\\lambda_j\\rangle &= \\frac{1}{\\lambda_i}\\langle\\lambda_i| \\partial_{a}\\rho |\\lambda_j\\rangle,~~\\lambda_i\\neq 0; \\\\ \\langle\\lambda_i| \\mathcal{R}_{a}^{\\dagger} |\\lambda_j\\rangle &= \\frac{1}{\\lambda_j}\\langle\\lambda_i| \\partial_{a}\\rho |\\lambda_j\\rangle,~~\\lambda_j\\neq 0. \\end{align}\\] In QuanEstimation, three types of the logarithmic derivatives can be solved by calling the codes Python SLD ( rho , drho , rep = \"original\" , eps = 1e-8 ) RLD ( rho , drho , rep = \"original\" , eps = 1e-8 ) LLD ( rho , drho , rep = \"original\" , eps = 1e-8 ) Julia SLD ( rho , drho ; rep = \"original\" , eps = 1e-8 ) RLD ( rho , drho ; rep = \"original\" , eps = 1e-8 ) LLD ( rho , drho ; rep = \"original\" , eps = 1e-8 ) where rho and drho are the density matrix of the state and its derivatives with respect to the unknown parameters to be estimated. drho should be input as \\([\\partial_a{\\rho}, \\partial_b{\\rho}, \\cdots]\\) . For single parameter estimation (the length of drho is equal to one), the output is a matrix and for multiparameter estimation (the length of drho is more than one), it returns a list. There are two output choices for the logarithmic derivatives basis which can be setting through rep . The default basis ( rep=\"original\" ) of the logarithmic derivatives is the same with rho and the users can also request the logarithmic derivatives written in the eigenspace of rho by rep=\"eigen\" . eps represents the machine epsilon which defaults to \\(10^{-8}\\) . In QuanEstimation, the QFI and QFIM can be calculated via the following function Python QFIM ( rho , drho , LDtype = \"SLD\" , exportLD = False , eps = 1e-8 ) LDtype represents the types of QFI (QFIM) can be set. Options are LDtype=SLD (default), LDtype=RLD and LDtype=LLD . This function will return QFI (QFIM) if exportLD=False , however, if the users set exportLD=True , it will return logarithmic derivatives apart from QFI (QFIM). Julia QFIM ( rho , drho ; LDtype = :SLD , exportLD = false , eps = 1e-8 ) LDtype represents the types of QFI (QFIM) can be set. Options are LDtype=SLD (default), LDtype=RLD and LDtype=LLD . This function will return QFI (QFIM) if exportLD=false , however, if the users set exportLD=true , it will return logarithmic derivatives apart from QFI (QFIM). Example 3.1 The Hamiltonian of a single qubit system is \\(H=\\frac{1}{2}\\omega \\sigma_3\\) with \\(\\omega\\) the frequency and \\(\\sigma_3\\) a Pauli matrix. The dynamics of the system is governed by \\begin{align} \\partial_t\\rho=-i[H, \\rho]+ \\gamma_{+}\\left(\\sigma_{+}\\rho\\sigma_{-}-\\frac{1}{2}{\\sigma_{-} \\sigma_{+},\\rho}\\right)+ \\gamma_{-}\\left(\\sigma_{-}\\rho\\sigma_{+}-\\frac{1}{2}{\\sigma_{+} \\sigma_{-},\\rho}\\right), \\end{align} where \\(\\sigma_{\\pm}=\\frac{1}{2}(\\sigma_1 \\pm \\sigma_2)\\) with \\(\\sigma_{1}\\) , \\(\\sigma_{2}\\) Pauli matrices and \\(\\gamma_{+}\\) , \\(\\gamma_{-}\\) are decay rates. The probe state is taken as \\(|+\\rangle\\) with \\(|+\\rangle=\\frac{1}{\\sqrt{2}}(|0\\rangle+|1\\rangle)\\) . Here \\(|0\\rangle\\) and \\(|1\\rangle\\) are the eigenstates of \\(\\sigma_3\\) with respect to the eigenvalues \\(1\\) and \\(-1\\) . Python from quanestimation import * import numpy as np # initial state rho0 = 0.5 * np . array ([[ 1. , 1. ], [ 1. , 1. ]]) # free Hamiltonian omega = 1.0 sz = np . array ([[ 1. , 0. ], [ 0. , - 1. ]]) H0 = 0.5 * omega * sz # derivative of the free Hamiltonian on omega dH = [ 0.5 * sz ] # dissipation sp = np . array ([[ 0. , 1. ], [ 0. , 0. ]]) sm = np . array ([[ 0. , 0. ], [ 1. , 0. ]]) decay = [[ sp , 0.0 ], [ sm , 0.1 ]] # time length for the evolution tspan = np . linspace ( 0. , 50. , 2000 ) # dynamics dynamics = Lindblad ( tspan , rho0 , H0 , dH , decay ) rho , drho = dynamics . expm () # calculation of the QFI F = [] for ti in range ( 1 , 2000 ): # QFI F_tp = QFIM ( rho [ ti ], drho [ ti ]) F . append ( F_tp ) Julia using QuanEstimation # initial state rho0 = 0.5 * ones ( 2 , 2 ) # free Hamiltonian omega = 1.0 sx = [ 0. 1. ; 1. 0.0 im ] sy = [ 0. - im ; im 0. ] sz = [ 1. 0.0 im ; 0. - 1. ] H0 = 0.5 * omega * sz # derivative of the free Hamiltonian on omega dH = [ 0.5 * sz ] # dissipation sp = [ 0. 1. ; 0. 0.0 im ] sm = [ 0. 0. ; 1. 0.0 im ] decay = [[ sp , 0.0 ], [ sm , 0.1 ]] # time length for the evolution tspan = range ( 0. , 50. , length = 2000 ) # dynamics rho , drho = QuanEstimation . expm ( tspan , rho0 , H0 , dH , decay ) # calculation of the QFI F = Float64 [] for ti in 2 : length ( tspan ) # QFI F_tp = QuanEstimation . QFIM ( rho [ ti ], drho [ ti ]) append! ( F , F_tp ) end If the parameterization process is excuted via the Kraus operators, the QFI (QFIM) can be calculated by calling the function Python QFIM_Kraus ( rho0 , K , dK , LDtype = \"SLD\" , exportLD = False , eps = 1e-8 ) Julia QFIM_Kraus ( rho0 , K , dK ; LDtype = :SLD , exportLD = false , eps = 1e-8 ) where K and dK are the Kraus operators and the derivatives with respect to the unknown parameters to be estimated. Example 3.2 The Kraus operators for the amplitude damping channel are \\[\\begin{eqnarray} K_1 = \\left(\\begin{array}{cc} 1 & 0 \\\\ 0 & \\sqrt{1-\\gamma} \\end{array}\\right), K_2 = \\left(\\begin{array}{cc} 0 & \\sqrt{\\gamma} \\\\ 0 & 0 \\end{array}\\right), \\nonumber \\end{eqnarray}\\] where \\(\\gamma\\) is unknown parameter to be estimated which represents the decay probability. In this example, the probe state is taken as \\(|+\\rangle\\langle+|\\) with \\(|+\\rangle:=\\frac{1} {\\sqrt{2}}(|0\\rangle+|1\\rangle)\\) . \\(|0\\rangle\\) \\((|1\\rangle)\\) is the eigenstate of \\(\\sigma_3\\) (Pauli matrix) with respect to the eigenvalue \\(1\\) \\((-1)\\) . Python from quanestimation import * import numpy as np # initial state rho0 = 0.5 * np . array ([[ 1. , 1. ], [ 1. , 1. ]]) # Kraus operators for the amplitude damping channel gamma = 0.1 K1 = np . array ([[ 1. , 0. ], [ 0. , np . sqrt ( 1 - gamma )]]) K2 = np . array ([[ 0. , np . sqrt ( gamma )], [ 0. , 0. ]]) K = [ K1 , K2 ] # derivatives of Kraus operators on gamma dK1 = np . array ([[ 1. , 0. ], [ 0. , - 0.5 / np . sqrt ( 1 - gamma )]]) dK2 = np . array ([[ 0. , 0.5 / np . sqrt ( gamma )], [ 0. , 0. ]]) dK = [[ dK1 ], [ dK2 ]] F = QFIM_Kraus ( rho0 , K , dK ) Julia using QuanEstimation # initial state rho0 = [ 0.5 + 0 im 0.5 ; 0.5 0.5 ] # Kraus operators for the amplitude damping channel gamma = 0.1 K1 = [ 1. 0. ; 0. sqrt ( 1 - gamma )] K2 = [ 0. sqrt ( gamma ); 0. 0. ] K = [ K1 , K2 ] # derivatives of Kraus operators on gamma dK1 = [ 1. 0. ; 0. - 0.5 / sqrt ( 1 - gamma )] dK2 = [ 0. 0.5 / sqrt ( gamma ); 0. 0. ] dK = [[ dK1 ], [ dK2 ]] F = QuanEstimation . QFIM_Kraus ( rho0 , K , dK ) The FI (FIM) for a set of the probabilities p can be calculated by Python FIM ( p , dp , eps = 1e-8 ) Julia FIM ( p , dp ; eps = 1e-8 ) where dp is a list representing the derivatives of the probabilities p with respect to the unknown parameters. Example 3.3 Python from quanestimation import * p = [ 0.54 , 0.46 ] dp = [[ 0.54 ], [ - 0.54 ]] F = FIM ( p , dp ) Julia using QuanEstimation p = [ 0.54 , 0.46 ] dp = [[ 0.54 ], [ - 0.54 ]] F = QuanEstimation . FIM ( p , dp ) In quantum metrology, the CFI (CFIM) are solved by Python CFIM ( rho , drho , M = [], eps = 1e-8 ) Here M represents a set of positive operator-valued measure (POVM) with default value [] . In this function, a set of rank-one symmetric informationally complete POVM (SIC-POVM) is used when M=[] . SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from here . Julia CFIM ( rho , drho ; M = missing , eps = 1e-8 ) Here M represents a set of positive operator-valued measure (POVM) with default value missing . In this function, a set of rank-one symmetric informationally complete POVM (SIC-POVM) is used when M=missing . SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from here . Example 3.4 The Hamiltonian of a single qubit system is \\(H=\\frac{1}{2}\\omega \\sigma_3\\) with \\(\\omega\\) the frequency and \\(\\sigma_3\\) a Pauli matrix. The dynamics of the system is governed by \\begin{align} \\partial_t\\rho=-i[H, \\rho]+ \\gamma_{+}\\left(\\sigma_{+}\\rho\\sigma_{-}-\\frac{1}{2}{\\sigma_{-} \\sigma_{+}, \\rho}\\right)+ \\gamma_{-}\\left(\\sigma_{-}\\rho\\sigma_{+}-\\frac{1}{2}{\\sigma_{+} \\sigma_{-},\\rho}\\right), \\end{align} where \\(\\sigma_{\\pm}=\\frac{1}{2}(\\sigma_1 \\pm \\sigma_2)\\) with \\(\\sigma_{1}\\) , \\(\\sigma_{2}\\) Pauli matrices and \\(\\gamma_{+}\\) , \\(\\gamma_{-}\\) are decay rates. The probe state is taken as \\(|+\\rangle\\) and the measurement for CFI is \\(\\{|+\\rangle\\langle+|, |-\\rangle\\langle-|\\}\\) with \\(|\\pm\\rangle=\\frac{1}{\\sqrt{2}}(|0\\rangle\\pm|1\\rangle)\\) . Here \\(|0\\rangle\\) and \\(|1\\rangle\\) are the eigenstates of \\(\\sigma_3\\) with respect to the eigenvalues \\(1\\) and \\(-1\\) . Python from quanestimation import * import numpy as np # initial state rho0 = 0.5 * np . array ([[ 1. , 1. ], [ 1. , 1. ]]) # free Hamiltonian omega = 1.0 sz = np . array ([[ 1. , 0. ], [ 0. , - 1. ]]) H0 = 0.5 * omega * sz # derivative of the free Hamiltonian on omega dH = [ 0.5 * sz ] # dissipation sp = np . array ([[ 0. , 1. ], [ 0. , 0. ]]) sm = np . array ([[ 0. , 0. ], [ 1. , 0. ]]) decay = [[ sp , 0.0 ], [ sm , 0.1 ]] # measurement M1 = 0.5 * np . array ([[ 1. , 1. ], [ 1. , 1. ]]) M2 = 0.5 * np . array ([[ 1. , - 1. ], [ - 1. , 1. ]]) M = [ M1 , M2 ] # time length for the evolution tspan = np . linspace ( 0. , 50. , 2000 ) # dynamics dynamics = Lindblad ( tspan , rho0 , H0 , dH , decay ) rho , drho = dynamics . expm () # calculation of the CFI I = [] for ti in range ( 1 , 2000 ): # CFI I_tp = CFIM ( rho [ ti ], drho [ ti ], M = M ) I . append ( I_tp ) Julia using QuanEstimation # initial state rho0 = 0.5 * ones ( 2 , 2 ) # free Hamiltonian omega = 1.0 sx = [ 0. 1. ; 1. 0.0 im ] sy = [ 0. - im ; im 0. ] sz = [ 1. 0.0 im ; 0. - 1. ] H0 = 0.5 * omega * sz # derivative of the free Hamiltonian on omega dH = [ 0.5 * sz ] # dissipation sp = [ 0. 1. ; 0. 0.0 im ] sm = [ 0. 0. ; 1. 0.0 im ] decay = [[ sp , 0.0 ], [ sm , 0.1 ]] # measurement M1 = 0.5 * [ 1.0 + 0.0 im 1. ; 1. 1. ] M2 = 0.5 * [ 1.0 + 0.0 im - 1. ; - 1. 1. ] M = [ M1 , M2 ] # time length for the evolution tspan = range ( 0. , 50. , length = 2000 ) # dynamics rho , drho = QuanEstimation . expm ( tspan , rho0 , H0 , dH , decay ) # calculation of the CFI Im = Float64 [] for ti in 2 : length ( tspan ) # CFI I_tp = QuanEstimation . CFIM ( rho [ ti ], drho [ ti ], M ) append! ( Im , I_tp ) end In Bloch representation, the SLD based QFI (QFIM) is calculated by Python QFIM_Bloch ( r , dr , eps = 1e-8 ) Julia QFIM_Bloch ( r , dr ; eps = 1e-8 ) r and dr are the parameterized Bloch vector and its derivatives of with respect to the unknown parameters to be estimated. Example 3.5 The arbitrary single-qubit state can be written as \\begin{align} |\\psi\\rangle=\\cos\\frac{\\theta}{2}|0\\rangle+e^{i\\phi}\\sin\\frac{\\theta}{2}|1\\rangle \\end{align} with \\(\\theta\\) and \\(\\phi\\) the parameters to be estimated. The Bloch vector for this state is \\(r=(\\sin\\theta\\cos\\phi, \\sin\\theta\\sin\\phi, \\cos\\theta)^{\\mathrm{T}}\\) and the derivatives with respect to \\(\\theta\\) and \\(\\phi\\) are \\(\\partial_\\theta r=(\\cos\\theta\\cos\\phi, \\cos\\theta\\sin\\phi, -\\sin\\theta)^{\\mathrm{T}}\\) and \\(\\partial_\\phi r=(-\\sin\\theta\\sin\\phi, \\sin\\theta\\cos\\phi, 0)^{\\mathrm{T}}\\) Python from quanestimation import * import numpy as np theta , phi = 0.25 * np . pi , 0.25 * np . pi r = np . array ([ np . sin ( theta ) * np . cos ( phi ), \\ np . sin ( theta ) * np . sin ( phi ), \\ np . cos ( theta )]) dr_theta = np . array ([ np . cos ( theta ) * np . cos ( phi ), \\ np . cos ( theta ) * np . sin ( phi ), \\ - np . sin ( theta )]) dr_phi = np . array ([ - np . sin ( theta ) * np . sin ( phi ), \\ np . sin ( theta ) * np . cos ( phi ), \\ 0. ]) dr = [ dr_theta , dr_phi ] F = QFIM_Bloch ( r , dr ) Julia using QuanEstimation using LinearAlgebra theta , phi = 0.25 * pi , 0.25 * pi r = [ sin ( theta ) * cos ( phi ), sin ( theta ) * sin ( phi ), cos ( theta )] dr_theta = [ cos ( theta ) * cos ( phi ), cos ( theta ) * sin ( phi ), - sin ( theta )] dr_phi = [ - sin ( theta ) * sin ( phi ), sin ( theta ) * cos ( phi ), 0. ] dr = [ dr_theta , dr_phi ] F = QuanEstimation . QFIM_Bloch ( r , dr ) The package can also calculte the SLD based QFI (QFIM) with Gaussian states. Python QFIM_Gauss ( R , dR , D , dD ) Julia QFIM_Gauss ( R , dR , D , dD ) The variable R is the expected value \\(\\left(\\langle[\\textbf{R}]_i\\rangle\\right)\\) of \\(\\textbf{R}\\) with respect to \\(\\rho\\) , it is an array representing the first-order moment. Here \\(\\textbf{R}=(q_1,p_1,q_2,p_2,\\dots)^{\\mathrm{T}}\\) with \\(q_i=\\frac{1}{\\sqrt{2}} (a_i+a^{\\dagger}_i)\\) and \\(p_i=\\frac{1}{i\\sqrt{2}}(a_i-a^{\\dagger}_i)\\) represents a vector of quadrature operators. dR is a list of derivatives of R with respect to the unknown parameters. The \\(i\\) th entry of dR is \\(\\partial_{\\textbf{x}} \\langle[\\textbf{R}]_i\\rangle\\) . D and dD represent the second-order moment matrix with the \\(ij\\) th entry \\(D_{ij}=\\langle [\\textbf{R}]_i [\\textbf{R}]_j+[\\textbf{R}]_j [\\textbf{R}]_i\\rangle/2\\) and its derivatives with respect tp the unknown parameters. Example 3.6 The first and second moments [10] are \\[\\begin{eqnarray} \\langle[\\textbf{R}]_i\\rangle = \\left(\\begin{array}{cc} 0 \\\\ 0 \\end{array}\\right), D = \\lambda\\left(\\begin{array}{cc} \\cosh 2r & -\\sinh 2r \\\\ -\\sinh 2r & -\\sinh 2r \\end{array}\\right), \\nonumber \\end{eqnarray}\\] where \\(\\lambda=\\coth\\frac{\\beta}{2}\\) . \\(r\\) and \\(\\beta\\) are the parameters to be estimated. Python from quanestimation import * import numpy as np dim = 2 r , beta = 0.2 , 1.0 Lambda = np . cosh ( 0.5 * beta ) / np . sinh ( 0.5 * beta ) # the first-order moment R = np . zeros ( dim ) dR = [ np . zeros ( dim ), np . zeros ( dim )] # the second-order moment D = Lambda * np . array ([[ np . cosh ( 2 * r ), - np . sinh ( 2 * r )], \\ [ - np . sinh ( 2 * r ), np . cosh ( 2 * r )]]) dD_r = 2 * Lambda * np . array ([[ np . sinh ( 2 * r ), - np . cosh ( 2 * r )], \\ [ - np . cosh ( 2 * r ), np . sinh ( 2 * r )]]) dD_Lambda = 0.5 * ( Lambda ** 2 - 1 ) * np . array ([[ - np . cosh ( 2 * r ), np . sinh ( 2 * r )], \\ [ np . sinh ( 2 * r ), - np . cosh ( 2 * r )]]) dD = np . array ([ dD_r , dD_Lambda ]) F = QFIM_Gauss ( R , dR , D , dD ) Julia using QuanEstimation dim = 2 r , beta = 0.2 , 1.0 Lambda = coth ( 0.5 * beta ) # the first-order moment R = zeros ( dim ) dR = [ zeros ( dim ), zeros ( dim )] D = Lambda * [ cosh ( 2 * r ) - sinh ( 2 * r ); - sinh ( 2 * r ) cosh ( 2 * r )] dD_r = 2 * Lambda * [ sinh ( 2 * r ) - cosh ( 2 * r ); - cosh ( 2 * r ) sinh ( 2 * r )] dD_Lambda = 0.5 * ( Lambda ^ 2 - 1 ) * [ - cosh ( 2 * r ) sinh ( 2 * r ); sinh ( 2 * r ) - cosh ( 2 * r )] dD = [ dD_r , dD_Lambda ] F = QuanEstimation . QFIM_Gauss ( R , dR , D , dD )","title":"Quantum Cram\u00e9r-Rao bounds"},{"location":"guide/guide_bounds/#holevo-cramer-rao-bound","text":"Holevo Cram\u00e9r-Rao bound (HCRB) is of the form [4,5] \\begin{align} \\mathrm{Tr}(W\\mathrm{cov}(\\hat{\\textbf{x}},{\\Pi_y}))\\geq \\min_{\\textbf{X},V} \\mathrm{Tr}(WV), \\end{align} where \\(W\\) is the weight matrix and \\(V\\geq Z(\\textbf{X})\\) with \\([Z(\\textbf{X})]_{ab}=\\mathrm{Tr} (\\rho X_a X_b)\\) . \\(\\textbf{X}=[X_0,X_1,\\cdots]\\) with \\(X_i:=\\sum_y (\\hat{x}_i(y)-x_i)\\Pi_y\\) . The HCRB can be calculated via semidefinite programming as \\[\\begin{align} & \\min_{\\textbf{X},V}~\\mathrm{Tr}(WV), \\nonumber \\\\ & \\mathrm{subject}~\\mathrm{to} \\begin{cases} \\left(\\begin{array}{cc} V & \\Lambda^{\\mathrm{T}}R^{\\dagger} \\\\ R\\Lambda & I\\\\ \\end{array}\\right)\\geq 0, \\\\ \\sum_i[\\Lambda]_{ai}\\mathrm{Tr}(\\lambda_i\\partial_b\\rho)=\\delta_{ab}. \\end{cases} \\end{align}\\] Here \\(X_i\\) is expanded in a specific basis \\(\\{\\lambda_i\\}\\) as \\(X_i=\\sum_j [\\Lambda]_{ij}\\lambda_j\\) , the Hermitian matrix \\(Z(\\textbf{X})\\) satisfies \\(Z(\\textbf{X})=\\Lambda^{\\mathrm{T}}R^{\\dagger} R\\Lambda\\) . In QuanEstimation, the HCRB can be solved by Python HCRB ( rho , drho , W , eps = 1e-8 ) Julia HCRB ( rho , drho , W ; eps = 1e-8 ) where rho and drho are the density matrix of the state and its derivatives with respect to the unknown parameters to be estimated, respectively. W represents the weight matrix defaults to identity matrix and eps is the machine epsilon with default value \\(10^{-8}\\) . Example 3.7 The Hamiltonian of a two-qubit system with \\(XX\\) coupling is \\begin{align} H=\\omega_1\\sigma_3^{(1)}+\\omega_2\\sigma_3^{(2)}+g\\sigma_1^{(1)}\\sigma_1^{(2)}, \\end{align} where \\(\\omega_1\\) , \\(\\omega_2\\) are the frequencies of the first and second qubit, \\(\\sigma_i^{(1)} =\\sigma_i\\otimes I\\) and \\(\\sigma_i^{(2)}=I\\otimes\\sigma_i\\) for \\(i=1,2,3\\) . \\(\\sigma_1\\) , \\(\\sigma_2\\) , \\(\\sigma_3\\) are Pauli matrices and \\(I\\) denotes the identity matrix. The dynamics is described by the master equation \\begin{align} \\partial_t\\rho=-i[H, \\rho]+\\sum_{i=1,2}\\gamma_i\\left(\\sigma_3^{(i)}\\rho\\sigma_3^{(i)}-\\rho\\right) \\end{align} with \\(\\gamma_i\\) the decay rate for the \\(i\\) th qubit. The probe state is taken as \\(\\frac{1}{\\sqrt{2}}(|00\\rangle+|11\\rangle)\\) and the weight matrix is set to be identity. The measurement for \\(\\mathrm{Tr}(W\\mathcal{I^{-1}})\\) is \\(\\{\\Pi_1\\) , \\(\\Pi_2\\) , \\(I-\\Pi_1-\\Pi_2\\}\\) with \\(\\Pi_1=0.85|00\\rangle\\langle 00|\\) and \\(\\Pi_2=0.1|\\!+ \\!+\\rangle\\langle+\\!+\\!|\\) . Here \\(|\\pm\\rangle:=\\frac{1}{\\sqrt{2}}(|0\\rangle\\pm|1\\rangle)\\) with \\(|0\\rangle\\) \\((|1\\rangle)\\) the eigenstate of \\(\\sigma_3\\) with respect to the eigenvalue \\(1\\) ( \\(-1\\) ). Python from quanestimation import * import numpy as np # initial state psi0 = np . array ([ 1. , 0. , 0. , 1. ]) / np . sqrt ( 2 ) rho0 = np . dot ( psi0 . reshape ( - 1 , 1 ), psi0 . reshape ( 1 , - 1 ) . conj ()) # free Hamiltonian omega1 , omega2 , g = 1.0 , 1.0 , 0.1 sx = np . array ([[ 0. , 1. ], [ 1. , 0. ]]) sy = np . array ([[ 0. , - 1. j ], [ 1. j , 0. ]]) sz = np . array ([[ 1. , 0. ], [ 0. , - 1. ]]) ide = np . array ([[ 1. , 0. ], [ 0. , 1. ]]) H0 = omega1 * np . kron ( sz , ide ) + omega2 * np . kron ( ide , sz ) + g * np . kron ( sx , sx ) # derivatives of the free Hamiltonian on omega2 and g dH = [ np . kron ( ide , sz ), np . kron ( sx , sx )] # dissipation decay = [[ np . kron ( sz , ide ), 0.05 ], [ np . kron ( ide , sz ), 0.05 ]] # measurement m1 = np . array ([ 1. , 0. , 0. , 0. ]) M1 = 0.85 * np . dot ( m1 . reshape ( - 1 , 1 ), m1 . reshape ( 1 , - 1 ) . conj ()) M2 = 0.1 * np . ones (( 4 , 4 )) M = [ M1 , M2 , np . identity ( 4 ) - M1 - M2 ] # time length for the evolution tspan = np . linspace ( 0. , 10. , 1000 ) # dynamics dynamics = Lindblad ( tspan , rho0 , H0 , dH , decay ) rho , drho = dynamics . expm () # weight matrix W = np . identity ( 2 ) # calculation of the CFIM, QFIM and HCRB F , I , f = [], [], [] for ti in range ( 1 , 1000 ): # CFIM I_tp = CFIM ( rho [ ti ], drho [ ti ], M = M ) I . append ( I_tp ) # QFIM F_tp = QFIM ( rho [ ti ], drho [ ti ]) F . append ( F_tp ) # HCRB f_tp = HCRB ( rho [ ti ], drho [ ti ], W , eps = 1e-6 ) f . append ( f_tp ) Julia using QuanEstimation using LinearAlgebra # initial state psi0 = [ 1. , 0. , 0. , 1. ] / sqrt ( 2 ) rho0 = psi0 * psi0 ' # free Hamiltonian omega1 , omega2 , g = 1.0 , 1.0 , 0.1 sx = [ 0. 1. ; 1. 0.0 im ] sy = [ 0. - im ; im 0. ] sz = [ 1. 0.0 im ; 0. - 1. ] H0 = omega1 * kron ( sz , I ( 2 )) + omega2 * kron ( I ( 2 ), sz ) + g * kron ( sx , sx ) # derivatives of the free Hamiltonian with respect to omega2 and g dH = [ kron ( I ( 2 ), sz ), kron ( sx , sx )] # dissipation decay = [[ kron ( sz , I ( 2 )), 0.05 ], [ kron ( I ( 2 ), sz ), 0.05 ]] # measurement m1 = [ 1. , 0. , 0. , 0. ] M1 = 0.85 * m1 * m1 ' M2 = 0.1 * ones ( 4 , 4 ) M = [ M1 , M2 , I ( 4 ) - M1 - M2 ] # time length for the evolution tspan = range ( 0. , 10. , length = 1000 ) # dynamics rho , drho = QuanEstimation . expm ( tspan , rho0 , H0 , dH , decay ) # weight matrix W = one ( zeros ( 2 , 2 )) # calculation of the CFIM, QFIM and HCRB Im , F , f = [], [], Float64 [] for ti in 2 : length ( tspan ) # CFIM I_tp = QuanEstimation . CFIM ( rho [ ti ], drho [ ti ], M ) append! ( Im , [ I_tp ]) # QFIM F_tp = QuanEstimation . QFIM ( rho [ ti ], drho [ ti ]) append! ( F , [ F_tp ]) # HCRB f_tp = QuanEstimation . HCRB ( rho [ ti ], drho [ ti ], W ) append! ( f , f_tp ) end","title":"Holevo Cram\u00e9r-Rao bound"},{"location":"guide/guide_bounds/#bayesian-cramer-rao-bounds","text":"The Bayesion version of the classical Fisher information (matrix) and quantum Fisher information (matrix) can be calculated by \\(\\mathcal{I}_{\\mathrm{Bayes}}=\\int p(\\textbf{x})\\mathcal{I}\\mathrm{d}\\textbf{x}\\) and \\(\\mathcal{F}_{\\mathrm{Bayes}}=\\int p(\\textbf{x})\\mathcal{F}\\mathrm{d}\\textbf{x},\\) where \\(p(\\textbf{x})\\) is the prior distribution, \\(\\mathcal{I}\\) and \\(\\mathcal{F}\\) are CFI (CFIM) and QFI (QFIM) of all types, respectively. In QuanEstimation, BCFI (BCFIM) and BQFI (BQFIM) can be solved via Python BCFIM ( x , p , rho , drho , M = [], eps = 1e-8 ) BQFIM ( x , p , rho , drho , LDtype = \"SLD\" , eps = 1e-8 ) where x represents the regimes of the parameters for the integral, it should be input as a list of arrays. p is an array representing the prior distribution. The input varibles rho and drho are two multidimensional lists with the dimensions as x . For example, for three parameter ( \\(x_0, x_1, x_2\\) ) estimation, the \\(ijk\\) th entry of rho and drho are \\(\\rho\\) and \\([\\partial_0\\rho, \\partial_1\\rho, \\partial_2\\rho]\\) with respect to the values \\([x_0]_i\\) , \\([x_1]_j\\) and \\([x_2]_k\\) , respectively. LDtype represents the types of QFI (QFIM) can be set, options are LDtype=SLD (default), LDtype=RLD and LDtype=LLD . M represents a set of positive operator-valued measure (POVM) with default value [] . In QuanEstimation, a set of rank-one symmetric informationally complete POVM (SIC-POVM) is load when M=[] . SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from here . Julia BCFIM ( x , p , rho , drho ; M = missing , eps = 1e-8 ) BQFIM ( x , p , rho , drho ; LDtype = :SLD , eps = 1e-8 ) where x represents the regimes of the parameters for the integral, it should be input as a list of arrays. p is an array representing the prior distribution. The input varibles rho and drho are two multidimensional lists with the dimensions as x . For example, for three parameter ( \\(x_0, x_1, x_2\\) ) estimation, the \\(ijk\\) th entry of rho and drho are \\(\\rho\\) and \\([\\partial_0\\rho, \\partial_1\\rho, \\partial_2\\rho]\\) with respect to the values \\([x_0]_i\\) , \\([x_1]_j\\) and \\([x_2]_k\\) , respectively. LDtype represents the types of QFI (QFIM) can be set, options are LDtype=SLD (default), LDtype=RLD and LDtype=LLD . M represents a set of positive operator-valued measure (POVM) with default value missing . In QuanEstimation, a set of rank-one symmetric informationally complete POVM (SIC-POVM) is load when M=missing . SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from here . In the Bayesian scenarios, the covariance matrix with a prior distribution \\(p(\\textbf{x})\\) is defined as \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},{\\Pi_y})=\\int p(\\textbf{x})\\sum_y\\mathrm{Tr}(\\rho\\Pi_y) (\\hat{\\textbf{x}}-\\textbf{x})(\\hat{\\textbf{x}}-\\textbf{x})^{\\mathrm{T}}\\mathrm{d}\\textbf{x}, \\end{align} where \\(\\textbf{x}=(x_0,x_1,\\dots)^{\\mathrm{T}}\\) are the unknown parameters to be estimated and the integral \\(\\int\\mathrm{d}\\textbf{x}:=\\int\\mathrm{d}x_0\\int\\mathrm{d}x_1\\cdots\\) . \\(\\{\\Pi_y\\}\\) is a set of POVM and \\(\\rho\\) represents the parameterized density matrix. Two types of Bayesian Cram\u00e9r-Rao bound (BCRB) are calculated in this package, the first one is \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},{\\Pi_y})\\geq \\int p(\\textbf{x})\\left(B\\mathcal{I}^{-1}B +\\textbf{b}\\textbf{b}^{\\mathrm{T}}\\right)\\mathrm{d}\\textbf{x}, \\end{align} where \\(\\textbf{b}\\) and \\(\\textbf{b}'\\) are the vectors of biase and its derivatives with respect to \\(\\textbf{x}\\) . \\(B\\) is a diagonal matrix with the \\(i\\) th entry \\(B_{ii}=1+[\\textbf{b}']_{i}\\) and \\(\\mathcal{I}\\) is the CFIM. The second one is \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},{\\Pi_y})\\geq \\mathcal{B}\\,\\mathcal{I}_{\\mathrm{Bayes}}^{-1}\\, \\mathcal{B}+\\int p(\\textbf{x})\\textbf{b}\\textbf{b}^{\\mathrm{T}}\\mathrm{d}\\textbf{x}, \\end{align} where \\(\\mathcal{B}=\\int p(\\textbf{x})B\\mathrm{d}\\textbf{x}\\) is the average of \\(B\\) and \\(\\mathcal{I}_{\\mathrm{Bayes}}\\) is the average of the CFIM. The third one is \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},{\\Pi_y})\\geq \\int p(\\textbf{x}) \\mathcal{G}\\left(\\mathcal{I}_p+\\mathcal{I}\\right)^{-1}\\mathcal{G}^{\\mathrm{T}}\\mathrm{d}\\textbf{x} \\end{align} with \\([\\mathcal{I}_{p}]_{ab}:=[\\partial_a \\ln p(\\textbf{x})][\\partial_b \\ln p(\\textbf{x})]\\) and \\(\\mathcal{G}_{ab}:=[\\partial_b\\ln p(\\textbf{x})][\\textbf{b}]_a+B_{aa}\\delta_{ab}\\) . Three types of Bayesian Quantum Cram\u00e9r-Rao bound (BCRB) are calculated, the first one is \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},{\\Pi_y})\\geq\\int p(\\textbf{x})\\left(B\\mathcal{F}^{-1}B +\\textbf{b}\\textbf{b}^{\\mathrm{T}}\\right)\\mathrm{d}\\textbf{x} \\end{align} with \\(\\mathcal{F}\\) the QFIM for all types. The second one is \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},{\\Pi_y})\\geq \\mathcal{B}\\,\\mathcal{F}_{\\mathrm{Bayes}}^{-1}\\, \\mathcal{B}+\\int p(\\textbf{x})\\textbf{b}\\textbf{b}^{\\mathrm{T}}\\mathrm{d}\\textbf{x} \\end{align} with \\(\\mathcal{F}_{\\mathrm{Bayes}}\\) the average of the QFIM. The third one is \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},{\\Pi_y})\\geq \\int p(\\textbf{x}) \\mathcal{G}\\left(\\mathcal{I}_p+\\mathcal{F}\\right)^{-1}\\mathcal{G}^{\\mathrm{T}}\\mathrm{d}\\textbf{x}. \\end{align} In QuanEstimation, the BCRB and BQCRB are calculated via Python BCRB ( x , p , dp , rho , drho , M = [], b = [], db = [], btype = 1 , eps = 1e-8 ) BQCRB ( x , p , dp , rho , drho , b = [], db = [], btype = 1 , LDtype = \"SLD\" , eps = 1e-8 ) where b and db are the vectors of biases and its derivatives on the unknown parameters. For unbiased estimates, b=[] and db=[] . In QuanEstimation, the users can set the types of BCRB and BQCRB via the variable btype . Julia BCRB ( x , p , dp , rho , drho ; M = missing , b = missing , db = missing , btype = 1 , eps = 1e-8 ) BQCRB ( x , p , dp , rho , drho ; b = missing , db = missing , btype = 1 , LDtype = :SLD , eps = 1e-8 ) where b and db are the vectors of biases and its derivatives on the unknown parameters. For unbiased estimates, b=missing and db=missing . In QuanEstimation, the users can set the types of BCRB and BQCRB via the variable btype . For single parameter estimation, Ref [6] calculates the optimal biased bound based on the first type of the BQCRB, it can be realized numerically via Python OBB ( x , p , dp , rho , drho , d2rho , LDtype = \"SLD\" , eps = 1e-8 ) Julia OBB ( x , p , dp , rho , drho , d2rho ; LDtype = :SLD , eps = 1e-8 ) d2rho is a list representing the second order derivatives of rho on x . Van Trees in 1968 [7] provides a well used Bayesian version of Cram\u00e9r-Rao bound known as Van Trees bound (VTB). \\(\\mathrm{cov}(\\hat{\\textbf{x}},\\{\\Pi_y\\})\\geq \\left(\\mathcal{I}_{\\mathrm{prior}} +\\mathcal{I}_{\\mathrm{Bayes}}\\right)^{-1},\\) where \\(\\mathcal{I}_{\\mathrm{prior}}=\\int p(\\textbf{x})\\mathcal{I}_{p}\\mathrm{d}\\textbf{x}\\) is the CFIM for \\(p(\\textbf{x})\\) and \\(\\mathcal{I}_{\\mathrm{Bayes}}\\) is the average of the CFIM. The quantum version (QVTB) provided by Tsang, Wiseman and Caves [9] . \\(\\mathrm{cov}(\\hat{\\textbf{x}},\\{\\Pi_y\\})\\geq \\left(\\mathcal{I}_{\\mathrm{prior}} +\\mathcal{F}_{\\mathrm{Bayes}}\\right)^{-1}\\) with \\(\\mathcal{F}_{\\mathrm{Bayes}}\\) the average of the QFIM of all types. The functions to calculate the VTB and QVTB are Python VTB ( x , p , dp , rho , drho , M = [], eps = 1e-8 ) QVTB ( x , p , dp , rho , drho , LDtype = \"SLD\" , eps = 1e-8 ) Julia VTB ( x , p , dp , rho , drho ; M = missing , eps = 1e-8 ) QVTB ( x , p , dp , rho , drho ; LDtype = :SLD , eps = 1e-8 ) Here the variables in the codes are the same with BCRB and BQCRB .","title":"Bayesian Cram\u00e9r-Rao bounds"},{"location":"guide/guide_bounds/#quantum-ziv-zakai-bound","text":"The expression of Quantum Ziv-Zakai bound (QZZB) with a prior distribution \\(p(x)\\) in a finite regime \\([\\alpha,\\beta]\\) is \\[\\begin{eqnarray} \\mathrm{var}(\\hat{x},\\{\\Pi_y\\}) &\\geq & \\frac{1}{2}\\int_0^\\infty \\mathrm{d}\\tau\\tau \\mathcal{V}\\int_{-\\infty}^{\\infty} \\mathrm{d}x\\min\\!\\left\\{p(x), p(x+\\tau)\\right\\} \\nonumber \\\\ & & \\times\\left(1-\\frac{1}{2}||\\rho(x)-\\rho(x+\\tau)||\\right), \\end{eqnarray}\\] where \\(||\\cdot||\\) represents the trace norm and \\(\\mathcal{V}\\) is the \"valley-filling\" operator satisfying \\(\\mathcal{V}f(\\tau)=\\max_{h\\geq 0}f(\\tau+h)\\) . \\(\\rho(x)\\) is the parameterized density matrix. In QuanEstimation, the QZZB can be calculated via the function: Python QZZB ( x , p , rho , eps = 1e-8 ) Julia QZZB ( x , p , rho ; eps = 1e-8 ) where x is a list of array representing the regime of the parameter for the integral, p is an array representing the prior distribution and rho is a multidimensional list representing the density matrix. eps is the machine epsilon with default value \\(10^{-8}\\) . Example 3.8 The Hamiltonian of a qubit system under a magnetic field \\(B\\) in the XZ plane is \\begin{align} H=\\frac{B\\omega_0}{2}(\\sigma_1\\cos{x}+\\sigma_3\\sin{x}) \\end{align} with \\(x\\) the unknown parameter and \\(\\sigma_{1}\\) , \\(\\sigma_{3}\\) Pauli matrices. The probe state is taken as \\(\\frac{1}{\\sqrt{2}}(|0\\rangle+|1\\rangle)\\) with \\(|0\\rangle\\) ( \\(|1\\rangle\\) ) the eigenvstates of \\(\\sigma_3\\) with respect to the eigenvalues \\(1\\) ( \\(-1\\) ). The measurement for classical bounds is a set of rank-one symmetric informationally complete positive operator-valued measure (SIC-POVM). Take the Gaussian prior distribution \\(p(x)=\\frac{1}{c\\eta\\sqrt{2\\pi}}\\exp\\left({-\\frac{(x-\\mu)^2} {2\\eta^2}}\\right)\\) on \\([-\\pi/2, \\pi/2]\\) with \\(\\mu\\) and \\(\\eta\\) the expectation and standard deviation, respectively. Here \\(c=\\frac{1}{2}\\big[\\mathrm{erf}(\\frac{\\pi-2\\mu}{2\\sqrt{2}\\eta}) +\\mathrm{erf}(\\frac{\\pi+2\\mu}{2\\sqrt{2}\\eta})\\big]\\) is the normalized coefficient with \\(\\mathrm{erf}(x):=\\frac{2}{\\sqrt{\\pi}}\\int^x_0 e^{-t^2}\\mathrm{d}t\\) the error function. Python from quanestimation import * import numpy as np from scipy.integrate import simps # initial state rho0 = 0.5 * np . array ([[ 1. , 1. ], [ 1. , 1. ]]) # free Hamiltonian B , omega0 = 0.5 * np . pi , 1.0 sx = np . array ([[ 0. , 1. ], [ 1. , 0. ]]) sy = np . array ([[ 0. , - 1. j ], [ 1. j , 0. ]]) sz = np . array ([[ 1. , 0. ], [ 0. , - 1. ]]) H0_func = lambda x : 0.5 * B * omega0 * ( sx * np . cos ( x ) + sz * np . sin ( x )) # derivative of the free Hamiltonian on x dH_func = lambda x : [ 0.5 * B * omega0 * ( - sx * np . sin ( x ) + sz * np . cos ( x ))] # prior distribution x = np . linspace ( - 0.5 * np . pi , 0.5 * np . pi , 100 ) mu , eta = 0.0 , 0.2 p_func = lambda x , mu , eta : np . exp ( - ( x - mu ) ** 2 / ( 2 * eta ** 2 )) \\ / ( eta * np . sqrt ( 2 * np . pi )) dp_func = lambda x , mu , eta : - ( x - mu ) * np . exp ( - ( x - mu ) ** 2 / ( 2 * eta ** 2 )) \\ / ( eta ** 3 * np . sqrt ( 2 * np . pi )) p_tp = [ p_func ( x [ i ], mu , eta ) for i in range ( len ( x ))] dp_tp = [ dp_func ( x [ i ], mu , eta ) for i in range ( len ( x ))] # normalization of the distribution c = simps ( p_tp , x ) p , dp = p_tp / c , dp_tp / c # time length for the evolution tspan = np . linspace ( 0. , 1. , 1000 ) # dynamics rho = [ np . zeros (( len ( rho0 ), len ( rho0 )), dtype = np . complex128 ) \\ for i in range ( len ( x ))] drho = [[ np . zeros (( len ( rho0 ), len ( rho0 )), dtype = np . complex128 )] \\ for i in range ( len ( x ))] for i in range ( len ( x )): H0_tp = H0_func ( x [ i ]) dH_tp = dH_func ( x [ i ]) dynamics = Lindblad ( tspan , rho0 , H0_tp , dH_tp ) rho_tp , drho_tp = dynamics . expm () rho [ i ] = rho_tp [ - 1 ] drho [ i ] = drho_tp [ - 1 ] # Classical Bayesian bounds f_BCRB1 = BCRB ([ x ], p , [], rho , drho , M = [], btype = 1 ) f_BCRB2 = BCRB ([ x ], p , [], rho , drho , M = [], btype = 2 ) f_BCRB3 = BCRB ([ x ], p , dp , rho , drho , M = [], btype = 3 ) f_VTB = VTB ([ x ], p , dp , rho , drho , M = []) # Quantum Bayesian bounds f_BQCRB1 = BQCRB ([ x ], p , [], rho , drho , btype = 1 ) f_BQCRB2 = BQCRB ([ x ], p , [], rho , drho , btype = 2 ) f_BQCRB3 = BQCRB ([ x ], p , dp , rho , drho , btype = 3 ) f_QVTB = QVTB ([ x ], p , dp , rho , drho ) f_QZZB = QZZB ([ x ], p , rho ) Julia using QuanEstimation using Trapz # free Hamiltonian function H0_func ( x ) return 0.5 * B * omega0 * ( sx * cos ( x ) + sz * sin ( x )) end # derivative of the free Hamiltonian on x function dH_func ( x ) return [ 0.5 * B * omega0 * ( - sx * sin ( x ) + sz * cos ( x ))] end # prior distribution function p_func ( x , mu , eta ) return exp ( - ( x - mu ) ^ 2 / ( 2 * eta ^ 2 )) / ( eta * sqrt ( 2 * pi )) end function dp_func ( x , mu , eta ) return - ( x - mu ) * exp ( - ( x - mu ) ^ 2 / ( 2 * eta ^ 2 )) / ( eta ^ 3 * sqrt ( 2 * pi )) end B , omega0 = 0.5 * pi , 1.0 sx = [ 0. 1. ; 1. 0.0 im ] sy = [ 0. - im ; im 0. ] sz = [ 1. 0.0 im ; 0. - 1. ] # initial state rho0 = 0.5 * ones ( 2 , 2 ) # prior distribution x = range ( - 0.5 * pi , stop = 0.5 * pi , length = 100 ) |> Vector mu , eta = 0.0 , 0.2 p_tp = [ p_func ( x [ i ], mu , eta ) for i in 1 : length ( x )] dp_tp = [ dp_func ( x [ i ], mu , eta ) for i in 1 : length ( x )] # normalization of the distribution c = trapz ( x , p_tp ) p = p_tp / c dp = dp_tp / c # time length for the evolution tspan = range ( 0. , stop = 1. , length = 1000 ) # dynamics rho = Vector { Matrix { ComplexF64 }}( undef , length ( x )) drho = Vector { Vector { Matrix { ComplexF64 }}}( undef , length ( x )) for i = 1 : length ( x ) H0_tp = H0_func ( x [ i ]) dH_tp = dH_func ( x [ i ]) rho_tp , drho_tp = QuanEstimation . expm ( tspan , rho0 , H0_tp , dH_tp ) rho [ i ], drho [ i ] = rho_tp [ end ], drho_tp [ end ] end # Classical Bayesian bounds f_BCRB1 = QuanEstimation . BCRB ([ x ], p , dp , rho , drho ; btype = 1 ) f_BCRB2 = QuanEstimation . BCRB ([ x ], p , dp , rho , drho ; btype = 2 ) f_BCRB3 = QuanEstimation . BCRB ([ x ], p , dp , rho , drho ; btype = 3 ) f_VTB = QuanEstimation . VTB ([ x ], p , dp , rho , drho ) # Quantum Bayesian bounds f_BQCRB1 = QuanEstimation . BQCRB ([ x ], p , dp , rho , drho , btype = 1 ) f_BQCRB2 = QuanEstimation . BQCRB ([ x ], p , dp , rho , drho , btype = 2 ) f_BQCRB3 = QuanEstimation . BQCRB ([ x ], p , dp , rho , drho , btype = 3 ) f_QVTB = QuanEstimation . QVTB ([ x ], p , dp , rho , drho ) f_QZZB = QuanEstimation . QZZB ([ x ], p , rho )","title":"Quantum Ziv-Zakai bound"},{"location":"guide/guide_bounds/#bayesian-estimation","text":"In QuanEstimation, two types of Bayesian estimation are considered including maximum a posteriori estimation (MAP) and maximum likelihood estimation (MLE). In Bayesian estimation, the prior distribution is updated as \\begin{align} p(\\textbf{x}|y)=\\frac{p(y|\\textbf{x})p(\\textbf{x})}{\\int p(y|\\textbf{x})p(\\textbf{x}) \\mathrm{d}\\textbf{x}} \\end{align} with \\(p(\\textbf{x})\\) the current prior distribution and \\(y\\) the outcome of the experiment. In practice, the prior distribution is replaced with \\(p(\\textbf{x}|y)\\) and the estimated value of \\(\\textbf{x}\\) can be evaluated by Python Bayes ( x , p , rho , y , M = [], estimator = \"mean\" , savefile = False ) MLE ( x , rho , y , M = [], savefile = False ) where x is a list of arrays representing the regimes of the parameters for the integral and p is an array representing the prior distribution. For multiparameter estimation, p is multidimensional. The input varible rho is a multidimensional list with the dimensions as x representing the parameterized density matrix. M contains a set of positive operator-valued measure (POVM). In QuanEstimation, a set of rank-one symmetric informationally complete POVM (SIC-POVM) is used when M=[] . SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from here . eatimator in Bayes() representing the estimators which is defaulted by the mean value of the paramters. Also, it can be set as MAP . The posterior distributions (likelihood function) in the final iteration and the estimated values in all iterations will be saved in \"pout.npy\" (\"Lout.npy\") and \"xout.npy\" if savefile=False . However, if the users want to save all the posterior distributions (likelihood function) and the estimated values in all iterations, the variable savefile needs to be set to True . Julia Bayes ( x , p , rho , y ; M = missing , estimator = \"mean\" , savefile = false ) MLE ( x , rho , y ; M = missing , savefile = false ) where x is a list of arrays representing the regimes of the parameters for the integral and p is an array representing the prior distribution. For multiparameter estimation, p is multidimensional. The input varible rho is a multidimensional list with the dimensions as x representing the parameterized density matrix. M contains a set of positive operator-valued measure (POVM). In QuanEstimation, a set of rank-one symmetric informationally complete POVM (SIC-POVM) is used when M=missing . SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from here . eatimator in Bayes() representing the estimators which is defaulted by the mean value of the paramters. Also, it can be set as MAP . The posterior distributions (likelihood function) in the final iteration and the estimated values in all iterations will be saved in \"pout.csv\" (\"Lout.csv\") and \"xout.csv\" if savefile=false . However, if the users want to save all the posterior distributions (likelihood function) and the estimated values in all iterations, the variable savefile needs to be set to true . Example 3.9 The Hamiltonian of a qubit system is \\begin{align} H=\\frac{B\\omega_0}{2}(\\sigma_1\\cos{x}+\\sigma_3\\sin{x}), \\end{align} where \\(B\\) is the magnetic field in the XZ plane, \\(x\\) is the unknown parameter and \\(\\sigma_{1}\\) , \\(\\sigma_{3}\\) are the Pauli matrices. The probe state is taken as \\(|\\pm\\rangle\\) . The measurement is \\(\\{|\\!+\\rangle\\langle+\\!|,|\\!-\\rangle\\langle-\\!|\\}\\) . Here \\(|\\pm\\rangle:=\\frac{1}{\\sqrt{2}} (|0\\rangle\\pm|1\\rangle)\\) with \\(|0\\rangle\\) \\((|1\\rangle)\\) the eigenstate of \\(\\sigma_3\\) with respect to the eigenvalue \\(1\\) \\((-1)\\) . In this example, the prior distribution \\(p(x)\\) is uniform on \\([0, \\pi/2]\\) . Python from quanestimation import * import numpy as np import random # initial state rho0 = 0.5 * np . array ([[ 1. , 1. ], [ 1. , 1. ]]) # free Hamiltonian B , omega0 = np . pi / 2.0 , 1.0 sx = np . array ([[ 0. , 1. ], [ 1. , 0. ]]) sy = np . array ([[ 0. , - 1. j ], [ 1. j , 0. ]]) sz = np . array ([[ 1. , 0. ], [ 0. , - 1. ]]) H0_func = lambda x : 0.5 * B * omega0 * ( sx * np . cos ( x ) + sz * np . sin ( x )) # derivative of the free Hamiltonian on x dH_func = lambda x : [ 0.5 * B * omega0 * ( - sx * np . sin ( x ) + sz * np . cos ( x ))] # measurement M1 = 0.5 * np . array ([[ 1. , 1. ], [ 1. , 1. ]]) M2 = 0.5 * np . array ([[ 1. , - 1. ], [ - 1. , 1. ]]) M = [ M1 , M2 ] # prior distribution x = np . linspace ( 0. , 0.5 * np . pi , 1000 ) p = ( 1.0 / ( x [ - 1 ] - x [ 0 ])) * np . ones ( len ( x )) # time length for the evolution tspan = np . linspace ( 0. , 1. , 1000 ) # dynamics rho = [ np . zeros (( len ( rho0 ), len ( rho0 )), dtype = np . complex128 ) \\ for i in range ( len ( x ))] for i in range ( len ( x )): H0 = H0_func ( x [ i ]) dH = dH_func ( x [ i ]) dynamics = Lindblad ( tspan , rho0 , H0 , dH ) rho_tp , drho_tp = dynamics . expm () rho [ i ] = rho_tp [ - 1 ] # Generation of the experimental results y = [ 0 for i in range ( 500 )] res_rand = random . sample ( range ( 0 , len ( y )), 125 ) for i in range ( len ( res_rand )): y [ res_rand [ i ]] = 1 # Maximum a posteriori estimation pout , xout = Bayes ([ x ], p , rho , y , M = M , estimator = \"MAP\" , \\ savefile = False ) # Maximum likelihood estimation Lout , xout = MLE ([ x ], rho , y , M = M , savefile = False ) Julia using QuanEstimation using Random using StatsBase # free Hamiltonian function H0_func ( x ) return 0.5 * B * omega0 * ( sx * cos ( x ) + sz * sin ( x )) end # derivative of the free Hamiltonian on x function dH_func ( x ) return [ 0.5 * B * omega0 * ( - sx * sin ( x ) + sz * cos ( x ))] end B , omega0 = pi / 2.0 , 1.0 sx = [ 0. 1. ; 1. 0.0 im ] sy = [ 0. - im ; im 0. ] sz = [ 1. 0.0 im ; 0. - 1. ] # initial state rho0 = 0.5 * ones ( 2 , 2 ) # measurement M1 = 0.5 * [ 1.0 + 0.0 im 1. ; 1. 1. ] M2 = 0.5 * [ 1.0 + 0.0 im - 1. ; - 1. 1. ] M = [ M1 , M2 ] # prior distribution x = range ( 0. , stop = 0.5 * pi , length = 100 ) |> Vector p = ( 1.0 / ( x [ end ] - x [ 1 ])) * ones ( length ( x )) # time length for the evolution tspan = range ( 0. , stop = 1. , length = 1000 ) # dynamics rho = Vector { Matrix { ComplexF64 }}( undef , length ( x )) for i = 1 : length ( x ) H0_tp = H0_func ( x [ i ]) dH_tp = dH_func ( x [ i ]) rho_tp , drho_tp = QuanEstimation . expm ( tspan , rho0 , H0_tp , dH_tp ) rho [ i ] = rho_tp [ end ] end # Generation of the experimental results Random . seed! ( 1234 ) y = [ 0 for i in 1 : 500 ] res_rand = sample ( 1 : length ( y ), 125 , replace = false ) for i in 1 : length ( res_rand ) y [ res_rand [ i ]] = 1 end # Maximum a posteriori estimation pout , xout = QuanEstimation . Bayes ([ x ], p , rho , y ; M = M , estimator = \"MAP\" , savefile = false ) # Maximum likelihood estimation Lout , xout = QuanEstimation . MLE ([ x ], rho , y , M = M ; savefile = false ) The average Bayesian cost [11] for a quadratic cost function can be calculated via \\begin{equation} \\bar{C}:=\\int p(\\textbf{x})\\sum_y p(y|\\textbf{x})(\\textbf{x}-\\hat{\\textbf{x}})^{\\mathrm{T}} W(\\textbf{x}-\\hat{\\textbf{x}})\\,\\mathrm{d}\\textbf{x} \\end{equation} In QuanEstimation, this can be realized by calling Python BayesCost ( x , p , xest , rho , y , M , W = [], eps = 1e-8 ) Julia BayesCost ( x , p , xest , rho , y , M ; W = missing , eps = 1e-8 ) xest represents the estimators for the parameters. Besides, the average Bayesian cost bounded by [5] \\begin{equation} \\bar{C}\\geq\\int p(\\textbf{x})\\left(\\textbf{x}^{\\mathrm{T}}W\\textbf{x}\\right)\\mathrm{d}\\textbf{x} -\\sum_{ab}W_{ab}\\mathrm{Tr}\\left(\\bar{\\rho}\\bar{L}_a \\bar{L}_b\\right), \\label{eq:BCB} \\end{equation} and for single-parameter scenario, this inequality reduces to \\begin{equation} \\bar{C}\\geq \\int p(x) x^2\\,\\mathrm{d}x-\\mathrm{Tr}(\\bar{\\rho}\\bar{L}^2). \\end{equation} The function for calculating the Bayesian cost bound (BCB) is Python BCB ( x , p , rho , W = [], eps = 1e-8 ) Julia BCB ( x , p , rho ; W = missing , eps = 1e-8 ) Example 3.10 The Hamiltonian of a qubit system is \\begin{align} H=\\frac{B\\omega_0}{2}(\\sigma_1\\cos{x}+\\sigma_3\\sin{x}), \\end{align} where \\(B\\) is the magnetic field in the XZ plane, \\(x\\) is the unknown parameter and \\(\\sigma_{1}\\) , \\(\\sigma_{3}\\) are the Pauli matrices. The probe state is taken as \\(|\\pm\\rangle\\) . The measurement is \\(\\{|\\!+\\rangle\\langle+\\!|,|\\!-\\rangle\\langle-\\!|\\}\\) . Here \\(|\\pm\\rangle:=\\frac{1}{\\sqrt{2}} (|0\\rangle\\pm|1\\rangle)\\) with \\(|0\\rangle\\) \\((|1\\rangle)\\) the eigenstate of \\(\\sigma_3\\) with respect to the eigenvalue \\(1\\) \\((-1)\\) . In this example, the prior distribution \\(p(x)\\) is uniform on \\([0, \\pi/2]\\) . Python from quanestimation import * import numpy as np import random # initial state rho0 = 0.5 * np . array ([[ 1. , 1. ], [ 1. , 1. ]]) # free Hamiltonian B , omega0 = np . pi / 2.0 , 1.0 sx = np . array ([[ 0. , 1. ], [ 1. , 0. ]]) sy = np . array ([[ 0. , - 1. j ], [ 1. j , 0. ]]) sz = np . array ([[ 1. , 0. ], [ 0. , - 1. ]]) H0_func = lambda x : 0.5 * B * omega0 * ( sx * np . cos ( x ) + sz * np . sin ( x )) # derivative of the free Hamiltonian on x dH_func = lambda x : [ 0.5 * B * omega0 * ( - sx * np . sin ( x ) + sz * np . cos ( x ))] # measurement M1 = 0.5 * np . array ([[ 1. , 1. ], [ 1. , 1. ]]) M2 = 0.5 * np . array ([[ 1. , - 1. ], [ - 1. , 1. ]]) M = [ M1 , M2 ] # prior distribution x = np . linspace ( 0. , 0.5 * np . pi , 1000 ) p = ( 1.0 / ( x [ - 1 ] - x [ 0 ])) * np . ones ( len ( x )) # time length for the evolution tspan = np . linspace ( 0. , 1. , 1000 ) # dynamics rho = [ np . zeros (( len ( rho0 ), len ( rho0 )), dtype = np . complex128 ) \\ for i in range ( len ( x ))] for i in range ( len ( x )): H0 = H0_func ( x [ i ]) dH = dH_func ( x [ i ]) dynamics = Lindblad ( tspan , rho0 , H0 , dH ) rho_tp , drho_tp = dynamics . expm () rho [ i ] = rho_tp [ - 1 ] # average Bayesian cost M = SIC ( 2 ) xest = [ np . array ([ 0.8 ]), np . array ([ 0.9 ]), np . array ([ 1.0 ]), np . array ([ 1.2 ])] C = BayesCost ([ x ], p , xest , rho , M , eps = 1e-8 ) # Bayesian cost Bound C = BCB ([ x ], p , rho , eps = 1e-8 ) Julia using QuanEstimation using Random using StatsBase # free Hamiltonian function H0_func ( x ) return 0.5 * B * omega0 * ( sx * cos ( x ) + sz * sin ( x )) end # derivative of the free Hamiltonian on x function dH_func ( x ) return [ 0.5 * B * omega0 * ( - sx * sin ( x ) + sz * cos ( x ))] end B , omega0 = pi / 2.0 , 1.0 sx = [ 0. 1. ; 1. 0.0 im ] sy = [ 0. - im ; im 0. ] sz = [ 1. 0.0 im ; 0. - 1. ] # initial state rho0 = 0.5 * ones ( 2 , 2 ) # measurement M1 = 0.5 * [ 1.0 + 0.0 im 1. ; 1. 1. ] M2 = 0.5 * [ 1.0 + 0.0 im - 1. ; - 1. 1. ] M = [ M1 , M2 ] # prior distribution x = range ( 0. , stop = 0.5 * pi , length = 100 ) |> Vector p = ( 1.0 / ( x [ end ] - x [ 1 ])) * ones ( length ( x )) # time length for the evolution tspan = range ( 0. , stop = 1. , length = 1000 ) # dynamics rho = Vector { Matrix { ComplexF64 }}( undef , length ( x )) for i = 1 : length ( x ) H0_tp = H0_func ( x [ i ]) dH_tp = dH_func ( x [ i ]) rho_tp , drho_tp = QuanEstimation . expm ( tspan , rho0 , H0_tp , dH_tp ) rho [ i ] = rho_tp [ end ] end # average Bayesian cost M = QuanEstimation . SIC ( 2 ) xest = [[ 0.8 ], [ 0.9 ], [ 1.0 ], [ 1.2 ]] C = QuanEstimation . BayesCost ([ x ], p , xest , rho , M , eps = 1e-8 ) # Bayesian cost Bound C = QuanEstimation . BCB ([ x ], p , rho , eps = 1e-8 )","title":"Bayesian estimation"},{"location":"guide/guide_bounds/#bibliography","text":"[1] C. W. Helstrom, Quantum Detection and Estimation Theory (New York: Academic, 1976). [2] A. S. Holevo, Probabilistic and Statistical Aspects of Quantum Theory (Amsterdam: North-Holland, 1982). [3] J. Liu, H. Yuan, X.-M. Lu, and X. Wang, Quantum Fisher information matrix and multiparameter estimation, J. Phys. A: Math. Theor. 53 , 023001 (2020). [4] A. S Holevo, Statistical decision theory for quantum systems, J. Multivariate Anal. 3 , 337-394 (1973). [5] R. Demkowicz-Dobrza\u0144ski, W. G\u00f3recki, and M. Gu\u0163\u0103, Multi-parameter estimation beyond Quantum Fisher Information, J. Phys. A: Math. Theor. 53 , 363001 (2020). [6] J. Liu and H. Yuan, Valid lower bound for all estimators in quantum parameter estimation, New J. Phys. 18 , 093009 (2016). [7] H. L. Van Trees, Detection, estimation, and modulation theory: Part I (Wiley, New York, 1968). [8] W. Zhong, Z. Sun, J. Ma, X. Wang, and F. Nori, Fisher information under decoherence in Bloch representation, Phys. Rev. A 87 , 022337 (2013). [9] M. Tsang, H. M. Wiseman, and C. M. Caves, Fundamental quantum limit to waveform estimation, Phys. Rev. Lett. 106 , 090401 (2011). [10] D. \u0160afr\u00e1nek, Estimation of Gaussian quantum states, J. Phys. A: Math. Theor. 52 , 035304 (2019). [11] C. P. Robert, The Bayesian Choice (Berlin: Springer, 2007).","title":"Bibliography"},{"location":"guide/guide_dynamics/","text":"Parameterization process \u00b6 In QuanEstimation, two types of parameterization processes are considered. The first one is the master equation of the form \\[\\begin{align} \\partial_t\\rho &=\\mathcal{L}\\rho \\nonumber \\\\ &=-i[H,\\rho]+\\sum_i \\gamma_i\\left(\\Gamma_i\\rho\\Gamma^{\\dagger}_i-\\frac{1}{2} \\left\\{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\right\\}\\right), \\end{align}\\] where \\(\\rho\\) is the evolved density matrix, \\(H\\) is the Hamiltonian of the system, \\(\\Gamma_i\\) and \\(\\gamma_i\\) are the \\(i\\mathrm{th}\\) decay operator and the corresponding decay rate. Numerically, the evolved state at \\(j\\) th time interval is obtained by \\(\\rho_j=e^{\\Delta t\\mathcal{L}} \\rho_{j-1}\\) with \\(\\Delta t\\) the time interval. The derivatives of \\(\\rho_j\\) on \\(\\textbf{x}\\) is calculated via \\(\\partial_{\\textbf{x}}\\rho_j =\\Delta t(\\partial_{\\textbf{x}}\\mathcal{L})\\rho_j +e^{\\Delta t \\mathcal{L}}(\\partial_{\\textbf{x}}\\rho_{j-1}),\\) where \\(\\rho_{j-1}\\) is the evolved density matrix at \\((j-1)\\) th time interval. The evolved density matrix \\(\\rho\\) and its derivatives ( \\(\\partial_{\\textbf{x}}\\rho\\) ) with respect to \\(\\textbf{x}\\) can be calculated via the codes Python dynamics = Lindblad ( tspan , rho0 , H0 , dH , decay = [], Hc = [], ctrl = []) rho , drho = dynamics . expm () Here tspan is the time length for the evolution, rho0 represents the density matrix of the probe state, H0 and dH are the free Hamiltonian and its derivatives with respect to the unknown parameters to be estimated. The variable H0 is a matrix when the free Hamiltonian is time-independent and a list with the length equal to tspan when it is time-dependent. dH should be input as \\([\\partial_a{H_0}, \\partial_b{H_0}, \\cdots]\\) . decay contains decay operators \\((\\Gamma_1, \\Gamma_2, \\cdots)\\) and the corresponding decay rates \\((\\gamma_1, \\gamma_2, \\cdots)\\) with the input rule decay=[[ \\(\\Gamma_1\\) , \\(\\gamma_1\\) ], [ \\(\\Gamma_2\\) , \\(\\gamma_2\\) ],...]. Hc and ctrl are two lists represent the control Hamiltonians and the corresponding control coefficients. The default values for decay , Hc and ctrl are [] which means the dynamics is unitary and only governed by the free Hamiltonian. The output ( rho and drho ) of this class by calling dynamics.expm() are two lists with the length equal to tspan . Here rho represents the parameterized density matrix and drho is the corresponding derivatives with respect to all the parameters, the \\(i\\) th entry of drho is \\([\\partial_a{\\rho},\\partial_b{\\rho},\\cdots].\\) Julia rho , drho = expm ( tspan , rho0 , H0 , dH , decay = missing , Hc = missing , ctrl = missing ) Here tspan is the time length for the evolution, rho0 represents the density matrix of the probe state, H0 and dH are the free Hamiltonian and its derivatives with respect to the unknown parameters to be estimated. The variable H0 is a matrix when the free Hamiltonian is time-independent and a list with the length equal to tspan when it is time-dependent. dH should be input as \\([\\partial_a{H_0}, \\partial_b{H_0}, \\cdots]\\) . decay contains decay operators \\((\\Gamma_1, \\Gamma_2, \\cdots)\\) and the corresponding decay rates \\((\\gamma_1, \\gamma_2, \\cdots)\\) with the input rule decay=[[ \\(\\Gamma_1\\) , \\(\\gamma_1\\) ], [ \\(\\Gamma_2\\) , \\(\\gamma_2\\) ],...]. Hc and ctrl are two lists represent the control Hamiltonians and the corresponding control coefficients. The default values for decay , Hc and ctrl are missing which means the dynamics is unitary and only governed by the free Hamiltonian. The output ( rho and drho ) of this function by calling expm() are two lists with the length equal to tspan . Here rho represents the parameterized density matrix and drho is the corresponding derivatives with respect to all the parameters, the \\(i\\) th entry of drho is \\([\\partial_a{\\rho},\\partial_b{\\rho},\\cdots].\\) Example 2.1 In this example, the free evolution Hamiltonian of a single qubit system is \\(H_0=\\frac{1}{2} \\omega \\sigma_3\\) with \\(\\omega\\) the frequency and \\(\\sigma_3\\) a Pauli matrix. The dynamics of the system is governed by \\begin{align} \\partial_t\\rho=-i[H_0, \\rho], \\end{align} where \\(\\rho\\) is the parameterized density matrix. The probe state is taken as \\(|+\\rangle\\langle+|\\) with \\(|+\\rangle=\\frac{1}{\\sqrt{2}}(|0\\rangle+|1\\rangle)\\) . Here \\(|0\\rangle\\) \\((|1\\rangle)\\) is the eigenstate of \\(\\sigma_3\\) with respect to the eigenvalue \\(1\\) \\((-1)\\) . Python from quanestimation import * import numpy as np # initial state rho0 = 0.5 * np . array ([[ 1. , 1. ], [ 1. , 1. ]]) # free Hamiltonian omega = 1.0 sz = np . array ([[ 1. , 0. ], [ 0. , - 1. ]]) H0 = 0.5 * omega * sz # derivative of the free Hamiltonian on omega dH = [ 0.5 * sz ] # time length for the evolution tspan = np . linspace ( 0. , 10. , 2500 ) # dynamics dynamics = Lindblad ( tspan , rho0 , H0 , dH ) rho , drho = dynamics . expm () Julia using QuanEstimation # initial state rho0 = 0.5 * ones ( 2 , 2 ) # free Hamiltonian omega = 1.0 sz = [ 1. 0.0 im ; 0. - 1. ] H0 = 0.5 * omega * sz # derivative of the free Hamiltonian on omega dH = [ 0.5 * sz ] # time length for the evolution tspan = range ( 0. , 10. , length = 2500 ) # dynamics rho , drho = QuanEstimation . expm ( tspan , rho0 , H0 , dH ) The parameterization process can also be implemented with the Kraus operators. In this case, the parameterized density matrix and its derivatives with respect to the unknown parameters can be calculated via \\begin{align} \\rho=\\sum_i K_i\\rho_0K_i^{\\dagger}, \\end{align} \\[\\begin{align} \\partial_{\\textbf{x}}\\rho=\\sum_i \\partial_{\\textbf{x}}K_i\\rho_0K_i^{\\dagger} + K_i\\rho_0\\partial_{\\textbf{x}}K_i^{\\dagger}, \\end{align}\\] where \\(K_i\\) is a Kraus operator satisfying \\(\\sum_{i}K^{\\dagger}_i K_i=I\\) and \\(\\partial_{\\textbf{x}}K_i\\) represents its derivatives with respect to \\(\\textbf{x}\\) . Here \\(I\\) is the identity operator and \\(\\rho_0\\) is the probe state. In QuanEstimation, \\(\\rho\\) and \\(\\partial_{\\textbf{x}}\\rho\\) can be solved by Python rho , drho = Kraus ( rho0 , K , dK ) Julia Kraus = Kraus ( rho0 , K , dK ) rho , drho = evolve ( Kraus ) where K and dK are the Kraus operators and its derivatives with respect to the unknown parameters. Example 2.2 The Kraus operators for the amplitude damping channel are \\[\\begin{eqnarray} K_1 = \\left(\\begin{array}{cc} 1 & 0 \\\\ 0 & \\sqrt{1-\\gamma} \\end{array}\\right), K_2 = \\left(\\begin{array}{cc} 0 & \\sqrt{\\gamma} \\\\ 0 & 0 \\end{array}\\right), \\nonumber \\end{eqnarray}\\] where \\(\\gamma\\) is the decay probability. In this example, the probe state is taken as \\(|+\\rangle\\langle+|\\) with \\(|+\\rangle=\\frac{1}{\\sqrt{2}}(|0\\rangle+ |1\\rangle)\\) . Here \\(|0\\rangle\\) \\((|1\\rangle)\\) is the eigenstate of \\(\\sigma_3\\) with respect to the eigenvalue \\(1\\) \\((-1)\\) . Python from quanestimation import * import numpy as np # initial state rho0 = 0.5 * np . array ([[ 1. , 1. ], [ 1. , 1. ]]) # Kraus operators for the amplitude damping channel gamma = 0.1 K1 = np . array ([[ 1. , 0. ], [ 0. , np . sqrt ( 1 - gamma )]]) K2 = np . array ([[ 0. , np . sqrt ( gamma )], [ 0. , 0. ]]) K = [ K1 , K2 ] # derivatives of Kraus operators on gamma dK1 = np . array ([[ 1. , 0. ], [ 0. , - 0.5 / np . sqrt ( 1 - gamma )]]) dK2 = np . array ([[ 0. , 0.5 / np . sqrt ( gamma )], [ 0. , 0. ]]) dK = [[ dK1 ], [ dK2 ]] # parameterization process rho , drho = Kraus ( rho0 , K , dK ) Julia using QuanEstimation # initial state rho0 = 0.5 * ones ( 2 , 2 ) # Kraus operators for the amplitude damping channel gamma = 0.1 K1 = [ 1. 0. ; 0. sqrt ( 1 - gamma )] K2 = [ 0. sqrt ( gamma ); 0. 0. ] K = [ K1 , K2 ] # derivatives of Kraus operators on gamma dK1 = [ 1. 0. ; 0. - 0.5 / sqrt ( 1 - gamma )] dK2 = [ 0. 0.5 / sqrt ( gamma ); 0. 0. ] dK = [[ dK1 ], [ dK2 ]] # parameterization process Kraus = QuanEstimation . Kraus ( rho0 , K , dK ) rho , drho = QuanEstimation . evolve ( Kraus )","title":"Parameterization process"},{"location":"guide/guide_dynamics/#parameterization-process","text":"In QuanEstimation, two types of parameterization processes are considered. The first one is the master equation of the form \\[\\begin{align} \\partial_t\\rho &=\\mathcal{L}\\rho \\nonumber \\\\ &=-i[H,\\rho]+\\sum_i \\gamma_i\\left(\\Gamma_i\\rho\\Gamma^{\\dagger}_i-\\frac{1}{2} \\left\\{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\right\\}\\right), \\end{align}\\] where \\(\\rho\\) is the evolved density matrix, \\(H\\) is the Hamiltonian of the system, \\(\\Gamma_i\\) and \\(\\gamma_i\\) are the \\(i\\mathrm{th}\\) decay operator and the corresponding decay rate. Numerically, the evolved state at \\(j\\) th time interval is obtained by \\(\\rho_j=e^{\\Delta t\\mathcal{L}} \\rho_{j-1}\\) with \\(\\Delta t\\) the time interval. The derivatives of \\(\\rho_j\\) on \\(\\textbf{x}\\) is calculated via \\(\\partial_{\\textbf{x}}\\rho_j =\\Delta t(\\partial_{\\textbf{x}}\\mathcal{L})\\rho_j +e^{\\Delta t \\mathcal{L}}(\\partial_{\\textbf{x}}\\rho_{j-1}),\\) where \\(\\rho_{j-1}\\) is the evolved density matrix at \\((j-1)\\) th time interval. The evolved density matrix \\(\\rho\\) and its derivatives ( \\(\\partial_{\\textbf{x}}\\rho\\) ) with respect to \\(\\textbf{x}\\) can be calculated via the codes Python dynamics = Lindblad ( tspan , rho0 , H0 , dH , decay = [], Hc = [], ctrl = []) rho , drho = dynamics . expm () Here tspan is the time length for the evolution, rho0 represents the density matrix of the probe state, H0 and dH are the free Hamiltonian and its derivatives with respect to the unknown parameters to be estimated. The variable H0 is a matrix when the free Hamiltonian is time-independent and a list with the length equal to tspan when it is time-dependent. dH should be input as \\([\\partial_a{H_0}, \\partial_b{H_0}, \\cdots]\\) . decay contains decay operators \\((\\Gamma_1, \\Gamma_2, \\cdots)\\) and the corresponding decay rates \\((\\gamma_1, \\gamma_2, \\cdots)\\) with the input rule decay=[[ \\(\\Gamma_1\\) , \\(\\gamma_1\\) ], [ \\(\\Gamma_2\\) , \\(\\gamma_2\\) ],...]. Hc and ctrl are two lists represent the control Hamiltonians and the corresponding control coefficients. The default values for decay , Hc and ctrl are [] which means the dynamics is unitary and only governed by the free Hamiltonian. The output ( rho and drho ) of this class by calling dynamics.expm() are two lists with the length equal to tspan . Here rho represents the parameterized density matrix and drho is the corresponding derivatives with respect to all the parameters, the \\(i\\) th entry of drho is \\([\\partial_a{\\rho},\\partial_b{\\rho},\\cdots].\\) Julia rho , drho = expm ( tspan , rho0 , H0 , dH , decay = missing , Hc = missing , ctrl = missing ) Here tspan is the time length for the evolution, rho0 represents the density matrix of the probe state, H0 and dH are the free Hamiltonian and its derivatives with respect to the unknown parameters to be estimated. The variable H0 is a matrix when the free Hamiltonian is time-independent and a list with the length equal to tspan when it is time-dependent. dH should be input as \\([\\partial_a{H_0}, \\partial_b{H_0}, \\cdots]\\) . decay contains decay operators \\((\\Gamma_1, \\Gamma_2, \\cdots)\\) and the corresponding decay rates \\((\\gamma_1, \\gamma_2, \\cdots)\\) with the input rule decay=[[ \\(\\Gamma_1\\) , \\(\\gamma_1\\) ], [ \\(\\Gamma_2\\) , \\(\\gamma_2\\) ],...]. Hc and ctrl are two lists represent the control Hamiltonians and the corresponding control coefficients. The default values for decay , Hc and ctrl are missing which means the dynamics is unitary and only governed by the free Hamiltonian. The output ( rho and drho ) of this function by calling expm() are two lists with the length equal to tspan . Here rho represents the parameterized density matrix and drho is the corresponding derivatives with respect to all the parameters, the \\(i\\) th entry of drho is \\([\\partial_a{\\rho},\\partial_b{\\rho},\\cdots].\\) Example 2.1 In this example, the free evolution Hamiltonian of a single qubit system is \\(H_0=\\frac{1}{2} \\omega \\sigma_3\\) with \\(\\omega\\) the frequency and \\(\\sigma_3\\) a Pauli matrix. The dynamics of the system is governed by \\begin{align} \\partial_t\\rho=-i[H_0, \\rho], \\end{align} where \\(\\rho\\) is the parameterized density matrix. The probe state is taken as \\(|+\\rangle\\langle+|\\) with \\(|+\\rangle=\\frac{1}{\\sqrt{2}}(|0\\rangle+|1\\rangle)\\) . Here \\(|0\\rangle\\) \\((|1\\rangle)\\) is the eigenstate of \\(\\sigma_3\\) with respect to the eigenvalue \\(1\\) \\((-1)\\) . Python from quanestimation import * import numpy as np # initial state rho0 = 0.5 * np . array ([[ 1. , 1. ], [ 1. , 1. ]]) # free Hamiltonian omega = 1.0 sz = np . array ([[ 1. , 0. ], [ 0. , - 1. ]]) H0 = 0.5 * omega * sz # derivative of the free Hamiltonian on omega dH = [ 0.5 * sz ] # time length for the evolution tspan = np . linspace ( 0. , 10. , 2500 ) # dynamics dynamics = Lindblad ( tspan , rho0 , H0 , dH ) rho , drho = dynamics . expm () Julia using QuanEstimation # initial state rho0 = 0.5 * ones ( 2 , 2 ) # free Hamiltonian omega = 1.0 sz = [ 1. 0.0 im ; 0. - 1. ] H0 = 0.5 * omega * sz # derivative of the free Hamiltonian on omega dH = [ 0.5 * sz ] # time length for the evolution tspan = range ( 0. , 10. , length = 2500 ) # dynamics rho , drho = QuanEstimation . expm ( tspan , rho0 , H0 , dH ) The parameterization process can also be implemented with the Kraus operators. In this case, the parameterized density matrix and its derivatives with respect to the unknown parameters can be calculated via \\begin{align} \\rho=\\sum_i K_i\\rho_0K_i^{\\dagger}, \\end{align} \\[\\begin{align} \\partial_{\\textbf{x}}\\rho=\\sum_i \\partial_{\\textbf{x}}K_i\\rho_0K_i^{\\dagger} + K_i\\rho_0\\partial_{\\textbf{x}}K_i^{\\dagger}, \\end{align}\\] where \\(K_i\\) is a Kraus operator satisfying \\(\\sum_{i}K^{\\dagger}_i K_i=I\\) and \\(\\partial_{\\textbf{x}}K_i\\) represents its derivatives with respect to \\(\\textbf{x}\\) . Here \\(I\\) is the identity operator and \\(\\rho_0\\) is the probe state. In QuanEstimation, \\(\\rho\\) and \\(\\partial_{\\textbf{x}}\\rho\\) can be solved by Python rho , drho = Kraus ( rho0 , K , dK ) Julia Kraus = Kraus ( rho0 , K , dK ) rho , drho = evolve ( Kraus ) where K and dK are the Kraus operators and its derivatives with respect to the unknown parameters. Example 2.2 The Kraus operators for the amplitude damping channel are \\[\\begin{eqnarray} K_1 = \\left(\\begin{array}{cc} 1 & 0 \\\\ 0 & \\sqrt{1-\\gamma} \\end{array}\\right), K_2 = \\left(\\begin{array}{cc} 0 & \\sqrt{\\gamma} \\\\ 0 & 0 \\end{array}\\right), \\nonumber \\end{eqnarray}\\] where \\(\\gamma\\) is the decay probability. In this example, the probe state is taken as \\(|+\\rangle\\langle+|\\) with \\(|+\\rangle=\\frac{1}{\\sqrt{2}}(|0\\rangle+ |1\\rangle)\\) . Here \\(|0\\rangle\\) \\((|1\\rangle)\\) is the eigenstate of \\(\\sigma_3\\) with respect to the eigenvalue \\(1\\) \\((-1)\\) . Python from quanestimation import * import numpy as np # initial state rho0 = 0.5 * np . array ([[ 1. , 1. ], [ 1. , 1. ]]) # Kraus operators for the amplitude damping channel gamma = 0.1 K1 = np . array ([[ 1. , 0. ], [ 0. , np . sqrt ( 1 - gamma )]]) K2 = np . array ([[ 0. , np . sqrt ( gamma )], [ 0. , 0. ]]) K = [ K1 , K2 ] # derivatives of Kraus operators on gamma dK1 = np . array ([[ 1. , 0. ], [ 0. , - 0.5 / np . sqrt ( 1 - gamma )]]) dK2 = np . array ([[ 0. , 0.5 / np . sqrt ( gamma )], [ 0. , 0. ]]) dK = [[ dK1 ], [ dK2 ]] # parameterization process rho , drho = Kraus ( rho0 , K , dK ) Julia using QuanEstimation # initial state rho0 = 0.5 * ones ( 2 , 2 ) # Kraus operators for the amplitude damping channel gamma = 0.1 K1 = [ 1. 0. ; 0. sqrt ( 1 - gamma )] K2 = [ 0. sqrt ( gamma ); 0. 0. ] K = [ K1 , K2 ] # derivatives of Kraus operators on gamma dK1 = [ 1. 0. ; 0. - 0.5 / sqrt ( 1 - gamma )] dK2 = [ 0. 0.5 / sqrt ( gamma ); 0. 0. ] dK = [[ dK1 ], [ dK2 ]] # parameterization process Kraus = QuanEstimation . Kraus ( rho0 , K , dK ) rho , drho = QuanEstimation . evolve ( Kraus )","title":"Parameterization process"},{"location":"guide/guide_import/","text":"Getting started \u00b6 To load QuanEstimation, start with the statement: Python from quanestimation import * Julia using quanestimation","title":"Getting started"},{"location":"guide/guide_import/#getting-started","text":"To load QuanEstimation, start with the statement: Python from quanestimation import * Julia using quanestimation","title":"Getting started"},{"location":"guide/guide_resources/","text":"Metrological resources \u00b6 The metrological resources that QuanEstimation can calculate are spin squeezing and the minimum time to reach the given target. The spin squeezing can be calculated via the function: Python SpinSqueezing ( rho , basis = \"Dicke\" , output = \"KU\" ) Julia SpinSqueezing ( rho ; basis = \"Dicke\" , output = \"KU\" ) rho represents the density matrix of the state. In this function, the basis of the state can be Dicke basis or the original basis of each spin, which can be adjusted by setting basis=\"Dicke\" or basis=\"Pauli\" . The variable output represents the type of spin squeezing calculation. output=\"KU\" represents the spin squeezing defined by Kitagawa and Ueda [1] and output=\"WBIMH\" calculates the spin squeezing defined by Wineland et al. [2] . Example 4.1 In this example, QuTip [3,4] is used to generate spin coherent state. Python from quanestimation import * import numpy as np from qutip import spin_coherent # generation of spin coherent state with QuTip j = 2 theta = 0.5 * np . pi phi = 0.5 * np . pi rho_CSS = spin_coherent ( j , theta , phi , type = 'dm' ) . full () xi = SpinSqueezing ( rho_CSS , basis = \"Dicke\" , output = \"KU\" ) Julia using QuanEstimation using SparseArrays # generation of the coherent spin state j , theta , phi = 2 , 0.5 pi , 0.5 pi Jp = Matrix ( spdiagm ( 1 => [ sqrt ( j * ( j + 1 ) - m * ( m + 1 )) for m in j :- 1 :- j ][ 2 : end ])) Jm = Jp ' psi0 = exp ( 0.5 * theta * exp ( im * phi ) * Jm - 0.5 * theta * exp ( - im * phi ) * Jp ) * QuanEstimation . basis ( Int ( 2 * j + 1 ), 1 ) rho = psi0 * psi0 ' xi = QuanEstimation . SpinSqueezing ( rho ; basis = \"Dicke\" , output = \"KU\" ) Calculation of the minimum time to reach a given precision limit with Python TargetTime ( f , tspan , func , * args , ** kwargs ) where f is the given value of the objective function and tspan is the time length for the evolution. func represents the function for calculating the objective function, *args and **kwargs are the corresponding input parameters and the keyword arguments. Julia TargetTime ( f , tspan , func , args ... ; kwargs ... ) where f is the given value of the objective function and tspan is the time length for the evolution. func represents the function for calculating the objective function, args... and kwargs... are the corresponding input parameters and the keyword arguments. Example 4.2 In this example, the free evolution Hamiltonian of a single qubit system is \\(H_0=\\frac{1}{2} \\omega \\sigma_3\\) with \\(\\omega\\) the frequency and \\(\\sigma_3\\) a Pauli matrix. The dynamics of the system is governed by \\begin{align} \\partial_t\\rho=-i[H_0, \\rho], \\end{align} where \\(\\rho\\) is the parameterized density matrix. The probe state is taken as \\(|+\\rangle\\langle+|\\) with \\(|+\\rangle=\\frac{1}{\\sqrt{2}}(|0\\rangle+|1\\rangle)\\) . Here \\(|0\\rangle\\) \\((|1\\rangle)\\) is the eigenstate of \\(\\sigma_3\\) with respect to the eigenvalue \\(1\\) \\((-1)\\) . Python from quanestimation import * import numpy as np # initial state rho0 = 0.5 * np . array ([[ 1. , 1. ], [ 1. , 1. ]]) # free Hamiltonian omega = 1.0 sz = np . array ([[ 1. , 0. ], [ 0. , - 1. ]]) H0 = 0.5 * omega * sz # derivative of the free Hamiltonian on omega dH = [ 0.5 * sz ] # time length for the evolution tspan = np . linspace ( 0. , 50. , 2000 ) # dynamics dynamics = Lindblad ( tspan , rho0 , H0 , dH ) rho , drho = dynamics . expm () # the value of the objective function f = 20.0 t = TargetTime ( f , tspan , QFIM , rho , drho ) Julia using QuanEstimation # initial state rho0 = 0.5 * ones ( 2 , 2 ) # free Hamiltonian omega = 1.0 sx = [ 0. 1. ; 1. 0.0 im ] sy = [ 0. - im ; im 0. ] sz = [ 1. 0.0 im ; 0. - 1. ] H0 = 0.5 * omega * sz # derivative of the free Hamiltonian on omega dH = [ 0.5 * sz ] # time length for the evolution tspan = range ( 0. , 50. , length = 2000 ) # dynamics rho , drho = QuanEstimation . expm ( tspan , rho0 , H0 , dH ) drho = [ drho [ i ][ 1 ] for i in 1 : 2000 ] # the value of the objective function f = 20 t = QuanEstimation . TargetTime ( f , tspan , QuanEstimation . QFIM , rho , drho ) Bibliography \u00b6 [1] M. Kitagawa and M. Ueda, Squeezed spin states, Phys. Rev. A 47 , 5138 (1993). [2] D. J. Wineland, J. J. Bollinger, W. M. Itano, F. L. Moore, and D. J. Heinzen, Spin squeezing and reduced quantum noise in spectroscopy, Phys. Rev. A 46 , R6797(R) (1992). [3] J. R. Johansson, P. D. Nation, and F. Nori, QuTiP: An open-source Python framework for the dynamics of open quantum systems, Comp. Phys. Comm. 183 , 1760 (2012). [4] J. R. Johansson, P. D. Nation, and F. Nori, QuTiP 2: A Python framework for the dynamics of open quantum systems, Comp. Phys. Comm. 184 , 1234 (2013).","title":"Metrological resources"},{"location":"guide/guide_resources/#metrological-resources","text":"The metrological resources that QuanEstimation can calculate are spin squeezing and the minimum time to reach the given target. The spin squeezing can be calculated via the function: Python SpinSqueezing ( rho , basis = \"Dicke\" , output = \"KU\" ) Julia SpinSqueezing ( rho ; basis = \"Dicke\" , output = \"KU\" ) rho represents the density matrix of the state. In this function, the basis of the state can be Dicke basis or the original basis of each spin, which can be adjusted by setting basis=\"Dicke\" or basis=\"Pauli\" . The variable output represents the type of spin squeezing calculation. output=\"KU\" represents the spin squeezing defined by Kitagawa and Ueda [1] and output=\"WBIMH\" calculates the spin squeezing defined by Wineland et al. [2] . Example 4.1 In this example, QuTip [3,4] is used to generate spin coherent state. Python from quanestimation import * import numpy as np from qutip import spin_coherent # generation of spin coherent state with QuTip j = 2 theta = 0.5 * np . pi phi = 0.5 * np . pi rho_CSS = spin_coherent ( j , theta , phi , type = 'dm' ) . full () xi = SpinSqueezing ( rho_CSS , basis = \"Dicke\" , output = \"KU\" ) Julia using QuanEstimation using SparseArrays # generation of the coherent spin state j , theta , phi = 2 , 0.5 pi , 0.5 pi Jp = Matrix ( spdiagm ( 1 => [ sqrt ( j * ( j + 1 ) - m * ( m + 1 )) for m in j :- 1 :- j ][ 2 : end ])) Jm = Jp ' psi0 = exp ( 0.5 * theta * exp ( im * phi ) * Jm - 0.5 * theta * exp ( - im * phi ) * Jp ) * QuanEstimation . basis ( Int ( 2 * j + 1 ), 1 ) rho = psi0 * psi0 ' xi = QuanEstimation . SpinSqueezing ( rho ; basis = \"Dicke\" , output = \"KU\" ) Calculation of the minimum time to reach a given precision limit with Python TargetTime ( f , tspan , func , * args , ** kwargs ) where f is the given value of the objective function and tspan is the time length for the evolution. func represents the function for calculating the objective function, *args and **kwargs are the corresponding input parameters and the keyword arguments. Julia TargetTime ( f , tspan , func , args ... ; kwargs ... ) where f is the given value of the objective function and tspan is the time length for the evolution. func represents the function for calculating the objective function, args... and kwargs... are the corresponding input parameters and the keyword arguments. Example 4.2 In this example, the free evolution Hamiltonian of a single qubit system is \\(H_0=\\frac{1}{2} \\omega \\sigma_3\\) with \\(\\omega\\) the frequency and \\(\\sigma_3\\) a Pauli matrix. The dynamics of the system is governed by \\begin{align} \\partial_t\\rho=-i[H_0, \\rho], \\end{align} where \\(\\rho\\) is the parameterized density matrix. The probe state is taken as \\(|+\\rangle\\langle+|\\) with \\(|+\\rangle=\\frac{1}{\\sqrt{2}}(|0\\rangle+|1\\rangle)\\) . Here \\(|0\\rangle\\) \\((|1\\rangle)\\) is the eigenstate of \\(\\sigma_3\\) with respect to the eigenvalue \\(1\\) \\((-1)\\) . Python from quanestimation import * import numpy as np # initial state rho0 = 0.5 * np . array ([[ 1. , 1. ], [ 1. , 1. ]]) # free Hamiltonian omega = 1.0 sz = np . array ([[ 1. , 0. ], [ 0. , - 1. ]]) H0 = 0.5 * omega * sz # derivative of the free Hamiltonian on omega dH = [ 0.5 * sz ] # time length for the evolution tspan = np . linspace ( 0. , 50. , 2000 ) # dynamics dynamics = Lindblad ( tspan , rho0 , H0 , dH ) rho , drho = dynamics . expm () # the value of the objective function f = 20.0 t = TargetTime ( f , tspan , QFIM , rho , drho ) Julia using QuanEstimation # initial state rho0 = 0.5 * ones ( 2 , 2 ) # free Hamiltonian omega = 1.0 sx = [ 0. 1. ; 1. 0.0 im ] sy = [ 0. - im ; im 0. ] sz = [ 1. 0.0 im ; 0. - 1. ] H0 = 0.5 * omega * sz # derivative of the free Hamiltonian on omega dH = [ 0.5 * sz ] # time length for the evolution tspan = range ( 0. , 50. , length = 2000 ) # dynamics rho , drho = QuanEstimation . expm ( tspan , rho0 , H0 , dH ) drho = [ drho [ i ][ 1 ] for i in 1 : 2000 ] # the value of the objective function f = 20 t = QuanEstimation . TargetTime ( f , tspan , QuanEstimation . QFIM , rho , drho )","title":"Metrological resources"},{"location":"guide/guide_resources/#bibliography","text":"[1] M. Kitagawa and M. Ueda, Squeezed spin states, Phys. Rev. A 47 , 5138 (1993). [2] D. J. Wineland, J. J. Bollinger, W. M. Itano, F. L. Moore, and D. J. Heinzen, Spin squeezing and reduced quantum noise in spectroscopy, Phys. Rev. A 46 , R6797(R) (1992). [3] J. R. Johansson, P. D. Nation, and F. Nori, QuTiP: An open-source Python framework for the dynamics of open quantum systems, Comp. Phys. Comm. 183 , 1760 (2012). [4] J. R. Johansson, P. D. Nation, and F. Nori, QuTiP 2: A Python framework for the dynamics of open quantum systems, Comp. Phys. Comm. 184 , 1234 (2013).","title":"Bibliography"}]}