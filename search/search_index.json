{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the QuanEstimation","text":"<p>QuanEstimation is a Python-Julia-based open-source toolkit for quantum parameter estimation, which consist in the calculation of  the quantum metrological tools and quantum resources, and the optimizations with respect to the probe states, the controls or  the measurements, as well as comprehensive optimizations in quantum metrology. Futhermore, QuanEstimation can generate not only  optimal quantum parameter estimation schemes, but also adaptive measurement schemes.The package structure of QuanEstimation can  be seen in the following figure:</p> <p> </p> The package structure of QuanEstimation. The blue boxes and the light blue boxes reprsent   the folders and the python files. The orange boxes and the gray boxes represent the classes and the    functions. In the figure, the functions which are circled by dotted lines represent the wrapped Julia    methods that are calculated in Julia.    <p>The package contains several well-used metrological tools, such as quantum (classical)  Cram\u00e9r-Rao bounds, Hevolo Cram\u00e9r-Rao bound and Bayesian versions of quantum (classical)  Cram\u00e9r-Rao bounds, quantum Ziv-Zakai bound, and Bayesian estimation. The users can use these bounds as the objective functions to optimize the probe state, control, measurement and  simultaneous optimizations among them. The optimization methods include the gradient-based  algorithms such as the gradient ascent pulse engineering (GRAPE), GRAPE algorithm based on the  automatic differentiation (auto-GRAPE), automatic differentiation (AD) and the  gradient-free algorithms such as particle swarm optimization (PSO), differential evolution (DE),  and reverse iterative (RI) algorithm.</p> <p>The interface of QuanEstimation is written in Python, but the most calculation processes are executed in Julia for the computational efficiency. Therefore, QuanEstimation also has a full Julia version apart from the Python-Julia version. </p>"},{"location":"citing/","title":"Citing QuanEstimation","text":"<p>If you use QuanEstimation in your research, please cite the following papers:</p> <p>[1] M. Zhang, H.-M. Yu, H. Yuan, X. Wang, R. Demkowicz-Dobrza\u0144ski, and J. Liu,  QuanEstimation: An open-source toolkit for quantum parameter estimation,  Phys. Rev. Res. 4, 043057 (2022).</p> <p>[2] Huai-Ming Yu and Jing Liu, QuanEstimation.jl: An open-source Julia framework for quantum parameter estimation,  Fundam. Res. (2025).</p> <p>Development of the GRAPE algorithm in quantum parameter estimation can be found in the following papers:</p> <ul> <li> <p>auto-GRAPE:</p> <p>M. Zhang, H.-M. Yu, H. Yuan, X. Wang, R. Demkowicz-Dobrza\u0144ski, and J. Liu,  QuanEstimation: An open-source toolkit for quantum parameter estimation,  Phys. Rev. Res. 4, 043057 (2022).</p> </li> <li> <p>GRAPE for single-parameter estimation:</p> <p>Jing Liu and Haidong Yuan, Quantum parameter estimation with optimal control,  Phys. Rev. A 96, 012117 (2017).</p> </li> <li> <p>GRAPE for multiparameter estimation:</p> <p>Jing Liu and Haidong Yuan, Control-enhanced multiparameter quantum estimation,  Phys. Rev. A 96, 042114 (2017).</p> </li> </ul>"},{"location":"developers/","title":"Developers","text":""},{"location":"developers/#prof-jing-liu","title":"Prof. Jing Liu","text":"<p>Hainan University Email: liujing@hainanu.edu.cn Biography: Prof. Liu is currently a full-time professor at the Center for Theoretical Physics  and School of Physics and Optoelectronic Engineering, Hainan University. His main research interests  focus on the topics in quantum metrology, quantum control, quantum information theory, and  foundations of quantum mechanics, especially the design of high-precision measurement schemes  using the features of quantum mechanics.</p>"},{"location":"developers/#prof-rafa-demkowicz-dobrzanski","title":"Prof. Rafa\u0142 Demkowicz-Dobrza\u0144ski","text":"<p>University of Warsaw Email: Rafal.Demkowicz-Dobrzanski@fuw.edu.pl Biography: Prof. Demkowicz-Dobrza\u0144ski is a faculty at the Faculty of Physics,  University of Warsaw. He is a theorist actively working in the field of quantum metrology,  who developed methods to identify fundamental limits in quantum metrology in presence of  decoherence.</p>"},{"location":"developers/#mr-huai-ming-yu","title":"Mr. Huai-Ming Yu","text":"<p>Huazhong University of Science and Technology Email: HuaimingYuuu@gmail.com Biography: Mr. Yu is a M.Sc. student at the School of Physics, Huazhong University of  Science and Technology. His\u00a0research\u00a0interests\u00a0lie primarily in the\u00a0fields\u00a0of quantum information, quantum control, quantum foundations, as well as scientific programming and its applications in quantum technology.</p>"},{"location":"developers/#contributors","title":"Contributors","text":""},{"location":"developers/#mr-zheng-wei-an","title":"Mr. Zheng-Wei An","text":"<p>Huazhong University of Science and Technology </p>"},{"location":"developers/#advisors","title":"Advisors","text":""},{"location":"developers/#prof-haidong-yuan","title":"Prof. Haidong Yuan","text":"<p>The Chinese University of Hong Kong Biography: Prof. Yuan is an associate professor at the Department of Mechanical  and Automation Engineering, The Chinese University of Hong Kong.</p>"},{"location":"developers/#prof-xiaoguang-wang","title":"Prof. Xiaoguang Wang","text":"<p>Zhejiang Sci-Tech University Biography: Prof. Wang used to be a full-time professor at the Department of Physics, Zhejiang University and now is a full-time professor at the Department of Physics, Zhejiang Sci-Tech University.</p>"},{"location":"developers/#former-developer","title":"Former Developer","text":""},{"location":"developers/#dr-mao-zhang","title":"Dr. Mao Zhang","text":"<p>Email: zhangmao2018@foxmail.com Biography: Dr. Zhang is now working at the United Imaging Healthcare Co., Ltd.. She used to be a Ph.D. student in the National Precise Gravity Measurement Facility, School of Physics, Huazhong University of Science and Technology. </p>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#calculate-fisher-information-and-quantum-fisher-information","title":"Calculate Fisher information and quantum Fisher information","text":"<p>The example is discussed in Example 3.1  and Example 3.4 in quantum metrological tools. CramerRao_bounds.ipynb CramerRao_bounds.jl </p>"},{"location":"examples/#calculate-fisher-information-matrix-quantum-fisher-information-matrix-holevo-cramer-rao-bound-and-nagaoka-hayashi-bound","title":"Calculate Fisher information matrix, quantum Fisher information matrix, Holevo Cram\u00e9r-Rao bound and Nagaoka-Hayashi bound","text":"<p>The example is discussed in detail in Example 3.7  in quantum metrological tools. HCRB_NHB.ipynb HCRB_NHB.jl </p>"},{"location":"examples/#calculate-bayesian-cramer-rao-bounds","title":"Calculate Bayesian Cram\u00e9r-Rao bounds","text":"<p>The example is discussed in detail in Example 3.8  in quantum metrological tools. Bayesian_CramerRao_bounds.ipynb Bayesian_CramerRao_bounds.jl </p>"},{"location":"examples/#bayesian-estimation","title":"Bayesian estimation","text":"<p>The example is discussed in detail in Example 3.9  in quantum metrological tools.  Bayesian_estimation.ipynb Bayesian_estimation.jl </p>"},{"location":"examples/#control-optimization-in-single-qubit-system-single-parameter","title":"Control optimization in single qubit system (single parameter)","text":"<p>The example is discussed in detail in Example 5.1  in control optimization. control_optimization_NV.ipynb control_optimization_NV.jl </p>"},{"location":"examples/#control-optimization-in-nitrogen-vacancy-center-in-diamond-multiparameter","title":"Control optimization in nitrogen-vacancy center in diamond (multiparameter)","text":"<p>The example is discussed in detail in Example 5.2  in control optimization. control_optimization_qubit.ipynb control_optimization_qubit.jl </p>"},{"location":"examples/#state-optimization-in-lipkinmeshkovglick-model-single-parameter","title":"State optimization in Lipkin\u2013Meshkov\u2013Glick model (single parameter)","text":"<p>The example is discussed in detail in Example 6.1  in state optimization. state_optimization_LMG1.ipynb state_optimization_LMG1.jl </p>"},{"location":"examples/#state-optimization-in-lipkinmeshkovglick-model-multiparameter","title":"State optimization in Lipkin\u2013Meshkov\u2013Glick model (multiparameter)","text":"<p>The example is discussed in detail in Example 6.2  in state optimization. state_optimization_LMG2.ipynb state_optimization_LMG2.jl </p>"},{"location":"examples/#measurement-optimization-in-single-qubit-system-single-parameter","title":"Measurement optimization in single qubit system (single parameter)","text":"<p>The example is discussed in detail in Example 7.2  in measurement optimization. measurement_optimization_qubit.ipynb measurement_optimization_qubit.jl </p>"},{"location":"examples/#measurement-optimization-in-nitrogen-vacancy-center-in-diamond-multiparameter","title":"Measurement optimization in nitrogen-vacancy center in diamond (multiparameter)","text":"<p>The example is discussed in detail in Example 7.3  in measurement optimization. measurement_optimization_NV.ipynb measurement_optimization_NV.jl </p>"},{"location":"examples/#comprehensive-optimization-in-single-qubit-system-single-parameter","title":"Comprehensive optimization in single qubit system (single parameter)","text":"<p>The example is discussed in detail in Example 8.1  in comprehensive optimization. comprehensive_optimization_qubit.ipynb comprehensive_optimization_qubit.jl </p>"},{"location":"examples/#comprehensive-optimization-in-nitrogen-vacancy-center-in-diamond-multiparameter","title":"Comprehensive optimization in nitrogen-vacancy center in diamond (multiparameter)","text":"<p>The example is discussed in detail in Example 8.2  in comprehensive optimization. comprehensive_optimization_NV.ipynb comprehensive_optimization_NV.jl</p>"},{"location":"installation/","title":"Installation","text":"<p>Run the command in the terminal to install QuanEstimation:  </p> PythonJulia <p><pre><code>pip install quanestimation\n</code></pre> The users can also run  <pre><code>git clone https://github.com/QuanEstimation/QuanEstimation.git\n</code></pre> to install the latest development version of QuanEstimation from Github.</p> <p><pre><code>import Pkg\nPkg.add(\"QuanEstimation\")\n</code></pre> If the users want to install the package via a Julia mirror, please  click here for usage.</p>"},{"location":"installation/#requirements","title":"Requirements","text":"<p>QuanEstimation requires several open-source packages in Python and Julia. The versions  of Python and Julia should be above 3.10 and 1.10, respectively.</p>"},{"location":"installation/#python-packages","title":"Python packages","text":"\\(~~~~~~~~~~~\\)Package\\(~~~~~~~\\) Version numpy &gt;=1.22 sympy &gt;=1.10 scipy &gt;=1.8 cvxpy &gt;=1.2 more-itertools &gt;=8.12.0"},{"location":"installation/#julia-packages","title":"Julia packages","text":"\\(~~~~~~~~~~~~~~~~\\)Package\\(~~~~~~~~~~~~\\) Version \\(~~~~~~~~~~~~~~~~\\)Package\\(~~~~~~~~~~~~\\) Version LinearAlgebra -- BoundaryValueDiffEq 2.7.2 Zygote 0.6.37 SCS 0.8.1 Convex 0.14.18 Trapz 2.0.3 ReinforcementLearning 0.10.0 Interpolations 0.13.5 IntervalSets 0.5.4 SparseArrays -- Flux 0.12.4 DelimitedFiles -- StatsBase 0.33.16 Random -- Printf -- StableRNGs -- Distributions -- QuadGK -- DifferentialEquations -- <p>The version information of the packages without the version number is the same with the  corresponding packages in Julia 1.10. Besides, the version information of the full Julia package  is also the same as the table above. All of these packages will be automatically installed when the users install QuanEstimation.</p>"},{"location":"API/julia/api/","title":"Julia","text":"<p>This part contains the methods and structs in Julia that are called by the Python-Julia packagea and the full Julia package.</p>"},{"location":"API/julia/api/#quanestimationad-method","title":"<code>QuanEstimation.AD</code> \u2014 Method.","text":"<pre><code>AD(;max_episode=300, epsilon=0.01, beta1=0.90, beta2=0.99, Adam::Bool=true)\n</code></pre> <p>Optimization algorithm: AD.</p> <ul> <li><code>max_episode</code>: The number of episodes.</li> <li><code>epsilon</code>: Learning rate.</li> <li><code>beta1</code>: The exponential decay rate for the first moment estimates.</li> <li><code>beta2</code>: The exponential decay rate for the second moment estimates.</li> <li><code>Adam</code>: Whether or not to use Adam for updating control coefficients.</li> </ul> <p>source</p>"},{"location":"API/julia/api/#quanestimationcfim_obj-method","title":"<code>QuanEstimation.CFIM_obj</code> \u2014 Method.","text":"<pre><code>CFIM_obj(;M=missing, W=missing, eps=GLOBAL_EPS)\n</code></pre> <p>Choose CFI [\\(\\mathrm{Tr}(WI^{-1})\\)] as the objective function with \\(W\\) the weight matrix and \\(I\\) the CFIM.</p> <ul> <li><code>M</code>: A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM).</li> <li><code>W</code>: Weight matrix.</li> <li><code>eps</code>: Machine epsilon.</li> </ul> <p>source</p>"},{"location":"API/julia/api/#quanestimationcmopt-type","title":"<code>QuanEstimation.CMopt</code> \u2014 Type.","text":"<pre><code>CMopt(ctrl=missing, M=missing, ctrl_bound=[-Inf, Inf], seed=1234)\n</code></pre> <p>Control and measurement optimization.</p> <ul> <li><code>ctrl</code>: Guessed control coefficients.</li> <li><code>M</code>: Guessed projective measurement (a set of basis)</li> <li><code>ctrl_bound</code>: Lower and upper bounds of the control coefficients.</li> <li><code>seed</code>: Random seed.</li> </ul> <p>source</p>"},{"location":"API/julia/api/#quanestimationcontrolopt-method","title":"<code>QuanEstimation.ControlOpt</code> \u2014 Method.","text":"<pre><code>ControlOpt(ctrl=missing, ctrl_bound=[-Inf, Inf], seed=1234)\n</code></pre> <p>Control optimization.</p> <ul> <li><code>ctrl</code>: Guessed control coefficients.</li> <li><code>ctrl_bound</code>: Lower and upper bounds of the control coefficients.</li> <li><code>seed</code>: Random seed.</li> </ul> <p>source</p> <p>&lt;!-- ##  <code>QuanEstimation.DDPG</code> \u2014 Method.</p> <pre><code>DDPG(;max_episode::Int=500, layer_num::Int=3, layer_dim::Int=200, seed::Number=1234)\n``` --&gt;\n\nOptimization algorithm: DE.\n\n  * `max_episode`: The number of populations.\n  * `layer_num`: The number of layers (include the input and output layer).\n  * `layer_dim`: The number of neurons in the hidden layer.\n  * `seed`: Random seed.\n\n\n&lt;a target='_blank' href='https://github.com/QuanEstimation/QuanEstimation.jl/blob/5f47a686c13b059023de2abe67017d7c9564bc9d/src/Algorithm/Algorithm.jl#L146-L155' class='documenter-source'&gt;source&lt;/a&gt;&lt;br&gt;\n\n##  **`QuanEstimation.DE`** &amp;mdash; *Method*.\n\n\n\n```julia\nDE(;max_episode::Number=1000, p_num::Number=10, ini_population=missing, c::Number=1.0, cr::Number=0.5, seed::Number=1234)\n</code></pre> <p>Optimization algorithm: DE.</p> <ul> <li><code>max_episode</code>: The number of populations.</li> <li><code>p_num</code>: The number of particles.</li> <li><code>ini_population</code>: Initial guesses of the optimization variables.</li> <li><code>c</code>: Mutation constant.</li> <li><code>cr</code>: Crossover constant.</li> </ul> <p>sourcettps://github.com/QuanEstimation/QuanEstimation.jl/blob/5f47a686c13b059023de2abe67017d7c9564bc9d/src/Parameterization/Kraus/KrausWrapper.jl#L25-L30' class='documenter-source'&gt;"},{"location":"API/julia/api/#quanestimationgrape-method","title":"<code>QuanEstimation.GRAPE</code> \u2014 Method.","text":"<pre><code>GRAPE(;max_episode=300, epsilon=0.01, beta1=0.90, beta2=0.99, Adam::Bool=true)\n</code></pre> <p>Control optimization algorithm: GRAPE.</p> <ul> <li><code>max_episode</code>: The number of episodes.</li> <li><code>epsilon</code>: Learning rate.</li> <li><code>beta1</code>: The exponential decay rate for the first moment estimates.</li> <li><code>beta2</code>: The exponential decay rate for the second moment estimates.</li> <li><code>Adam</code>: Whether or not to use Adam for updating control coefficients.</li> </ul> <p>source686c13b059023de2abe67017d7c9564bc9d/src/Parameterization/Kraus/KrausWrapper.jl#L41-L46' class='documenter-source'&gt;"},{"location":"API/julia/api/#quanestimationhcrb_obj-method","title":"<code>QuanEstimation.HCRB_obj</code> \u2014 Method.","text":"<pre><code>HCRB_obj(;W=missing, eps=GLOBAL_EPS)\n</code></pre> <p>Choose HCRB as the objective function. </p> <ul> <li><code>W</code>: Weight matrix.</li> <li><code>eps</code>: Machine epsilon.</li> </ul> <p>sourceLD operator. Options can be: \"original\" (default) and \"eigen\".   * <code>eps</code>: Machine epsilon. <p>"},{"location":"API/julia/api/#quanestimationkraus-method","title":"<code>QuanEstimation.Kraus</code> \u2014 Method.","text":"<pre><code>Kraus(\u03c10::AbstractMatrix, K::AbstractVector, dK::AbstractVector)\n</code></pre> <p>The parameterization of a state is \\(\\rho=\\sum_i K_i\\rho_0K_i^{\\dagger}\\) with \\(\\rho\\) the evolved density matrix and \\(K_i\\) the Kraus operator.</p> <ul> <li><code>\u03c10</code>: Initial state (density matrix).</li> <li><code>K</code>: Kraus operators.</li> <li><code>dK</code>: Derivatives of the Kraus operators with respect to the unknown parameters to be estimated. For example, dK[0] is the derivative vector on the first parameter.</li> </ul> <p>sourcece'&gt;"},{"location":"API/julia/api/#quanestimationkraus-method_1","title":"<code>QuanEstimation.Kraus</code> \u2014 Method.","text":"<pre><code>Kraus(\u03c80::AbstractMatrix, K::AbstractVector, dK::AbstractVector)\n</code></pre> <p>The parameterization of a state is \\(\\psi\\rangle=\\sum_i K_i|\\psi_0\\rangle\\) with \\(\\psi\\) the evolved state and \\(K_i\\) the Kraus operator.</p> <ul> <li><code>\u03c80</code>: Initial state (ket).</li> <li><code>K</code>: Kraus operators.</li> <li><code>dK</code>: Derivatives of the Kraus operators with respect to the unknown parameters to be estimated. For example, dK[0] is the derivative vector on the first parameter.</li> </ul> <p>source://github.com/QuanEstimation/QuanEstimation.jl/blob/5f47a686c13b059023de2abe67017d7c9564bc9d/src/Parameterization/Lindblad/LindbladWrapper.jl#L361-L366' class='documenter-source'&gt;"},{"location":"API/julia/api/#quanestimationkraus-method_2","title":"<code>QuanEstimation.Kraus</code> \u2014 Method.","text":"<pre><code>Kraus(opt::AbstractMopt, \u03c1\u2080::AbstractMatrix, K, dK; eps=GLOBAL_EPS)\n</code></pre> <p>Initialize the parameterization described by the Kraus operators for the measurement optimization. </p> <p>sourceimation.jl/blob/5f47a686c13b059023de2abe67017d7c9564bc9d/src/Parameterization/Lindblad/LindbladWrapper.jl#L2-L7' class='documenter-source'&gt;"},{"location":"API/julia/api/#quanestimationkraus-method_3","title":"<code>QuanEstimation.Kraus</code> \u2014 Method.","text":"<pre><code>Kraus(opt::CompOpt, K, dK; eps=GLOBAL_EPS)\n</code></pre> <p>Initialize the parameterization described by the Kraus operators for the comprehensive optimization. </p> <p>sourcettps://github.com/QuanEstimation/QuanEstimation.jl/blob/5f47a686c13b059023de2abe67017d7c9564bc9d/src/Parameterization/Lindblad/LindbladWrapper.jl#L507-L512' class='documenter-source'&gt;"},{"location":"API/julia/api/#quanestimationlld-method","title":"<code>QuanEstimation.LLD</code> \u2014 Method.","text":"<pre><code>LLD(\u03c1::Matrix{T}, d\u03c1::Vector{Matrix{T}}; rep=\"original\", eps=GLOBAL_EPS) where {T&lt;:Complex}\n</code></pre> <p>Calculate the left logarrithmic derivatives (LLDs). The LLD operator is defined as \\(\\partial_{a}\\rho=\\mathcal{R}_a^{\\dagger}\\rho\\), where \u03c1 is the parameterized density matrix.    </p> <ul> <li><code>\u03c1</code>: Density matrix.</li> <li><code>d\u03c1</code>: Derivatives of the density matrix with respect to the unknown parameters to be estimated. For example, drho[1] is the derivative vector with respect to the first parameter.</li> <li><code>rep</code>: Representation of the LLD operator. Options can be: \"original\" (default) and \"eigen\".</li> <li><code>eps</code>: Machine epsilon.</li> </ul> <p>sourcenEstimation.jl/blob/5f47a686c13b059023de2abe67017d7c9564bc9d/src/Parameterization/Lindblad/LindbladWrapper.jl#L298-L303' class='documenter-source'&gt;"},{"location":"API/julia/api/#quanestimationlld-method_1","title":"<code>QuanEstimation.LLD</code> \u2014 Method.","text":"<pre><code>LLD(\u03c1::Matrix{T}, d\u03c1::Matrix{T}; rep=\"original\", eps=GLOBAL_EPS) where {T&lt;:Complex}\n</code></pre> <p>When applied to the case of single parameter.</p> <p>source/QuanEstimation.jl/blob/5f47a686c13b059023de2abe67017d7c9564bc9d/src/Parameterization/Lindblad/LindbladWrapper.jl#L419-L424' class='documenter-source'&gt;"},{"location":"API/julia/api/#quanestimationlindblad-method","title":"<code>QuanEstimation.Lindblad</code> \u2014 Method.","text":"<pre><code>Lindblad(opt::AbstractMopt, tspan, \u03c1\u2080, H0, dH; Hc=missing, ctrl=missing, decay=missing, dyn_method=:Expm, eps=GLOBAL_EPS)\n</code></pre> <p>Initialize the parameterization described by the Lindblad master equation governed dynamics for the measurement optimization.</p> <p>sourceb059023de2abe67017d7c9564bc9d/src/Parameterization/Lindblad/LindbladWrapper.jl#L59-L64' class='documenter-source'&gt;"},{"location":"API/julia/api/#quanestimationlindblad-method_1","title":"<code>QuanEstimation.Lindblad</code> \u2014 Method.","text":"<pre><code>Lindblad(opt::ControlMeasurementOpt, tspan, \u03c1\u2080, H0, dH, Hc; decay=missing, dyn_method=:Expm, eps=GLOBAL_EPS)\n</code></pre> <p>Initialize the parameterization described by the Lindblad master equation governed dynamics for the comprehensive optimization on control and measurement.</p> <p>sourcenstant.   * <code>ae</code>: Expansion constant.   * <code>ac</code>: Constraction constant.   * <code>as0</code>: Shrink constant. <p>"},{"location":"API/julia/api/#quanestimationlindblad-method_2","title":"<code>QuanEstimation.Lindblad</code> \u2014 Method.","text":"<pre><code>Lindblad(opt::ControlOpt, tspan, \u03c1\u2080, H0, dH, Hc; decay=missing, dyn_method=:Expm, eps=GLOBAL_EPS)\n</code></pre> <p>Initialize the parameterization described by the Lindblad master equation governed dynamics for the control optimization.</p> <p>sourceuanEstimation.PSO` \u2014 Method. <pre><code>PSO(;max_episode::Union{T,Vector{T}} where {T&lt;:Int}=[1000, 100], p_num::Number=10, ini_particle=missing, c0::Number=1.0, c1::Number=2.0, c2::Number=2.0, seed::Number=1234)\n</code></pre> <p>Optimization algorithm: PSO.</p> <ul> <li><code>max_episode</code>: The number of episodes, it accepts both integer and array with two elements.</li> <li><code>p_num</code>: The number of particles.</li> <li><code>ini_particle</code>: Initial guesses of the optimization variables.</li> <li><code>c0</code>: The damping factor that assists convergence, also known as inertia weight.</li> <li><code>c1</code>: The exploitation weight that attracts the particle to its best previous position, also known as cognitive learning factor.</li> <li><code>c2</code>: The exploitation weight that attracts the particle to the best position in the neighborhood, also known as social learning factor.</li> </ul> <p>"},{"location":"API/julia/api/#quanestimationlindblad-method_3","title":"<code>QuanEstimation.Lindblad</code> \u2014 Method.","text":"<pre><code>Lindblad(opt::StateControlMeasurementOpt, tspan, H0, dH, Hc; decay=missing, dyn_method=:Expm, eps=GLOBAL_EPS)\n</code></pre> <p>Initialize the parameterization described by the Lindblad master equation governed dynamics for the comprehensive optimization on state, control and measurement.</p> <p>sourcen weight that attracts the particle to its best previous position, also known as cognitive learning factor.   * <code>c2</code>: The exploitation weight that attracts the particle to the best position in the neighborhood, also known as social learning factor. <p>"},{"location":"API/julia/api/#quanestimationlindblad-method_4","title":"<code>QuanEstimation.Lindblad</code> \u2014 Method.","text":"<pre><code>Lindblad(opt::StateControlOpt, tspan, H0, dH, Hc; decay=missing, dyn_method=:Expm, eps=GLOBAL_EPS)\n</code></pre> <p>Initialize the parameterization described by the Lindblad master equation governed dynamics for the comprehensive optimization on state and control.</p> <p>sourcee set as the objective function. Options are <code>:SLD</code> (default), <code>:RLD</code> and <code>:LLD</code>. <p>"},{"location":"API/julia/api/#quanestimationlindblad-method_5","title":"<code>QuanEstimation.Lindblad</code> \u2014 Method.","text":"<pre><code>Lindblad(opt::StateMeasurementOpt, tspan, H0, dH; Hc=missing, ctrl=missing, decay=missing, dyn_method=:Expm)\n</code></pre> <p>Initialize the parameterization described by the Lindblad master equation governed dynamics for the comprehensive optimization on state and measurement.</p> <p>sourcece</p>"},{"location":"API/julia/api/#quanestimationlindblad-method_6","title":"<code>QuanEstimation.Lindblad</code> \u2014 Method.","text":"<pre><code>Lindblad(opt::StateOpt, tspan, H0, dH; Hc=missing, ctrl=missing, decay=missing, dyn_method=:Expm, eps=GLOBAL_EPS)\n</code></pre> <p>Initialize the parameterization described by the Lindblad master equation governed dynamics for the state optimization.</p> <p>sourceuanEstimation.RLD` \u2014 Method. <pre><code>RLD(\u03c1::Matrix{T}, d\u03c1::Vector{Matrix{T}}; rep=\"original\", eps=GLOBAL_EPS) where {T&lt;:Complex}\n</code></pre> <p>Calculate the right logarrithmic derivatives (RLDs). The RLD operator is defined as  \\(\\partial_{a}\\rho=\\rho \\mathcal{R}_a\\), where \\(\\rho\\) is the parameterized density matrix.  </p> <ul> <li><code>\u03c1</code>: Density matrix.</li> <li><code>d\u03c1</code>: Derivatives of the density matrix with respect to the unknown parameters to be estimated. For example, drho[1] is the derivative vector with respect to the first parameter.</li> <li><code>rep</code>: Representation of the RLD operator. Options can be: \"original\" (default) and \"eigen\".</li> <li><code>eps</code>: Machine epsilon.</li> </ul> <p>"},{"location":"API/julia/api/#quanestimationnm-method","title":"<code>QuanEstimation.NM</code> \u2014 Method.","text":"<pre><code>NM(;max_episode::Int=1000, p_num::Int=10, nelder_mead=missing, ar::Number=1.0, ae::Number=2.0, ac::Number=0.5, as0::Number=0.5, seed::Number=1234)\n</code></pre> <p>State optimization algorithm: NM.</p> <ul> <li><code>max_episode</code>: The number of populations.</li> <li><code>p_num</code>: The number of the input states.</li> <li><code>nelder_mead</code>: Initial guesses of the optimization variables.</li> <li><code>ar</code>: Reflection constant.</li> <li><code>ae</code>: Expansion constant.</li> <li><code>ac</code>: Constraction constant.</li> <li><code>as0</code>: Shrink constant.</li> </ul> <p>sourceb/5f47a686c13b059023de2abe67017d7c9564bc9d/src/ObjectiveFunc/AsymptoticBound/CramerRao.jl#L104-L109' class='documenter-source'&gt;"},{"location":"API/julia/api/#quanestimationpso-method","title":"<code>QuanEstimation.PSO</code> \u2014 Method.","text":"<pre><code>PSO(;max_episode::Union{T,Vector{T}} where {T&lt;:Int}=[1000, 100], p_num::Number=10, ini_particle=missing, c0::Number=1.0, c1::Number=2.0, c2::Number=2.0, seed::Number=1234)\n</code></pre> <p>Optimization algorithm: PSO.</p> <ul> <li><code>max_episode</code>: The number of episodes, it accepts both integer and array with two elements.</li> <li><code>p_num</code>: The number of particles.</li> <li><code>ini_particle</code>: Initial guesses of the optimization variables.</li> <li><code>c0</code>: The damping factor that assists convergence, also known as inertia weight.</li> <li><code>c1</code>: The exploitation weight that attracts the particle to its best previous position, also known as cognitive learning factor.</li> <li><code>c2</code>: The exploitation weight that attracts the particle to the best position in the neighborhood, also known as social learning factor.</li> </ul> <p>sourced<code>:  Lower and upper bounds of the control coefficients.   *</code>seed`: Random seed. <p>"},{"location":"API/julia/api/#quanestimationqfim_obj-method","title":"<code>QuanEstimation.QFIM_obj</code> \u2014 Method.","text":"<pre><code>QFIM_obj(;W=missing, eps=GLOBAL_EPS, LDtype::Symbol=:SLD)\n</code></pre> <p>Choose QFI [\\(\\mathrm{Tr}(WF^{-1})\\)] as the objective function with \\(W\\) the weight matrix and \\(F\\) the QFIM.</p> <ul> <li><code>W</code>: Weight matrix.</li> <li><code>eps</code>: Machine epsilon.</li> <li><code>LDtype</code>: Types of QFI (QFIM) can be set as the objective function. Options are <code>:SLD</code> (default), <code>:RLD</code> and <code>:LLD</code>.</li> </ul> <p>source"},{"location":"API/julia/api/#quanestimationri-method","title":"<code>QuanEstimation.RI</code> \u2014 Method.","text":"<pre><code>RI(;max_episode::Int=300, seed::Number=1234)\n</code></pre> <p>State optimization algorithm: RI.</p> <ul> <li><code>max_episode</code>: The number of episodes.</li> </ul> <p>sourcerized density matrix.  <ul> <li><code>\u03c1</code>: Density matrix.</li> <li><code>d\u03c1</code>: Derivatives of the density matrix with respect to the unknown parameters to be estimated. For example, drho[1] is the derivative vector with respect to the first parameter.</li> <li><code>rep</code>: Representation of the SLD operator. Options can be: \"original\" (default) and \"eigen\" .</li> <li><code>eps</code>: Machine epsilon.</li> </ul> <p>"},{"location":"API/julia/api/#quanestimationrld-method","title":"<code>QuanEstimation.RLD</code> \u2014 Method.","text":"<pre><code>RLD(\u03c1::Matrix{T}, d\u03c1::Vector{Matrix{T}}; rep=\"original\", eps=GLOBAL_EPS) where {T&lt;:Complex}\n</code></pre> <p>Calculate the right logarrithmic derivatives (RLDs). The RLD operator is defined as  \\(\\partial_{a}\\rho=\\rho \\mathcal{R}_a\\), where \\(\\rho\\) is the parameterized density matrix.  </p> <ul> <li><code>\u03c1</code>: Density matrix.</li> <li><code>d\u03c1</code>: Derivatives of the density matrix with respect to the unknown parameters to be estimated. For example, drho[1] is the derivative vector with respect to the first parameter.</li> <li><code>rep</code>: Representation of the RLD operator. Options can be: \"original\" (default) and \"eigen\".</li> <li><code>eps</code>: Machine epsilon.</li> </ul> <p>sourcetoticBound/CramerRao.jl#L22-L27' class='documenter-source'&gt;"},{"location":"API/julia/api/#quanestimationrld-method_1","title":"<code>QuanEstimation.RLD</code> \u2014 Method.","text":"<pre><code>RLD(\u03c1::Matrix{T}, d\u03c1::Matrix{T}; rep=\"original\", eps=GLOBAL_EPS) where {T&lt;:Complex}\n</code></pre> <p>When applied to the case of single parameter.</p> <p>sourceanEstimation/QuanEstimation.jl/blob/5f47a686c13b059023de2abe67017d7c9564bc9d/src/OptScenario/OptScenario.jl#L146-L154' class='documenter-source'&gt;"},{"location":"API/julia/api/#quanestimationscmopt-type","title":"<code>QuanEstimation.SCMopt</code> \u2014 Type.","text":"<pre><code>SCMopt(psi=missing, ctrl=missing, M=missing, ctrl_bound=[-Inf, Inf], seed=1234)\n</code></pre> <p>State, control and measurement optimization.</p> <ul> <li><code>psi</code>: Guessed probe state.</li> <li><code>ctrl</code>: Guessed control coefficients.</li> <li><code>M</code>: Guessed projective measurement (a set of basis).</li> <li><code>ctrl_bound</code>:  Lower and upper bounds of the control coefficients.</li> <li><code>seed</code>: Random seed.</li> </ul> <p>source2abe67017d7c9564bc9d/src/OptScenario/OptScenario.jl#L35-L42' class='documenter-source'&gt;"},{"location":"API/julia/api/#quanestimationscopt-type","title":"<code>QuanEstimation.SCopt</code> \u2014 Type.","text":"<pre><code>SCopt(psi=missing, ctrl=missing, ctrl_bound=[-Inf, Inf], seed=1234)\n</code></pre> <p>State and control optimization.</p> <ul> <li><code>psi</code>: Guessed probe state.</li> <li><code>ctrl</code>: Guessed control coefficients.</li> <li><code>ctrl_bound</code>: Lower and upper bounds of the control coefficients.</li> <li><code>seed</code>: Random seed.</li> </ul> <p>sourceeta2<code>: The exponential decay rate for the second moment estimates.   *</code>Adam`: Whether or not to use Adam for updating control coefficients. <p>"},{"location":"API/julia/api/#quanestimationsld-method","title":"<code>QuanEstimation.SLD</code> \u2014 Method.","text":"<pre><code>SLD(\u03c1::Matrix{T}, d\u03c1::Vector{Matrix{T}}; rep=\"original\", eps=GLOBAL_EPS) where {T&lt;:Complex}\n</code></pre> <p>Calculate the symmetric logarrithmic derivatives (SLDs). The SLD operator \\(L_a\\) is defined  as\\(\\partial_{a}\\rho=\\frac{1}{2}(\\rho L_{a}+L_{a}\\rho)\\), where \\(\\rho\\) is the parameterized density matrix. </p> <ul> <li><code>\u03c1</code>: Density matrix.</li> <li><code>d\u03c1</code>: Derivatives of the density matrix with respect to the unknown parameters to be estimated. For example, drho[1] is the derivative vector with respect to the first parameter.</li> <li><code>rep</code>: Representation of the SLD operator. Options can be: \"original\" (default) and \"eigen\" .</li> <li><code>eps</code>: Machine epsilon.</li> </ul> <p>sourceble parameters \\(\\textbf{u}\\) are used to let the  Hamiltonian work at the optimal point \\(\\textbf{x}_{\\mathrm{opt}}\\).  <ul> <li><code>x</code>: The regimes of the parameters for the integral.</li> <li><code>p</code>: The prior distribution.</li> <li><code>rho0</code>: Density matrix.</li> <li><code>tspan</code>: The experimental results obtained in practice.</li> <li><code>H</code>: Free Hamiltonian with respect to the values in x.</li> <li><code>dH</code>: Derivatives of the free Hamiltonian with respect to the unknown parameters to be estimated.</li> <li><code>dyn_method</code>: Setting the method for solving the Lindblad dynamics. Options are: \"expm\" and \"ode\".</li> <li><code>method</code>: Choose the method for updating the tunable parameters (u). Options are: \"FOP\" and \"MI\".</li> <li><code>savefile</code>: Whether or not to save all the posterior distributions.</li> <li><code>max_episode</code>: The number of episodes.</li> <li><code>eps</code>: Machine epsilon.</li> <li><code>Hc</code>: Control Hamiltonians.</li> <li><code>ctrl</code>: Control coefficients.</li> <li><code>decay</code>: Decay operators and the corresponding decay rates.</li> <li><code>M</code>: A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM).</li> <li><code>W</code>: Whether or not to save all the posterior distributions.</li> </ul> <p>"},{"location":"API/julia/api/#quanestimationsld-method_1","title":"<code>QuanEstimation.SLD</code> \u2014 Method.","text":"<pre><code>SLD(\u03c1::Matrix{T}, d\u03c1::Matrix{T}; rep=\"original\", eps=GLOBAL_EPS) where {T&lt;:Complex}\n</code></pre> <p>When applied to the case of single parameter.</p> <p>sourceodes.   * <code>eps</code>: Machine epsilon.   * <code>Hc</code>: Control Hamiltonians.   * <code>ctrl</code>: Control coefficients.   * <code>decay</code>: Decay operators and the corresponding decay rates.   * <code>M</code>: A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM).   * <code>W</code>: Whether or not to save all the posterior distributions. <p>"},{"location":"API/julia/api/#quanestimationsmopt-type","title":"<code>QuanEstimation.SMopt</code> \u2014 Type.","text":"<pre><code>SMopt(psi=missing, M=missing, seed=1234)\n</code></pre> <p>State and control optimization.</p> <ul> <li><code>psi</code>: Guessed probe state.</li> <li><code>M</code>: Guessed projective measurement (a set of basis).</li> <li><code>seed</code>: Random seed.</li> </ul> <p>sourceeters. The tunable parameters \\(\\textbf{u}\\) are used to let the  Hamiltonian work at the optimal point \\(\\textbf{x}_{\\mathrm{opt}}\\).  <ul> <li><code>x</code>: The regimes of the parameters for the integral.</li> <li><code>p</code>: The prior distribution.</li> <li><code>rho0</code>: Density matrix.</li> <li><code>K</code>: Kraus operator(s) with respect to the values in x.</li> <li><code>dK</code>: Derivatives of the Kraus operator(s) with respect to the unknown parameters to be estimated.</li> <li><code>method</code>: Choose the method for updating the tunable parameters (u). Options are: \"FOP\" and \"MI\".</li> <li><code>savefile</code>: Whether or not to save all the posterior distributions.</li> <li><code>max_episode</code>: The number of episodes.</li> <li><code>eps</code>: Machine epsilon.</li> <li><code>M</code>: A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM).</li> <li><code>W</code>: Whether or not to save all the posterior distributions.</li> </ul> <p>"},{"location":"API/julia/api/#quanestimationstateopt-method","title":"<code>QuanEstimation.StateOpt</code> \u2014 Method.","text":"<pre><code>StateOpt(psi=missing, seed=1234)\n</code></pre> <p>State optimization.</p> <ul> <li><code>psi</code>: Guessed probe state.</li> <li><code>seed</code>: Random seed.</li> </ul> <p>sourceether or not to save all the posterior distributions. <p>"},{"location":"API/julia/api/#quanestimationautogrape-method","title":"<code>QuanEstimation.autoGRAPE</code> \u2014 Method.","text":"<pre><code>autoGRAPE(;max_episode=300, epsilon=0.01, beta1=0.90, beta2=0.99, Adam::Bool=true)\n</code></pre> <p>Control optimization algorithm: auto-GRAPE.</p> <ul> <li><code>max_episode</code>: The number of episodes.</li> <li><code>epsilon</code>: Learning rate.</li> <li><code>beta1</code>: The exponential decay rate for the first moment estimates.</li> <li><code>beta2</code>: The exponential decay rate for the second moment estimates.</li> <li><code>Adam</code>: Whether or not to use Adam for updating control coefficients.</li> </ul> <p>source9023de2abe67017d7c9564bc9d/src/Common/BayesEstimation.jl#L363-L373' class='documenter-source'&gt;"},{"location":"API/julia/api/#quanestimationadapt-method","title":"<code>QuanEstimation.Adapt</code> \u2014 Method.","text":"<pre><code>Adapt(x::AbstractVector, p, rho0::AbstractMatrix, tspan, H, dH; dyn_method=:Expm, method=\"FOP\", savefile=false, max_episode::Int=1000, eps::Float64=1e-8, Hc=missing, ctrl=missing, decay=missing, M=missing, W=missing)\n</code></pre> <p>In QuanEstimation, the Hamiltonian of the adaptive system should be written as \\(H(\\textbf{x}+\\textbf{u})\\) with \\(\\textbf{x}\\) the unknown parameters and \\(\\textbf{u}\\) the tunable parameters. The tunable parameters \\(\\textbf{u}\\) are used to let the  Hamiltonian work at the optimal point \\(\\textbf{x}_{\\mathrm{opt}}\\). </p> <ul> <li><code>x</code>: The regimes of the parameters for the integral.</li> <li><code>p</code>: The prior distribution.</li> <li><code>rho0</code>: Density matrix.</li> <li><code>tspan</code>: The experimental results obtained in practice.</li> <li><code>H</code>: Free Hamiltonian with respect to the values in x.</li> <li><code>dH</code>: Derivatives of the free Hamiltonian with respect to the unknown parameters to be estimated.</li> <li><code>dyn_method</code>: Setting the method for solving the Lindblad dynamics. Options are: \"expm\" and \"ode\".</li> <li><code>method</code>: Choose the method for updating the tunable parameters (u). Options are: \"FOP\" and \"MI\".</li> <li><code>savefile</code>: Whether or not to save all the posterior distributions.</li> <li><code>max_episode</code>: The number of episodes.</li> <li><code>eps</code>: Machine epsilon.</li> <li><code>Hc</code>: Control Hamiltonians.</li> <li><code>ctrl</code>: Control coefficients.</li> <li><code>decay</code>: Decay operators and the corresponding decay rates.</li> <li><code>M</code>: A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM).</li> <li><code>W</code>: Whether or not to save all the posterior distributions.</li> </ul> <p>sourcer distribution with respect to the unknown parameters to be estimated. For example, dp[0] is the derivative vector on the first parameter.   * <code>rho</code>: Parameterized density matrix.   * <code>drho</code>: Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated.   * <code>M</code>: A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM).   * <code>b</code>: Vector of biases of the form \\(\\textbf{b}=(b(x_0),b(x_1),\\dots)^{\\mathrm{T}}\\).   * <code>db</code>: Derivatives of b on the unknown parameters to be estimated, It should be expressed as \\(\\textbf{b}'=(\\partial_0 b(x_0),\\partial_1 b(x_1),\\dots)^{\\mathrm{T}}\\).   * <code>btype</code>: Types of the BCRB. Options are 1, 2 and 3.   * <code>eps</code>: Machine epsilon. <p>"},{"location":"API/julia/api/#quanestimationadapt-method_1","title":"<code>QuanEstimation.Adapt</code> \u2014 Method.","text":"<pre><code>Adapt(x::AbstractVector, p, rho0::AbstractMatrix, K, dK; method=\"FOP\", savefile=false, max_episode::Int=1000, eps::Float64=1e-8, M=missing, W=missing)\n</code></pre> <p>In QuanEstimation, the Hamiltonian of the adaptive system should be written as \\(H(\\textbf{x}+\\textbf{u})\\) with \\(\\textbf{x}\\) the unknown parameters and \\(\\textbf{u}\\) the tunable parameters. The tunable parameters \\(\\textbf{u}\\) are used to let the  Hamiltonian work at the optimal point \\(\\textbf{x}_{\\mathrm{opt}}\\). </p> <ul> <li><code>x</code>: The regimes of the parameters for the integral.</li> <li><code>p</code>: The prior distribution.</li> <li><code>rho0</code>: Density matrix.</li> <li><code>K</code>: Kraus operator(s) with respect to the values in x.</li> <li><code>dK</code>: Derivatives of the Kraus operator(s) with respect to the unknown parameters to be estimated.</li> <li><code>method</code>: Choose the method for updating the tunable parameters (u). Options are: \"FOP\" and \"MI\".</li> <li><code>savefile</code>: Whether or not to save all the posterior distributions.</li> <li><code>max_episode</code>: The number of episodes.</li> <li><code>eps</code>: Machine epsilon.</li> <li><code>M</code>: A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM).</li> <li><code>W</code>: Whether or not to save all the posterior distributions.</li> </ul> <p>source prior distribution with respect to the unknown parameters to be estimated. For example, dp[0] is the derivative vector on the first parameter.   * <code>rho</code>: Parameterized density matrix.   * <code>drho</code>: Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated.   * <code>b</code>: Vector of biases of the form \\(\\textbf{b}=(b(x_0),b(x_1),\\dots)^{\\mathrm{T}}\\).   * <code>db</code>: Derivatives of b on the unknown parameters to be estimated, It should be expressed as \\(\\textbf{b}'=(\\partial_0 b(x_0),\\partial_1 b(x_1),\\dots)^{\\mathrm{T}}\\).   * <code>LDtype</code>: Types of QFI (QFIM) can be set as the objective function. Options are \"SLD\" (default), \"RLD\" and \"LLD\".   * <code>btype</code>: Types of the BCRB. Options are 1, 2 and 3.   * <code>eps</code>: Machine epsilon. <p>"},{"location":"API/julia/api/#quanestimationbcb-method","title":"<code>QuanEstimation.BCB</code> \u2014 Method.","text":"<pre><code>BCB(x, p, rho; W=missing, eps=GLOBAL_EPS)\n</code></pre> <p>Calculation of the minimum Bayesian cost with a quadratic cost function.</p> <ul> <li><code>x</code>: The regimes of the parameters for the integral.</li> <li><code>p</code>: The prior distribution.</li> <li><code>rho</code>: Parameterized density matrix.</li> <li><code>W</code>: Weight matrix.</li> <li><code>eps</code>: Machine epsilon.</li> </ul> <p>sourceorm \\(\\mathcal{F}_{\\mathrm{Bayes}}=\\int p(\\textbf{x})\\mathcal{F}\\mathrm{d}\\textbf{x}\\) with \\(\\mathcal{F}\\) the QFIM of all types and \\(p(\\textbf{x})\\) the prior distribution. <ul> <li><code>x</code>: The regimes of the parameters for the integral.</li> <li><code>p</code>: The prior distribution.</li> <li><code>rho</code>: Parameterized density matrix.</li> <li><code>drho</code>: Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated.</li> <li><code>LDtype</code>: Types of QFI (QFIM) can be set as the objective function. Options are \"SLD\" (default), \"RLD\" and \"LLD\".</li> <li><code>eps</code>: Machine epsilon.</li> </ul> <p>"},{"location":"API/julia/api/#quanestimationbcfim-method","title":"<code>QuanEstimation.BCFIM</code> \u2014 Method.","text":"<pre><code>BCFIM(x::AbstractVector, p, rho, drho; M=missing, eps=GLOBAL_EPS)\n</code></pre> <p>Calculation of the Bayesian classical Fisher information (BCFI) and the Bayesian classical Fisher information matrix (BCFIM) of the form \\(\\mathcal{I}_{\\mathrm{Bayes}}=\\int p(\\textbf{x})\\mathcal{I}\\mathrm{d}\\textbf{x}\\) with \\(\\mathcal{I}\\) the CFIM and \\(p(\\textbf{x})\\) the prior distribution.</p> <ul> <li><code>x</code>: The regimes of the parameters for the integral.</li> <li><code>p</code>: The prior distribution.</li> <li><code>rho</code>: Parameterized density matrix.</li> <li><code>drho</code>: Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated.</li> <li><code>M</code>: A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM).</li> <li><code>eps</code>: Machine epsilon.</li> </ul> <p>sourcers obtained via the maximum a posteriori probability (MAP). <ul> <li><code>x</code>: The regimes of the parameters for the integral.</li> <li><code>p</code>: The prior distribution.</li> <li><code>rho</code>: Parameterized density matrix.</li> <li><code>y</code>: The experimental results obtained in practice.</li> <li><code>M</code>: A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM).</li> <li><code>savefile</code>: Whether or not to save all the posterior distributions.</li> </ul> <p>"},{"location":"API/julia/api/#quanestimationbcrb-method","title":"<code>QuanEstimation.BCRB</code> \u2014 Method.","text":"<pre><code>BCRB(x::AbstractVector, p, dp, rho, drho; M=missing, b=missing, db=missing, btype=1, eps=GLOBAL_EPS)\n</code></pre> <p>Calculation of the Bayesian Cramer-Rao bound (BCRB).</p> <ul> <li><code>x</code>: The regimes of the parameters for the integral.</li> <li><code>p</code>: The prior distribution.</li> <li><code>dp</code>: Derivatives of the prior distribution with respect to the unknown parameters to be estimated. For example, dp[0] is the derivative vector on the first parameter.</li> <li><code>rho</code>: Parameterized density matrix.</li> <li><code>drho</code>: Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated.</li> <li><code>M</code>: A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM).</li> <li><code>b</code>: Vector of biases of the form \\(\\textbf{b}=(b(x_0),b(x_1),\\dots)^{\\mathrm{T}}\\).</li> <li><code>db</code>: Derivatives of b on the unknown parameters to be estimated, It should be expressed as \\(\\textbf{b}'=(\\partial_0 b(x_0),\\partial_1 b(x_1),\\dots)^{\\mathrm{T}}\\).</li> <li><code>btype</code>: Types of the BCRB. Options are 1, 2 and 3.</li> <li><code>eps</code>: Machine epsilon.</li> </ul> <p>sourcearameterized density matrix.   * <code>M</code>: A set of POVM.   * <code>W</code>: Weight matrix.   * <code>eps</code>: Machine epsilon. <p>"},{"location":"API/julia/api/#quanestimationbqcrb-method","title":"<code>QuanEstimation.BQCRB</code> \u2014 Method.","text":"<pre><code>BQCRB(x::AbstractVector, p, dp, rho, drho; b=missing, db=missing, LDtype=:SLD, btype=1, eps=GLOBAL_EPS)\n</code></pre> <p>Calculation of the Bayesian quantum Cramer-Rao bound (BQCRB).</p> <ul> <li><code>x</code>: The regimes of the parameters for the integral.</li> <li><code>p</code>: The prior distribution.</li> <li><code>dp</code>: Derivatives of the prior distribution with respect to the unknown parameters to be estimated. For example, dp[0] is the derivative vector on the first parameter.</li> <li><code>rho</code>: Parameterized density matrix.</li> <li><code>drho</code>: Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated.</li> <li><code>b</code>: Vector of biases of the form \\(\\textbf{b}=(b(x_0),b(x_1),\\dots)^{\\mathrm{T}}\\).</li> <li><code>db</code>: Derivatives of b on the unknown parameters to be estimated, It should be expressed as \\(\\textbf{b}'=(\\partial_0 b(x_0),\\partial_1 b(x_1),\\dots)^{\\mathrm{T}}\\).</li> <li><code>LDtype</code>: Types of QFI (QFIM) can be set as the objective function. Options are \"SLD\" (default), \"RLD\" and \"LLD\".</li> <li><code>btype</code>: Types of the BCRB. Options are 1, 2 and 3.</li> <li><code>eps</code>: Machine epsilon.</li> </ul> <p>sourcevative vector with respect to the first parameter.   * <code>M</code>: A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM).   * <code>eps</code>: Machine epsilon. <p>"},{"location":"API/julia/api/#quanestimationbqfim-method","title":"<code>QuanEstimation.BQFIM</code> \u2014 Method.","text":"<pre><code>BQFIM(x::AbstractVector, p, rho, drho; LDtype=:SLD, eps=GLOBAL_EPS)\n</code></pre> <p>Calculation of the Bayesian quantum Fisher information (BQFI) and the Bayesian quantum Fisher information matrix (BQFIM) of the form \\(\\mathcal{F}_{\\mathrm{Bayes}}=\\int p(\\textbf{x})\\mathcal{F}\\mathrm{d}\\textbf{x}\\) with \\(\\mathcal{F}\\) the QFIM of all types and \\(p(\\textbf{x})\\) the prior distribution.</p> <ul> <li><code>x</code>: The regimes of the parameters for the integral.</li> <li><code>p</code>: The prior distribution.</li> <li><code>rho</code>: Parameterized density matrix.</li> <li><code>drho</code>: Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated.</li> <li><code>LDtype</code>: Types of QFI (QFIM) can be set as the objective function. Options are \"SLD\" (default), \"RLD\" and \"LLD\".</li> <li><code>eps</code>: Machine epsilon.</li> </ul> <p>source&gt;"},{"location":"API/julia/api/#quanestimationbayes-method","title":"<code>QuanEstimation.Bayes</code> \u2014 Method.","text":"<pre><code>Bayes(x, p, rho, y; M=missing, savefile=false)\n</code></pre> <p>Bayesian estimation. The prior distribution is updated via the posterior distribution obtained by the Bayes' rule and the estimated value of parameters obtained via the maximum a posteriori probability (MAP).</p> <ul> <li><code>x</code>: The regimes of the parameters for the integral.</li> <li><code>p</code>: The prior distribution.</li> <li><code>rho</code>: Parameterized density matrix.</li> <li><code>y</code>: The experimental results obtained in practice.</li> <li><code>M</code>: A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM).</li> <li><code>savefile</code>: Whether or not to save all the posterior distributions.</li> </ul> <p>sourcestimation.jl/blob/5f47a686c13b059023de2abe67017d7c9564bc9d/src/ObjectiveFunc/AsymptoticBound/CramerRao.jl#L341-L346' class='documenter-source'&gt;"},{"location":"API/julia/api/#quanestimationbayescost-method","title":"<code>QuanEstimation.BayesCost</code> \u2014 Method.","text":"<pre><code>BayesCost(x, p, xest, rho, M; W=missing, eps=GLOBAL_EPS)\n</code></pre> <p>Calculation of the average Bayesian cost with a quadratic cost function.</p> <ul> <li><code>x</code>: The regimes of the parameters for the integral.</li> <li><code>p</code>: The prior distribution.</li> <li><code>xest</code>: The estimators.</li> <li><code>rho</code>: Parameterized density matrix.</li> <li><code>M</code>: A set of POVM.</li> <li><code>W</code>: Weight matrix.</li> <li><code>eps</code>: Machine epsilon.</li> </ul> <p>sourceter-source'&gt;"},{"location":"API/julia/api/#quanestimationcfim-method","title":"<code>QuanEstimation.CFIM</code> \u2014 Method.","text":"<pre><code>CFIM(\u03c1::Matrix{T}, d\u03c1::Vector{Matrix{T}}, M; eps=GLOBAL_EPS) where {T&lt;:Complex}\n</code></pre> <p>Calculate the classical Fisher information matrix (CFIM). </p> <ul> <li><code>\u03c1</code>: Density matrix.</li> <li><code>d\u03c1</code>: Derivatives of the density matrix with respect to the unknown parameters to be estimated. For example, drho[1] is the derivative vector with respect to the first parameter.</li> <li><code>M</code>: A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM).</li> <li><code>eps</code>: Machine epsilon.</li> </ul> <p>sourceA known small drift of the parameter.   * <code>ftype</code>: The distribution the data follows. Options are: norm, gamma, rayleigh, and poisson. <p>"},{"location":"API/julia/api/#quanestimationcfim-method_1","title":"<code>QuanEstimation.CFIM</code> \u2014 Method.","text":"<pre><code>CFIM(\u03c1::Matrix{T}, d\u03c1::Vector{Matrix{T}}; M=nothing, eps=GLOBAL_EPS) where {T&lt;:Complex}\n</code></pre> <p>When the set of POVM is not given. Calculate the CFIM with SIC-POVM. The SIC-POVM is generated from the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from here.</p> <p>sourcee</p>"},{"location":"API/julia/api/#quanestimationcfim-method_2","title":"<code>QuanEstimation.CFIM</code> \u2014 Method.","text":"<pre><code>CFIM(\u03c1::Matrix{T}, d\u03c1::Matrix{T}, M; eps=GLOBAL_EPS) where {T&lt;:Complex}\n</code></pre> <p>When applied to the case of single parameter. Calculate the classical Fisher information (CFI). </p> <p>sources`: Machine epsilon. <p>"},{"location":"API/julia/api/#quanestimationcfim-method_3","title":"<code>QuanEstimation.CFIM</code> \u2014 Method.","text":"<pre><code>CFIM(\u03c1::Matrix{T}, d\u03c1::Matrix{T}; eps=GLOBAL_EPS) where {T&lt;:Complex}\n</code></pre> <p>When applied to the case of single parameter and the set of POVM is not given. Calculate the CFI with SIC-POVM. </p> <p>sourcey matrix.   * <code>y</code>: The experimental results obtained in practice.   * <code>M</code>: A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM).   * <code>savefile</code>: Whether or not to save all the posterior distributions. <p>"},{"location":"API/julia/api/#quanestimationfim-method","title":"<code>QuanEstimation.FIM</code> \u2014 Method.","text":"<pre><code>FIM(p::Vector{R}, dp::Vector{R}; eps=GLOBAL_EPS) where {R&lt;:Real}\n</code></pre> <p>Calculation of the classical Fisher information matrix for classical scenarios. </p> <ul> <li><code>p</code>: The probability distribution.</li> <li><code>dp</code>: Derivatives of the probability distribution on the unknown parameters to be estimated. For example, dp[0] is the derivative vector on the first parameter.</li> <li><code>eps</code>: Machine epsilon.</li> </ul> <p>sourceonding default vaules. <code>mtype=:Projection</code>, <code>mtype=:LC</code> and <code>mtype=:Rotation</code>, the <code>kwargs...</code> are <code>M=missing</code>, <code>B=missing, POVM_basis=missing</code>, and <code>s=missing, POVM_basis=missing</code>, respectively. <p>"},{"location":"API/julia/api/#quanestimationfim-method_1","title":"<code>QuanEstimation.FIM</code> \u2014 Method.","text":"<pre><code>FIM(p::Vector{R}, dp::Vector{R}; eps=GLOBAL_EPS) where {R&lt;:Real}\n</code></pre> <p>When applied to the case of single parameter and the set of POVM is not given. Calculate the classical Fisher information for classical scenarios. </p> <p>sourceuanEstimation.NHB` \u2014 Method. <pre><code>NHB(\u03c1::AbstractMatrix, d\u03c1::AbstractVector, W::AbstractMatrix)\n</code></pre> <p>Nagaoka-Hayashi bound (NHB) via the semidefinite program (SDP).</p> <ul> <li><code>\u03c1</code>: Density matrix.</li> <li><code>d\u03c1</code>: Derivatives of the density matrix on the unknown parameters to be estimated. For example, drho[0] is the derivative vector on the first parameter.</li> <li><code>W</code>: Weight matrix.</li> </ul> <p>"},{"location":"API/julia/api/#quanestimationfi_expt-method","title":"<code>QuanEstimation.FI_Expt</code> \u2014 Method.","text":"<pre><code>FI_Expt(y1, y2, dx; ftype=:norm)\n</code></pre> <p>Calculate the classical Fisher information (CFI) based on the experiment data.</p> <ul> <li><code>y1</code>: Experimental data obtained at the truth value (x).</li> <li><code>y1</code>: Experimental data obtained at x+dx.</li> <li><code>dx</code>: A known small drift of the parameter.</li> <li><code>ftype</code>: The distribution the data follows. Options are: norm, gamma, rayleigh, and poisson.</li> </ul> <p>source <code>p</code>: The prior distribution.   * <code>dp</code>: Derivatives of the prior distribution with respect to the unknown parameters to be estimated. For example, dp[0] is the derivative vector on the first parameter.   * <code>rho</code>: Parameterized density matrix.   * <code>drho</code>: Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated.   * <code>d2rho</code>: Second order Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated.   * <code>LDtype</code>: Types of QFI (QFIM) can be set as the objective function. Options are \"SLD\" (default), \"RLD\" and \"LLD\".   * <code>eps</code>: Machine epsilon. <p>"},{"location":"API/julia/api/#quanestimationhcrb-method","title":"<code>QuanEstimation.HCRB</code> \u2014 Method.","text":"<pre><code>HCRB(\u03c1::AbstractMatrix, d\u03c1::AbstractVector, C::AbstractMatrix; eps=GLOBAL_EPS)\n</code></pre> <p>Caltulate the Holevo Cramer-Rao bound (HCRB) via the semidefinite program (SDP).</p> <ul> <li><code>\u03c1</code>: Density matrix.</li> <li><code>d\u03c1</code>: Derivatives of the density matrix on the unknown parameters to be estimated. For example, drho[0] is the derivative vector on the first parameter.</li> <li><code>W</code>: Weight matrix.</li> <li><code>eps</code>: Machine epsilon.</li> </ul> <p>source class='documenter-source'&gt;"},{"location":"API/julia/api/#quanestimationmle-method","title":"<code>QuanEstimation.MLE</code> \u2014 Method.","text":"<pre><code>MLE(x, rho, y; M=missing, savefile=false)\n</code></pre> <p>Bayesian estimation. The estimated value of parameters obtained via the maximum likelihood estimation (MLE).</p> <ul> <li><code>x</code>: The regimes of the parameters for the integral.</li> <li><code>rho</code>: Parameterized density matrix.</li> <li><code>y</code>: The experimental results obtained in practice.</li> <li><code>M</code>: A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM).</li> <li><code>savefile</code>: Whether or not to save all the posterior distributions.</li> </ul> <p>source be estimated. For example, drho[1] is the derivative vector with respect to the first parameter.   * <code>LDtype</code>: Types of QFI (QFIM) can be set as the objective function. Options are <code>:SLD</code> (default), <code>:RLD</code> and <code>:LLD</code>.   * <code>exportLD</code>: export logarithmic derivatives apart from F.   * <code>eps</code>: Machine epsilon. <p>"},{"location":"API/julia/api/#quanestimationmeasurementopt-method","title":"<code>QuanEstimation.MeasurementOpt</code> \u2014 Method.","text":"<pre><code>MeasurementOpt(mtype=:Projection, kwargs...)\n</code></pre> <p>Measurement optimization.</p> <ul> <li><code>mtype</code>: The type of scenarios for the measurement optimization. Options are <code>:Projection</code> (default), <code>:LC</code> and <code>:Rotation</code>.</li> <li><code>kwargs...</code>: keywords and the correponding default vaules. <code>mtype=:Projection</code>, <code>mtype=:LC</code> and <code>mtype=:Rotation</code>, the <code>kwargs...</code> are <code>M=missing</code>, <code>B=missing, POVM_basis=missing</code>, and <code>s=missing, POVM_basis=missing</code>, respectively.</li> </ul> <p>sourceter-source'&gt;"},{"location":"API/julia/api/#quanestimationnhb-method","title":"<code>QuanEstimation.NHB</code> \u2014 Method.","text":"<pre><code>NHB(\u03c1::AbstractMatrix, d\u03c1::AbstractVector, W::AbstractMatrix)\n</code></pre> <p>Nagaoka-Hayashi bound (NHB) via the semidefinite program (SDP).</p> <ul> <li><code>\u03c1</code>: Density matrix.</li> <li><code>d\u03c1</code>: Derivatives of the density matrix on the unknown parameters to be estimated. For example, drho[0] is the derivative vector on the first parameter.</li> <li><code>W</code>: Weight matrix.</li> </ul> <p>source&gt;"},{"location":"API/julia/api/#quanestimationobb-method","title":"<code>QuanEstimation.OBB</code> \u2014 Method.","text":"<pre><code>OBB(x::AbstractVector, p, dp, rho, drho, d2rho; LDtype=:SLD, eps=GLOBAL_EPS)\n</code></pre> <p>Calculation of the Bayesian version of Cramer-Rao bound introduced by Van Trees (VTB).</p> <ul> <li><code>x</code>: The regimes of the parameters for the integral.</li> <li><code>p</code>: The prior distribution.</li> <li><code>dp</code>: Derivatives of the prior distribution with respect to the unknown parameters to be estimated. For example, dp[0] is the derivative vector on the first parameter.</li> <li><code>rho</code>: Parameterized density matrix.</li> <li><code>drho</code>: Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated.</li> <li><code>d2rho</code>: Second order Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated.</li> <li><code>LDtype</code>: Types of QFI (QFIM) can be set as the objective function. Options are \"SLD\" (default), \"RLD\" and \"LLD\".</li> <li><code>eps</code>: Machine epsilon.</li> </ul> <p>sourcer&gt;"},{"location":"API/julia/api/#quanestimationqfim-method","title":"<code>QuanEstimation.QFIM</code> \u2014 Method.","text":"<pre><code>QFIM(\u03c1::Matrix{T}, d\u03c1::Vector{Matrix{T}}; LDtype=:SLD, exportLD::Bool= false, eps=GLOBAL_EPS) where {T&lt;:Complex}\n</code></pre> <p>When applied to the case of single parameter. Calculation of the quantum Fisher information (QFI) for all types.</p> <p>source<code>: Parameterized density matrix.   *</code>drho<code>: Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated.   *</code>LDtype<code>: Types of QFI (QFIM) can be set as the objective function. Options are \"SLD\" (default), \"RLD\" and \"LLD\".   *</code>eps`: Machine epsilon. <p>"},{"location":"API/julia/api/#quanestimationqfim-method_1","title":"<code>QuanEstimation.QFIM</code> \u2014 Method.","text":"<pre><code>QFIM(\u03c1::Matrix{T}, d\u03c1::Matrix{T}; LDtype=:SLD, exportLD::Bool= false, eps=GLOBAL_EPS) where {T&lt;:Complex}\n</code></pre> <p>Calculation of the quantum Fisher information (QFI) for all types. </p> <ul> <li><code>\u03c1</code>: Density matrix.</li> <li><code>d\u03c1</code>: Derivatives of the density matrix with respect to the unknown parameters to be estimated. For example, drho[1] is the derivative vector with respect to the first parameter.</li> <li><code>LDtype</code>: Types of QFI (QFIM) can be set as the objective function. Options are <code>:SLD</code> (default), <code>:RLD</code> and <code>:LLD</code>.</li> <li><code>exportLD</code>: export logarithmic derivatives apart from F.</li> <li><code>eps</code>: Machine epsilon.</li> </ul> <p>sourceimation/QuanEstimation.jl/blob/5f47a686c13b059023de2abe67017d7c9564bc9d/src/ObjectiveFunc/BayesianBound/ZivZakai.jl#L25-L34' class='documenter-source'&gt;"},{"location":"API/julia/api/#quanestimationqfim_gauss-method","title":"<code>QuanEstimation.QFIM_Gauss</code> \u2014 Method.","text":"<pre><code>QFIM_Gauss(R\u0304::V, dR\u0304::VV, D::M, dD::VM) where {V,VV,M,VM&lt;:AbstractVecOrMat}\n</code></pre> <p>Calculate the SLD based quantum Fisher information matrix (QFIM) with gaussian states.  </p> <ul> <li><code>R\u0304</code> : First-order moment.</li> <li><code>dR\u0304</code>: Derivatives of the first-order moment with respect to the unknown parameters to be estimated. For example, dR[1] is the derivative vector on the first parameter.</li> <li><code>D</code>: Second-order moment.</li> <li><code>dD</code>: Derivatives of the second-order moment with respect to the unknown parameters to be estimated.</li> <li><code>eps</code>: Machine epsilon.</li> </ul> <p>sources.html). <p>"},{"location":"API/julia/api/#quanestimationqfim_kraus-method","title":"<code>QuanEstimation.QFIM_Kraus</code> \u2014 Method.","text":"<pre><code>QFIM_Kraus(\u03c10::AbstractMatrix, K::AbstractVector, dK::AbstractVector; LDtype=:SLD, exportLD::Bool=false, eps=GLOBAL_EPS)\n</code></pre> <p>Calculation of the quantum Fisher information (QFI) and quantum Fisher information matrix (QFIM) with Kraus operator(s) for all types.</p> <ul> <li><code>\u03c10</code>: Density matrix.</li> <li><code>K</code>: Kraus operator(s).</li> <li><code>dK</code>: Derivatives of the Kraus operator(s) on the unknown parameters to be estimated. For example, dK[0] is the derivative vector on the first parameter.</li> <li><code>LDtype</code>: Types of QFI (QFIM) can be set as the objective function. Options are <code>:SLD</code> (default), <code>:RLD</code> and <code>:LLD</code>.</li> <li><code>exportLD</code>: Whether or not to export the values of logarithmic derivatives. If set True then the the values of logarithmic derivatives will be exported.</li> <li><code>eps</code>: Machine epsilon.</li> </ul> <p>source, e.g. QFIM, CFIM, HCRB, etc. <p>"},{"location":"API/julia/api/#quanestimationqvtb-method","title":"<code>QuanEstimation.QVTB</code> \u2014 Method.","text":"<pre><code>QVTB(x::AbstractVector, p, dp, rho, drho; LDtype=:SLD, eps=GLOBAL_EPS)\n</code></pre> <p>Calculation of the Bayesian version of Cramer-Rao bound in troduced by Van Trees (VTB).</p> <ul> <li><code>x</code>: The regimes of the parameters for the integral.</li> <li><code>p</code>: The prior distribution.</li> <li><code>dp</code>: Derivatives of the prior distribution with respect to the unknown parameters to be estimated. For example, dp[0] is the derivative vector on the first parameter.</li> <li><code>rho</code>: Parameterized density matrix.</li> <li><code>drho</code>: Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated.</li> <li><code>LDtype</code>: Types of QFI (QFIM) can be set as the objective function. Options are \"SLD\" (default), \"RLD\" and \"LLD\".</li> <li><code>eps</code>: Machine epsilon.</li> </ul> <p>source derivative vector on the first parameter.   * <code>rho</code>: Parameterized density matrix.   * <code>drho</code>: Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated.   * <code>M</code>: A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM).   * <code>eps</code>: Machine epsilon. <p>"},{"location":"API/julia/api/#quanestimationqzzb-method","title":"<code>QuanEstimation.QZZB</code> \u2014 Method.","text":"<pre><code>QZZB(x::AbstractVector, p::AbstractVector, rho::AbstractVecOrMat; eps=GLOBAL_EPS)\n</code></pre> <p>Calculation of the quantum Ziv-Zakai bound (QZZB).</p> <ul> <li><code>x</code>: The regimes of the parameters for the integral.</li> <li><code>p</code>: The prior distribution.</li> <li><code>rho</code>: Parameterized density matrix.</li> <li><code>eps</code>: Machine epsilon.</li> </ul> <p>source9564bc9d/src/Parameterization/Kraus/KrausDynamics.jl#L20-L25' class='documenter-source'&gt;"},{"location":"API/julia/api/#quanestimationsic-method","title":"<code>QuanEstimation.SIC</code> \u2014 Method.","text":"<pre><code>SIC(dim::Int64)\n</code></pre> <p>Generation of a set of rank-one symmetric informationally complete positive operator-valued measure (SIC-POVM).</p> <ul> <li><code>dim</code>: The dimension of the system.</li> </ul> <p>Note: SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded from here.</p> <p>sourcenter-source'&gt;"},{"location":"API/julia/api/#quanestimationspinsqueezing-method","title":"<code>QuanEstimation.SpinSqueezing</code> \u2014 Method.","text":"<pre><code>SpinSqueezing(\u03c1::AbstractMatrix; basis=\"Dicke\", output=\"KU\")\n</code></pre> <p>Calculate the spin squeezing parameter for the input density matrix. The <code>basis</code> can be <code>\"Dicke\"</code> for the Dicke basis, or <code>\"Pauli\"</code> for the Pauli basis. The <code>output</code> can be both <code>\"KU\"</code>(for spin squeezing defined by Kitagawa and Ueda) and <code>\"WBIMH\"</code>(for spin squeezing defined by Wineland et al.).</p> <p>source='documenter-source'&gt;"},{"location":"API/julia/api/#quanestimationtargettime-method","title":"<code>QuanEstimation.TargetTime</code> \u2014 Method.","text":"<pre><code>TargetTime(f::Number, tspan::AbstractVector, func::Function, args...; kwargs...)\n</code></pre> <p>Calculate the minimum time to reach a precision limit of given level. The <code>func</code> can be any objective function during the control optimization, e.g. QFIM, CFIM, HCRB, etc.</p> <p>source] is the derivative vector on the first parameter.   * <code>decay</code>: Decay operators and the corresponding decay rates. Its input rule is decay=[[\\(\\Gamma_1\\), \\(\\gamma_1\\)], [\\(\\Gamma_2\\), \\(\\gamma_2\\)],...], where \\(\\Gamma_1\\) \\((\\Gamma_2)\\) represents the decay operator and \\(\\gamma_1\\) \\((\\gamma_2)\\) is the corresponding decay rate.   * <code>Hc</code>: Control Hamiltonians.   * <code>ctrl</code>: Control coefficients. <p>"},{"location":"API/julia/api/#quanestimationvtb-method","title":"<code>QuanEstimation.VTB</code> \u2014 Method.","text":"<pre><code>VTB(x::AbstractVector, p, dp, rho, drho; M=missing, eps=GLOBAL_EPS)\n</code></pre> <p>Calculation of the Bayesian version of Cramer-Rao bound introduced by Van Trees (VTB).</p> <ul> <li><code>x</code>: The regimes of the parameters for the integral.</li> <li><code>p</code>: The prior distribution.</li> <li><code>dp</code>: Derivatives of the prior distribution with respect to the unknown parameters to be estimated. For example, dp[0] is the derivative vector on the first parameter.</li> <li><code>rho</code>: Parameterized density matrix.</li> <li><code>drho</code>: Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated.</li> <li><code>M</code>: A set of positive operator-valued measure (POVM). The default measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM).</li> <li><code>eps</code>: Machine epsilon.</li> </ul> <p>sourcemics<code>: Lindblad dynamics.   *</code>savefile<code>: Whether or not to save all the control coeffients.   *</code>method<code>: Methods for searching the minimum time to reach the given value of the objective function. Options are</code>binary<code>and</code>forward<code>.   *</code>system`: control system. <p>"},{"location":"API/julia/api/#quanestimationevolve-method","title":"<code>QuanEstimation.evolve</code> \u2014 Method.","text":"<pre><code>evolve(dynamics::Kraus{dm})\n</code></pre> <p>Evolution of density matrix under time-independent Hamiltonian without noise and controls.</p> <p>source59023de2abe67017d7c9564bc9d/src/Parameterization/Lindblad/LindbladDynamics.jl#L393-L398' class='documenter-source'&gt;"},{"location":"API/julia/api/#quanestimationevolve-method_1","title":"<code>QuanEstimation.evolve</code> \u2014 Method.","text":"<pre><code>evolve(dynamics::Kraus{ket})\n</code></pre> <p>Evolution of pure states under time-independent Hamiltonian without noise and controls</p> <p>sourceft{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\right}\\right)$, where \\(\\rho\\) is the evolved density matrix, \\(H\\) is the Hamiltonian of the system, \\(\\Gamma_i\\) and \\(\\gamma_i\\) are the \\(i\\mathrm{th}\\) decay operator and the corresponding decay rate. <ul> <li><code>tspan</code>: Time length for the evolution.</li> <li><code>\u03c10</code>: Initial state (density matrix).</li> <li><code>H0</code>: Free Hamiltonian.</li> <li><code>dH</code>: Derivatives of the free Hamiltonian with respect to the unknown parameters to be estimated. For example, dH[0] is the derivative vector on the first parameter.</li> <li><code>decay</code>: Decay operators and the corresponding decay rates. Its input rule is decay=[[\\(\\Gamma_1\\), \\(\\gamma_1\\)], [\\(\\Gamma_2\\), \\(\\gamma_2\\)],...], where \\(\\Gamma_1\\) \\((\\Gamma_2)\\) represents the decay operator and \\(\\gamma_1\\) \\((\\gamma_2)\\) is the corresponding decay rate.</li> <li><code>Hc</code>: Control Hamiltonians.</li> <li><code>ctrl</code>: Control coefficients.</li> </ul> <p>"},{"location":"API/julia/api/#quanestimationexpm-method","title":"<code>QuanEstimation.expm</code> \u2014 Method.","text":"<pre><code>expm(tspan::AbstractVector, \u03c10::AbstractMatrix, H0::AbstractMatrix, dH::AbstractMatrix; decay::Union{AbstractVector, Missing}=missing, Hc::Union{AbstractVector, Missing}=missing, ctrl::Union{AbstractVector, Missing}=missing)\n</code></pre> <p>When applied to the case of single parameter. </p> <p>sourceding decay rates. Its input rule is decay=[[\\(\\Gamma_1\\), \\(\\gamma_1\\)], [\\(\\Gamma_2\\), \\(\\gamma_2\\)],...], where \\(\\Gamma_1\\) \\((\\Gamma_2)\\) represents the decay operator and \\(\\gamma_1\\) \\((\\gamma_2)\\) is the corresponding decay rate.   * <code>Hc</code>: Control Hamiltonians.   * <code>ctrl</code>: Control coefficients. <p>"},{"location":"API/julia/api/#quanestimationexpm-method_1","title":"<code>QuanEstimation.expm</code> \u2014 Method.","text":"<pre><code>expm(tspan::AbstractVector, \u03c10::AbstractMatrix, H0::AbstractMatrix, dH::AbstractVector; decay::Union{AbstractVector, Missing}=missing, Hc::Union{AbstractVector, Missing}=missing, ctrl::Union{AbstractVector, Missing}=missing)\n</code></pre> <p>The dynamics of a density matrix is of the form  \\(\\partial_t\\rho=-i[H,\\rho]+\\sum_i \\gamma_i\\left(\\Gamma_i\\rho\\Gamma^{\\dagger}_i-\\frac{1}{2}\\left\\{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\right\\}\\right)\\), where \\(\\rho\\) is the evolved density matrix, \\(H\\) is the Hamiltonian of the system, \\(\\Gamma_i\\) and \\(\\gamma_i\\) are the \\(i\\mathrm{th}\\) decay operator and the corresponding decay rate.</p> <ul> <li><code>tspan</code>: Time length for the evolution.</li> <li><code>\u03c10</code>: Initial state (density matrix).</li> <li><code>H0</code>: Free Hamiltonian.</li> <li><code>dH</code>: Derivatives of the free Hamiltonian with respect to the unknown parameters to be estimated. For example, dH[0] is the derivative vector on the first parameter.</li> <li><code>decay</code>: Decay operators and the corresponding decay rates. Its input rule is decay=[[\\(\\Gamma_1\\), \\(\\gamma_1\\)], [\\(\\Gamma_2\\), \\(\\gamma_2\\)],...], where \\(\\Gamma_1\\) \\((\\Gamma_2)\\) represents the decay operator and \\(\\gamma_1\\) \\((\\gamma_2)\\) is the corresponding decay rate.</li> <li><code>Hc</code>: Control Hamiltonians.</li> <li><code>ctrl</code>: Control coefficients.</li> </ul> <p>source' class='documenter-source'&gt;"},{"location":"API/julia/api/#quanestimationmintime-method","title":"<code>QuanEstimation.mintime</code> \u2014 Method.","text":"<pre><code>mintime(f::Number, opt::ControlOpt, alg::AbstractAlgorithm, obj::AbstractObj, dynamics::AbstractDynamics; savefile::Bool=false, method::String=\"binary\")\n</code></pre> <p>Search of the minimum time to reach a given value of the objective function.</p> <ul> <li><code>f</code>: The given value of the objective function.</li> <li><code>opt</code>: Control Optimization.</li> <li><code>alg</code>: Optimization algorithms, options are <code>auto-GRAPE</code>, <code>GRAPE</code>, <code>PSO</code>, <code>DE</code> and <code>DDPG</code>.</li> <li><code>obj</code>: Objective function, options are <code>QFIM_obj</code>, <code>CFIM_obj</code> and <code>HCRB_obj</code>.</li> <li><code>dynamics</code>: Lindblad dynamics.</li> <li><code>savefile</code>: Whether or not to save all the control coeffients.</li> <li><code>method</code>: Methods for searching the minimum time to reach the given value of the objective function. Options are <code>binary</code> and <code>forward</code>.</li> <li><code>system</code>: control system.</li> </ul> <p>sourceementOpt<code>,</code>SMopt<code>,</code>SCopt<code>,</code>CMopt<code>and</code>SCMopt<code>.   *</code>alg<code>: Optimization algorithms, options are</code>auto-GRAPE<code>,</code>GRAPE<code>,</code>AD<code>,</code>PSO<code>,</code>DE<code>, 'NM' and</code>DDPG<code>.   *</code>obj<code>: Objective function, options are</code>QFIM_obj<code>,</code>CFIM_obj<code>and</code>HCRB_obj<code>.   *</code>dynamics<code>: Lindblad or Kraus parameterization process.   *</code>savefile`: Whether or not to save all the control coeffients. <p>"},{"location":"API/julia/api/#quanestimationode-method","title":"<code>QuanEstimation.ode</code> \u2014 Method.","text":"<pre><code>ode(tspan::AbstractVector, \u03c10::AbstractMatrix, H0::AbstractMatrix, dH::AbstractMatrix; decay::Union{AbstractVector, Missing}=missing, Hc::Union{AbstractVector, Missing}=missing, ctrl::Union{AbstractVector, Missing}=missing)\n</code></pre> <p>When applied to the case of single parameter. </p> <p>sourcerget='_blank' href='https://github.com/QuanEstimation/QuanEstimation.jl/blob/5f47a686c13b059023de2abe67017d7c9564bc9d/src/run.jl#L24-L35' class='documenter-source'&gt;"},{"location":"API/julia/api/#quanestimationode-method_1","title":"<code>QuanEstimation.ode</code> \u2014 Method.","text":"<pre><code>ode(tspan::AbstractVector, \u03c10::AbstractMatrix, H0::AbstractVector, dH::AbstractVector; decay::Union{AbstractVector, Missing}=missing, Hc::Union{AbstractVector, Missing}=missing, ctrl::Union{AbstractVector, Missing}=missing)\n</code></pre> <p>The dynamics of a density matrix is of the form  \\(\\partial_t\\rho=-i[H,\\rho]+\\sum_i \\gamma_i\\left(\\Gamma_i\\rho\\Gamma^{\\dagger}_i-\\frac{1}{2}\\left\\{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\right\\}\\right)\\), where \\(\\rho\\) is the evolved density matrix, \\(H\\) is the Hamiltonian of the system, \\(\\Gamma_i\\) and \\(\\gamma_i\\) are the \\(i\\mathrm{th}\\) decay operator and the corresponding decay rate.</p> <ul> <li><code>tspan</code>: Time length for the evolution.</li> <li><code>\u03c10</code>: Initial state (density matrix).</li> <li><code>H0</code>: Free Hamiltonian.</li> <li><code>dH</code>: Derivatives of the free Hamiltonian with respect to the unknown parameters to be estimated. For example, dH[0] is the derivative vector on the first parameter.</li> <li><code>decay</code>: Decay operators and the corresponding decay rates. Its input rule is decay=[[\\(\\Gamma_1\\), \\(\\gamma_1\\)], [\\(\\Gamma_2\\), \\(\\gamma_2\\)],...], where \\(\\Gamma_1\\) \\((\\Gamma_2)\\) represents the decay operator and \\(\\gamma_1\\) \\((\\gamma_2)\\) is the corresponding decay rate.</li> <li><code>Hc</code>: Control Hamiltonians.</li> <li><code>ctrl</code>: Control coefficients.</li> </ul> <p>source</p>"},{"location":"API/julia/api/#quanestimationoffline-method","title":"<code>QuanEstimation.offline</code> \u2014 Method.","text":"<pre><code>offline(apt::Adapt_MZI, alg; target::Symbol=:sharpness, eps = GLOBAL_EPS, seed=1234)\n</code></pre> <p>Offline adaptive phase estimation in the MZI.</p> <ul> <li><code>apt</code>: Adaptive MZI struct which contains <code>x</code>, <code>p</code>, and <code>rho0</code>.</li> <li><code>alg</code>: The algorithms for searching the optimal tunable phase. Here, DE and PSO are available.</li> <li><code>target</code>: Setting the target function for calculating the tunable phase. Options are: \"sharpness\" and \"MI\".</li> <li><code>eps</code>: Machine epsilon.</li> <li><code>seed</code>: Random seed.</li> </ul> <p>source</p>"},{"location":"API/julia/api/#quanestimationonline-method","title":"<code>QuanEstimation.online</code> \u2014 Method.","text":"<pre><code>online(apt::Adapt_MZI; target::Symbol=:sharpness, output::String=\"phi\")\n</code></pre> <p>Online adaptive phase estimation in the MZI.</p> <ul> <li><code>apt</code>: Adaptive MZI struct which contains x, p, and rho0.</li> <li><code>target</code>: Setting the target function for calculating the tunable phase. Options are: \"sharpness\" and \"MI\".</li> <li><code>output</code>: Choose the output variables. Options are: \"phi\" and \"dphi\".</li> </ul> <p>source</p>"},{"location":"API/julia/api/#quanestimationrun-method","title":"<code>QuanEstimation.run</code> \u2014 Method.","text":"<pre><code>run(opt::AbstractOpt, alg::AbstractAlgorithm, obj::AbstractObj, dynamics::AbstractDynamics; savefile::Bool=false)\n</code></pre> <p>Run the optimization problem.</p> <ul> <li><code>opt</code>: Types of optimization, options are <code>ControlOpt</code>, <code>StateOpt</code>, <code>MeasurementOpt</code>, <code>SMopt</code>, <code>SCopt</code>, <code>CMopt</code> and <code>SCMopt</code>.</li> <li><code>alg</code>: Optimization algorithms, options are <code>auto-GRAPE</code>, <code>GRAPE</code>, <code>AD</code>, <code>PSO</code>, <code>DE</code>, 'NM' and <code>DDPG</code>.</li> <li><code>obj</code>: Objective function, options are <code>QFIM_obj</code>, <code>CFIM_obj</code> and <code>HCRB_obj</code>.</li> <li><code>dynamics</code>: Lindblad or Kraus parameterization process.</li> <li><code>savefile</code>: Whether or not to save all the control coeffients.</li> </ul> <p>source</p>"},{"location":"API/julia/api/#quanestimationsun_generator-method","title":"<code>QuanEstimation.suN_generator</code> \u2014 Method.","text":"<pre><code>suN_generator(n::Int64)\n</code></pre> <p>Generation of the SU(\\(N\\)) generators with \\(N\\) the dimension of the system.</p> <ul> <li><code>N</code>: The dimension of the system.</li> </ul> <p>source</p>"},{"location":"API/python/classes/","title":"Classes","text":"<p>This part is the classes of the Python-Julia package which written in Python.</p>"},{"location":"API/python/classes/#dynamics","title":"Dynamics","text":"<p>Class for simulating quantum dynamics governed by the Lindblad master equation.</p> <p>The dynamics of a density matrix is described by the Lindblad master equation:</p> \\[\\begin{aligned}     \\partial_t\\rho &amp;=\\mathcal{L}\\rho \\nonumber \\\\     &amp;=-i[H,\\rho]+\\sum_i \\gamma_i(\\Gamma_i\\rho\\Gamma^{\\dagger}_i-\\frac{1}{2}     \\{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\}), \\end{aligned}\\] Symbols <ul> <li>\\(\\rho\\): the evolved density matrix</li> <li>\\(H\\): the Hamiltonian of the system</li> <li>\\(\\Gamma_i\\): the \\(i\\)th decay operator</li> <li>\\(\\gamma_i\\): the \\(i\\)th decay rate</li> </ul> <p>Attributes:</p> Name Type Description <code>tspan</code> <code>array</code> <p>Time points for the evolution.</p> <code>rho0</code> <code>array</code> <p>Initial state (density matrix).</p> <code>H0</code> <code>array / list</code> <p>Free Hamiltonian. It is a matrix when time-independent, or a list of matrices  (with length equal to <code>tspan</code>) when time-dependent.</p> <code>dH</code> <code>list</code> <p>Derivatives of the free Hamiltonian with respect to the unknown parameters. Each element is a matrix representing the partial derivative with respect to  one parameter. For example, <code>dH[0]</code> is the derivative with respect to the  first parameter.</p> <code>decay</code> <code>list</code> <p>Decay operators and corresponding decay rates. Input format: <code>decay=[[\u0393\u2081, \u03b3\u2081], [\u0393\u2082, \u03b3\u2082], ...]</code>, where \u0393\u2081, \u0393\u2082 are decay operators and \u03b3\u2081, \u03b3\u2082  are the corresponding decay rates.</p> <code>Hc</code> <code>list</code> <p>Control Hamiltonians.</p> <code>ctrl</code> <code>list</code> <p>Control coefficients for each control Hamiltonian.</p> Source code in <code>quanestimation/Parameterization/GeneralDynamics.py</code> <pre><code>class Lindblad:\n    r\"\"\"\n    Class for simulating quantum dynamics governed by the Lindblad master equation.\n\n    The dynamics of a density matrix is described by the Lindblad master equation:\n\n    \\begin{aligned}\n        \\partial_t\\rho &amp;=\\mathcal{L}\\rho \\nonumber \\\\\n        &amp;=-i[H,\\rho]+\\sum_i \\gamma_i(\\Gamma_i\\rho\\Gamma^{\\dagger}_i-\\frac{1}{2}\n        \\{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\}),\n    \\end{aligned}\n\n    Symbols: \n        - $\\rho$: the evolved density matrix\n        - $H$: the Hamiltonian of the system\n        - $\\Gamma_i$: the $i$th decay operator\n        - $\\gamma_i$: the $i$th decay rate\n\n    Attributes:\n        tspan (np.array): \n            Time points for the evolution.\n        rho0 (np.array): \n            Initial state (density matrix).\n        H0 (np.array/list): \n            Free Hamiltonian. It is a matrix when time-independent, or a list of matrices \n            (with length equal to `tspan`) when time-dependent.\n        dH (list): \n            Derivatives of the free Hamiltonian with respect to the unknown parameters.  \n            Each element is a matrix representing the partial derivative with respect to \n            one parameter. For example, `dH[0]` is the derivative with respect to the \n            first parameter.\n        decay (list): \n            Decay operators and corresponding decay rates. Input format:  \n            `decay=[[\u0393\u2081, \u03b3\u2081], [\u0393\u2082, \u03b3\u2082], ...]`, where \u0393\u2081, \u0393\u2082 are decay operators and \u03b3\u2081, \u03b3\u2082 \n            are the corresponding decay rates.\n        Hc (list): \n            Control Hamiltonians.\n        ctrl (list, optional): \n            Control coefficients for each control Hamiltonian.\n    \"\"\"\n\n    def __init__(self, tspan, rho0, H0, dH, decay=[], Hc=[], ctrl=[]):\n\n        self.tspan = tspan\n        self.rho0 = np.array(rho0, dtype=np.complex128)\n\n        if type(H0) == np.ndarray:\n            self.freeHamiltonian = np.array(H0, dtype=np.complex128)\n        else:\n            self.freeHamiltonian = [np.array(x, dtype=np.complex128) for x in H0]\n\n        if type(dH[0]) != np.ndarray:\n            raise TypeError(\"The derivative of Hamiltonian should be a list!\")\n\n        if not dH:\n            dH = [np.zeros((len(self.rho0), len(self.rho0)))]\n        self.Hamiltonian_derivative = [np.array(x, dtype=np.complex128) for x in dH]\n\n        if not decay:\n            decay_opt = [np.zeros((len(self.rho0), len(self.rho0)))]\n            self.gamma = [0.0]\n        else:\n            decay_opt = [decay[i][0] for i in range(len(decay))]\n            self.gamma = [decay[i][1] for i in range(len(decay))]\n        self.decay_opt = [np.array(x, dtype=np.complex128) for x in decay_opt]\n\n        if not Hc:\n            Hc = [np.zeros((len(self.rho0), len(self.rho0)))]\n            ctrl = [np.zeros(len(self.tspan) - 1)]\n            self.control_Hamiltonian = [np.array(x, dtype=np.complex128) for x in Hc]\n            self.control_coefficients = ctrl\n        elif not ctrl:\n            ctrl = [np.zeros(len(self.tspan) - 1) for j in range(len(Hc))]\n            self.control_Hamiltonian = Hc\n            self.control_coefficients = ctrl\n        else:\n            ctrl_length = len(ctrl)\n            ctrlnum = len(Hc)\n            if ctrlnum &lt; ctrl_length:\n                raise TypeError(\n                    \"There are %d control Hamiltonians but %d coefficients sequences: \\\n                                too many coefficients sequences\"\n                    % (ctrlnum, ctrl_length)\n                )\n            elif ctrlnum &gt; ctrl_length:\n                warnings.warn(\n                    \"Not enough coefficients sequences: there are %d control Hamiltonians \\\n                            but %d coefficients sequences. The rest of the control sequences are\\\n                            set to be 0.\"\n                    % (ctrlnum, ctrl_length),\n                    DeprecationWarning,\n                )\n\n            number = math.ceil((len(self.tspan) - 1) / len(ctrl[0]))\n            if len(self.tspan) - 1 % len(ctrl[0]) != 0:\n                tnum = number * len(ctrl[0])\n                self.tspan = np.linspace(self.tspan[0], self.tspan[-1], tnum + 1)\n            self.control_Hamiltonian = Hc\n            self.control_coefficients = ctrl\n\n    def expm(self):\n        r\"\"\"\n        Calculate the density matrix and its derivatives using the matrix exponential method.\n\n        The density matrix at the $j$th time interval is obtained by:\n\n        $$\n            \\rho_j = e^{\\Delta t \\mathcal{L}} \\rho_{j-1}\n        $$\n\n        where $\\Delta t$ is the time interval and $\\rho_{j-1}$ is the density matrix \n        at the previous time step.\n\n        The derivative $\\partial_{\\textbf{x}}\\rho_j$ is calculated as:\n\n        $$\n            \\partial_{\\textbf{x}}\\rho_j = \\Delta t (\\partial_{\\textbf{x}}\\mathcal{L}) \\rho_j\n            + e^{\\Delta t \\mathcal{L}} (\\partial_{\\textbf{x}}\\rho_{j-1})\n        $$\n\n        Returns: \n            (tuple):\n                rho (list): \n                    Density matrices at each time point in `tspan`.\n\n                drho (list): \n                    Derivatives of the density matrices with respect to the unknown parameters.  \n                    `drho[i][j]` is the derivative of the density matrix at the i-th time point \n                    with respect to the j-th parameter.\n        \"\"\"\n\n        rho, drho = QJL.expm_py(\n            self.tspan,\n            self.rho0,\n            self.freeHamiltonian,\n            self.Hamiltonian_derivative,\n            self.decay_opt,\n            self.gamma,\n            self.control_Hamiltonian,\n            self.control_coefficients,\n        )\n\n        # Convert Julia matrices to numpy arrays safely\n        rho = [np.array(rho_i) if not hasattr(rho_i, '_jl') else np.array(rho_i._jl) for rho_i in rho]\n        drho = [\n            [np.array(drho_ij) if not hasattr(drho_ij, '_jl') else np.array(drho_ij._jl) \n             for drho_ij in drho_i] \n            for drho_i in drho\n        ]\n\n        return rho, drho\n\n    def ode(self):\n        r\"\"\"\n        Calculate the density matrix and its derivatives using an ODE solver.\n\n        The density matrix at the $j$th time interval is obtained by:\n\n        $$\n            \\rho_j = e^{\\Delta t \\mathcal{L}} \\rho_{j-1},\n        $$\n\n        where $\\Delta t$ is the time interval and $\\rho_{j-1}$ is the density matrix \n        at the previous time step.\n\n        The derivative $\\partial_{\\textbf{x}}\\rho_j$ is calculated as:\n\n        $$\n            \\partial_{\\textbf{x}}\\rho_j = \\Delta t (\\partial_{\\textbf{x}}\\mathcal{L}) \\rho_j\n            + e^{\\Delta t \\mathcal{L}} (\\partial_{\\textbf{x}}\\rho_{j-1}).\n        $$\n\n        Returns:\n            (tuple):\n                rho (list): \n                    Density matrices at each time point in `tspan`.\n\n                drho (list): \n                    Derivatives of the density matrices with respect to the unknown parameters.  \n                    `drho[i][j]` is the derivative of the density matrix at the i-th time point \n                    with respect to the j-th parameter.\n        \"\"\"\n\n        rho, drho = QJL.ode_py(\n            self.tspan,\n            self.rho0,\n            self.freeHamiltonian,\n            self.Hamiltonian_derivative,\n            self.decay_opt,\n            self.gamma,\n            self.control_Hamiltonian,\n            self.control_coefficients,\n        )\n\n        # Convert Julia matrices to numpy arrays safely\n        rho = [np.array(rho_i) if not hasattr(rho_i, '_jl') else np.array(rho_i._jl) for rho_i in rho]\n        drho = [\n            [np.array(drho_ij) if not hasattr(drho_ij, '_jl') else np.array(drho_ij._jl) \n             for drho_ij in drho_i] \n            for drho_i in drho\n        ]\n\n        return rho, drho\n\n    def secondorder_derivative(self, d2H):\n        r\"\"\"\n        Calculate the density matrix, its first derivatives, and second derivatives \n        with respect to the unknown parameters.\n\n        The density matrix at the $j$th time interval is obtained by:\n\n        $$\n            \\rho_j = e^{\\Delta t \\mathcal{L}} \\rho_{j-1}.\n        $$\n\n        The first derivative $\\partial_{\\textbf{x}}\\rho_j$ is calculated as:\n\n        $$\n            \\partial_{\\textbf{x}}\\rho_j = \\Delta t (\\partial_{\\textbf{x}}\\mathcal{L}) \\rho_j\n            + e^{\\Delta t \\mathcal{L}} (\\partial_{\\textbf{x}}\\rho_{j-1}).\n        $$\n\n        The second derivative $\\partial_{\\textbf{x}}^2\\rho_j$ is calculated as:\n\n        \\begin{aligned}\n            \\partial_{\\textbf{x}}^2\\rho_j =&amp; \\Delta t (\\partial_{\\textbf{x}}^2\\mathcal{L}) \\rho_j \n            + \\Delta t (\\partial_{\\textbf{x}}\\mathcal{L}) \\partial_{\\textbf{x}}\\rho_j \\\\\n            &amp;+ \\Delta t (\\partial_{\\textbf{x}}\\mathcal{L}) e^{\\Delta t \\mathcal{L}} \\partial_{\\textbf{x}}\\rho_{j-1} \n            + e^{\\Delta t \\mathcal{L}} (\\partial_{\\textbf{x}}^2\\rho_{j-1}).\n        \\end{aligned}\n\n        Args:\n            d2H (list): Second-order derivatives of the free Hamiltonian with respect to the unknown parameters.  \n                Each element is a matrix representing the second partial derivative with respect to \n                two parameters. For example, `d2H[0]` might be the second derivative with respect to \n                the first parameter twice, or a mixed partial derivative.\n\n        Returns:\n            (tuple):\n                rho (list): \n                    Density matrices at each time point in `tspan`.\n\n                drho (list): \n                    First derivatives of the density matrices with respect to the unknown parameters.\n\n                d2rho (list): \n                    Second derivatives of the density matrices with respect to the unknown parameters.\n        \"\"\"\n\n        d2H = [np.array(x, dtype=np.complex128) for x in d2H]\n        rho, drho, d2rho = QJL.secondorder_derivative(\n            self.tspan,\n            self.rho0,\n            self.freeHamiltonian,\n            self.Hamiltonian_derivative,\n            d2H,\n            self.decay_opt,\n            self.gamma,\n            self.control_Hamiltonian,\n            self.control_coefficients,\n        )\n        rho = [np.array(rho_i) for rho_i in rho]\n        drho = [[np.array(drho_ij) for drho_ij in drho_i] for drho_i in drho]\n\n        return rho, drho, d2rho\n</code></pre>"},{"location":"API/python/classes/#quanestimation.Lindblad.expm","title":"<code>expm()</code>","text":"<p>Calculate the density matrix and its derivatives using the matrix exponential method.</p> <p>The density matrix at the \\(j\\)th time interval is obtained by:</p> \\[     \\rho_j = e^{\\Delta t \\mathcal{L}} \\rho_{j-1} \\] <p>where \\(\\Delta t\\) is the time interval and \\(\\rho_{j-1}\\) is the density matrix  at the previous time step.</p> <p>The derivative \\(\\partial_{\\textbf{x}}\\rho_j\\) is calculated as:</p> \\[     \\partial_{\\textbf{x}}\\rho_j = \\Delta t (\\partial_{\\textbf{x}}\\mathcal{L}) \\rho_j     + e^{\\Delta t \\mathcal{L}} (\\partial_{\\textbf{x}}\\rho_{j-1}) \\] <p>Returns:</p> Type Description <code>tuple</code> <p>rho (list):      Density matrices at each time point in <code>tspan</code>.</p> <p>drho (list):      Derivatives of the density matrices with respect to the unknown parameters. <code>drho[i][j]</code> is the derivative of the density matrix at the i-th time point      with respect to the j-th parameter.</p> Source code in <code>quanestimation/Parameterization/GeneralDynamics.py</code> <pre><code>def expm(self):\n    r\"\"\"\n    Calculate the density matrix and its derivatives using the matrix exponential method.\n\n    The density matrix at the $j$th time interval is obtained by:\n\n    $$\n        \\rho_j = e^{\\Delta t \\mathcal{L}} \\rho_{j-1}\n    $$\n\n    where $\\Delta t$ is the time interval and $\\rho_{j-1}$ is the density matrix \n    at the previous time step.\n\n    The derivative $\\partial_{\\textbf{x}}\\rho_j$ is calculated as:\n\n    $$\n        \\partial_{\\textbf{x}}\\rho_j = \\Delta t (\\partial_{\\textbf{x}}\\mathcal{L}) \\rho_j\n        + e^{\\Delta t \\mathcal{L}} (\\partial_{\\textbf{x}}\\rho_{j-1})\n    $$\n\n    Returns: \n        (tuple):\n            rho (list): \n                Density matrices at each time point in `tspan`.\n\n            drho (list): \n                Derivatives of the density matrices with respect to the unknown parameters.  \n                `drho[i][j]` is the derivative of the density matrix at the i-th time point \n                with respect to the j-th parameter.\n    \"\"\"\n\n    rho, drho = QJL.expm_py(\n        self.tspan,\n        self.rho0,\n        self.freeHamiltonian,\n        self.Hamiltonian_derivative,\n        self.decay_opt,\n        self.gamma,\n        self.control_Hamiltonian,\n        self.control_coefficients,\n    )\n\n    # Convert Julia matrices to numpy arrays safely\n    rho = [np.array(rho_i) if not hasattr(rho_i, '_jl') else np.array(rho_i._jl) for rho_i in rho]\n    drho = [\n        [np.array(drho_ij) if not hasattr(drho_ij, '_jl') else np.array(drho_ij._jl) \n         for drho_ij in drho_i] \n        for drho_i in drho\n    ]\n\n    return rho, drho\n</code></pre>"},{"location":"API/python/classes/#quanestimation.Lindblad.ode","title":"<code>ode()</code>","text":"<p>Calculate the density matrix and its derivatives using an ODE solver.</p> <p>The density matrix at the \\(j\\)th time interval is obtained by:</p> \\[     \\rho_j = e^{\\Delta t \\mathcal{L}} \\rho_{j-1}, \\] <p>where \\(\\Delta t\\) is the time interval and \\(\\rho_{j-1}\\) is the density matrix  at the previous time step.</p> <p>The derivative \\(\\partial_{\\textbf{x}}\\rho_j\\) is calculated as:</p> \\[     \\partial_{\\textbf{x}}\\rho_j = \\Delta t (\\partial_{\\textbf{x}}\\mathcal{L}) \\rho_j     + e^{\\Delta t \\mathcal{L}} (\\partial_{\\textbf{x}}\\rho_{j-1}). \\] <p>Returns:</p> Type Description <code>tuple</code> <p>rho (list):      Density matrices at each time point in <code>tspan</code>.</p> <p>drho (list):      Derivatives of the density matrices with respect to the unknown parameters. <code>drho[i][j]</code> is the derivative of the density matrix at the i-th time point      with respect to the j-th parameter.</p> Source code in <code>quanestimation/Parameterization/GeneralDynamics.py</code> <pre><code>def ode(self):\n    r\"\"\"\n    Calculate the density matrix and its derivatives using an ODE solver.\n\n    The density matrix at the $j$th time interval is obtained by:\n\n    $$\n        \\rho_j = e^{\\Delta t \\mathcal{L}} \\rho_{j-1},\n    $$\n\n    where $\\Delta t$ is the time interval and $\\rho_{j-1}$ is the density matrix \n    at the previous time step.\n\n    The derivative $\\partial_{\\textbf{x}}\\rho_j$ is calculated as:\n\n    $$\n        \\partial_{\\textbf{x}}\\rho_j = \\Delta t (\\partial_{\\textbf{x}}\\mathcal{L}) \\rho_j\n        + e^{\\Delta t \\mathcal{L}} (\\partial_{\\textbf{x}}\\rho_{j-1}).\n    $$\n\n    Returns:\n        (tuple):\n            rho (list): \n                Density matrices at each time point in `tspan`.\n\n            drho (list): \n                Derivatives of the density matrices with respect to the unknown parameters.  \n                `drho[i][j]` is the derivative of the density matrix at the i-th time point \n                with respect to the j-th parameter.\n    \"\"\"\n\n    rho, drho = QJL.ode_py(\n        self.tspan,\n        self.rho0,\n        self.freeHamiltonian,\n        self.Hamiltonian_derivative,\n        self.decay_opt,\n        self.gamma,\n        self.control_Hamiltonian,\n        self.control_coefficients,\n    )\n\n    # Convert Julia matrices to numpy arrays safely\n    rho = [np.array(rho_i) if not hasattr(rho_i, '_jl') else np.array(rho_i._jl) for rho_i in rho]\n    drho = [\n        [np.array(drho_ij) if not hasattr(drho_ij, '_jl') else np.array(drho_ij._jl) \n         for drho_ij in drho_i] \n        for drho_i in drho\n    ]\n\n    return rho, drho\n</code></pre>"},{"location":"API/python/classes/#quanestimation.Lindblad.secondorder_derivative","title":"<code>secondorder_derivative(d2H)</code>","text":"<p>Calculate the density matrix, its first derivatives, and second derivatives  with respect to the unknown parameters.</p> <p>The density matrix at the \\(j\\)th time interval is obtained by:</p> \\[     \\rho_j = e^{\\Delta t \\mathcal{L}} \\rho_{j-1}. \\] <p>The first derivative \\(\\partial_{\\textbf{x}}\\rho_j\\) is calculated as:</p> \\[     \\partial_{\\textbf{x}}\\rho_j = \\Delta t (\\partial_{\\textbf{x}}\\mathcal{L}) \\rho_j     + e^{\\Delta t \\mathcal{L}} (\\partial_{\\textbf{x}}\\rho_{j-1}). \\] <p>The second derivative \\(\\partial_{\\textbf{x}}^2\\rho_j\\) is calculated as:</p> \\[\\begin{aligned}     \\partial_{\\textbf{x}}^2\\rho_j =&amp; \\Delta t (\\partial_{\\textbf{x}}^2\\mathcal{L}) \\rho_j      + \\Delta t (\\partial_{\\textbf{x}}\\mathcal{L}) \\partial_{\\textbf{x}}\\rho_j \\\\     &amp;+ \\Delta t (\\partial_{\\textbf{x}}\\mathcal{L}) e^{\\Delta t \\mathcal{L}} \\partial_{\\textbf{x}}\\rho_{j-1}      + e^{\\Delta t \\mathcal{L}} (\\partial_{\\textbf{x}}^2\\rho_{j-1}). \\end{aligned}\\] <p>Parameters:</p> Name Type Description Default <code>d2H</code> <code>list</code> <p>Second-order derivatives of the free Hamiltonian with respect to the unknown parameters. Each element is a matrix representing the second partial derivative with respect to  two parameters. For example, <code>d2H[0]</code> might be the second derivative with respect to  the first parameter twice, or a mixed partial derivative.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>rho (list):      Density matrices at each time point in <code>tspan</code>.</p> <p>drho (list):      First derivatives of the density matrices with respect to the unknown parameters.</p> <p>d2rho (list):      Second derivatives of the density matrices with respect to the unknown parameters.</p> Source code in <code>quanestimation/Parameterization/GeneralDynamics.py</code> <pre><code>def secondorder_derivative(self, d2H):\n    r\"\"\"\n    Calculate the density matrix, its first derivatives, and second derivatives \n    with respect to the unknown parameters.\n\n    The density matrix at the $j$th time interval is obtained by:\n\n    $$\n        \\rho_j = e^{\\Delta t \\mathcal{L}} \\rho_{j-1}.\n    $$\n\n    The first derivative $\\partial_{\\textbf{x}}\\rho_j$ is calculated as:\n\n    $$\n        \\partial_{\\textbf{x}}\\rho_j = \\Delta t (\\partial_{\\textbf{x}}\\mathcal{L}) \\rho_j\n        + e^{\\Delta t \\mathcal{L}} (\\partial_{\\textbf{x}}\\rho_{j-1}).\n    $$\n\n    The second derivative $\\partial_{\\textbf{x}}^2\\rho_j$ is calculated as:\n\n    \\begin{aligned}\n        \\partial_{\\textbf{x}}^2\\rho_j =&amp; \\Delta t (\\partial_{\\textbf{x}}^2\\mathcal{L}) \\rho_j \n        + \\Delta t (\\partial_{\\textbf{x}}\\mathcal{L}) \\partial_{\\textbf{x}}\\rho_j \\\\\n        &amp;+ \\Delta t (\\partial_{\\textbf{x}}\\mathcal{L}) e^{\\Delta t \\mathcal{L}} \\partial_{\\textbf{x}}\\rho_{j-1} \n        + e^{\\Delta t \\mathcal{L}} (\\partial_{\\textbf{x}}^2\\rho_{j-1}).\n    \\end{aligned}\n\n    Args:\n        d2H (list): Second-order derivatives of the free Hamiltonian with respect to the unknown parameters.  \n            Each element is a matrix representing the second partial derivative with respect to \n            two parameters. For example, `d2H[0]` might be the second derivative with respect to \n            the first parameter twice, or a mixed partial derivative.\n\n    Returns:\n        (tuple):\n            rho (list): \n                Density matrices at each time point in `tspan`.\n\n            drho (list): \n                First derivatives of the density matrices with respect to the unknown parameters.\n\n            d2rho (list): \n                Second derivatives of the density matrices with respect to the unknown parameters.\n    \"\"\"\n\n    d2H = [np.array(x, dtype=np.complex128) for x in d2H]\n    rho, drho, d2rho = QJL.secondorder_derivative(\n        self.tspan,\n        self.rho0,\n        self.freeHamiltonian,\n        self.Hamiltonian_derivative,\n        d2H,\n        self.decay_opt,\n        self.gamma,\n        self.control_Hamiltonian,\n        self.control_coefficients,\n    )\n    rho = [np.array(rho_i) for rho_i in rho]\n    drho = [[np.array(drho_ij) for drho_ij in drho_i] for drho_i in drho]\n\n    return rho, drho, d2rho\n</code></pre>"},{"location":"API/python/classes/#control-optimization","title":"Control Optimization","text":"<p>The Hamiltonian of a controlled system can be written as \\begin{align} H = H_0(\\textbf{x})+\\sum_{k=1}^K u_k(t) H_k, \\end{align}</p> <p>where \\(H_0(\\textbf{x})\\) is the free evolution Hamiltonian with unknown parameters  \\(\\textbf{x}\\) and \\(H_k\\) represents the \\(k\\)th control Hamiltonian with \\(u_k\\) the  corresponding control coefficient. In QuanEstimation, different algorithms are invoked to  update the optimal control coefficients. The control optimization algorithms are gradient ascent pulse engineering (GRAPE), GRAPE algorithm based on the automatic  differentiation (auto-GRAPE), particle swarm optimization (PSO),  differential evolution (DE) and deep deterministic policy gradients (DDPG).</p>"},{"location":"API/python/classes/#base","title":"Base","text":""},{"location":"API/python/classes/#quanestimation.ControlSystem--attributes","title":"Attributes","text":"<p>savefile: <code>bool</code>     -- Whether or not to save all the control coeffients.     If set <code>True</code> then the control coefficients and the values of the      objective function obtained in all episodes will be saved during      the training. If set <code>False</code> the control coefficients in the final      episode and the values of the objective function in all episodes      will be saved.</p> <p>ctrl0: <code>list of arrays</code>     -- Initial guesses of control coefficients.</p> <p>eps: <code>float</code>     -- Machine epsilon.</p> <p>load: <code>bool</code>     -- Whether or not to load control coefficients in the current location.     If set <code>True</code> then the program will load control coefficients from      \"controls.csv\" file in the current location and use it as the initial      control coefficients.</p> Source code in <code>quanestimation/ControlOpt/ControlStruct.py</code> <pre><code>class ControlSystem:\n    \"\"\"\n    Attributes\n    ----------\n    &gt; **savefile:** `bool`\n        -- Whether or not to save all the control coeffients.  \n        If set `True` then the control coefficients and the values of the \n        objective function obtained in all episodes will be saved during \n        the training. If set `False` the control coefficients in the final \n        episode and the values of the objective function in all episodes \n        will be saved.\n\n    &gt; **ctrl0:** `list of arrays`\n        -- Initial guesses of control coefficients.\n\n    &gt; **eps:** `float`\n        -- Machine epsilon.\n\n    &gt; **load:** `bool`\n        -- Whether or not to load control coefficients in the current location.  \n        If set `True` then the program will load control coefficients from \n        \"controls.csv\" file in the current location and use it as the initial \n        control coefficients.\n    \"\"\"\n\n    def __init__(self, savefile, ctrl0, eps, load):\n        self.savefile = savefile\n        self.ctrl0 = ctrl0\n        self.eps = eps\n        self.load = load\n\n        self.QJLType_ctrl = QJL.Vector[QJL.Vector[QJL.Vector[QJL.Float64]]] \n\n    def load_save(self, cnum, max_episode):\n        if os.path.exists(\"controls.dat\"):\n            fl = h5py.File(\"controls.dat\",'r')\n            dset = fl[\"controls\"]\n            if self.savefile:\n                controls = np.array([[np.array(fl[fl[dset[i]][j]]) for j in range(cnum)] for i in range(max_episode)])\n            else:\n                controls = np.array([np.array(fl[dset[j]]) for j in range(cnum)])\n            np.save(\"controls\", controls)\n        else: pass\n\n    def dynamics(self, tspan, rho0, H0, dH, Hc, decay=[], ctrl_bound=[], dyn_method=\"expm\"):\n        r\"\"\"\n        The dynamics of a density matrix is of the form \n\n        \\begin{aligned}\n            \\partial_t\\rho &amp;=\\mathcal{L}\\rho \\nonumber \\\\\n            &amp;=-i[H,\\rho]+\\sum_i \\gamma_i\\left(\\Gamma_i\\rho\\Gamma^{\\dagger}_i-\\frac{1}{2}\n            \\left\\{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\right\\}\\right),\n        \\end{aligned}\n\n        where $\\rho$ is the evolved density matrix, H is the Hamiltonian of the \n        system, $\\Gamma_i$ and $\\gamma_i$ are the $i\\mathrm{th}$ decay \n        operator and corresponding decay rate.\n\n        Parameters\n        ----------\n        &gt; **tspan:** `array`\n            -- Time length for the evolution.\n\n        &gt; **rho0:** `matrix`\n            -- Initial state (density matrix).\n\n        &gt; **H0:** `matrix or list`\n            -- Free Hamiltonian. It is a matrix when the free Hamiltonian is time-\n            independent and a list of length equal to `tspan` when it is time-dependent.\n\n        &gt; **dH:** `list`\n            -- Derivatives of the free Hamiltonian on the unknown parameters to be \n            estimated. For example, dH[0] is the derivative vector on the first \n            parameter.\n\n        &gt; **Hc:** `list`\n            -- Control Hamiltonians.\n\n        &gt; **decay:** `list`\n            -- Decay operators and the corresponding decay rates. Its input rule is \n            decay=[[$\\Gamma_1$, $\\gamma_1$], [$\\Gamma_2$,$\\gamma_2$],...], where $\\Gamma_1$ \n            $(\\Gamma_2)$ represents the decay operator and $\\gamma_1$ $(\\gamma_2)$ is the \n            corresponding decay rate.\n\n        &gt; **ctrl_bound:** `array`\n            -- Lower and upper bounds of the control coefficients.\n            `ctrl_bound[0]` represents the lower bound of the control coefficients and\n            `ctrl_bound[1]` represents the upper bound of the control coefficients.\n\n        &gt; **dyn_method:** `string`\n            -- Setting the method for solving the Lindblad dynamics. Options are:  \n            \"expm\" (default) -- Matrix exponential.  \n            \"ode\" -- Solving the differential equations directly.  \n        \"\"\"\n\n        self.tspan = tspan\n        self.rho0 = np.array(rho0, dtype=np.complex128)\n\n        if dyn_method == \"expm\":\n            self.dyn_method = \"Expm\"\n        elif dyn_method == \"ode\":\n            self.dyn_method = \"Ode\"\n\n        if type(H0) == np.ndarray:\n            self.freeHamiltonian = np.array(H0, dtype=np.complex128)\n        else:\n            self.freeHamiltonian = [np.array(x, dtype=np.complex128) for x in H0[:-1]]\n\n        if Hc == []:\n            Hc = [np.zeros((len(self.rho0), len(self.rho0)))]\n        self.control_Hamiltonian = [np.array(x, dtype=np.complex128) for x in Hc]\n\n        if type(dH) != list:\n            raise TypeError(\"The derivative of Hamiltonian should be a list!\")\n\n        if dH == []:\n            dH = [np.zeros((len(self.rho0), len(self.rho0)))]\n        self.Hamiltonian_derivative = [np.array(x, dtype=np.complex128) for x in dH]\n        if len(dH) == 1:\n            self.para_type = \"single_para\"\n        else:\n            self.para_type = \"multi_para\"\n\n        if decay == []:\n            decay_opt = [np.zeros((len(self.rho0), len(self.rho0)))]\n            self.gamma = [0.0]\n        else:\n            decay_opt = [decay[i][0] for i in range(len(decay))]\n            self.gamma = [decay[i][1] for i in range(len(decay))]\n        self.decay_opt = [np.array(x, dtype=np.complex128) for x in decay_opt]\n\n        if ctrl_bound == []:\n            self.ctrl_bound =  [-jl.Inf, jl.Inf]\n        else:\n            self.ctrl_bound = [float(ctrl_bound[0]), float(ctrl_bound[1])]\n        self.ctrl_bound = jl.convert(jl.Vector[jl.Float64], self.ctrl_bound)\n\n        if self.ctrl0 == []:\n            if ctrl_bound == []:\n                ctrl0 = [\n                    2 * np.random.random(len(self.tspan) - 1)\n                    - np.ones(len(self.tspan) - 1)\n                    for i in range(len(self.control_Hamiltonian))\n                ]\n                self.control_coefficients = ctrl0\n                self.ctrl0 = [np.array(ctrl0)]\n            else:\n                a = ctrl_bound[0]\n                b = ctrl_bound[1]\n                ctrl0 = [\n                    (b - a) * np.random.random(len(self.tspan) - 1)\n                    + a * np.ones(len(self.tspan) - 1)\n                    for i in range(len(self.control_Hamiltonian))\n                ]\n            self.control_coefficients = ctrl0\n            self.ctrl0 = [np.array(ctrl0)]\n        elif len(self.ctrl0) &gt;= 1:\n            self.control_coefficients = [\n                self.ctrl0[0][i] for i in range(len(self.control_Hamiltonian))\n            ]\n        ## TODO\n        self.ctrl0 = QJL.convert(self.QJLType_ctrl, [[c for c in ctrls ]for ctrls in self.ctrl0])\n\n        if self.load == True:\n            if os.path.exists(\"controls.csv\"):\n                data = np.genfromtxt(\"controls.csv\")[-len(self.control_Hamiltonian) :]\n                self.control_coefficients = [data[i] for i in range(len(data))]\n\n        ctrl_num = len(self.control_coefficients)\n        Hc_num = len(self.control_Hamiltonian)\n        if Hc_num &lt; ctrl_num:\n            raise TypeError(\n                \"There are %d control Hamiltonians but %d coefficients sequences: too many coefficients sequences\"\n                % (Hc_num, ctrl_num)\n            )\n        elif Hc_num &gt; ctrl_num:\n            warnings.warn(\n                \"Not enough coefficients sequences: there are %d control Hamiltonians but %d coefficients sequences. The rest of the control sequences are set to be 0.\"\n                % (Hc_num, ctrl_num),\n                DeprecationWarning,\n            )\n            for i in range(Hc_num - ctrl_num):\n                self.control_coefficients = np.concatenate(\n                    (\n                        self.control_coefficients,\n                        np.zeros(len(self.control_coefficients[0])),\n                    )\n                )\n        else: pass\n\n        if type(H0) != np.ndarray:\n            #### linear interpolation  ####\n            f = interp1d(self.tspan, H0, axis=0)\n        else: pass\n        number = math.ceil((len(self.tspan) - 1) / len(self.control_coefficients[0]))\n        if len(self.tspan) - 1 % len(self.control_coefficients[0]) != 0:\n            tnum = number * len(self.control_coefficients[0])\n            self.tspan = np.linspace(self.tspan[0], self.tspan[-1], tnum + 1)\n            if type(H0) != np.ndarray:\n                H0_inter = f(self.tspan)\n                self.freeHamiltonian = [np.array(x, dtype=np.complex128) for x in H0_inter[:-1]]\n            else: pass\n\n        else: pass\n\n\n        self.opt = QJL.ControlOpt(\n            ctrl = self.ctrl0,\n            ctrl_bound=self.ctrl_bound, \n            seed=self.seed\n        )\n        self.dynamic = jl.QuanEstimation.Lindblad(\n            self.freeHamiltonian,\n            self.Hamiltonian_derivative,\n            self.control_Hamiltonian,\n            self.control_coefficients,\n            self.rho0,\n            self.tspan,\n            self.decay_opt,\n            self.gamma,\n            dyn_method = self.dyn_method,\n        )\n        self.output = QJL.Output(self.opt, save=self.savefile)\n\n        self.dynamics_type = \"lindblad\"\n\n    def QFIM(self, W=[], LDtype=\"SLD\"):\n        r\"\"\"\n        Choose QFI or $\\mathrm{Tr}(WF^{-1})$ as the objective function. \n        In single parameter estimation the objective function is QFI and in \n        multiparameter estimation it will be $\\mathrm{Tr}(WF^{-1})$.\n\n        Parameters\n        ----------\n        &gt; **W:** `matrix`\n            -- Weight matrix.\n\n        &gt; **LDtype:** `string`\n            -- Types of QFI (QFIM) can be set as the objective function. Options are:  \n            \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD).  \n            \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD).  \n            \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD).  \n        \"\"\"\n\n        if LDtype != \"SLD\" and LDtype != \"RLD\" and LDtype != \"LLD\":\n            raise ValueError(\n                \"{!r} is not a valid value for LDtype, supported values are 'SLD', 'RLD' and 'LLD'.\".format(\n                    LDtype\n                )\n            )\n\n        if W == []:\n            W = np.eye(len(self.Hamiltonian_derivative))\n        self.W = W\n\n        self.obj = QJL.QFIM_obj(\n            self.W, self.eps, self.para_type, LDtype\n        )\n        system = QJL.QuanEstSystem(\n            self.opt, self.alg, self.obj, self.dynamic, self.output\n        )\n        QJL.run(system)\n        max_num = self.max_episode if type(self.max_episode) == int else self.max_episode[0]\n        self.load_save(len(self.control_Hamiltonian), max_num)\n\n    def CFIM(self, M=[], W=[]):\n        r\"\"\"\n        Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. \n        In single parameter estimation the objective function is CFI and \n        in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$.\n\n        Parameters\n        ----------\n        &gt; **W:** `matrix`\n            -- Weight matrix.\n\n        &gt; **M:** `list`\n            -- A set of positive operator-valued measure (POVM). The default measurement \n            is a set of rank-one symmetric informationally complete POVM (SIC-POVM).\n\n        **Note:** \n            SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state \n            which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/\n            solutions.html).\n        \"\"\"\n\n        if M == []:\n            M = SIC(len(self.rho0))\n        M = [np.array(x, dtype=np.complex128) for x in M]\n\n        if W == []:\n            W = np.eye(len(self.Hamiltonian_derivative))\n        self.W = W\n\n        self.obj = QJL.CFIM_obj(M, self.W, self.eps, self.para_type)\n        system = QJL.QuanEstSystem(\n            self.opt, self.alg, self.obj, self.dynamic, self.output\n        )\n        QJL.run(system)\n        max_num = self.max_episode if type(self.max_episode) == int else self.max_episode[0]\n        self.load_save(len(self.control_Hamiltonian), max_num)\n\n    def HCRB(self, W=[]):\n        \"\"\"\n        Choose HCRB as the objective function. \n\n        **Notes:** (1) In single parameter estimation, HCRB is equivalent to QFI, please\n        choose QFI as the objective function. (2) GRAPE and auto-GRAPE are not available\n        when the objective function is HCRB. Supported methods are PSO, DE and DDPG.\n\n        Parameters\n        ----------\n        &gt; **W:** `matrix` \n            -- Weight matrix.\n        \"\"\"\n\n        if W == []:\n            W = np.eye(len(self.Hamiltonian_derivative))\n        self.W = W\n\n        if len(self.Hamiltonian_derivative) == 1:\n            print(\"Program terminated. In the single-parameter scenario, HCRB is equivalent to QFI. Please choose QFIM as the objective function.\"\n                    )\n        else:\n            if W == []:\n                W = np.eye(len(self.Hamiltonian_derivative))\n            self.W = W  \n\n            self.obj = QJL.HCRB_obj(self.W, self.eps, self.para_type)\n            system = QJL.QuanEstSystem(\n                self.opt, self.alg, self.obj, self.dynamic, self.output\n            )\n            QJL.run(system)\n            max_num = self.max_episode if type(self.max_episode) == int else self.max_episode[0]\n        self.load_save(len(self.control_Hamiltonian), max_num)\n\n    def mintime(self, f, W=[], M=[], method=\"binary\", target=\"QFIM\", LDtype=\"SLD\"):\n        \"\"\"\n        Search of the minimum time to reach a given value of the objective function.\n\n        Parameters\n        ----------\n        &gt; **f:** `float`\n            -- The given value of the objective function.\n\n        &gt; **W:** `matrix`\n            -- Weight matrix.\n\n        &gt; **M:** `list of matrices`\n            -- A set of positive operator-valued measure (POVM). The default measurement \n            is a set of rank-one symmetric informationally complete POVM (SIC-POVM).\n\n        &gt; **method:** `string`\n            -- Methods for searching the minimum time to reach the given value of the \n            objective function. Options are:  \n            \"binary\" (default) -- Binary search (logarithmic search).  \n            \"forward\" -- Forward search from the beginning of time.  \n\n        &gt; **target:** `string`\n            -- Objective functions for searching the minimum time to reach the given \n            value of the objective function. Options are:  \n            \"QFIM\" (default) -- Choose QFI (QFIM) as the objective function.  \n            \"CFIM\" -- Choose CFI (CFIM) as the objective function.  \n            \"HCRB\" -- Choose HCRB as the objective function.  \n\n        &gt; **LDtype:** `string`\n            -- Types of QFI (QFIM) can be set as the objective function. Options are:  \n            \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD).  \n            \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD).  \n            \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD).  \n        \"\"\"\n\n        if not (method == \"binary\" or method == \"forward\"):\n            raise ValueError(\n                \"{!r} is not a valid value for method, supported values are 'binary' and 'forward'.\".format(\n                    method\n                )\n            )\n\n        if self.dynamics_type != \"lindblad\":\n            raise ValueError(\n                \"Supported type of dynamics is Lindblad.\"\n                )\n        if self.savefile == True:\n            warnings.warn(\n                    \"savefile is set to be False\",\n                    DeprecationWarning,\n                )\n        self.output = QJL.Output(self.opt)\n\n        if len(self.Hamiltonian_derivative) &gt; 1:\n            f = 1 / f\n\n        if W == []:\n            W = np.eye(len(self.Hamiltonian_derivative))\n        self.W = W\n\n        if M != []:\n            M = [np.array(x, dtype=np.complex128) for x in M]\n            self.obj = QJL.CFIM_obj(M, self.W, self.eps, self.para_type)\n        else:\n            if target == \"HCRB\":\n                if self.para_type == \"single_para\":\n                    print(\n                        \"Program terminated. In the single-parameter scenario, the HCRB is equivalent to the QFI. Please choose 'QFIM' as the objective function.\")\n                self.obj = QJL.HCRB_obj(\n                    self.W, self.eps, self.para_type\n                )\n            elif target == \"QFIM\" or (\n                LDtype == \"SLD\" and LDtype == \"LLD\" and LDtype == \"RLD\"\n            ):\n                self.obj = QJL.QFIM_obj(\n                    self.W, self.eps, self.para_type, LDtype\n                )\n            else:\n                raise ValueError(\n                    \"Please enter the correct values for target and LDtype. Supported target are 'QFIM', 'CFIM' and 'HCRB', supported LDtype are 'SLD', 'RLD' and 'LLD'.\"\n                )\n\n        system = QJL.QuanEstSystem(\n            self.opt, self.alg, self.obj, self.dynamic, self.output\n        )\n        QJL.mintime(method, f, system)\n        max_num = self.max_episode if type(self.max_episode) == int else self.max_episode[0]\n        self.load_save(len(self.control_Hamiltonian), max_num)\n</code></pre>"},{"location":"API/python/classes/#quanestimation.ControlSystem.CFIM","title":"<code>CFIM(M=[], W=[])</code>","text":"<p>Choose CFI or \\(\\mathrm{Tr}(WI^{-1})\\) as the objective function.  In single parameter estimation the objective function is CFI and  in multiparameter estimation it will be \\(\\mathrm{Tr}(WI^{-1})\\).</p>"},{"location":"API/python/classes/#quanestimation.ControlSystem.CFIM--parameters","title":"Parameters","text":"<p>W: <code>matrix</code>     -- Weight matrix.</p> <p>M: <code>list</code>     -- A set of positive operator-valued measure (POVM). The default measurement      is a set of rank-one symmetric informationally complete POVM (SIC-POVM).</p> <p>Note:      SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state      which can be downloaded from here.</p> Source code in <code>quanestimation/ControlOpt/ControlStruct.py</code> <pre><code>def CFIM(self, M=[], W=[]):\n    r\"\"\"\n    Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. \n    In single parameter estimation the objective function is CFI and \n    in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$.\n\n    Parameters\n    ----------\n    &gt; **W:** `matrix`\n        -- Weight matrix.\n\n    &gt; **M:** `list`\n        -- A set of positive operator-valued measure (POVM). The default measurement \n        is a set of rank-one symmetric informationally complete POVM (SIC-POVM).\n\n    **Note:** \n        SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state \n        which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/\n        solutions.html).\n    \"\"\"\n\n    if M == []:\n        M = SIC(len(self.rho0))\n    M = [np.array(x, dtype=np.complex128) for x in M]\n\n    if W == []:\n        W = np.eye(len(self.Hamiltonian_derivative))\n    self.W = W\n\n    self.obj = QJL.CFIM_obj(M, self.W, self.eps, self.para_type)\n    system = QJL.QuanEstSystem(\n        self.opt, self.alg, self.obj, self.dynamic, self.output\n    )\n    QJL.run(system)\n    max_num = self.max_episode if type(self.max_episode) == int else self.max_episode[0]\n    self.load_save(len(self.control_Hamiltonian), max_num)\n</code></pre>"},{"location":"API/python/classes/#quanestimation.ControlSystem.HCRB","title":"<code>HCRB(W=[])</code>","text":"<p>Choose HCRB as the objective function. </p> <p>Notes: (1) In single parameter estimation, HCRB is equivalent to QFI, please choose QFI as the objective function. (2) GRAPE and auto-GRAPE are not available when the objective function is HCRB. Supported methods are PSO, DE and DDPG.</p>"},{"location":"API/python/classes/#quanestimation.ControlSystem.HCRB--parameters","title":"Parameters","text":"<p>W: <code>matrix</code>      -- Weight matrix.</p> Source code in <code>quanestimation/ControlOpt/ControlStruct.py</code> <pre><code>def HCRB(self, W=[]):\n    \"\"\"\n    Choose HCRB as the objective function. \n\n    **Notes:** (1) In single parameter estimation, HCRB is equivalent to QFI, please\n    choose QFI as the objective function. (2) GRAPE and auto-GRAPE are not available\n    when the objective function is HCRB. Supported methods are PSO, DE and DDPG.\n\n    Parameters\n    ----------\n    &gt; **W:** `matrix` \n        -- Weight matrix.\n    \"\"\"\n\n    if W == []:\n        W = np.eye(len(self.Hamiltonian_derivative))\n    self.W = W\n\n    if len(self.Hamiltonian_derivative) == 1:\n        print(\"Program terminated. In the single-parameter scenario, HCRB is equivalent to QFI. Please choose QFIM as the objective function.\"\n                )\n    else:\n        if W == []:\n            W = np.eye(len(self.Hamiltonian_derivative))\n        self.W = W  \n\n        self.obj = QJL.HCRB_obj(self.W, self.eps, self.para_type)\n        system = QJL.QuanEstSystem(\n            self.opt, self.alg, self.obj, self.dynamic, self.output\n        )\n        QJL.run(system)\n        max_num = self.max_episode if type(self.max_episode) == int else self.max_episode[0]\n    self.load_save(len(self.control_Hamiltonian), max_num)\n</code></pre>"},{"location":"API/python/classes/#quanestimation.ControlSystem.QFIM","title":"<code>QFIM(W=[], LDtype='SLD')</code>","text":"<p>Choose QFI or \\(\\mathrm{Tr}(WF^{-1})\\) as the objective function.  In single parameter estimation the objective function is QFI and in  multiparameter estimation it will be \\(\\mathrm{Tr}(WF^{-1})\\).</p>"},{"location":"API/python/classes/#quanestimation.ControlSystem.QFIM--parameters","title":"Parameters","text":"<p>W: <code>matrix</code>     -- Weight matrix.</p> <p>LDtype: <code>string</code>     -- Types of QFI (QFIM) can be set as the objective function. Options are:     \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD).     \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD).     \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD).</p> Source code in <code>quanestimation/ControlOpt/ControlStruct.py</code> <pre><code>def QFIM(self, W=[], LDtype=\"SLD\"):\n    r\"\"\"\n    Choose QFI or $\\mathrm{Tr}(WF^{-1})$ as the objective function. \n    In single parameter estimation the objective function is QFI and in \n    multiparameter estimation it will be $\\mathrm{Tr}(WF^{-1})$.\n\n    Parameters\n    ----------\n    &gt; **W:** `matrix`\n        -- Weight matrix.\n\n    &gt; **LDtype:** `string`\n        -- Types of QFI (QFIM) can be set as the objective function. Options are:  \n        \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD).  \n        \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD).  \n        \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD).  \n    \"\"\"\n\n    if LDtype != \"SLD\" and LDtype != \"RLD\" and LDtype != \"LLD\":\n        raise ValueError(\n            \"{!r} is not a valid value for LDtype, supported values are 'SLD', 'RLD' and 'LLD'.\".format(\n                LDtype\n            )\n        )\n\n    if W == []:\n        W = np.eye(len(self.Hamiltonian_derivative))\n    self.W = W\n\n    self.obj = QJL.QFIM_obj(\n        self.W, self.eps, self.para_type, LDtype\n    )\n    system = QJL.QuanEstSystem(\n        self.opt, self.alg, self.obj, self.dynamic, self.output\n    )\n    QJL.run(system)\n    max_num = self.max_episode if type(self.max_episode) == int else self.max_episode[0]\n    self.load_save(len(self.control_Hamiltonian), max_num)\n</code></pre>"},{"location":"API/python/classes/#quanestimation.ControlSystem.dynamics","title":"<code>dynamics(tspan, rho0, H0, dH, Hc, decay=[], ctrl_bound=[], dyn_method='expm')</code>","text":"<p>The dynamics of a density matrix is of the form </p> \\[\\begin{aligned}     \\partial_t\\rho &amp;=\\mathcal{L}\\rho \\nonumber \\\\     &amp;=-i[H,\\rho]+\\sum_i \\gamma_i\\left(\\Gamma_i\\rho\\Gamma^{\\dagger}_i-\\frac{1}{2}     \\left\\{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\right\\}\\right), \\end{aligned}\\] <p>where \\(\\rho\\) is the evolved density matrix, H is the Hamiltonian of the  system, \\(\\Gamma_i\\) and \\(\\gamma_i\\) are the \\(i\\mathrm{th}\\) decay  operator and corresponding decay rate.</p>"},{"location":"API/python/classes/#quanestimation.ControlSystem.dynamics--parameters","title":"Parameters","text":"<p>tspan: <code>array</code>     -- Time length for the evolution.</p> <p>rho0: <code>matrix</code>     -- Initial state (density matrix).</p> <p>H0: <code>matrix or list</code>     -- Free Hamiltonian. It is a matrix when the free Hamiltonian is time-     independent and a list of length equal to <code>tspan</code> when it is time-dependent.</p> <p>dH: <code>list</code>     -- Derivatives of the free Hamiltonian on the unknown parameters to be      estimated. For example, dH[0] is the derivative vector on the first      parameter.</p> <p>Hc: <code>list</code>     -- Control Hamiltonians.</p> <p>decay: <code>list</code>     -- Decay operators and the corresponding decay rates. Its input rule is      decay=[[\\(\\Gamma_1\\), \\(\\gamma_1\\)], [\\(\\Gamma_2\\),\\(\\gamma_2\\)],...], where \\(\\Gamma_1\\) \\((\\Gamma_2)\\) represents the decay operator and \\(\\gamma_1\\) \\((\\gamma_2)\\) is the      corresponding decay rate.</p> <p>ctrl_bound: <code>array</code>     -- Lower and upper bounds of the control coefficients.     <code>ctrl_bound[0]</code> represents the lower bound of the control coefficients and     <code>ctrl_bound[1]</code> represents the upper bound of the control coefficients.</p> <p>dyn_method: <code>string</code>     -- Setting the method for solving the Lindblad dynamics. Options are:     \"expm\" (default) -- Matrix exponential.     \"ode\" -- Solving the differential equations directly.</p> Source code in <code>quanestimation/ControlOpt/ControlStruct.py</code> <pre><code>def dynamics(self, tspan, rho0, H0, dH, Hc, decay=[], ctrl_bound=[], dyn_method=\"expm\"):\n    r\"\"\"\n    The dynamics of a density matrix is of the form \n\n    \\begin{aligned}\n        \\partial_t\\rho &amp;=\\mathcal{L}\\rho \\nonumber \\\\\n        &amp;=-i[H,\\rho]+\\sum_i \\gamma_i\\left(\\Gamma_i\\rho\\Gamma^{\\dagger}_i-\\frac{1}{2}\n        \\left\\{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\right\\}\\right),\n    \\end{aligned}\n\n    where $\\rho$ is the evolved density matrix, H is the Hamiltonian of the \n    system, $\\Gamma_i$ and $\\gamma_i$ are the $i\\mathrm{th}$ decay \n    operator and corresponding decay rate.\n\n    Parameters\n    ----------\n    &gt; **tspan:** `array`\n        -- Time length for the evolution.\n\n    &gt; **rho0:** `matrix`\n        -- Initial state (density matrix).\n\n    &gt; **H0:** `matrix or list`\n        -- Free Hamiltonian. It is a matrix when the free Hamiltonian is time-\n        independent and a list of length equal to `tspan` when it is time-dependent.\n\n    &gt; **dH:** `list`\n        -- Derivatives of the free Hamiltonian on the unknown parameters to be \n        estimated. For example, dH[0] is the derivative vector on the first \n        parameter.\n\n    &gt; **Hc:** `list`\n        -- Control Hamiltonians.\n\n    &gt; **decay:** `list`\n        -- Decay operators and the corresponding decay rates. Its input rule is \n        decay=[[$\\Gamma_1$, $\\gamma_1$], [$\\Gamma_2$,$\\gamma_2$],...], where $\\Gamma_1$ \n        $(\\Gamma_2)$ represents the decay operator and $\\gamma_1$ $(\\gamma_2)$ is the \n        corresponding decay rate.\n\n    &gt; **ctrl_bound:** `array`\n        -- Lower and upper bounds of the control coefficients.\n        `ctrl_bound[0]` represents the lower bound of the control coefficients and\n        `ctrl_bound[1]` represents the upper bound of the control coefficients.\n\n    &gt; **dyn_method:** `string`\n        -- Setting the method for solving the Lindblad dynamics. Options are:  \n        \"expm\" (default) -- Matrix exponential.  \n        \"ode\" -- Solving the differential equations directly.  \n    \"\"\"\n\n    self.tspan = tspan\n    self.rho0 = np.array(rho0, dtype=np.complex128)\n\n    if dyn_method == \"expm\":\n        self.dyn_method = \"Expm\"\n    elif dyn_method == \"ode\":\n        self.dyn_method = \"Ode\"\n\n    if type(H0) == np.ndarray:\n        self.freeHamiltonian = np.array(H0, dtype=np.complex128)\n    else:\n        self.freeHamiltonian = [np.array(x, dtype=np.complex128) for x in H0[:-1]]\n\n    if Hc == []:\n        Hc = [np.zeros((len(self.rho0), len(self.rho0)))]\n    self.control_Hamiltonian = [np.array(x, dtype=np.complex128) for x in Hc]\n\n    if type(dH) != list:\n        raise TypeError(\"The derivative of Hamiltonian should be a list!\")\n\n    if dH == []:\n        dH = [np.zeros((len(self.rho0), len(self.rho0)))]\n    self.Hamiltonian_derivative = [np.array(x, dtype=np.complex128) for x in dH]\n    if len(dH) == 1:\n        self.para_type = \"single_para\"\n    else:\n        self.para_type = \"multi_para\"\n\n    if decay == []:\n        decay_opt = [np.zeros((len(self.rho0), len(self.rho0)))]\n        self.gamma = [0.0]\n    else:\n        decay_opt = [decay[i][0] for i in range(len(decay))]\n        self.gamma = [decay[i][1] for i in range(len(decay))]\n    self.decay_opt = [np.array(x, dtype=np.complex128) for x in decay_opt]\n\n    if ctrl_bound == []:\n        self.ctrl_bound =  [-jl.Inf, jl.Inf]\n    else:\n        self.ctrl_bound = [float(ctrl_bound[0]), float(ctrl_bound[1])]\n    self.ctrl_bound = jl.convert(jl.Vector[jl.Float64], self.ctrl_bound)\n\n    if self.ctrl0 == []:\n        if ctrl_bound == []:\n            ctrl0 = [\n                2 * np.random.random(len(self.tspan) - 1)\n                - np.ones(len(self.tspan) - 1)\n                for i in range(len(self.control_Hamiltonian))\n            ]\n            self.control_coefficients = ctrl0\n            self.ctrl0 = [np.array(ctrl0)]\n        else:\n            a = ctrl_bound[0]\n            b = ctrl_bound[1]\n            ctrl0 = [\n                (b - a) * np.random.random(len(self.tspan) - 1)\n                + a * np.ones(len(self.tspan) - 1)\n                for i in range(len(self.control_Hamiltonian))\n            ]\n        self.control_coefficients = ctrl0\n        self.ctrl0 = [np.array(ctrl0)]\n    elif len(self.ctrl0) &gt;= 1:\n        self.control_coefficients = [\n            self.ctrl0[0][i] for i in range(len(self.control_Hamiltonian))\n        ]\n    ## TODO\n    self.ctrl0 = QJL.convert(self.QJLType_ctrl, [[c for c in ctrls ]for ctrls in self.ctrl0])\n\n    if self.load == True:\n        if os.path.exists(\"controls.csv\"):\n            data = np.genfromtxt(\"controls.csv\")[-len(self.control_Hamiltonian) :]\n            self.control_coefficients = [data[i] for i in range(len(data))]\n\n    ctrl_num = len(self.control_coefficients)\n    Hc_num = len(self.control_Hamiltonian)\n    if Hc_num &lt; ctrl_num:\n        raise TypeError(\n            \"There are %d control Hamiltonians but %d coefficients sequences: too many coefficients sequences\"\n            % (Hc_num, ctrl_num)\n        )\n    elif Hc_num &gt; ctrl_num:\n        warnings.warn(\n            \"Not enough coefficients sequences: there are %d control Hamiltonians but %d coefficients sequences. The rest of the control sequences are set to be 0.\"\n            % (Hc_num, ctrl_num),\n            DeprecationWarning,\n        )\n        for i in range(Hc_num - ctrl_num):\n            self.control_coefficients = np.concatenate(\n                (\n                    self.control_coefficients,\n                    np.zeros(len(self.control_coefficients[0])),\n                )\n            )\n    else: pass\n\n    if type(H0) != np.ndarray:\n        #### linear interpolation  ####\n        f = interp1d(self.tspan, H0, axis=0)\n    else: pass\n    number = math.ceil((len(self.tspan) - 1) / len(self.control_coefficients[0]))\n    if len(self.tspan) - 1 % len(self.control_coefficients[0]) != 0:\n        tnum = number * len(self.control_coefficients[0])\n        self.tspan = np.linspace(self.tspan[0], self.tspan[-1], tnum + 1)\n        if type(H0) != np.ndarray:\n            H0_inter = f(self.tspan)\n            self.freeHamiltonian = [np.array(x, dtype=np.complex128) for x in H0_inter[:-1]]\n        else: pass\n\n    else: pass\n\n\n    self.opt = QJL.ControlOpt(\n        ctrl = self.ctrl0,\n        ctrl_bound=self.ctrl_bound, \n        seed=self.seed\n    )\n    self.dynamic = jl.QuanEstimation.Lindblad(\n        self.freeHamiltonian,\n        self.Hamiltonian_derivative,\n        self.control_Hamiltonian,\n        self.control_coefficients,\n        self.rho0,\n        self.tspan,\n        self.decay_opt,\n        self.gamma,\n        dyn_method = self.dyn_method,\n    )\n    self.output = QJL.Output(self.opt, save=self.savefile)\n\n    self.dynamics_type = \"lindblad\"\n</code></pre>"},{"location":"API/python/classes/#quanestimation.ControlSystem.mintime","title":"<code>mintime(f, W=[], M=[], method='binary', target='QFIM', LDtype='SLD')</code>","text":"<p>Search of the minimum time to reach a given value of the objective function.</p>"},{"location":"API/python/classes/#quanestimation.ControlSystem.mintime--parameters","title":"Parameters","text":"<p>f: <code>float</code>     -- The given value of the objective function.</p> <p>W: <code>matrix</code>     -- Weight matrix.</p> <p>M: <code>list of matrices</code>     -- A set of positive operator-valued measure (POVM). The default measurement      is a set of rank-one symmetric informationally complete POVM (SIC-POVM).</p> <p>method: <code>string</code>     -- Methods for searching the minimum time to reach the given value of the      objective function. Options are:     \"binary\" (default) -- Binary search (logarithmic search).     \"forward\" -- Forward search from the beginning of time.  </p> <p>target: <code>string</code>     -- Objective functions for searching the minimum time to reach the given      value of the objective function. Options are:     \"QFIM\" (default) -- Choose QFI (QFIM) as the objective function.     \"CFIM\" -- Choose CFI (CFIM) as the objective function.     \"HCRB\" -- Choose HCRB as the objective function.  </p> <p>LDtype: <code>string</code>     -- Types of QFI (QFIM) can be set as the objective function. Options are:     \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD).     \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD).     \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD).</p> Source code in <code>quanestimation/ControlOpt/ControlStruct.py</code> <pre><code>def mintime(self, f, W=[], M=[], method=\"binary\", target=\"QFIM\", LDtype=\"SLD\"):\n    \"\"\"\n    Search of the minimum time to reach a given value of the objective function.\n\n    Parameters\n    ----------\n    &gt; **f:** `float`\n        -- The given value of the objective function.\n\n    &gt; **W:** `matrix`\n        -- Weight matrix.\n\n    &gt; **M:** `list of matrices`\n        -- A set of positive operator-valued measure (POVM). The default measurement \n        is a set of rank-one symmetric informationally complete POVM (SIC-POVM).\n\n    &gt; **method:** `string`\n        -- Methods for searching the minimum time to reach the given value of the \n        objective function. Options are:  \n        \"binary\" (default) -- Binary search (logarithmic search).  \n        \"forward\" -- Forward search from the beginning of time.  \n\n    &gt; **target:** `string`\n        -- Objective functions for searching the minimum time to reach the given \n        value of the objective function. Options are:  \n        \"QFIM\" (default) -- Choose QFI (QFIM) as the objective function.  \n        \"CFIM\" -- Choose CFI (CFIM) as the objective function.  \n        \"HCRB\" -- Choose HCRB as the objective function.  \n\n    &gt; **LDtype:** `string`\n        -- Types of QFI (QFIM) can be set as the objective function. Options are:  \n        \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD).  \n        \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD).  \n        \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD).  \n    \"\"\"\n\n    if not (method == \"binary\" or method == \"forward\"):\n        raise ValueError(\n            \"{!r} is not a valid value for method, supported values are 'binary' and 'forward'.\".format(\n                method\n            )\n        )\n\n    if self.dynamics_type != \"lindblad\":\n        raise ValueError(\n            \"Supported type of dynamics is Lindblad.\"\n            )\n    if self.savefile == True:\n        warnings.warn(\n                \"savefile is set to be False\",\n                DeprecationWarning,\n            )\n    self.output = QJL.Output(self.opt)\n\n    if len(self.Hamiltonian_derivative) &gt; 1:\n        f = 1 / f\n\n    if W == []:\n        W = np.eye(len(self.Hamiltonian_derivative))\n    self.W = W\n\n    if M != []:\n        M = [np.array(x, dtype=np.complex128) for x in M]\n        self.obj = QJL.CFIM_obj(M, self.W, self.eps, self.para_type)\n    else:\n        if target == \"HCRB\":\n            if self.para_type == \"single_para\":\n                print(\n                    \"Program terminated. In the single-parameter scenario, the HCRB is equivalent to the QFI. Please choose 'QFIM' as the objective function.\")\n            self.obj = QJL.HCRB_obj(\n                self.W, self.eps, self.para_type\n            )\n        elif target == \"QFIM\" or (\n            LDtype == \"SLD\" and LDtype == \"LLD\" and LDtype == \"RLD\"\n        ):\n            self.obj = QJL.QFIM_obj(\n                self.W, self.eps, self.para_type, LDtype\n            )\n        else:\n            raise ValueError(\n                \"Please enter the correct values for target and LDtype. Supported target are 'QFIM', 'CFIM' and 'HCRB', supported LDtype are 'SLD', 'RLD' and 'LLD'.\"\n            )\n\n    system = QJL.QuanEstSystem(\n        self.opt, self.alg, self.obj, self.dynamic, self.output\n    )\n    QJL.mintime(method, f, system)\n    max_num = self.max_episode if type(self.max_episode) == int else self.max_episode[0]\n    self.load_save(len(self.control_Hamiltonian), max_num)\n</code></pre>"},{"location":"API/python/classes/#control-optimization-with-grape-and-auto-grape","title":"Control optimization with GRAPE and auto-GRAPE","text":"<p>             Bases: <code>ControlSystem</code></p>"},{"location":"API/python/classes/#quanestimation.GRAPE_Copt--attributes","title":"Attributes","text":"<p>savefile: <code>bool</code>     -- Whether or not to save all the control coeffients.     If set <code>True</code> then the control coefficients and the values of the      objective function obtained in all episodes will be saved during      the training. If set <code>False</code> the control coefficients in the final      episode and the values of the objective function in all episodes      will be saved.</p> <p>Adam: <code>bool</code>     -- Whether or not to use Adam for updating control coefficients.</p> <p>ctrl0: <code>list of arrays</code>     -- Initial guesses of control coefficients.</p> <p>max_episode: <code>int</code>     -- The number of episodes.</p> <p>epsilon: <code>float</code>     -- Learning rate.</p> <p>beta1: <code>float</code>     -- The exponential decay rate for the first moment estimates.</p> <p>beta2: <code>float</code>     -- The exponential decay rate for the second moment estimates.</p> <p>eps: <code>float</code>     -- Machine epsilon.</p> <p>load: <code>bool</code>     -- Whether or not to load control coefficients in the current location.     If set <code>True</code> then the program will load control coefficients from      \"controls.csv\" file in the current location and use it as the initial      control coefficients.</p> <p>auto: <code>bool</code>     -- Whether or not to invoke automatic differentiation algorithm to evaluate     the gradient. If set <code>True</code> then the gradient will be calculated with      automatic differentiation algorithm otherwise it will be calculated      using analytical method.</p> Source code in <code>quanestimation/ControlOpt/GRAPE_Copt.py</code> <pre><code>class GRAPE_Copt(Control.ControlSystem):\n    \"\"\"\n    Attributes\n    ----------\n    &gt; **savefile:** `bool`\n        -- Whether or not to save all the control coeffients.  \n        If set `True` then the control coefficients and the values of the \n        objective function obtained in all episodes will be saved during \n        the training. If set `False` the control coefficients in the final \n        episode and the values of the objective function in all episodes \n        will be saved.\n\n    &gt; **Adam:** `bool`\n        -- Whether or not to use Adam for updating control coefficients.\n\n    &gt; **ctrl0:** `list of arrays`\n        -- Initial guesses of control coefficients.\n\n    &gt; **max_episode:** `int`\n        -- The number of episodes.\n\n    &gt; **epsilon:** `float`\n        -- Learning rate.\n\n    &gt; **beta1:** `float`\n        -- The exponential decay rate for the first moment estimates.\n\n    &gt; **beta2:** `float`\n        -- The exponential decay rate for the second moment estimates.\n\n    &gt; **eps:** `float`\n        -- Machine epsilon.\n\n    &gt; **load:** `bool`\n        -- Whether or not to load control coefficients in the current location.  \n        If set `True` then the program will load control coefficients from \n        \"controls.csv\" file in the current location and use it as the initial \n        control coefficients.\n\n    &gt; **auto:** `bool`\n        -- Whether or not to invoke automatic differentiation algorithm to evaluate  \n        the gradient. If set `True` then the gradient will be calculated with \n        automatic differentiation algorithm otherwise it will be calculated \n        using analytical method.\n    \"\"\"\n\n    def __init__(\n        self,\n        savefile=False,\n        Adam=True,\n        ctrl0=[],\n        max_episode=300,\n        epsilon=0.01,\n        beta1=0.90,\n        beta2=0.99,\n        eps=1e-8,\n        seed=1234,\n        load=False,\n        auto=True,\n    ):\n\n        Control.ControlSystem.__init__(self, savefile, ctrl0, eps, load)\n\n        self.Adam = Adam\n        self.max_episode = max_episode\n        self.epsilon = epsilon\n        self.beta1 = beta1\n        self.beta2 = beta2\n        self.mt = 0.0\n        self.vt = 0.0\n        self.seed = seed\n        self.auto = auto\n\n    def QFIM(self, W=[], LDtype=\"SLD\"):\n        r\"\"\"\n        Choose QFI or $\\mathrm{Tr}(WF^{-1})$ as the objective function. \n        In single parameter estimation the objective function is QFI and in \n        multiparameter estimation it will be $\\mathrm{Tr}(WF^{-1})$.\n\n        Parameters\n        ----------\n        &gt; **W:** `matrix`\n            -- Weight matrix.\n\n        &gt; **LDtype:** `string`\n            -- Types of QFI (QFIM) can be set as the objective function. Options are:  \n            \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD).  \n            \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD).  \n            \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD).\n        \"\"\"\n\n        if self.auto:\n            if self.Adam:\n                self.alg = QJL.autoGRAPE(\n                    self.max_episode, self.epsilon, self.beta1, self.beta2\n                )\n            else:\n                self.alg = QJL.autoGRAPE(self.max_episode, self.epsilon)\n        else:\n            if (len(self.tspan) - 1) != len(self.control_coefficients[0]):\n                warnings.warn(\"GRAPE is not available when the length of each control is not \\\n                               equal to the length of time, and is replaced by auto-GRAPE.\",\n                               DeprecationWarning)\n                #### call autoGRAPE automatically ####\n                if self.Adam:\n                    self.alg = QJL.autoGRAPE(\n                        self.max_episode, self.epsilon, self.beta1, self.beta2\n                    )\n                else:\n                    self.alg = QJL.autoGRAPE(self.max_episode, self.epsilon)\n            else:\n                if LDtype == \"SLD\":\n                    if self.Adam:\n                        self.alg = QJL.GRAPE(\n                            self.max_episode, self.epsilon, self.beta1, self.beta2\n                            )\n                    else:\n                        self.alg = QJL.GRAPE(self.max_episode, self.epsilon)\n                else:\n                    raise ValueError(\"GRAPE is only available when LDtype is SLD.\")\n\n        super().QFIM(W, LDtype)\n\n    def CFIM(self, M=[], W=[]):\n        r\"\"\"\n        Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. \n        In single parameter estimation the objective function is CFI and \n        in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$.\n\n        Parameters\n        ----------\n        &gt; **W:** `matrix`\n            -- Weight matrix.\n\n        &gt; **M:** `list of matrices`\n            -- A set of positive operator-valued measure (POVM). The default measurement \n            is a set of rank-one symmetric informationally complete POVM (SIC-POVM).\n\n        **Note:** \n            SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state \n            which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/\n            solutions.html).\n        \"\"\"\n\n        if self.auto:\n            if self.Adam:\n                self.alg = QJL.autoGRAPE(\n                    self.max_episode, self.epsilon, self.beta1, self.beta2\n                )\n            else:\n                self.alg = QJL.autoGRAPE(self.max_episode, self.epsilon)\n        else:\n            if (len(self.tspan) - 1) != len(self.control_coefficients[0]):\n                warnings.warn(\"GRAPE is not available when the length of each control is not \\\n                               equal to the length of time, and is replaced by auto-GRAPE.\",\n                               DeprecationWarning)\n                #### call autoGRAPE automatically ####\n                if self.Adam:\n                    self.alg = QJL.autoGRAPE(\n                        self.max_episode, self.epsilon, self.beta1, self.beta2\n                    )\n                else:\n                    self.alg = QJL.autoGRAPE(self.max_episode, self.epsilon)\n            else:    \n                if self.Adam:\n                    self.alg = QJL.GRAPE(\n                        self.max_episode, self.epsilon, self.beta1, self.beta2\n                    )\n                else:\n                    self.alg = QJL.GRAPE(self.max_episode, self.epsilon)\n\n        super().CFIM(M, W)\n\n    def HCRB(self, W=[]):\n        \"\"\"\n        GRAPE and auto-GRAPE are not available when the objective function is HCRB. \n        Supported methods are PSO, DE and DDPG.\n\n        Parameters\n        ----------\n        &gt; **W:** `matrix`\n            -- Weight matrix.\n        \"\"\"\n        raise ValueError(\n            \"GRAPE and auto-GRAPE are not available when the objective function is HCRB. Supported methods are 'PSO', 'DE' and 'DDPG'.\",\n        )\n\n    def mintime(self, f, W=[], M=[], method=\"binary\", target=\"QFIM\", LDtype=\"SLD\"):\n        \"\"\"\n        Search of the minimum time to reach a given value of the objective function.\n\n        Parameters\n        ----------\n        &gt; **f:** `float`\n            -- The given value of the objective function.\n\n        &gt; **W:** `matrix`\n            -- Weight matrix.\n\n        &gt; **M:** `list of matrices`\n            -- A set of positive operator-valued measure (POVM). The default measurement \n            is a set of rank-one symmetric informationally complete POVM (SIC-POVM).\n\n        &gt; **method:** `string`\n            -- Methods for searching the minimum time to reach the given value of the \n            objective function. Options are:  \n            \"binary\" (default) -- Binary search (logarithmic search).  \n            \"forward\" -- Forward search from the beginning of time.  \n\n        &gt; **target:** `string`\n            -- Objective functions for searching the minimum time to reach the given \n            value of the objective function. Options are:  \n            \"QFIM\" (default) -- Choose QFI (QFIM) as the objective function.  \n            \"CFIM\" -- Choose CFI (CFIM) as the objective function.  \n            \"HCRB\" -- Choose HCRB as the objective function.\n\n        &gt; **LDtype:** `string`\n            -- Types of QFI (QFIM) can be set as the objective function. Options are:  \n            \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD).  \n            \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD).  \n            \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD).\n\n        **Note:** \n            SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state \n            which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/\n            solutions.html).\n        \"\"\"\n\n        if target == \"HCRB\":\n            raise ValueError(\n                \"GRAPE and auto-GRAPE are not available when the objective function is HCRB. Supported methods are 'PSO', 'DE' and 'DDPG'.\",\n            )\n        if self.auto:\n            if self.Adam:\n                self.alg = QJL.autoGRAPE(\n                    self.max_episode, self.epsilon, self.beta1, self.beta2\n                )\n            else:\n                self.alg = QJL.autoGRAPE(self.max_episode, self.epsilon)\n        else:\n\n            if self.Adam:\n                self.alg = QJL.GRAPE(\n                        self.max_episode, self.epsilon, self.beta1, self.beta2\n                    )\n            else:\n                self.alg = QJL.GRAPE(self.max_episode, self.epsilon)\n\n        super().mintime(f, W, M, method, target, LDtype)\n</code></pre>"},{"location":"API/python/classes/#quanestimation.GRAPE_Copt.CFIM","title":"<code>CFIM(M=[], W=[])</code>","text":"<p>Choose CFI or \\(\\mathrm{Tr}(WI^{-1})\\) as the objective function.  In single parameter estimation the objective function is CFI and  in multiparameter estimation it will be \\(\\mathrm{Tr}(WI^{-1})\\).</p>"},{"location":"API/python/classes/#quanestimation.GRAPE_Copt.CFIM--parameters","title":"Parameters","text":"<p>W: <code>matrix</code>     -- Weight matrix.</p> <p>M: <code>list of matrices</code>     -- A set of positive operator-valued measure (POVM). The default measurement      is a set of rank-one symmetric informationally complete POVM (SIC-POVM).</p> <p>Note:      SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state      which can be downloaded from here.</p> Source code in <code>quanestimation/ControlOpt/GRAPE_Copt.py</code> <pre><code>def CFIM(self, M=[], W=[]):\n    r\"\"\"\n    Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. \n    In single parameter estimation the objective function is CFI and \n    in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$.\n\n    Parameters\n    ----------\n    &gt; **W:** `matrix`\n        -- Weight matrix.\n\n    &gt; **M:** `list of matrices`\n        -- A set of positive operator-valued measure (POVM). The default measurement \n        is a set of rank-one symmetric informationally complete POVM (SIC-POVM).\n\n    **Note:** \n        SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state \n        which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/\n        solutions.html).\n    \"\"\"\n\n    if self.auto:\n        if self.Adam:\n            self.alg = QJL.autoGRAPE(\n                self.max_episode, self.epsilon, self.beta1, self.beta2\n            )\n        else:\n            self.alg = QJL.autoGRAPE(self.max_episode, self.epsilon)\n    else:\n        if (len(self.tspan) - 1) != len(self.control_coefficients[0]):\n            warnings.warn(\"GRAPE is not available when the length of each control is not \\\n                           equal to the length of time, and is replaced by auto-GRAPE.\",\n                           DeprecationWarning)\n            #### call autoGRAPE automatically ####\n            if self.Adam:\n                self.alg = QJL.autoGRAPE(\n                    self.max_episode, self.epsilon, self.beta1, self.beta2\n                )\n            else:\n                self.alg = QJL.autoGRAPE(self.max_episode, self.epsilon)\n        else:    \n            if self.Adam:\n                self.alg = QJL.GRAPE(\n                    self.max_episode, self.epsilon, self.beta1, self.beta2\n                )\n            else:\n                self.alg = QJL.GRAPE(self.max_episode, self.epsilon)\n\n    super().CFIM(M, W)\n</code></pre>"},{"location":"API/python/classes/#quanestimation.GRAPE_Copt.HCRB","title":"<code>HCRB(W=[])</code>","text":"<p>GRAPE and auto-GRAPE are not available when the objective function is HCRB.  Supported methods are PSO, DE and DDPG.</p>"},{"location":"API/python/classes/#quanestimation.GRAPE_Copt.HCRB--parameters","title":"Parameters","text":"<p>W: <code>matrix</code>     -- Weight matrix.</p> Source code in <code>quanestimation/ControlOpt/GRAPE_Copt.py</code> <pre><code>def HCRB(self, W=[]):\n    \"\"\"\n    GRAPE and auto-GRAPE are not available when the objective function is HCRB. \n    Supported methods are PSO, DE and DDPG.\n\n    Parameters\n    ----------\n    &gt; **W:** `matrix`\n        -- Weight matrix.\n    \"\"\"\n    raise ValueError(\n        \"GRAPE and auto-GRAPE are not available when the objective function is HCRB. Supported methods are 'PSO', 'DE' and 'DDPG'.\",\n    )\n</code></pre>"},{"location":"API/python/classes/#quanestimation.GRAPE_Copt.QFIM","title":"<code>QFIM(W=[], LDtype='SLD')</code>","text":"<p>Choose QFI or \\(\\mathrm{Tr}(WF^{-1})\\) as the objective function.  In single parameter estimation the objective function is QFI and in  multiparameter estimation it will be \\(\\mathrm{Tr}(WF^{-1})\\).</p>"},{"location":"API/python/classes/#quanestimation.GRAPE_Copt.QFIM--parameters","title":"Parameters","text":"<p>W: <code>matrix</code>     -- Weight matrix.</p> <p>LDtype: <code>string</code>     -- Types of QFI (QFIM) can be set as the objective function. Options are:     \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD).     \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD).     \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD).</p> Source code in <code>quanestimation/ControlOpt/GRAPE_Copt.py</code> <pre><code>def QFIM(self, W=[], LDtype=\"SLD\"):\n    r\"\"\"\n    Choose QFI or $\\mathrm{Tr}(WF^{-1})$ as the objective function. \n    In single parameter estimation the objective function is QFI and in \n    multiparameter estimation it will be $\\mathrm{Tr}(WF^{-1})$.\n\n    Parameters\n    ----------\n    &gt; **W:** `matrix`\n        -- Weight matrix.\n\n    &gt; **LDtype:** `string`\n        -- Types of QFI (QFIM) can be set as the objective function. Options are:  \n        \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD).  \n        \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD).  \n        \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD).\n    \"\"\"\n\n    if self.auto:\n        if self.Adam:\n            self.alg = QJL.autoGRAPE(\n                self.max_episode, self.epsilon, self.beta1, self.beta2\n            )\n        else:\n            self.alg = QJL.autoGRAPE(self.max_episode, self.epsilon)\n    else:\n        if (len(self.tspan) - 1) != len(self.control_coefficients[0]):\n            warnings.warn(\"GRAPE is not available when the length of each control is not \\\n                           equal to the length of time, and is replaced by auto-GRAPE.\",\n                           DeprecationWarning)\n            #### call autoGRAPE automatically ####\n            if self.Adam:\n                self.alg = QJL.autoGRAPE(\n                    self.max_episode, self.epsilon, self.beta1, self.beta2\n                )\n            else:\n                self.alg = QJL.autoGRAPE(self.max_episode, self.epsilon)\n        else:\n            if LDtype == \"SLD\":\n                if self.Adam:\n                    self.alg = QJL.GRAPE(\n                        self.max_episode, self.epsilon, self.beta1, self.beta2\n                        )\n                else:\n                    self.alg = QJL.GRAPE(self.max_episode, self.epsilon)\n            else:\n                raise ValueError(\"GRAPE is only available when LDtype is SLD.\")\n\n    super().QFIM(W, LDtype)\n</code></pre>"},{"location":"API/python/classes/#quanestimation.GRAPE_Copt.mintime","title":"<code>mintime(f, W=[], M=[], method='binary', target='QFIM', LDtype='SLD')</code>","text":"<p>Search of the minimum time to reach a given value of the objective function.</p>"},{"location":"API/python/classes/#quanestimation.GRAPE_Copt.mintime--parameters","title":"Parameters","text":"<p>f: <code>float</code>     -- The given value of the objective function.</p> <p>W: <code>matrix</code>     -- Weight matrix.</p> <p>M: <code>list of matrices</code>     -- A set of positive operator-valued measure (POVM). The default measurement      is a set of rank-one symmetric informationally complete POVM (SIC-POVM).</p> <p>method: <code>string</code>     -- Methods for searching the minimum time to reach the given value of the      objective function. Options are:     \"binary\" (default) -- Binary search (logarithmic search).     \"forward\" -- Forward search from the beginning of time.  </p> <p>target: <code>string</code>     -- Objective functions for searching the minimum time to reach the given      value of the objective function. Options are:     \"QFIM\" (default) -- Choose QFI (QFIM) as the objective function.     \"CFIM\" -- Choose CFI (CFIM) as the objective function.     \"HCRB\" -- Choose HCRB as the objective function.</p> <p>LDtype: <code>string</code>     -- Types of QFI (QFIM) can be set as the objective function. Options are:     \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD).     \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD).     \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD).</p> <p>Note:      SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state      which can be downloaded from here.</p> Source code in <code>quanestimation/ControlOpt/GRAPE_Copt.py</code> <pre><code>def mintime(self, f, W=[], M=[], method=\"binary\", target=\"QFIM\", LDtype=\"SLD\"):\n    \"\"\"\n    Search of the minimum time to reach a given value of the objective function.\n\n    Parameters\n    ----------\n    &gt; **f:** `float`\n        -- The given value of the objective function.\n\n    &gt; **W:** `matrix`\n        -- Weight matrix.\n\n    &gt; **M:** `list of matrices`\n        -- A set of positive operator-valued measure (POVM). The default measurement \n        is a set of rank-one symmetric informationally complete POVM (SIC-POVM).\n\n    &gt; **method:** `string`\n        -- Methods for searching the minimum time to reach the given value of the \n        objective function. Options are:  \n        \"binary\" (default) -- Binary search (logarithmic search).  \n        \"forward\" -- Forward search from the beginning of time.  \n\n    &gt; **target:** `string`\n        -- Objective functions for searching the minimum time to reach the given \n        value of the objective function. Options are:  \n        \"QFIM\" (default) -- Choose QFI (QFIM) as the objective function.  \n        \"CFIM\" -- Choose CFI (CFIM) as the objective function.  \n        \"HCRB\" -- Choose HCRB as the objective function.\n\n    &gt; **LDtype:** `string`\n        -- Types of QFI (QFIM) can be set as the objective function. Options are:  \n        \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD).  \n        \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD).  \n        \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD).\n\n    **Note:** \n        SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state \n        which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/\n        solutions.html).\n    \"\"\"\n\n    if target == \"HCRB\":\n        raise ValueError(\n            \"GRAPE and auto-GRAPE are not available when the objective function is HCRB. Supported methods are 'PSO', 'DE' and 'DDPG'.\",\n        )\n    if self.auto:\n        if self.Adam:\n            self.alg = QJL.autoGRAPE(\n                self.max_episode, self.epsilon, self.beta1, self.beta2\n            )\n        else:\n            self.alg = QJL.autoGRAPE(self.max_episode, self.epsilon)\n    else:\n\n        if self.Adam:\n            self.alg = QJL.GRAPE(\n                    self.max_episode, self.epsilon, self.beta1, self.beta2\n                )\n        else:\n            self.alg = QJL.GRAPE(self.max_episode, self.epsilon)\n\n    super().mintime(f, W, M, method, target, LDtype)\n</code></pre>"},{"location":"API/python/classes/#control-optimization-with-pso","title":"Control Optimization with PSO","text":"<p>             Bases: <code>ControlSystem</code></p>"},{"location":"API/python/classes/#quanestimation.PSO_Copt--attributes","title":"Attributes","text":"<p>savefile: <code>bool</code>     -- Whether or not to save all the control coeffients.     If set <code>True</code> then the control coefficients and the values of the      objective function obtained in all episodes will be saved during      the training. If set <code>False</code> the control coefficients in the final      episode and the values of the objective function in all episodes      will be saved.</p> <p>p_num: <code>int</code>     -- The number of particles.</p> <p>ctrl0: <code>list of arrays</code>     -- Initial guesses of control coefficients.</p> <p>max_episode: <code>int or list</code>     -- If it is an integer, for example max_episode=1000, it means the      program will continuously run 1000 episodes. However, if it is an     array, for example max_episode=[1000,100], the program will run      1000 episodes in total but replace control coefficients of all     the particles with global best every 100 episodes.</p> <p>c0: <code>float</code>     -- The damping factor that assists convergence, also known as inertia weight.</p> <p>c1: <code>float</code>     -- The exploitation weight that attracts the particle to its best previous      position, also known as cognitive learning factor.</p> <p>c2: <code>float</code>     -- The exploitation weight that attracts the particle to the best position     in the neighborhood, also known as social learning factor.</p> <p>seed: <code>int</code>     -- Random seed.</p> <p>eps: <code>float</code>     -- Machine epsilon.</p> <p>load: <code>bool</code>     -- Whether or not to load control coefficients in the current location.     If set <code>True</code> then the program will load control coefficients from      \"controls.csv\" file in the current location and use it as the initial      control coefficients.</p> Source code in <code>quanestimation/ControlOpt/PSO_Copt.py</code> <pre><code>class PSO_Copt(Control.ControlSystem):\n    \"\"\"\n    Attributes\n    ----------\n    &gt; **savefile:** `bool`\n        -- Whether or not to save all the control coeffients.  \n        If set `True` then the control coefficients and the values of the \n        objective function obtained in all episodes will be saved during \n        the training. If set `False` the control coefficients in the final \n        episode and the values of the objective function in all episodes \n        will be saved.\n\n    &gt; **p_num:** `int`\n        -- The number of particles.\n\n    &gt; **ctrl0:** `list of arrays`\n        -- Initial guesses of control coefficients.\n\n    &gt; **max_episode:** `int or list`\n        -- If it is an integer, for example max_episode=1000, it means the \n        program will continuously run 1000 episodes. However, if it is an\n        array, for example max_episode=[1000,100], the program will run \n        1000 episodes in total but replace control coefficients of all\n        the particles with global best every 100 episodes.\n\n    &gt; **c0:** `float`\n        -- The damping factor that assists convergence, also known as inertia weight.\n\n    &gt; **c1:** `float`\n        -- The exploitation weight that attracts the particle to its best previous \n        position, also known as cognitive learning factor.\n\n    &gt; **c2:** `float`\n        -- The exploitation weight that attracts the particle to the best position  \n        in the neighborhood, also known as social learning factor.\n\n    &gt; **seed:** `int`\n        -- Random seed.\n\n    &gt; **eps:** `float`\n        -- Machine epsilon.\n\n    &gt; **load:** `bool`\n        -- Whether or not to load control coefficients in the current location.  \n        If set `True` then the program will load control coefficients from \n        \"controls.csv\" file in the current location and use it as the initial \n        control coefficients.\n    \"\"\"\n\n    def __init__(\n        self,\n        savefile=False,\n        p_num=10,\n        ctrl0=[],\n        max_episode=[1000, 100],\n        c0=1.0,\n        c1=2.0,\n        c2=2.0,\n        seed=1234,\n        eps=1e-8,\n        load=False,\n    ):\n\n        Control.ControlSystem.__init__(self, savefile, ctrl0, eps, load)\n\n        is_int = isinstance(max_episode, int)\n        self.max_episode = max_episode if is_int else QJL.Vector[QJL.Int64](max_episode)\n        self.p_num = p_num\n        self.c0 = c0\n        self.c1 = c1\n        self.c2 = c2\n        self.seed = seed\n\n    def QFIM(self, W=[], LDtype=\"SLD\"):\n        r\"\"\"\n        Choose QFI or $\\mathrm{Tr}(WF^{-1})$ as the objective function. \n        In single parameter estimation the objective function is QFI and in \n        multiparameter estimation it will be $\\mathrm{Tr}(WF^{-1})$.\n\n        Parameters\n        ----------\n        &gt; **W:** `matrix`\n            -- Weight matrix.\n\n        &gt; **LDtype:** `string`\n            -- Types of QFI (QFIM) can be set as the objective function. Options are:  \n            \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD).  \n            \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD).  \n            \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD).\n        \"\"\"\n        ini_particle = (self.ctrl0, )\n        self.alg = QJL.PSO(\n            self.max_episode,\n            self.p_num,\n            ini_particle,\n            self.c0,\n            self.c1,\n            self.c2,\n        )\n\n        super().QFIM(W, LDtype)\n\n    def CFIM(self, M=[], W=[]):\n        r\"\"\"\n        Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. \n        In single parameter estimation the objective function is CFI and \n        in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$.\n\n        Parameters\n        ----------\n        &gt; **W:** `matrix`\n            -- Weight matrix.\n\n        &gt; **M:** `list of matrices`\n            -- A set of positive operator-valued measure (POVM). The default measurement \n            is a set of rank-one symmetric informationally complete POVM (SIC-POVM).\n\n        **Note:** \n            SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state \n            which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/\n            solutions.html).\n        \"\"\"\n        ini_particle = (self.ctrl0, )\n        self.alg = QJL.PSO(\n            self.max_episode,\n            self.p_num,\n            ini_particle,\n            self.c0,\n            self.c1,\n            self.c2,\n        )\n\n        super().CFIM(M, W)\n\n    def HCRB(self, W=[]):\n        \"\"\"\n        Choose HCRB as the objective function. \n\n        **Note:** in single parameter estimation, HCRB is equivalent to QFI, please choose \n        QFI as the objective function.\n\n        Parameters\n        ----------\n        &gt; **W:** `matrix`\n            -- Weight matrix.\n        \"\"\"\n        ini_particle = (self.ctrl0, )\n        self.alg = QJL.PSO(\n            self.max_episode,\n            self.p_num,\n            ini_particle,\n            self.c0,\n            self.c1,\n            self.c2,\n        )\n\n        super().HCRB(W)\n\n    def mintime(self, f, W=[], M=[], method=\"binary\", target=\"QFIM\", LDtype=\"SLD\"):\n        \"\"\"\n        Search of the minimum time to reach a given value of the objective function.\n\n        Parameters\n        ----------\n        &gt; **f:** `float`\n            -- The given value of the objective function.\n\n        &gt; **W:** `matrix`\n            -- Weight matrix.\n\n        &gt; **M:** `list of matrices`\n            -- A set of positive operator-valued measure (POVM). The default measurement \n            is a set of rank-one symmetric informationally complete POVM (SIC-POVM).\n\n        &gt; **method:** `string`\n            -- Methods for searching the minimum time to reach the given value of the \n            objective function. Options are:  \n            \"binary\" (default) -- Binary search (logarithmic search).  \n            \"forward\" -- Forward search from the beginning of time.\n\n        &gt; **target:** `string`\n            -- Objective functions for searching the minimum time to reach the given \n            value of the objective function. Options are:  \n            \"QFIM\" (default) -- Choose QFI (QFIM) as the objective function.  \n            \"CFIM\" -- Choose CFI (CFIM) as the objective function.  \n            \"HCRB\" -- Choose HCRB as the objective function.\n\n        &gt; **LDtype:** `string`\n            -- Types of QFI (QFIM) can be set as the objective function. Options are:  \n            \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD).  \n            \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD).  \n            \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD).\n\n        **Note:** \n            SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state \n            which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/\n            solutions.html).\n        \"\"\"\n        ini_particle = (self.ctrl0,)\n        self.alg = QJL.PSO(\n            self.max_episode,\n            self.p_num,\n            ini_particle,\n            self.c0,\n            self.c1,\n            self.c2,\n        )\n\n        super().mintime(f, W, M, method, target, LDtype)\n</code></pre>"},{"location":"API/python/classes/#quanestimation.PSO_Copt.CFIM","title":"<code>CFIM(M=[], W=[])</code>","text":"<p>Choose CFI or \\(\\mathrm{Tr}(WI^{-1})\\) as the objective function.  In single parameter estimation the objective function is CFI and  in multiparameter estimation it will be \\(\\mathrm{Tr}(WI^{-1})\\).</p>"},{"location":"API/python/classes/#quanestimation.PSO_Copt.CFIM--parameters","title":"Parameters","text":"<p>W: <code>matrix</code>     -- Weight matrix.</p> <p>M: <code>list of matrices</code>     -- A set of positive operator-valued measure (POVM). The default measurement      is a set of rank-one symmetric informationally complete POVM (SIC-POVM).</p> <p>Note:      SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state      which can be downloaded from here.</p> Source code in <code>quanestimation/ControlOpt/PSO_Copt.py</code> <pre><code>def CFIM(self, M=[], W=[]):\n    r\"\"\"\n    Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. \n    In single parameter estimation the objective function is CFI and \n    in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$.\n\n    Parameters\n    ----------\n    &gt; **W:** `matrix`\n        -- Weight matrix.\n\n    &gt; **M:** `list of matrices`\n        -- A set of positive operator-valued measure (POVM). The default measurement \n        is a set of rank-one symmetric informationally complete POVM (SIC-POVM).\n\n    **Note:** \n        SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state \n        which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/\n        solutions.html).\n    \"\"\"\n    ini_particle = (self.ctrl0, )\n    self.alg = QJL.PSO(\n        self.max_episode,\n        self.p_num,\n        ini_particle,\n        self.c0,\n        self.c1,\n        self.c2,\n    )\n\n    super().CFIM(M, W)\n</code></pre>"},{"location":"API/python/classes/#quanestimation.PSO_Copt.HCRB","title":"<code>HCRB(W=[])</code>","text":"<p>Choose HCRB as the objective function. </p> <p>Note: in single parameter estimation, HCRB is equivalent to QFI, please choose  QFI as the objective function.</p>"},{"location":"API/python/classes/#quanestimation.PSO_Copt.HCRB--parameters","title":"Parameters","text":"<p>W: <code>matrix</code>     -- Weight matrix.</p> Source code in <code>quanestimation/ControlOpt/PSO_Copt.py</code> <pre><code>def HCRB(self, W=[]):\n    \"\"\"\n    Choose HCRB as the objective function. \n\n    **Note:** in single parameter estimation, HCRB is equivalent to QFI, please choose \n    QFI as the objective function.\n\n    Parameters\n    ----------\n    &gt; **W:** `matrix`\n        -- Weight matrix.\n    \"\"\"\n    ini_particle = (self.ctrl0, )\n    self.alg = QJL.PSO(\n        self.max_episode,\n        self.p_num,\n        ini_particle,\n        self.c0,\n        self.c1,\n        self.c2,\n    )\n\n    super().HCRB(W)\n</code></pre>"},{"location":"API/python/classes/#quanestimation.PSO_Copt.QFIM","title":"<code>QFIM(W=[], LDtype='SLD')</code>","text":"<p>Choose QFI or \\(\\mathrm{Tr}(WF^{-1})\\) as the objective function.  In single parameter estimation the objective function is QFI and in  multiparameter estimation it will be \\(\\mathrm{Tr}(WF^{-1})\\).</p>"},{"location":"API/python/classes/#quanestimation.PSO_Copt.QFIM--parameters","title":"Parameters","text":"<p>W: <code>matrix</code>     -- Weight matrix.</p> <p>LDtype: <code>string</code>     -- Types of QFI (QFIM) can be set as the objective function. Options are:     \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD).     \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD).     \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD).</p> Source code in <code>quanestimation/ControlOpt/PSO_Copt.py</code> <pre><code>def QFIM(self, W=[], LDtype=\"SLD\"):\n    r\"\"\"\n    Choose QFI or $\\mathrm{Tr}(WF^{-1})$ as the objective function. \n    In single parameter estimation the objective function is QFI and in \n    multiparameter estimation it will be $\\mathrm{Tr}(WF^{-1})$.\n\n    Parameters\n    ----------\n    &gt; **W:** `matrix`\n        -- Weight matrix.\n\n    &gt; **LDtype:** `string`\n        -- Types of QFI (QFIM) can be set as the objective function. Options are:  \n        \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD).  \n        \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD).  \n        \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD).\n    \"\"\"\n    ini_particle = (self.ctrl0, )\n    self.alg = QJL.PSO(\n        self.max_episode,\n        self.p_num,\n        ini_particle,\n        self.c0,\n        self.c1,\n        self.c2,\n    )\n\n    super().QFIM(W, LDtype)\n</code></pre>"},{"location":"API/python/classes/#quanestimation.PSO_Copt.mintime","title":"<code>mintime(f, W=[], M=[], method='binary', target='QFIM', LDtype='SLD')</code>","text":"<p>Search of the minimum time to reach a given value of the objective function.</p>"},{"location":"API/python/classes/#quanestimation.PSO_Copt.mintime--parameters","title":"Parameters","text":"<p>f: <code>float</code>     -- The given value of the objective function.</p> <p>W: <code>matrix</code>     -- Weight matrix.</p> <p>M: <code>list of matrices</code>     -- A set of positive operator-valued measure (POVM). The default measurement      is a set of rank-one symmetric informationally complete POVM (SIC-POVM).</p> <p>method: <code>string</code>     -- Methods for searching the minimum time to reach the given value of the      objective function. Options are:     \"binary\" (default) -- Binary search (logarithmic search).     \"forward\" -- Forward search from the beginning of time.</p> <p>target: <code>string</code>     -- Objective functions for searching the minimum time to reach the given      value of the objective function. Options are:     \"QFIM\" (default) -- Choose QFI (QFIM) as the objective function.     \"CFIM\" -- Choose CFI (CFIM) as the objective function.     \"HCRB\" -- Choose HCRB as the objective function.</p> <p>LDtype: <code>string</code>     -- Types of QFI (QFIM) can be set as the objective function. Options are:     \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD).     \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD).     \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD).</p> <p>Note:      SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state      which can be downloaded from here.</p> Source code in <code>quanestimation/ControlOpt/PSO_Copt.py</code> <pre><code>def mintime(self, f, W=[], M=[], method=\"binary\", target=\"QFIM\", LDtype=\"SLD\"):\n    \"\"\"\n    Search of the minimum time to reach a given value of the objective function.\n\n    Parameters\n    ----------\n    &gt; **f:** `float`\n        -- The given value of the objective function.\n\n    &gt; **W:** `matrix`\n        -- Weight matrix.\n\n    &gt; **M:** `list of matrices`\n        -- A set of positive operator-valued measure (POVM). The default measurement \n        is a set of rank-one symmetric informationally complete POVM (SIC-POVM).\n\n    &gt; **method:** `string`\n        -- Methods for searching the minimum time to reach the given value of the \n        objective function. Options are:  \n        \"binary\" (default) -- Binary search (logarithmic search).  \n        \"forward\" -- Forward search from the beginning of time.\n\n    &gt; **target:** `string`\n        -- Objective functions for searching the minimum time to reach the given \n        value of the objective function. Options are:  \n        \"QFIM\" (default) -- Choose QFI (QFIM) as the objective function.  \n        \"CFIM\" -- Choose CFI (CFIM) as the objective function.  \n        \"HCRB\" -- Choose HCRB as the objective function.\n\n    &gt; **LDtype:** `string`\n        -- Types of QFI (QFIM) can be set as the objective function. Options are:  \n        \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD).  \n        \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD).  \n        \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD).\n\n    **Note:** \n        SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state \n        which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/\n        solutions.html).\n    \"\"\"\n    ini_particle = (self.ctrl0,)\n    self.alg = QJL.PSO(\n        self.max_episode,\n        self.p_num,\n        ini_particle,\n        self.c0,\n        self.c1,\n        self.c2,\n    )\n\n    super().mintime(f, W, M, method, target, LDtype)\n</code></pre>"},{"location":"API/python/classes/#control-optimization-de","title":"Control Optimization DE","text":"<p>             Bases: <code>ControlSystem</code></p>"},{"location":"API/python/classes/#quanestimation.DE_Copt--attributes","title":"Attributes","text":"<p>savefile: <code>bool</code>     --Whether or not to save all the control coeffients.     If set <code>True</code> then the control coefficients and the values of the      objective function obtained in all episodes will be saved during      the training. If set <code>False</code> the control coefficients in the final      episode and the values of the objective function in all episodes      will be saved.</p> <p>p_num: <code>int</code>     -- The number of populations.</p> <p>ctrl0: list of arrays     -- Initial guesses of control coefficients.</p> <p>max_episode: <code>int</code>     -- The number of episodes.</p> <p>c: <code>float</code>     -- Mutation constant.</p> <p>cr: <code>float</code>     -- Crossover constant.</p> <p>seed: <code>int</code>     -- Random seed.</p> <p>eps: <code>float</code>     -- Machine epsilon.</p> <p>load: <code>bool</code>     -- Whether or not to load control coefficients in the current location.     If set <code>True</code> then the program will load control coefficients from      \"controls.csv\" file in the current location and use it as the initial      control coefficients.</p> Source code in <code>quanestimation/ControlOpt/DE_Copt.py</code> <pre><code>class DE_Copt(Control.ControlSystem):\n    \"\"\"\n    Attributes\n    ----------\n    &gt; **savefile:** `bool`\n        --Whether or not to save all the control coeffients.  \n        If set `True` then the control coefficients and the values of the \n        objective function obtained in all episodes will be saved during \n        the training. If set `False` the control coefficients in the final \n        episode and the values of the objective function in all episodes \n        will be saved.\n\n    &gt; **p_num:** `int`\n        -- The number of populations.\n\n    &gt; **ctrl0:** list of arrays\n        -- Initial guesses of control coefficients.\n\n    &gt; **max_episode:** `int`\n        -- The number of episodes.\n\n    &gt; **c:** `float`\n        -- Mutation constant.\n\n    &gt; **cr:** `float`\n        -- Crossover constant.\n\n    &gt; **seed:** `int`\n        -- Random seed.\n\n    &gt; **eps:** `float`\n        -- Machine epsilon.\n\n    &gt; **load:** `bool`\n        -- Whether or not to load control coefficients in the current location.  \n        If set `True` then the program will load control coefficients from \n        \"controls.csv\" file in the current location and use it as the initial \n        control coefficients.\n    \"\"\"\n\n    def __init__(\n        self,\n        savefile=False,\n        p_num=10,\n        ctrl0=[],\n        max_episode=1000,\n        c=1.0,\n        cr=0.5,\n        seed=1234,\n        eps=1e-8,\n        load=False,\n    ):\n\n        Control.ControlSystem.__init__(self, savefile, ctrl0, eps, load)\n\n        self.p_num = p_num\n        self.max_episode = max_episode\n        self.c = c\n        self.cr = cr\n        self.seed = seed\n\n    def QFIM(self, W=[], LDtype=\"SLD\"):\n        r\"\"\"\n        Choose QFI or $\\mathrm{Tr}(WF^{-1})$ as the objective function. \n        In single parameter estimation the objective function is QFI and in \n        multiparameter estimation it will be $\\mathrm{Tr}(WF^{-1})$.\n\n        Parameters\n        ----------\n        &gt; **W:** `matrix`\n            -- Weight matrix.\n\n        &gt; **LDtype:** `string`\n            -- Types of QFI (QFIM) can be set as the objective function. Options are:  \n            \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD).  \n            \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD).  \n            \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD).\n        \"\"\"\n        ini_population = (self.ctrl0, )\n        self.alg = QJL.DE(\n            self.max_episode,\n            self.p_num,\n            ini_population,\n            self.c,\n            self.cr,\n        )\n\n        super().QFIM(W, LDtype)\n\n    def CFIM(self, M=[], W=[]):\n        r\"\"\"\n        Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. \n        In single parameter estimation the objective function is CFI and \n        in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$.\n\n        Parameters\n        ----------\n        &gt; **W:** `matrix`\n            -- Weight matrix.\n\n        &gt; **M:** `list of matrices`\n            -- A set of positive operator-valued measure (POVM). The default measurement \n            is a set of rank-one symmetric informationally complete POVM (SIC-POVM).\n\n        **Note:** \n            SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state \n            which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/\n            solutions.html).\n        \"\"\"\n        ini_population = (self.ctrl0, )\n        self.alg = QJL.DE(\n            self.max_episode,\n            self.p_num,\n            ini_population,\n            self.c,\n            self.cr,\n        )\n\n        super().CFIM(M, W)\n\n    def HCRB(self, W=[]):\n        \"\"\"\n        Choose HCRB as the objective function. \n\n        **Note:** in single parameter estimation, HCRB is equivalent to QFI, please choose \n        QFI as the objective function.\n\n        Parameters\n        ----------\n        &gt; **W:** `matrix`\n            -- Weight matrix.\n        \"\"\"\n\n        ini_population = (self.ctrl0, )\n        self.alg = QJL.DE(\n            self.max_episode,\n            self.p_num,\n            ini_population,\n            self.c,\n            self.cr,\n        )\n\n        super().HCRB(W)\n\n    def mintime(self, f, W=[], M=[], method=\"binary\", target=\"QFIM\", LDtype=\"SLD\"):\n        \"\"\"\n        Search of the minimum time to reach a given value of the objective function.\n\n        Parameters\n        ----------\n        &gt; **f:** `float`\n            -- The given value of the objective function.\n\n        &gt; **W:** `matrix`\n            -- Weight matrix.\n\n        &gt; **M:** `list of matrices`\n            -- A set of positive operator-valued measure (POVM). The default measurement \n            is a set of rank-one symmetric informationally complete POVM (SIC-POVM).\n\n        &gt; **method:** `string`\n            -- Methods for searching the minimum time to reach the given value of the \n            objective function. Options are:  \n            \"binary\" (default) -- Binary search (logarithmic search).  \n            \"forward\" -- Forward search from the beginning of time.\n\n        &gt; **target:** `string`\n            -- Objective functions for searching the minimum time to reach the given \n            value of the objective function. Options are:&lt;br&gt;\n            \"QFIM\" (default) -- Choose QFI (QFIM) as the objective function.&lt;br&gt;\n            \"CFIM\" -- Choose CFI (CFIM) as the objective function.&lt;br&gt;\n            \"HCRB\" -- Choose HCRB as the objective function.\n\n        &gt; **LDtype:** `string`\n            -- Types of QFI (QFIM) can be set as the objective function. Options are:  \n            \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD).  \n            \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD).  \n            \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD).\n\n        **Note:** \n            SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state \n            which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/\n            solutions.html).\n        \"\"\"\n        ini_population = (self.ctrl0, )\n        self.alg = QJL.DE(\n            self.max_episode,\n            self.p_num,\n            ini_population,\n            self.c,\n            self.cr,\n        )\n\n        super().mintime(f, W, M, method, target, LDtype)\n</code></pre>"},{"location":"API/python/classes/#quanestimation.DE_Copt.CFIM","title":"<code>CFIM(M=[], W=[])</code>","text":"<p>Choose CFI or \\(\\mathrm{Tr}(WI^{-1})\\) as the objective function.  In single parameter estimation the objective function is CFI and  in multiparameter estimation it will be \\(\\mathrm{Tr}(WI^{-1})\\).</p>"},{"location":"API/python/classes/#quanestimation.DE_Copt.CFIM--parameters","title":"Parameters","text":"<p>W: <code>matrix</code>     -- Weight matrix.</p> <p>M: <code>list of matrices</code>     -- A set of positive operator-valued measure (POVM). The default measurement      is a set of rank-one symmetric informationally complete POVM (SIC-POVM).</p> <p>Note:      SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state      which can be downloaded from here.</p> Source code in <code>quanestimation/ControlOpt/DE_Copt.py</code> <pre><code>def CFIM(self, M=[], W=[]):\n    r\"\"\"\n    Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. \n    In single parameter estimation the objective function is CFI and \n    in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$.\n\n    Parameters\n    ----------\n    &gt; **W:** `matrix`\n        -- Weight matrix.\n\n    &gt; **M:** `list of matrices`\n        -- A set of positive operator-valued measure (POVM). The default measurement \n        is a set of rank-one symmetric informationally complete POVM (SIC-POVM).\n\n    **Note:** \n        SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state \n        which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/\n        solutions.html).\n    \"\"\"\n    ini_population = (self.ctrl0, )\n    self.alg = QJL.DE(\n        self.max_episode,\n        self.p_num,\n        ini_population,\n        self.c,\n        self.cr,\n    )\n\n    super().CFIM(M, W)\n</code></pre>"},{"location":"API/python/classes/#quanestimation.DE_Copt.HCRB","title":"<code>HCRB(W=[])</code>","text":"<p>Choose HCRB as the objective function. </p> <p>Note: in single parameter estimation, HCRB is equivalent to QFI, please choose  QFI as the objective function.</p>"},{"location":"API/python/classes/#quanestimation.DE_Copt.HCRB--parameters","title":"Parameters","text":"<p>W: <code>matrix</code>     -- Weight matrix.</p> Source code in <code>quanestimation/ControlOpt/DE_Copt.py</code> <pre><code>def HCRB(self, W=[]):\n    \"\"\"\n    Choose HCRB as the objective function. \n\n    **Note:** in single parameter estimation, HCRB is equivalent to QFI, please choose \n    QFI as the objective function.\n\n    Parameters\n    ----------\n    &gt; **W:** `matrix`\n        -- Weight matrix.\n    \"\"\"\n\n    ini_population = (self.ctrl0, )\n    self.alg = QJL.DE(\n        self.max_episode,\n        self.p_num,\n        ini_population,\n        self.c,\n        self.cr,\n    )\n\n    super().HCRB(W)\n</code></pre>"},{"location":"API/python/classes/#quanestimation.DE_Copt.QFIM","title":"<code>QFIM(W=[], LDtype='SLD')</code>","text":"<p>Choose QFI or \\(\\mathrm{Tr}(WF^{-1})\\) as the objective function.  In single parameter estimation the objective function is QFI and in  multiparameter estimation it will be \\(\\mathrm{Tr}(WF^{-1})\\).</p>"},{"location":"API/python/classes/#quanestimation.DE_Copt.QFIM--parameters","title":"Parameters","text":"<p>W: <code>matrix</code>     -- Weight matrix.</p> <p>LDtype: <code>string</code>     -- Types of QFI (QFIM) can be set as the objective function. Options are:     \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD).     \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD).     \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD).</p> Source code in <code>quanestimation/ControlOpt/DE_Copt.py</code> <pre><code>def QFIM(self, W=[], LDtype=\"SLD\"):\n    r\"\"\"\n    Choose QFI or $\\mathrm{Tr}(WF^{-1})$ as the objective function. \n    In single parameter estimation the objective function is QFI and in \n    multiparameter estimation it will be $\\mathrm{Tr}(WF^{-1})$.\n\n    Parameters\n    ----------\n    &gt; **W:** `matrix`\n        -- Weight matrix.\n\n    &gt; **LDtype:** `string`\n        -- Types of QFI (QFIM) can be set as the objective function. Options are:  \n        \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD).  \n        \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD).  \n        \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD).\n    \"\"\"\n    ini_population = (self.ctrl0, )\n    self.alg = QJL.DE(\n        self.max_episode,\n        self.p_num,\n        ini_population,\n        self.c,\n        self.cr,\n    )\n\n    super().QFIM(W, LDtype)\n</code></pre>"},{"location":"API/python/classes/#quanestimation.DE_Copt.mintime","title":"<code>mintime(f, W=[], M=[], method='binary', target='QFIM', LDtype='SLD')</code>","text":"<p>Search of the minimum time to reach a given value of the objective function.</p>"},{"location":"API/python/classes/#quanestimation.DE_Copt.mintime--parameters","title":"Parameters","text":"<p>f: <code>float</code>     -- The given value of the objective function.</p> <p>W: <code>matrix</code>     -- Weight matrix.</p> <p>M: <code>list of matrices</code>     -- A set of positive operator-valued measure (POVM). The default measurement      is a set of rank-one symmetric informationally complete POVM (SIC-POVM).</p> <p>method: <code>string</code>     -- Methods for searching the minimum time to reach the given value of the      objective function. Options are:     \"binary\" (default) -- Binary search (logarithmic search).     \"forward\" -- Forward search from the beginning of time.</p> <p>target: <code>string</code>     -- Objective functions for searching the minimum time to reach the given      value of the objective function. Options are:     \"QFIM\" (default) -- Choose QFI (QFIM) as the objective function.     \"CFIM\" -- Choose CFI (CFIM) as the objective function.     \"HCRB\" -- Choose HCRB as the objective function.</p> <p>LDtype: <code>string</code>     -- Types of QFI (QFIM) can be set as the objective function. Options are:     \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD).     \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD).     \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD).</p> <p>Note:      SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state      which can be downloaded from here.</p> Source code in <code>quanestimation/ControlOpt/DE_Copt.py</code> <pre><code>def mintime(self, f, W=[], M=[], method=\"binary\", target=\"QFIM\", LDtype=\"SLD\"):\n    \"\"\"\n    Search of the minimum time to reach a given value of the objective function.\n\n    Parameters\n    ----------\n    &gt; **f:** `float`\n        -- The given value of the objective function.\n\n    &gt; **W:** `matrix`\n        -- Weight matrix.\n\n    &gt; **M:** `list of matrices`\n        -- A set of positive operator-valued measure (POVM). The default measurement \n        is a set of rank-one symmetric informationally complete POVM (SIC-POVM).\n\n    &gt; **method:** `string`\n        -- Methods for searching the minimum time to reach the given value of the \n        objective function. Options are:  \n        \"binary\" (default) -- Binary search (logarithmic search).  \n        \"forward\" -- Forward search from the beginning of time.\n\n    &gt; **target:** `string`\n        -- Objective functions for searching the minimum time to reach the given \n        value of the objective function. Options are:&lt;br&gt;\n        \"QFIM\" (default) -- Choose QFI (QFIM) as the objective function.&lt;br&gt;\n        \"CFIM\" -- Choose CFI (CFIM) as the objective function.&lt;br&gt;\n        \"HCRB\" -- Choose HCRB as the objective function.\n\n    &gt; **LDtype:** `string`\n        -- Types of QFI (QFIM) can be set as the objective function. Options are:  \n        \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD).  \n        \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD).  \n        \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD).\n\n    **Note:** \n        SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state \n        which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/\n        solutions.html).\n    \"\"\"\n    ini_population = (self.ctrl0, )\n    self.alg = QJL.DE(\n        self.max_episode,\n        self.p_num,\n        ini_population,\n        self.c,\n        self.cr,\n    )\n\n    super().mintime(f, W, M, method, target, LDtype)\n</code></pre>"},{"location":"API/python/classes/#state-optimization","title":"State Optimization","text":"<p>The probe state is expanded as \\(|\\psi\\rangle=\\sum_i c_i|i\\rangle\\) in a specific basis, i.e., \\(\\{|i\\rangle\\}\\). In state optimization, the search of the optimal probe states is equal to search of the normalized complex coefficients \\(\\{c_i\\}\\). In QuanEstimation, the state optimization algorithms are  automatic differentiation (AD), reverse iterative (RI) algorithm, particle swarm  optimization (PSO), differential evolution (DE), deep deterministic policy gradients  (DDPG) and Nelder-Mead (NM).</p>"},{"location":"API/python/classes/#base_1","title":"Base","text":""},{"location":"API/python/classes/#quanestimation.StateSystem--attributes","title":"Attributes","text":"<p>savefile: <code>bool</code>     -- Whether or not to save all the states.     If set <code>True</code> then the states and the values of the objective function      obtained in all episodes will be saved during the training. If set <code>False</code>      the state in the final episode and the values of the objective function in      all episodes will be saved.</p> <p>psi0: <code>list of arrays</code>     -- Initial guesses of states.</p> <p>seed: <code>int</code>     -- Random seed.</p> <p>eps: <code>float</code>     -- Machine epsilon.</p> <p>load: <code>bool</code>     -- Whether or not to load states in the current location.     If set <code>True</code> then the program will load state from \"states.csv\"     file in the current location and use it as the initial state.</p> Source code in <code>quanestimation/StateOpt/StateStruct.py</code> <pre><code>class StateSystem:\n    \"\"\"\n    Attributes\n    ----------\n    &gt; **savefile:**  `bool`\n        -- Whether or not to save all the states.\n        If set `True` then the states and the values of the objective function \n        obtained in all episodes will be saved during the training. If set `False` \n        the state in the final episode and the values of the objective function in \n        all episodes will be saved.\n\n    &gt; **psi0:** `list of arrays`\n        -- Initial guesses of states.\n\n    &gt; **seed:** `int`\n        -- Random seed.\n\n    &gt; **eps:** `float`\n        -- Machine epsilon.\n\n    &gt; **load:** `bool`\n        -- Whether or not to load states in the current location.\n        If set `True` then the program will load state from \"states.csv\"\n        file in the current location and use it as the initial state.\n    \"\"\"\n\n    def __init__(self, savefile, psi0, seed, eps, load):\n\n        self.savefile = savefile\n        self.psi0 = psi0\n        self.psi = psi0\n        self.eps = eps\n        self.seed = seed\n\n        if load == True:\n            if os.path.exists(\"states.npy\"):\n                self.psi0 = [np.load(\"states.npy\", dtype=np.complex128)]\n\n    def load_save(self, max_episode):\n        if os.path.exists(\"states.dat\"):\n            fl = h5py.File(\"states.dat\",'r')\n            dset = fl[\"states\"]\n            if self.savefile:\n                psi = np.array([np.array(fl[dset[i]]).view('complex') for i in range(max_episode)])\n            else:\n                psi = np.array(dset).view('complex')\n            np.save(\"states\", psi)\n        else: pass\n\n    def dynamics(self, tspan, H0, dH, Hc=[], ctrl=[], decay=[], dyn_method=\"expm\"):\n        r\"\"\"\n        The dynamics of a density matrix is of the form \n\n        \\begin{align}\n        \\partial_t\\rho &amp;=\\mathcal{L}\\rho \\nonumber \\\\\n        &amp;=-i[H,\\rho]+\\sum_i \\gamma_i\\left(\\Gamma_i\\rho\\Gamma^{\\dagger}_i-\\frac{1}{2}\n        \\left\\{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\right\\}\\right),\n        \\end{align}\n\n        where $\\rho$ is the evolved density matrix, H is the Hamiltonian of the \n        system, $\\Gamma_i$ and $\\gamma_i$ are the $i\\mathrm{th}$ decay \n        operator and corresponding decay rate.\n\n        Parameters\n        ----------\n        &gt; **tspan:** `array`\n            -- Time length for the evolution.\n\n        &gt; **H0:** `matrix or list`\n            -- Free Hamiltonian. It is a matrix when the free Hamiltonian is time-\n            independent and a list of length equal to `tspan` when it is time-dependent.\n\n        &gt; **dH:** `list`\n            -- Derivatives of the free Hamiltonian on the unknown parameters to be \n            estimated. For example, dH[0] is the derivative vector on the first \n            parameter.\n\n        &gt; **Hc:** `list`\n            -- Control Hamiltonians.\n\n        &gt; **ctrl:** `list of arrays`\n            -- Control coefficients.\n\n        &gt; **decay:** `list`\n            -- Decay operators and the corresponding decay rates. Its input rule is \n            decay=[[$\\Gamma_1$, $\\gamma_1$], [$\\Gamma_2$,$\\gamma_2$],...], where $\\Gamma_1$ \n            $(\\Gamma_2)$ represents the decay operator and $\\gamma_1$ $(\\gamma_2)$ is the \n            corresponding decay rate.\n\n        &gt; **dyn_method:** `string`\n            -- Setting the method for solving the Lindblad dynamics. Options are:  \n            \"expm\" (default) -- Matrix exponential.  \n            \"ode\" -- Solving the differential equations directly.\n        \"\"\"\n\n        self.tspan = tspan\n\n        if dyn_method == \"expm\":\n            self.dyn_method = \"Expm\"\n        elif dyn_method == \"ode\":\n            self.dyn_method = \"Ode\"\n\n        if Hc == [] or ctrl == []:\n            if type(H0) == np.ndarray:\n                self.freeHamiltonian = np.array(H0, dtype=np.complex128)\n                self.dim = len(self.freeHamiltonian)\n            else:\n                self.freeHamiltonian = [np.array(x, dtype=np.complex128) for x in H0]\n                self.dim = len(self.freeHamiltonian[0])\n        else:\n            ctrl_num = len(ctrl)\n            Hc_num = len(Hc)\n            if Hc_num &lt; ctrl_num:\n                raise TypeError(\n                    \"There are %d control Hamiltonians but %d coefficients sequences: \\\n                                 too many coefficients sequences.\"\n                    % (Hc_num, ctrl_num)\n                )\n            elif Hc_num &gt; ctrl_num:\n                warnings.warn(\n                    \"Not enough coefficients sequences: there are %d control Hamiltonians \\\n                               but %d coefficients sequences. The rest of the control sequences are\\\n                               set to be 0.\"\n                    % (Hc_num, ctrl_num),\n                    DeprecationWarning,\n                )\n                for i in range(Hc_num - ctrl_num):\n                    ctrl = np.concatenate((ctrl, np.zeros(len(ctrl[0]))))\n            else: pass\n\n            if len(ctrl[0]) == 1:\n                if type(H0) == np.ndarray:\n                    H0 = np.array(H0, dtype=np.complex128)\n                    Hc = [np.array(x, dtype=np.complex128) for x in Hc]\n                    Htot = H0 + sum([Hc[i] * ctrl[i][0] for i in range(ctrl_num)])\n                    self.freeHamiltonian = np.array(Htot, dtype=np.complex128)\n                    self.dim = len(self.freeHamiltonian)\n                else:\n                    H0 = [np.array(x, dtype=np.complex128) for x in H0]\n                    Htot = []\n                    for i in range(len(H0)):\n                        Htot.append(\n                            H0[i] + sum([Hc[i] * ctrl[i][0] for i in range(ctrl_num)])\n                        )\n                    self.freeHamiltonian = [\n                        np.array(x, dtype=np.complex128) for x in Htot\n                    ]\n                    self.dim = len(self.freeHamiltonian[0])\n            else:\n                if type(H0) != np.ndarray:\n                    #### linear interpolation  ####\n                    f = interp1d(self.tspan, H0, axis=0)\n                else: pass\n                number = math.ceil((len(self.tspan) - 1) / len(ctrl[0]))\n                if len(self.tspan) - 1 % len(ctrl[0]) != 0:\n                    tnum = number * len(ctrl[0])\n                    self.tspan = np.linspace(self.tspan[0], self.tspan[-1], tnum + 1)\n                    if type(H0) != np.ndarray:\n                        H0_inter = f(self.tspan)\n                        H0 = [np.array(x, dtype=np.complex128) for x in H0_inter]\n                    else: pass\n                else: pass\n\n                if type(H0) == np.ndarray:\n                    H0 = np.array(H0, dtype=np.complex128)\n                    Hc = [np.array(x, dtype=np.complex128) for x in Hc]\n                    ctrl = [np.array(ctrl[i]).repeat(number) for i in range(len(Hc))]\n                    Htot = []\n                    for i in range(len(ctrl[0])):\n                        S_ctrl = sum([Hc[j] * ctrl[j][i] for j in range(len(ctrl))])\n                        Htot.append(H0 + S_ctrl)\n                    self.freeHamiltonian = [\n                        np.array(x, dtype=np.complex128) for x in Htot\n                    ]\n                    self.dim = len(self.freeHamiltonian)\n                else:\n                    H0 = [np.array(x, dtype=np.complex128) for x in H0]\n                    Hc = [np.array(x, dtype=np.complex128) for x in Hc]\n                    ctrl = [np.array(ctrl[i]).repeat(number) for i in range(len(Hc))]\n                    Htot = []\n                    for i in range(len(ctrl[0])):\n                        S_ctrl = sum([Hc[j] * ctrl[j][i] for j in range(len(ctrl))])\n                        Htot.append(H0[i] + S_ctrl)\n                    self.freeHamiltonian = [\n                        np.array(x, dtype=np.complex128) for x in Htot\n                    ]\n                    self.dim = len(self.freeHamiltonian[0])\n\n        QJLType_psi = QJL.Vector[QJL.Vector[QJL.ComplexF64]]\n        if self.psi0 == []:\n            np.random.seed(self.seed)\n            r_ini = 2 * np.random.random(self.dim) - np.ones(self.dim)\n            r = r_ini / np.linalg.norm(r_ini)\n            phi = 2 * np.pi * np.random.random(self.dim)\n            psi0 = [r[i] * np.exp(1.0j * phi[i]) for i in range(self.dim)]\n            self.psi0 = np.array(psi0)\n            self.psi = QJL.convert(QJLType_psi, [self.psi0]) # Initial guesses of states (a list of arrays)\n        else:\n            self.psi0 = np.array(self.psi0[0], dtype=np.complex128)\n            self.psi = QJL.convert(QJLType_psi, self.psi)\n\n        if type(dH) != list:\n            raise TypeError(\"The derivative of Hamiltonian should be a list!\")\n\n        if dH == []:\n            dH = [np.zeros((len(self.psi0), len(self.psi0)))]\n        self.Hamiltonian_derivative = [np.array(x, dtype=np.complex128) for x in dH]\n\n        if decay == []:\n            decay_opt = [np.zeros((len(self.psi0), len(self.psi0)))]\n            self.gamma = [0.0]\n        else:\n            decay_opt = [decay[i][0] for i in range(len(decay))]\n            self.gamma = [decay[i][1] for i in range(len(decay))]\n        self.decay_opt = [np.array(x, dtype=np.complex128) for x in decay_opt]\n\n        self.opt = QJL.StateOpt(psi=self.psi0, seed=self.seed)\n        if any(self.gamma):\n            self.dynamic = QJL.Lindblad(\n                self.freeHamiltonian,\n                self.Hamiltonian_derivative,\n                list(self.psi0),\n                self.tspan,\n                self.decay_opt,\n                self.gamma,\n                dyn_method = self.dyn_method,\n            )\n        else:\n            self.dynamic = QJL.Lindblad(\n                self.freeHamiltonian,\n                self.Hamiltonian_derivative,\n                list(self.psi0),\n                self.tspan,\n                dyn_method = self.dyn_method,\n            )\n        self.output = QJL.Output(self.opt, save=self.savefile)\n\n        self.dynamics_type = \"dynamics\"\n        if len(self.Hamiltonian_derivative) == 1:\n            self.para_type = \"single_para\"\n        else:\n            self.para_type = \"multi_para\"\n\n    def Kraus(self, K, dK):\n        r\"\"\"\n        The parameterization of a state is\n        \\begin{align}\n        \\rho=\\sum_i K_i\\rho_0K_i^{\\dagger},\n        \\end{align} \n\n        where $\\rho$ is the evolved density matrix, $K_i$ is the Kraus operator.\n\n        Parameters\n        ----------\n        &gt; **K:** `list`\n            -- Kraus operators.\n\n        &gt; **dK:** `list`\n            -- Derivatives of the Kraus operators on the unknown parameters to be \n            estimated. For example, dK[0] is the derivative vector on the first \n            parameter.\n        \"\"\"\n\n        k_num = len(K)\n        para_num = len(dK[0])\n        self.para_num = para_num\n        self.K = [np.array(x, dtype=np.complex128) for x in K]\n        self.dK = [\n            [np.array(dK[i][j], dtype=np.complex128) for j in range(para_num)]\n            for i in range(k_num)\n        ]\n\n        self.dim = len(self.K[0])\n\n        if self.psi0 == []:\n            np.random.seed(self.seed)\n            r_ini = 2 * np.random.random(self.dim) - np.ones(self.dim)\n            r = r_ini / np.linalg.norm(r_ini)\n            phi = 2 * np.pi * np.random.random(self.dim)\n            psi0 = [r[i] * np.exp(1.0j * phi[i]) for i in range(self.dim)]\n            self.psi0 = np.array(psi0)  # Initial state (an array)\n            self.psi = [self.psi0] # Initial guesses of states (a list of arrays)\n        else:\n            self.psi0 = np.array(self.psi0[0], dtype=np.complex128)\n            self.psi = [np.array(psi, dtype=np.complex128) for psi in self.psi]\n\n        self.opt = QJL.StateOpt(psi=self.psi0, seed=self.seed)\n        self.dynamic = QJL.Kraus(list(self.psi0), self.K, self.dK)\n        self.output = QJL.Output(self.opt, save=self.savefile)\n\n        self.dynamics_type = \"Kraus\"\n        if para_num == 1:\n            self.para_type = \"single_para\"\n        else:\n            self.para_type = \"multi_para\"\n\n    def QFIM(self, W=[], LDtype=\"SLD\"):\n        r\"\"\"\n        Choose QFI or $\\mathrm{Tr}(WF^{-1})$ as the objective function. \n        In single parameter estimation the objective function is QFI and in \n        multiparameter estimation it will be $\\mathrm{Tr}(WF^{-1})$.\n\n        Parameters\n        ----------\n        &gt; **W:** `matrix`\n            -- Weight matrix.\n\n        &gt; **LDtype:** `string`\n            -- Types of QFI (QFIM) can be set as the objective function. Options are:\n            \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD).\n            \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD).\n            \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD).\n        \"\"\"\n\n        if LDtype != \"SLD\" and LDtype != \"RLD\" and LDtype != \"LLD\":\n            raise ValueError(\n                \"{!r} is not a valid value for LDtype, supported values are 'SLD', 'RLD' and 'LLD'.\".format(\n                    LDtype\n                )\n            )\n\n        if self.dynamics_type == \"dynamics\":\n            if W == []:\n                W = np.eye(len(self.Hamiltonian_derivative))\n            self.W = W\n\n        elif self.dynamics_type == \"Kraus\":\n            if W == []:\n                W = np.eye(self.para_num)\n            self.W = W\n        else:\n            pass\n\n        self.obj = QJL.QFIM_obj(\n            self.W, self.eps, self.para_type, LDtype\n        )\n        system = QJL.QuanEstSystem(\n            self.opt, self.alg, self.obj, self.dynamic, self.output\n        )\n        QJL.run(system)\n\n        max_num = self.max_episode if isinstance(self.max_episode, int) else self.max_episode[0]\n        self.load_save(max_num)\n\n    def CFIM(self, M=[], W=[]):\n        r\"\"\"\n        Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. \n        In single parameter estimation the objective function is CFI and \n        in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$.\n\n        Parameters\n        ----------\n        &gt; **W:** `matrix`\n            -- Weight matrix.\n\n        &gt; **M:** `list of matrices`\n            -- A set of positive operator-valued measure (POVM). The default measurement \n            is a set of rank-one symmetric informationally complete POVM (SIC-POVM).\n\n        **Note:** \n            SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state \n            which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/\n            solutions.html).\n        \"\"\"\n\n        if M == []:\n            M = SIC(len(self.psi0))\n        M = [np.array(x, dtype=np.complex128) for x in M]\n\n        if self.dynamics_type == \"dynamics\":\n            if W == []:\n                W = np.eye(len(self.Hamiltonian_derivative))\n            self.W = W\n\n        elif self.dynamics_type == \"Kraus\":\n            if W == []:\n                W = np.eye(self.para_num)\n            self.W = W\n\n        self.obj = QJL.CFIM_obj(M, self.W, self.eps, self.para_type)\n        system = QJL.QuanEstSystem(\n            self.opt, self.alg, self.obj, self.dynamic, self.output\n        )\n        QJL.run(system)\n\n        max_num = self.max_episode if isinstance(self.max_episode, int) else self.max_episode[0]\n        self.load_save(max_num)\n\n    def HCRB(self, W=[]):\n        \"\"\"\n        Choose HCRB as the objective function. \n\n        **Notes:** (1) In single parameter estimation, HCRB is equivalent to QFI, please  \n        choose QFI as the objective function. (2) GRAPE and auto-GRAPE are not available\n        when the objective function is HCRB. Supported methods are PSO, DE and DDPG.\n\n        Parameters\n        ----------\n        &gt; **W:** `matrix` \n            -- Weight matrix.\n        \"\"\"\n\n        if self.dynamics_type == \"dynamics\":\n            if W == []:\n                W = np.eye(len(self.Hamiltonian_derivative))\n            self.W = W\n            if len(self.Hamiltonian_derivative) == 1:\n                print(\"Program terminated. In the single-parameter scenario, the HCRB is equivalent to the QFI. Please choose 'QFIM' as the objective function\"\n                    )\n            else: pass\n\n        elif self.dynamics_type == \"Kraus\":\n            if W == []:\n                W = np.eye(self.para_num)\n            self.W = W\n            if len(self.dK) == 1:\n                raise ValueError(\n                    \"In single parameter scenario, HCRB is equivalent to QFI. Please choose QFIM as the target function for control optimization\",\n                )\n            else: pass\n        else:\n            raise ValueError(\n                \"Supported type of dynamics are Lindblad and Kraus.\"\n                )\n\n        self.obj = QJL.HCRB_obj(self.W, self.eps, self.para_type)\n        system = QJL.QuanEstSystem(\n                self.opt, self.alg, self.obj, self.dynamic, self.output\n        )\n        QJL.run(system)\n\n        max_num = self.max_episode if isinstance(self.max_episode, int) else self.max_episode[0]\n        self.load_save(max_num)\n</code></pre>"},{"location":"API/python/classes/#quanestimation.StateSystem.CFIM","title":"<code>CFIM(M=[], W=[])</code>","text":"<p>Choose CFI or \\(\\mathrm{Tr}(WI^{-1})\\) as the objective function.  In single parameter estimation the objective function is CFI and  in multiparameter estimation it will be \\(\\mathrm{Tr}(WI^{-1})\\).</p>"},{"location":"API/python/classes/#quanestimation.StateSystem.CFIM--parameters","title":"Parameters","text":"<p>W: <code>matrix</code>     -- Weight matrix.</p> <p>M: <code>list of matrices</code>     -- A set of positive operator-valued measure (POVM). The default measurement      is a set of rank-one symmetric informationally complete POVM (SIC-POVM).</p> <p>Note:      SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state      which can be downloaded from here.</p> Source code in <code>quanestimation/StateOpt/StateStruct.py</code> <pre><code>def CFIM(self, M=[], W=[]):\n    r\"\"\"\n    Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. \n    In single parameter estimation the objective function is CFI and \n    in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$.\n\n    Parameters\n    ----------\n    &gt; **W:** `matrix`\n        -- Weight matrix.\n\n    &gt; **M:** `list of matrices`\n        -- A set of positive operator-valued measure (POVM). The default measurement \n        is a set of rank-one symmetric informationally complete POVM (SIC-POVM).\n\n    **Note:** \n        SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state \n        which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/\n        solutions.html).\n    \"\"\"\n\n    if M == []:\n        M = SIC(len(self.psi0))\n    M = [np.array(x, dtype=np.complex128) for x in M]\n\n    if self.dynamics_type == \"dynamics\":\n        if W == []:\n            W = np.eye(len(self.Hamiltonian_derivative))\n        self.W = W\n\n    elif self.dynamics_type == \"Kraus\":\n        if W == []:\n            W = np.eye(self.para_num)\n        self.W = W\n\n    self.obj = QJL.CFIM_obj(M, self.W, self.eps, self.para_type)\n    system = QJL.QuanEstSystem(\n        self.opt, self.alg, self.obj, self.dynamic, self.output\n    )\n    QJL.run(system)\n\n    max_num = self.max_episode if isinstance(self.max_episode, int) else self.max_episode[0]\n    self.load_save(max_num)\n</code></pre>"},{"location":"API/python/classes/#quanestimation.StateSystem.HCRB","title":"<code>HCRB(W=[])</code>","text":"<p>Choose HCRB as the objective function. </p> <p>Notes: (1) In single parameter estimation, HCRB is equivalent to QFI, please choose QFI as the objective function. (2) GRAPE and auto-GRAPE are not available when the objective function is HCRB. Supported methods are PSO, DE and DDPG.</p>"},{"location":"API/python/classes/#quanestimation.StateSystem.HCRB--parameters","title":"Parameters","text":"<p>W: <code>matrix</code>      -- Weight matrix.</p> Source code in <code>quanestimation/StateOpt/StateStruct.py</code> <pre><code>def HCRB(self, W=[]):\n    \"\"\"\n    Choose HCRB as the objective function. \n\n    **Notes:** (1) In single parameter estimation, HCRB is equivalent to QFI, please  \n    choose QFI as the objective function. (2) GRAPE and auto-GRAPE are not available\n    when the objective function is HCRB. Supported methods are PSO, DE and DDPG.\n\n    Parameters\n    ----------\n    &gt; **W:** `matrix` \n        -- Weight matrix.\n    \"\"\"\n\n    if self.dynamics_type == \"dynamics\":\n        if W == []:\n            W = np.eye(len(self.Hamiltonian_derivative))\n        self.W = W\n        if len(self.Hamiltonian_derivative) == 1:\n            print(\"Program terminated. In the single-parameter scenario, the HCRB is equivalent to the QFI. Please choose 'QFIM' as the objective function\"\n                )\n        else: pass\n\n    elif self.dynamics_type == \"Kraus\":\n        if W == []:\n            W = np.eye(self.para_num)\n        self.W = W\n        if len(self.dK) == 1:\n            raise ValueError(\n                \"In single parameter scenario, HCRB is equivalent to QFI. Please choose QFIM as the target function for control optimization\",\n            )\n        else: pass\n    else:\n        raise ValueError(\n            \"Supported type of dynamics are Lindblad and Kraus.\"\n            )\n\n    self.obj = QJL.HCRB_obj(self.W, self.eps, self.para_type)\n    system = QJL.QuanEstSystem(\n            self.opt, self.alg, self.obj, self.dynamic, self.output\n    )\n    QJL.run(system)\n\n    max_num = self.max_episode if isinstance(self.max_episode, int) else self.max_episode[0]\n    self.load_save(max_num)\n</code></pre>"},{"location":"API/python/classes/#quanestimation.StateSystem.Kraus","title":"<code>Kraus(K, dK)</code>","text":"<p>The parameterization of a state is \\begin{align} \\rho=\\sum_i K_i\\rho_0K_i^{\\dagger}, \\end{align} </p> <p>where \\(\\rho\\) is the evolved density matrix, \\(K_i\\) is the Kraus operator.</p>"},{"location":"API/python/classes/#quanestimation.StateSystem.Kraus--parameters","title":"Parameters","text":"<p>K: <code>list</code>     -- Kraus operators.</p> <p>dK: <code>list</code>     -- Derivatives of the Kraus operators on the unknown parameters to be      estimated. For example, dK[0] is the derivative vector on the first      parameter.</p> Source code in <code>quanestimation/StateOpt/StateStruct.py</code> <pre><code>def Kraus(self, K, dK):\n    r\"\"\"\n    The parameterization of a state is\n    \\begin{align}\n    \\rho=\\sum_i K_i\\rho_0K_i^{\\dagger},\n    \\end{align} \n\n    where $\\rho$ is the evolved density matrix, $K_i$ is the Kraus operator.\n\n    Parameters\n    ----------\n    &gt; **K:** `list`\n        -- Kraus operators.\n\n    &gt; **dK:** `list`\n        -- Derivatives of the Kraus operators on the unknown parameters to be \n        estimated. For example, dK[0] is the derivative vector on the first \n        parameter.\n    \"\"\"\n\n    k_num = len(K)\n    para_num = len(dK[0])\n    self.para_num = para_num\n    self.K = [np.array(x, dtype=np.complex128) for x in K]\n    self.dK = [\n        [np.array(dK[i][j], dtype=np.complex128) for j in range(para_num)]\n        for i in range(k_num)\n    ]\n\n    self.dim = len(self.K[0])\n\n    if self.psi0 == []:\n        np.random.seed(self.seed)\n        r_ini = 2 * np.random.random(self.dim) - np.ones(self.dim)\n        r = r_ini / np.linalg.norm(r_ini)\n        phi = 2 * np.pi * np.random.random(self.dim)\n        psi0 = [r[i] * np.exp(1.0j * phi[i]) for i in range(self.dim)]\n        self.psi0 = np.array(psi0)  # Initial state (an array)\n        self.psi = [self.psi0] # Initial guesses of states (a list of arrays)\n    else:\n        self.psi0 = np.array(self.psi0[0], dtype=np.complex128)\n        self.psi = [np.array(psi, dtype=np.complex128) for psi in self.psi]\n\n    self.opt = QJL.StateOpt(psi=self.psi0, seed=self.seed)\n    self.dynamic = QJL.Kraus(list(self.psi0), self.K, self.dK)\n    self.output = QJL.Output(self.opt, save=self.savefile)\n\n    self.dynamics_type = \"Kraus\"\n    if para_num == 1:\n        self.para_type = \"single_para\"\n    else:\n        self.para_type = \"multi_para\"\n</code></pre>"},{"location":"API/python/classes/#quanestimation.StateSystem.QFIM","title":"<code>QFIM(W=[], LDtype='SLD')</code>","text":"<p>Choose QFI or \\(\\mathrm{Tr}(WF^{-1})\\) as the objective function.  In single parameter estimation the objective function is QFI and in  multiparameter estimation it will be \\(\\mathrm{Tr}(WF^{-1})\\).</p>"},{"location":"API/python/classes/#quanestimation.StateSystem.QFIM--parameters","title":"Parameters","text":"<p>W: <code>matrix</code>     -- Weight matrix.</p> <p>LDtype: <code>string</code>     -- Types of QFI (QFIM) can be set as the objective function. Options are:     \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD).     \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD).     \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD).</p> Source code in <code>quanestimation/StateOpt/StateStruct.py</code> <pre><code>def QFIM(self, W=[], LDtype=\"SLD\"):\n    r\"\"\"\n    Choose QFI or $\\mathrm{Tr}(WF^{-1})$ as the objective function. \n    In single parameter estimation the objective function is QFI and in \n    multiparameter estimation it will be $\\mathrm{Tr}(WF^{-1})$.\n\n    Parameters\n    ----------\n    &gt; **W:** `matrix`\n        -- Weight matrix.\n\n    &gt; **LDtype:** `string`\n        -- Types of QFI (QFIM) can be set as the objective function. Options are:\n        \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD).\n        \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD).\n        \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD).\n    \"\"\"\n\n    if LDtype != \"SLD\" and LDtype != \"RLD\" and LDtype != \"LLD\":\n        raise ValueError(\n            \"{!r} is not a valid value for LDtype, supported values are 'SLD', 'RLD' and 'LLD'.\".format(\n                LDtype\n            )\n        )\n\n    if self.dynamics_type == \"dynamics\":\n        if W == []:\n            W = np.eye(len(self.Hamiltonian_derivative))\n        self.W = W\n\n    elif self.dynamics_type == \"Kraus\":\n        if W == []:\n            W = np.eye(self.para_num)\n        self.W = W\n    else:\n        pass\n\n    self.obj = QJL.QFIM_obj(\n        self.W, self.eps, self.para_type, LDtype\n    )\n    system = QJL.QuanEstSystem(\n        self.opt, self.alg, self.obj, self.dynamic, self.output\n    )\n    QJL.run(system)\n\n    max_num = self.max_episode if isinstance(self.max_episode, int) else self.max_episode[0]\n    self.load_save(max_num)\n</code></pre>"},{"location":"API/python/classes/#quanestimation.StateSystem.dynamics","title":"<code>dynamics(tspan, H0, dH, Hc=[], ctrl=[], decay=[], dyn_method='expm')</code>","text":"<p>The dynamics of a density matrix is of the form </p> \\[\\begin{align} \\partial_t\\rho &amp;=\\mathcal{L}\\rho \\nonumber \\\\ &amp;=-i[H,\\rho]+\\sum_i \\gamma_i\\left(\\Gamma_i\\rho\\Gamma^{\\dagger}_i-\\frac{1}{2} \\left\\{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\right\\}\\right), \\end{align}\\] <p>where \\(\\rho\\) is the evolved density matrix, H is the Hamiltonian of the  system, \\(\\Gamma_i\\) and \\(\\gamma_i\\) are the \\(i\\mathrm{th}\\) decay  operator and corresponding decay rate.</p>"},{"location":"API/python/classes/#quanestimation.StateSystem.dynamics--parameters","title":"Parameters","text":"<p>tspan: <code>array</code>     -- Time length for the evolution.</p> <p>H0: <code>matrix or list</code>     -- Free Hamiltonian. It is a matrix when the free Hamiltonian is time-     independent and a list of length equal to <code>tspan</code> when it is time-dependent.</p> <p>dH: <code>list</code>     -- Derivatives of the free Hamiltonian on the unknown parameters to be      estimated. For example, dH[0] is the derivative vector on the first      parameter.</p> <p>Hc: <code>list</code>     -- Control Hamiltonians.</p> <p>ctrl: <code>list of arrays</code>     -- Control coefficients.</p> <p>decay: <code>list</code>     -- Decay operators and the corresponding decay rates. Its input rule is      decay=[[\\(\\Gamma_1\\), \\(\\gamma_1\\)], [\\(\\Gamma_2\\),\\(\\gamma_2\\)],...], where \\(\\Gamma_1\\) \\((\\Gamma_2)\\) represents the decay operator and \\(\\gamma_1\\) \\((\\gamma_2)\\) is the      corresponding decay rate.</p> <p>dyn_method: <code>string</code>     -- Setting the method for solving the Lindblad dynamics. Options are:     \"expm\" (default) -- Matrix exponential.     \"ode\" -- Solving the differential equations directly.</p> Source code in <code>quanestimation/StateOpt/StateStruct.py</code> <pre><code>def dynamics(self, tspan, H0, dH, Hc=[], ctrl=[], decay=[], dyn_method=\"expm\"):\n    r\"\"\"\n    The dynamics of a density matrix is of the form \n\n    \\begin{align}\n    \\partial_t\\rho &amp;=\\mathcal{L}\\rho \\nonumber \\\\\n    &amp;=-i[H,\\rho]+\\sum_i \\gamma_i\\left(\\Gamma_i\\rho\\Gamma^{\\dagger}_i-\\frac{1}{2}\n    \\left\\{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\right\\}\\right),\n    \\end{align}\n\n    where $\\rho$ is the evolved density matrix, H is the Hamiltonian of the \n    system, $\\Gamma_i$ and $\\gamma_i$ are the $i\\mathrm{th}$ decay \n    operator and corresponding decay rate.\n\n    Parameters\n    ----------\n    &gt; **tspan:** `array`\n        -- Time length for the evolution.\n\n    &gt; **H0:** `matrix or list`\n        -- Free Hamiltonian. It is a matrix when the free Hamiltonian is time-\n        independent and a list of length equal to `tspan` when it is time-dependent.\n\n    &gt; **dH:** `list`\n        -- Derivatives of the free Hamiltonian on the unknown parameters to be \n        estimated. For example, dH[0] is the derivative vector on the first \n        parameter.\n\n    &gt; **Hc:** `list`\n        -- Control Hamiltonians.\n\n    &gt; **ctrl:** `list of arrays`\n        -- Control coefficients.\n\n    &gt; **decay:** `list`\n        -- Decay operators and the corresponding decay rates. Its input rule is \n        decay=[[$\\Gamma_1$, $\\gamma_1$], [$\\Gamma_2$,$\\gamma_2$],...], where $\\Gamma_1$ \n        $(\\Gamma_2)$ represents the decay operator and $\\gamma_1$ $(\\gamma_2)$ is the \n        corresponding decay rate.\n\n    &gt; **dyn_method:** `string`\n        -- Setting the method for solving the Lindblad dynamics. Options are:  \n        \"expm\" (default) -- Matrix exponential.  \n        \"ode\" -- Solving the differential equations directly.\n    \"\"\"\n\n    self.tspan = tspan\n\n    if dyn_method == \"expm\":\n        self.dyn_method = \"Expm\"\n    elif dyn_method == \"ode\":\n        self.dyn_method = \"Ode\"\n\n    if Hc == [] or ctrl == []:\n        if type(H0) == np.ndarray:\n            self.freeHamiltonian = np.array(H0, dtype=np.complex128)\n            self.dim = len(self.freeHamiltonian)\n        else:\n            self.freeHamiltonian = [np.array(x, dtype=np.complex128) for x in H0]\n            self.dim = len(self.freeHamiltonian[0])\n    else:\n        ctrl_num = len(ctrl)\n        Hc_num = len(Hc)\n        if Hc_num &lt; ctrl_num:\n            raise TypeError(\n                \"There are %d control Hamiltonians but %d coefficients sequences: \\\n                             too many coefficients sequences.\"\n                % (Hc_num, ctrl_num)\n            )\n        elif Hc_num &gt; ctrl_num:\n            warnings.warn(\n                \"Not enough coefficients sequences: there are %d control Hamiltonians \\\n                           but %d coefficients sequences. The rest of the control sequences are\\\n                           set to be 0.\"\n                % (Hc_num, ctrl_num),\n                DeprecationWarning,\n            )\n            for i in range(Hc_num - ctrl_num):\n                ctrl = np.concatenate((ctrl, np.zeros(len(ctrl[0]))))\n        else: pass\n\n        if len(ctrl[0]) == 1:\n            if type(H0) == np.ndarray:\n                H0 = np.array(H0, dtype=np.complex128)\n                Hc = [np.array(x, dtype=np.complex128) for x in Hc]\n                Htot = H0 + sum([Hc[i] * ctrl[i][0] for i in range(ctrl_num)])\n                self.freeHamiltonian = np.array(Htot, dtype=np.complex128)\n                self.dim = len(self.freeHamiltonian)\n            else:\n                H0 = [np.array(x, dtype=np.complex128) for x in H0]\n                Htot = []\n                for i in range(len(H0)):\n                    Htot.append(\n                        H0[i] + sum([Hc[i] * ctrl[i][0] for i in range(ctrl_num)])\n                    )\n                self.freeHamiltonian = [\n                    np.array(x, dtype=np.complex128) for x in Htot\n                ]\n                self.dim = len(self.freeHamiltonian[0])\n        else:\n            if type(H0) != np.ndarray:\n                #### linear interpolation  ####\n                f = interp1d(self.tspan, H0, axis=0)\n            else: pass\n            number = math.ceil((len(self.tspan) - 1) / len(ctrl[0]))\n            if len(self.tspan) - 1 % len(ctrl[0]) != 0:\n                tnum = number * len(ctrl[0])\n                self.tspan = np.linspace(self.tspan[0], self.tspan[-1], tnum + 1)\n                if type(H0) != np.ndarray:\n                    H0_inter = f(self.tspan)\n                    H0 = [np.array(x, dtype=np.complex128) for x in H0_inter]\n                else: pass\n            else: pass\n\n            if type(H0) == np.ndarray:\n                H0 = np.array(H0, dtype=np.complex128)\n                Hc = [np.array(x, dtype=np.complex128) for x in Hc]\n                ctrl = [np.array(ctrl[i]).repeat(number) for i in range(len(Hc))]\n                Htot = []\n                for i in range(len(ctrl[0])):\n                    S_ctrl = sum([Hc[j] * ctrl[j][i] for j in range(len(ctrl))])\n                    Htot.append(H0 + S_ctrl)\n                self.freeHamiltonian = [\n                    np.array(x, dtype=np.complex128) for x in Htot\n                ]\n                self.dim = len(self.freeHamiltonian)\n            else:\n                H0 = [np.array(x, dtype=np.complex128) for x in H0]\n                Hc = [np.array(x, dtype=np.complex128) for x in Hc]\n                ctrl = [np.array(ctrl[i]).repeat(number) for i in range(len(Hc))]\n                Htot = []\n                for i in range(len(ctrl[0])):\n                    S_ctrl = sum([Hc[j] * ctrl[j][i] for j in range(len(ctrl))])\n                    Htot.append(H0[i] + S_ctrl)\n                self.freeHamiltonian = [\n                    np.array(x, dtype=np.complex128) for x in Htot\n                ]\n                self.dim = len(self.freeHamiltonian[0])\n\n    QJLType_psi = QJL.Vector[QJL.Vector[QJL.ComplexF64]]\n    if self.psi0 == []:\n        np.random.seed(self.seed)\n        r_ini = 2 * np.random.random(self.dim) - np.ones(self.dim)\n        r = r_ini / np.linalg.norm(r_ini)\n        phi = 2 * np.pi * np.random.random(self.dim)\n        psi0 = [r[i] * np.exp(1.0j * phi[i]) for i in range(self.dim)]\n        self.psi0 = np.array(psi0)\n        self.psi = QJL.convert(QJLType_psi, [self.psi0]) # Initial guesses of states (a list of arrays)\n    else:\n        self.psi0 = np.array(self.psi0[0], dtype=np.complex128)\n        self.psi = QJL.convert(QJLType_psi, self.psi)\n\n    if type(dH) != list:\n        raise TypeError(\"The derivative of Hamiltonian should be a list!\")\n\n    if dH == []:\n        dH = [np.zeros((len(self.psi0), len(self.psi0)))]\n    self.Hamiltonian_derivative = [np.array(x, dtype=np.complex128) for x in dH]\n\n    if decay == []:\n        decay_opt = [np.zeros((len(self.psi0), len(self.psi0)))]\n        self.gamma = [0.0]\n    else:\n        decay_opt = [decay[i][0] for i in range(len(decay))]\n        self.gamma = [decay[i][1] for i in range(len(decay))]\n    self.decay_opt = [np.array(x, dtype=np.complex128) for x in decay_opt]\n\n    self.opt = QJL.StateOpt(psi=self.psi0, seed=self.seed)\n    if any(self.gamma):\n        self.dynamic = QJL.Lindblad(\n            self.freeHamiltonian,\n            self.Hamiltonian_derivative,\n            list(self.psi0),\n            self.tspan,\n            self.decay_opt,\n            self.gamma,\n            dyn_method = self.dyn_method,\n        )\n    else:\n        self.dynamic = QJL.Lindblad(\n            self.freeHamiltonian,\n            self.Hamiltonian_derivative,\n            list(self.psi0),\n            self.tspan,\n            dyn_method = self.dyn_method,\n        )\n    self.output = QJL.Output(self.opt, save=self.savefile)\n\n    self.dynamics_type = \"dynamics\"\n    if len(self.Hamiltonian_derivative) == 1:\n        self.para_type = \"single_para\"\n    else:\n        self.para_type = \"multi_para\"\n</code></pre>"},{"location":"API/python/classes/#state-optimization-with-ad","title":"State optimization with AD","text":"<p>             Bases: <code>StateSystem</code></p>"},{"location":"API/python/classes/#quanestimation.AD_Sopt--attributes","title":"Attributes","text":"<p>savefile: <code>bool</code>     -- Whether or not to save all the states.     If set <code>True</code> then the states and the values of the objective function      obtained in all episodes will be saved during the training. If set <code>False</code>      the state in the final episode and the values of the objective function in      all episodes will be saved.</p> <p>Adam: <code>bool</code>     -- Whether or not to use Adam for updating states.</p> <p>psi0: <code>list of arrays</code>     -- Initial guesses of states.</p> <p>max_episode: <code>int</code>     -- The number of episodes.</p> <p>epsilon: <code>float</code>     -- Learning rate.</p> <p>beta1: <code>float</code>     -- The exponential decay rate for the first moment estimates.</p> <p>beta2: <code>float</code>     -- The exponential decay rate for the second moment estimates.</p> <p>eps: <code>float</code>     -- Machine epsilon.</p> <p>load: <code>bool</code>     -- Whether or not to load states in the current location.     If set <code>True</code> then the program will load state from \"states.csv\"     file in the current location and use it as the initial state.</p> Source code in <code>quanestimation/StateOpt/AD_Sopt.py</code> <pre><code>class AD_Sopt(State.StateSystem):\n    \"\"\"\n    Attributes\n    ----------\n    &gt; **savefile:** `bool`\n        -- Whether or not to save all the states.  \n        If set `True` then the states and the values of the objective function \n        obtained in all episodes will be saved during the training. If set `False` \n        the state in the final episode and the values of the objective function in \n        all episodes will be saved.\n\n    &gt; **Adam:** `bool`\n        -- Whether or not to use Adam for updating states.\n\n    &gt; **psi0:** `list of arrays`\n        -- Initial guesses of states.\n\n    &gt; **max_episode:** `int`\n        -- The number of episodes.\n\n    &gt; **epsilon:** `float`\n        -- Learning rate.\n\n    &gt; **beta1:** `float`\n        -- The exponential decay rate for the first moment estimates.\n\n    &gt; **beta2:** `float`\n        -- The exponential decay rate for the second moment estimates.\n\n    &gt; **eps:** `float`\n        -- Machine epsilon.\n\n    &gt; **load:** `bool`\n        -- Whether or not to load states in the current location.  \n        If set `True` then the program will load state from \"states.csv\"\n        file in the current location and use it as the initial state.\n    \"\"\"\n\n    def __init__(\n        self,\n        savefile=False,\n        Adam=False,\n        psi0=[],\n        max_episode=300,\n        epsilon=0.01,\n        beta1=0.90,\n        beta2=0.99,\n        seed=1234,\n        eps=1e-8,\n        load=False,\n    ):\n\n        State.StateSystem.__init__(self, savefile, psi0, seed, eps, load)\n\n        self.Adam = Adam\n        self.max_episode = max_episode\n        self.epsilon = epsilon\n        self.beta1 = beta1\n        self.beta2 = beta2\n        self.mt = 0.0\n        self.vt = 0.0\n\n        if self.Adam:\n            self.alg = QJL.AD(\n                self.max_episode, self.epsilon, self.beta1, self.beta2,\n            )\n        else:\n            self.alg = QJL.AD(self.max_episode, self.epsilon)\n\n    def QFIM(self, W=[], LDtype=\"SLD\"):\n        r\"\"\"\n        Choose QFI or $\\mathrm{Tr}(WF^{-1})$ as the objective function. \n        In single parameter estimation the objective function is QFI and in \n        multiparameter estimation it will be $\\mathrm{Tr}(WF^{-1})$.\n\n        Parameters\n        ----------\n        &gt; **W:** `matrix`\n            -- Weight matrix.\n\n        &gt; **LDtype:** `string`\n            -- Types of QFI (QFIM) can be set as the objective function. Options are:  \n            \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD).  \n            \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD).  \n            \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD).\n        \"\"\"\n\n        super().QFIM(W, LDtype)\n\n    def CFIM(self, M=[], W=[]):\n        r\"\"\"\n        Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. \n        In single parameter estimation the objective function is CFI and \n        in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$.\n\n        Parameters\n        ----------\n        &gt; **W:** `matrix`\n            -- Weight matrix.\n\n        &gt; **M:** `list of matrices`\n            -- A set of positive operator-valued measure (POVM). The default measurement \n            is a set of rank-one symmetric informationally complete POVM (SIC-POVM).\n\n        **Note:** \n            SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state \n            which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/\n            solutions.html).\n        \"\"\"\n\n        super().CFIM(M, W)\n\n    def HCRB(self, W=[]):\n        \"\"\"\n        AD is not available when the objective function is HCRB. \n        Supported methods are PSO, DE, DDPG and NM.\n\n        Parameters\n        ----------\n        &gt; **W:** `matrix`\n            -- Weight matrix.\n        \"\"\"\n\n        raise ValueError(\n            \"AD is not available when the objective function is HCRB. Supported methods are 'PSO', 'DE', 'NM' and 'DDPG'.\")\n</code></pre>"},{"location":"API/python/classes/#quanestimation.AD_Sopt.CFIM","title":"<code>CFIM(M=[], W=[])</code>","text":"<p>Choose CFI or \\(\\mathrm{Tr}(WI^{-1})\\) as the objective function.  In single parameter estimation the objective function is CFI and  in multiparameter estimation it will be \\(\\mathrm{Tr}(WI^{-1})\\).</p>"},{"location":"API/python/classes/#quanestimation.AD_Sopt.CFIM--parameters","title":"Parameters","text":"<p>W: <code>matrix</code>     -- Weight matrix.</p> <p>M: <code>list of matrices</code>     -- A set of positive operator-valued measure (POVM). The default measurement      is a set of rank-one symmetric informationally complete POVM (SIC-POVM).</p> <p>Note:      SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state      which can be downloaded from here.</p> Source code in <code>quanestimation/StateOpt/AD_Sopt.py</code> <pre><code>def CFIM(self, M=[], W=[]):\n    r\"\"\"\n    Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. \n    In single parameter estimation the objective function is CFI and \n    in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$.\n\n    Parameters\n    ----------\n    &gt; **W:** `matrix`\n        -- Weight matrix.\n\n    &gt; **M:** `list of matrices`\n        -- A set of positive operator-valued measure (POVM). The default measurement \n        is a set of rank-one symmetric informationally complete POVM (SIC-POVM).\n\n    **Note:** \n        SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state \n        which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/\n        solutions.html).\n    \"\"\"\n\n    super().CFIM(M, W)\n</code></pre>"},{"location":"API/python/classes/#quanestimation.AD_Sopt.HCRB","title":"<code>HCRB(W=[])</code>","text":"<p>AD is not available when the objective function is HCRB.  Supported methods are PSO, DE, DDPG and NM.</p>"},{"location":"API/python/classes/#quanestimation.AD_Sopt.HCRB--parameters","title":"Parameters","text":"<p>W: <code>matrix</code>     -- Weight matrix.</p> Source code in <code>quanestimation/StateOpt/AD_Sopt.py</code> <pre><code>def HCRB(self, W=[]):\n    \"\"\"\n    AD is not available when the objective function is HCRB. \n    Supported methods are PSO, DE, DDPG and NM.\n\n    Parameters\n    ----------\n    &gt; **W:** `matrix`\n        -- Weight matrix.\n    \"\"\"\n\n    raise ValueError(\n        \"AD is not available when the objective function is HCRB. Supported methods are 'PSO', 'DE', 'NM' and 'DDPG'.\")\n</code></pre>"},{"location":"API/python/classes/#quanestimation.AD_Sopt.QFIM","title":"<code>QFIM(W=[], LDtype='SLD')</code>","text":"<p>Choose QFI or \\(\\mathrm{Tr}(WF^{-1})\\) as the objective function.  In single parameter estimation the objective function is QFI and in  multiparameter estimation it will be \\(\\mathrm{Tr}(WF^{-1})\\).</p>"},{"location":"API/python/classes/#quanestimation.AD_Sopt.QFIM--parameters","title":"Parameters","text":"<p>W: <code>matrix</code>     -- Weight matrix.</p> <p>LDtype: <code>string</code>     -- Types of QFI (QFIM) can be set as the objective function. Options are:     \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD).     \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD).     \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD).</p> Source code in <code>quanestimation/StateOpt/AD_Sopt.py</code> <pre><code>def QFIM(self, W=[], LDtype=\"SLD\"):\n    r\"\"\"\n    Choose QFI or $\\mathrm{Tr}(WF^{-1})$ as the objective function. \n    In single parameter estimation the objective function is QFI and in \n    multiparameter estimation it will be $\\mathrm{Tr}(WF^{-1})$.\n\n    Parameters\n    ----------\n    &gt; **W:** `matrix`\n        -- Weight matrix.\n\n    &gt; **LDtype:** `string`\n        -- Types of QFI (QFIM) can be set as the objective function. Options are:  \n        \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD).  \n        \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD).  \n        \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD).\n    \"\"\"\n\n    super().QFIM(W, LDtype)\n</code></pre>"},{"location":"API/python/classes/#state-optimization-with-ri","title":"State optimization with RI","text":"<p>             Bases: <code>StateSystem</code></p>"},{"location":"API/python/classes/#quanestimation.RI_Sopt--attributes","title":"Attributes","text":"<p>savefile: <code>bool</code>     -- Whether or not to save all the states.     If set <code>True</code> then the states and the values of the      objective function obtained in all episodes will be saved during      the training. If set <code>False</code> the state in the final      episode and the values of the objective function in all episodes      will be saved.</p> <p>psi0: <code>list of arrays</code>     -- Initial guesses of states.</p> <p>max_episode: <code>int</code>     -- The number of episodes.</p> <p>seed: <code>int</code>     -- Random seed.</p> <p>eps: <code>float</code>     -- Machine epsilon.</p> <p>load: <code>bool</code>     -- Whether or not to load states in the current location.     If set <code>True</code> then the program will load state from \"states.csv\"     file in the current location and use it as the initial state.</p> Source code in <code>quanestimation/StateOpt/RI_Sopt.py</code> <pre><code>class RI_Sopt(State.StateSystem):\n    \"\"\"\n    Attributes\n    ----------\n    &gt; **savefile:**  `bool`\n        -- Whether or not to save all the states.  \n        If set `True` then the states and the values of the \n        objective function obtained in all episodes will be saved during \n        the training. If set `False` the state in the final \n        episode and the values of the objective function in all episodes \n        will be saved.\n\n    &gt; **psi0:** `list of arrays`\n        -- Initial guesses of states.\n\n    &gt; **max_episode:** `int`\n        -- The number of episodes.\n\n    &gt; **seed:** `int`\n        -- Random seed.\n\n    &gt; **eps:** `float`\n        -- Machine epsilon.\n\n    &gt; **load:** `bool`\n        -- Whether or not to load states in the current location.  \n        If set `True` then the program will load state from \"states.csv\"\n        file in the current location and use it as the initial state.\n    \"\"\"\n\n    def __init__(\n        self,\n        savefile=False,\n        psi0=[],\n        max_episode=300,\n        seed=1234,\n        eps=1e-8,\n        load=False,\n    ):\n\n        State.StateSystem.__init__(self, savefile, psi0, seed, eps, load)\n\n        self.max_episode = max_episode\n        self.seed = seed\n\n    def QFIM(self, W=[], LDtype=\"SLD\"):\n        r\"\"\"\n        Choose QFI as the objective function. \n\n        Parameters\n        ----------\n        &gt; **W:** `matrix`\n            -- Weight matrix.\n\n        &gt; **LDtype:** `string`\n            -- Types of QFI (QFIM) can be set as the objective function. Only SLD can\n            is available here.\n        \"\"\"\n        self.alg = QJL.RI(\n            self.max_episode,\n        )\n        if self.dynamics_type != \"Kraus\":\n            raise ValueError(\"Only the parameterization with Kraus operators is available.\")\n\n        if LDtype == \"SLD\":\n            super().QFIM(W, LDtype)\n        else:\n            raise ValueError(\"Only SLD is available.\")\n\n    def CFIM(self, M=[], W=[]):\n        \"\"\"\n        Choose CFIM as the objective function. \n\n        **Note:** CFIM is not available.\n\n        Parameters\n        ----------\n        &gt; **M:** `list`\n            -- POVM.\n\n        &gt; **W:** `matrix`\n            -- Weight matrix.\n        \"\"\"\n        raise ValueError(\"CFIM is not available.\")\n\n    def HCRB(self, W=[]):\n        \"\"\"\n        Choose HCRB as the objective function. \n\n        **Note:** Here HCRB is not available.\n\n        Parameters\n        ----------\n        &gt; **W:** `matrix`\n            -- Weight matrix.\n        \"\"\"\n        raise ValueError(\"HCRB is not available.\")\n</code></pre>"},{"location":"API/python/classes/#quanestimation.RI_Sopt.CFIM","title":"<code>CFIM(M=[], W=[])</code>","text":"<p>Choose CFIM as the objective function. </p> <p>Note: CFIM is not available.</p>"},{"location":"API/python/classes/#quanestimation.RI_Sopt.CFIM--parameters","title":"Parameters","text":"<p>M: <code>list</code>     -- POVM.</p> <p>W: <code>matrix</code>     -- Weight matrix.</p> Source code in <code>quanestimation/StateOpt/RI_Sopt.py</code> <pre><code>def CFIM(self, M=[], W=[]):\n    \"\"\"\n    Choose CFIM as the objective function. \n\n    **Note:** CFIM is not available.\n\n    Parameters\n    ----------\n    &gt; **M:** `list`\n        -- POVM.\n\n    &gt; **W:** `matrix`\n        -- Weight matrix.\n    \"\"\"\n    raise ValueError(\"CFIM is not available.\")\n</code></pre>"},{"location":"API/python/classes/#quanestimation.RI_Sopt.HCRB","title":"<code>HCRB(W=[])</code>","text":"<p>Choose HCRB as the objective function. </p> <p>Note: Here HCRB is not available.</p>"},{"location":"API/python/classes/#quanestimation.RI_Sopt.HCRB--parameters","title":"Parameters","text":"<p>W: <code>matrix</code>     -- Weight matrix.</p> Source code in <code>quanestimation/StateOpt/RI_Sopt.py</code> <pre><code>def HCRB(self, W=[]):\n    \"\"\"\n    Choose HCRB as the objective function. \n\n    **Note:** Here HCRB is not available.\n\n    Parameters\n    ----------\n    &gt; **W:** `matrix`\n        -- Weight matrix.\n    \"\"\"\n    raise ValueError(\"HCRB is not available.\")\n</code></pre>"},{"location":"API/python/classes/#quanestimation.RI_Sopt.QFIM","title":"<code>QFIM(W=[], LDtype='SLD')</code>","text":"<p>Choose QFI as the objective function. </p>"},{"location":"API/python/classes/#quanestimation.RI_Sopt.QFIM--parameters","title":"Parameters","text":"<p>W: <code>matrix</code>     -- Weight matrix.</p> <p>LDtype: <code>string</code>     -- Types of QFI (QFIM) can be set as the objective function. Only SLD can     is available here.</p> Source code in <code>quanestimation/StateOpt/RI_Sopt.py</code> <pre><code>def QFIM(self, W=[], LDtype=\"SLD\"):\n    r\"\"\"\n    Choose QFI as the objective function. \n\n    Parameters\n    ----------\n    &gt; **W:** `matrix`\n        -- Weight matrix.\n\n    &gt; **LDtype:** `string`\n        -- Types of QFI (QFIM) can be set as the objective function. Only SLD can\n        is available here.\n    \"\"\"\n    self.alg = QJL.RI(\n        self.max_episode,\n    )\n    if self.dynamics_type != \"Kraus\":\n        raise ValueError(\"Only the parameterization with Kraus operators is available.\")\n\n    if LDtype == \"SLD\":\n        super().QFIM(W, LDtype)\n    else:\n        raise ValueError(\"Only SLD is available.\")\n</code></pre>"},{"location":"API/python/classes/#state-optimization-with-pso","title":"State Optimization with PSO","text":"<p>             Bases: <code>StateSystem</code></p>"},{"location":"API/python/classes/#quanestimation.PSO_Sopt--attributes","title":"Attributes","text":"<p>savefile: <code>bool</code>     -- Whether or not to save all the states.     If set <code>True</code> then the states and the values of the objective function      obtained in all episodes will be saved during the training. If set <code>False</code>      the state in the final episode and the values of the objective function      in all episodes will be saved.</p> <p>p_num: <code>int</code>     -- The number of particles.</p> <p>psi0: <code>list of arrays</code>     -- Initial guesses of states.</p> <p>max_episode: <code>int or list</code>     -- If it is an integer, for example max_episode=1000, it means the      program will continuously run 1000 episodes. However, if it is an     array, for example max_episode=[1000,100], the program will run      1000 episodes in total but replace states of all  the particles      with global best every 100 episodes.</p> <p>c0: <code>float</code>     -- The damping factor that assists convergence, also known as inertia weight.</p> <p>c1: <code>float</code>     -- The exploitation weight that attracts the particle to its best previous      position, also known as cognitive learning factor.</p> <p>c2: <code>float</code>     -- The exploitation weight that attracts the particle to the best position     in the neighborhood, also known as social learning factor.</p> <p>seed: <code>int</code>     -- Random seed.</p> <p>eps: <code>float</code>     -- Machine epsilon.</p> <p>load: <code>bool</code>     -- Whether or not to load states in the current location.     If set <code>True</code> then the program will load state from \"states.csv\"     file in the current location and use it as the initial state.</p> Source code in <code>quanestimation/StateOpt/PSO_Sopt.py</code> <pre><code>class PSO_Sopt(State.StateSystem):\n    \"\"\"\n    Attributes\n    ----------\n    &gt; **savefile:**  `bool`\n        -- Whether or not to save all the states.  \n        If set `True` then the states and the values of the objective function \n        obtained in all episodes will be saved during the training. If set `False` \n        the state in the final episode and the values of the objective function \n        in all episodes will be saved.\n\n    &gt; **p_num:** `int`\n        -- The number of particles.\n\n    &gt; **psi0:** `list of arrays`\n        -- Initial guesses of states.\n\n    &gt; **max_episode:** `int or list`\n        -- If it is an integer, for example max_episode=1000, it means the \n        program will continuously run 1000 episodes. However, if it is an\n        array, for example max_episode=[1000,100], the program will run \n        1000 episodes in total but replace states of all  the particles \n        with global best every 100 episodes.\n\n    &gt; **c0:** `float`\n        -- The damping factor that assists convergence, also known as inertia weight.\n\n    &gt; **c1:** `float`\n        -- The exploitation weight that attracts the particle to its best previous \n        position, also known as cognitive learning factor.\n\n    &gt; **c2:** `float`\n        -- The exploitation weight that attracts the particle to the best position  \n        in the neighborhood, also known as social learning factor.\n\n    &gt; **seed:** `int`\n        -- Random seed.\n\n    &gt; **eps:** `float`\n        -- Machine epsilon.\n\n    &gt; **load:** `bool`\n        -- Whether or not to load states in the current location.\n        If set `True` then the program will load state from \"states.csv\"\n        file in the current location and use it as the initial state.\n    \"\"\"\n\n    def __init__(\n        self,\n        savefile=False,\n        p_num=10,\n        psi0=[],\n        max_episode=[1000, 100],\n        c0=1.0,\n        c1=2.0,\n        c2=2.0,\n        seed=1234,\n        eps=1e-8,\n        load=False,\n    ):\n\n        State.StateSystem.__init__(self, savefile, psi0, seed, eps, load)\n\n        \"\"\"\n        --------\n        inputs\n        --------\n        p_num:\n           --description: the number of particles.\n           --type: int\n\n        psi0:\n           --description: initial guesses of states (kets).\n           --type: array\n\n        max_episode:\n            --description: max number of the training episodes.\n            --type: int\n\n        c0:\n            --description: damping factor that assists convergence.\n            --type: float\n\n        c1:\n            --description: exploitation weight that attract the particle to its best \n            previous position.\n            --type: float\n\n        c2:\n            --description: exploitation weight that attract the particle to the best \n            position in the neighborhood.\n            --type: float\n\n        seed:\n            --description: random seed.\n            --type: int\n\n        \"\"\"\n\n        is_int = isinstance(max_episode, int)\n        self.max_episode = max_episode if is_int else QJL.Vector[QJL.Int64](max_episode)\n        self.p_num = p_num\n        self.c0 = c0\n        self.c1 = c1\n        self.c2 = c2\n        self.seed = seed\n\n    def QFIM(self, W=[], LDtype=\"SLD\"):\n        r\"\"\"\n        Choose QFI or $\\mathrm{Tr}(WF^{-1})$ as the objective function. \n        In single parameter estimation the objective function is QFI and in \n        multiparameter estimation it will be $\\mathrm{Tr}(WF^{-1})$.\n\n        Parameters\n        ----------\n        &gt; **W:** `matrix`\n            -- Weight matrix.\n\n        &gt; **LDtype:** `string`\n            -- Types of QFI (QFIM) can be set as the objective function. Options are:  \n            \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD).  \n            \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD).  \n            \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD).\n        \"\"\"\n        ini_particle = (self.psi,)\n        self.alg = QJL.PSO(\n            self.max_episode,\n            self.p_num,\n            ini_particle,\n            self.c0,\n            self.c1,\n            self.c2,\n        )\n\n        super().QFIM(W, LDtype)\n\n    def CFIM(self, M=[], W=[]):\n        r\"\"\"\n        Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. \n        In single parameter estimation the objective function is CFI and \n        in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$.\n\n        Parameters\n        ----------\n        &gt; **W:** `matrix`\n            -- Weight matrix.\n\n        &gt; **M:** `list of matrices`\n            -- A set of positive operator-valued measure (POVM). The default measurement \n            is a set of rank-one symmetric informationally complete POVM (SIC-POVM).\n\n        **Note:** \n            SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state \n            which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/\n            solutions.html).\n        \"\"\"\n        ini_particle = (self.psi,)\n        self.alg = QJL.PSO(\n            self.max_episode,\n            self.p_num,\n            ini_particle,\n            self.c0,\n            self.c1,\n            self.c2,\n        )\n\n        super().CFIM(M, W)\n\n    def HCRB(self, W=[]):\n        \"\"\"\n        Choose HCRB as the objective function. \n\n        **Note:** in single parameter estimation, HCRB is equivalent to QFI, please choose \n        QFI as the objective function.\n\n        Parameters\n        ----------\n        &gt; **W:** `matrix`\n            -- Weight matrix.\n        \"\"\"\n        ini_particle = (self.psi,)\n        self.alg = QJL.PSO(\n            self.max_episode,\n            self.p_num,\n            ini_particle,\n            self.c0,\n            self.c1,\n            self.c2,\n        )\n\n        super().HCRB(W)\n</code></pre>"},{"location":"API/python/classes/#quanestimation.PSO_Sopt.CFIM","title":"<code>CFIM(M=[], W=[])</code>","text":"<p>Choose CFI or \\(\\mathrm{Tr}(WI^{-1})\\) as the objective function.  In single parameter estimation the objective function is CFI and  in multiparameter estimation it will be \\(\\mathrm{Tr}(WI^{-1})\\).</p>"},{"location":"API/python/classes/#quanestimation.PSO_Sopt.CFIM--parameters","title":"Parameters","text":"<p>W: <code>matrix</code>     -- Weight matrix.</p> <p>M: <code>list of matrices</code>     -- A set of positive operator-valued measure (POVM). The default measurement      is a set of rank-one symmetric informationally complete POVM (SIC-POVM).</p> <p>Note:      SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state      which can be downloaded from here.</p> Source code in <code>quanestimation/StateOpt/PSO_Sopt.py</code> <pre><code>def CFIM(self, M=[], W=[]):\n    r\"\"\"\n    Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. \n    In single parameter estimation the objective function is CFI and \n    in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$.\n\n    Parameters\n    ----------\n    &gt; **W:** `matrix`\n        -- Weight matrix.\n\n    &gt; **M:** `list of matrices`\n        -- A set of positive operator-valued measure (POVM). The default measurement \n        is a set of rank-one symmetric informationally complete POVM (SIC-POVM).\n\n    **Note:** \n        SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state \n        which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/\n        solutions.html).\n    \"\"\"\n    ini_particle = (self.psi,)\n    self.alg = QJL.PSO(\n        self.max_episode,\n        self.p_num,\n        ini_particle,\n        self.c0,\n        self.c1,\n        self.c2,\n    )\n\n    super().CFIM(M, W)\n</code></pre>"},{"location":"API/python/classes/#quanestimation.PSO_Sopt.HCRB","title":"<code>HCRB(W=[])</code>","text":"<p>Choose HCRB as the objective function. </p> <p>Note: in single parameter estimation, HCRB is equivalent to QFI, please choose  QFI as the objective function.</p>"},{"location":"API/python/classes/#quanestimation.PSO_Sopt.HCRB--parameters","title":"Parameters","text":"<p>W: <code>matrix</code>     -- Weight matrix.</p> Source code in <code>quanestimation/StateOpt/PSO_Sopt.py</code> <pre><code>def HCRB(self, W=[]):\n    \"\"\"\n    Choose HCRB as the objective function. \n\n    **Note:** in single parameter estimation, HCRB is equivalent to QFI, please choose \n    QFI as the objective function.\n\n    Parameters\n    ----------\n    &gt; **W:** `matrix`\n        -- Weight matrix.\n    \"\"\"\n    ini_particle = (self.psi,)\n    self.alg = QJL.PSO(\n        self.max_episode,\n        self.p_num,\n        ini_particle,\n        self.c0,\n        self.c1,\n        self.c2,\n    )\n\n    super().HCRB(W)\n</code></pre>"},{"location":"API/python/classes/#quanestimation.PSO_Sopt.QFIM","title":"<code>QFIM(W=[], LDtype='SLD')</code>","text":"<p>Choose QFI or \\(\\mathrm{Tr}(WF^{-1})\\) as the objective function.  In single parameter estimation the objective function is QFI and in  multiparameter estimation it will be \\(\\mathrm{Tr}(WF^{-1})\\).</p>"},{"location":"API/python/classes/#quanestimation.PSO_Sopt.QFIM--parameters","title":"Parameters","text":"<p>W: <code>matrix</code>     -- Weight matrix.</p> <p>LDtype: <code>string</code>     -- Types of QFI (QFIM) can be set as the objective function. Options are:     \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD).     \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD).     \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD).</p> Source code in <code>quanestimation/StateOpt/PSO_Sopt.py</code> <pre><code>def QFIM(self, W=[], LDtype=\"SLD\"):\n    r\"\"\"\n    Choose QFI or $\\mathrm{Tr}(WF^{-1})$ as the objective function. \n    In single parameter estimation the objective function is QFI and in \n    multiparameter estimation it will be $\\mathrm{Tr}(WF^{-1})$.\n\n    Parameters\n    ----------\n    &gt; **W:** `matrix`\n        -- Weight matrix.\n\n    &gt; **LDtype:** `string`\n        -- Types of QFI (QFIM) can be set as the objective function. Options are:  \n        \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD).  \n        \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD).  \n        \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD).\n    \"\"\"\n    ini_particle = (self.psi,)\n    self.alg = QJL.PSO(\n        self.max_episode,\n        self.p_num,\n        ini_particle,\n        self.c0,\n        self.c1,\n        self.c2,\n    )\n\n    super().QFIM(W, LDtype)\n</code></pre>"},{"location":"API/python/classes/#state-optimization-de","title":"State Optimization DE","text":"<p>             Bases: <code>StateSystem</code></p>"},{"location":"API/python/classes/#quanestimation.DE_Sopt--attributes","title":"Attributes","text":"<p>savefile: <code>bool</code>     -- Whether or not to save all the states.     If set <code>True</code> then the states and the values of the      objective function obtained in all episodes will be saved during      the training. If set <code>False</code> the state in the final      episode and the values of the objective function in all episodes      will be saved.</p> <p>p_num: <code>int</code>     -- The number of populations.</p> <p>psi0: <code>list of arrays</code>     -- Initial guesses of states.</p> <p>max_episode: <code>int</code>     -- The number of episodes.</p> <p>c: <code>float</code>     -- Mutation constant.</p> <p>cr: <code>float</code>     -- Crossover constant.</p> <p>seed: <code>int</code>     -- Random seed.</p> <p>eps: <code>float</code>     -- Machine epsilon.</p> <p>load: <code>bool</code>     -- Whether or not to load states in the current location.     If set <code>True</code> then the program will load state from \"states.csv\"     file in the current location and use it as the initial state.</p> Source code in <code>quanestimation/StateOpt/DE_Sopt.py</code> <pre><code>class DE_Sopt(State.StateSystem):\n    \"\"\"\n    Attributes\n    ----------\n    &gt; **savefile:**  `bool`\n        -- Whether or not to save all the states.  \n        If set `True` then the states and the values of the \n        objective function obtained in all episodes will be saved during \n        the training. If set `False` the state in the final \n        episode and the values of the objective function in all episodes \n        will be saved.\n\n    &gt; **p_num:** `int`\n        -- The number of populations.\n\n    &gt; **psi0:** `list of arrays`\n        -- Initial guesses of states.\n\n    &gt; **max_episode:** `int`\n        -- The number of episodes.\n\n    &gt; **c:** `float`\n        -- Mutation constant.\n\n    &gt; **cr:** `float`\n        -- Crossover constant.\n\n    &gt; **seed:** `int`\n        -- Random seed.\n\n    &gt; **eps:** `float`\n        -- Machine epsilon.\n\n    &gt; **load:** `bool`\n        -- Whether or not to load states in the current location.  \n        If set `True` then the program will load state from \"states.csv\"\n        file in the current location and use it as the initial state.\n    \"\"\"\n\n    def __init__(\n        self,\n        savefile=False,\n        p_num=10,\n        psi0=[],\n        max_episode=1000,\n        c=1.0,\n        cr=0.5,\n        seed=1234,\n        eps=1e-8,\n        load=False,\n    ):\n\n        State.StateSystem.__init__(self, savefile, psi0, seed, eps, load)\n\n        self.p_num = p_num\n        self.max_episode = max_episode\n        self.c = c\n        self.cr = cr\n        self.seed = seed\n\n    def QFIM(self, W=[], LDtype=\"SLD\"):\n        r\"\"\"\n        Choose QFI or $\\mathrm{Tr}(WF^{-1})$ as the objective function. \n        In single parameter estimation the objective function is QFI and in \n        multiparameter estimation it will be $\\mathrm{Tr}(WF^{-1})$.\n\n        Parameters\n        ----------\n        &gt; **W:** `matrix`\n            -- Weight matrix.\n\n        &gt; **LDtype:** `string`\n            -- Types of QFI (QFIM) can be set as the objective function. Options are:  \n            \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD).  \n            \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD).  \n            \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD).\n        \"\"\"\n        ini_population = (self.psi,)\n        self.alg = QJL.DE(\n            self.max_episode,\n            self.p_num,\n            ini_population,\n            self.c,\n            self.cr,\n        )\n        super().QFIM(W, LDtype)\n\n    def CFIM(self, M=[], W=[]):\n        r\"\"\"\n        Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. \n        In single parameter estimation the objective function is CFI and \n        in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$.\n\n        Parameters\n        ----------\n        &gt; **W:** `matrix`\n            -- Weight matrix.\n\n        &gt; **M:** `list of matrices`\n            -- A set of positive operator-valued measure (POVM). The default measurement \n            is a set of rank-one symmetric informationally complete POVM (SIC-POVM).\n\n        **Note:** \n            SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state \n            which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/\n            solutions.html).\n        \"\"\"\n        ini_population = (self.psi,)\n        self.alg = QJL.DE(\n            self.max_episode,\n            self.p_num,\n            ini_population,\n            self.c,\n            self.cr,\n        )\n        super().CFIM(M, W)\n\n    def HCRB(self, W=[]):\n        \"\"\"\n        Choose HCRB as the objective function. \n\n        **Note:** in single parameter estimation, HCRB is equivalent to QFI, please choose \n        QFI as the objective function.\n\n        Parameters\n        ----------\n        &gt; **W:** `matrix`\n            -- Weight matrix.\n        \"\"\"\n        ini_population = (self.psi,)\n        self.alg = QJL.DE(\n            self.max_episode,\n            self.p_num,\n            ini_population,\n            self.c,\n            self.cr,\n        )\n        super().HCRB(W)\n</code></pre>"},{"location":"API/python/classes/#quanestimation.DE_Sopt.CFIM","title":"<code>CFIM(M=[], W=[])</code>","text":"<p>Choose CFI or \\(\\mathrm{Tr}(WI^{-1})\\) as the objective function.  In single parameter estimation the objective function is CFI and  in multiparameter estimation it will be \\(\\mathrm{Tr}(WI^{-1})\\).</p>"},{"location":"API/python/classes/#quanestimation.DE_Sopt.CFIM--parameters","title":"Parameters","text":"<p>W: <code>matrix</code>     -- Weight matrix.</p> <p>M: <code>list of matrices</code>     -- A set of positive operator-valued measure (POVM). The default measurement      is a set of rank-one symmetric informationally complete POVM (SIC-POVM).</p> <p>Note:      SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state      which can be downloaded from here.</p> Source code in <code>quanestimation/StateOpt/DE_Sopt.py</code> <pre><code>def CFIM(self, M=[], W=[]):\n    r\"\"\"\n    Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. \n    In single parameter estimation the objective function is CFI and \n    in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$.\n\n    Parameters\n    ----------\n    &gt; **W:** `matrix`\n        -- Weight matrix.\n\n    &gt; **M:** `list of matrices`\n        -- A set of positive operator-valued measure (POVM). The default measurement \n        is a set of rank-one symmetric informationally complete POVM (SIC-POVM).\n\n    **Note:** \n        SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state \n        which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/\n        solutions.html).\n    \"\"\"\n    ini_population = (self.psi,)\n    self.alg = QJL.DE(\n        self.max_episode,\n        self.p_num,\n        ini_population,\n        self.c,\n        self.cr,\n    )\n    super().CFIM(M, W)\n</code></pre>"},{"location":"API/python/classes/#quanestimation.DE_Sopt.HCRB","title":"<code>HCRB(W=[])</code>","text":"<p>Choose HCRB as the objective function. </p> <p>Note: in single parameter estimation, HCRB is equivalent to QFI, please choose  QFI as the objective function.</p>"},{"location":"API/python/classes/#quanestimation.DE_Sopt.HCRB--parameters","title":"Parameters","text":"<p>W: <code>matrix</code>     -- Weight matrix.</p> Source code in <code>quanestimation/StateOpt/DE_Sopt.py</code> <pre><code>def HCRB(self, W=[]):\n    \"\"\"\n    Choose HCRB as the objective function. \n\n    **Note:** in single parameter estimation, HCRB is equivalent to QFI, please choose \n    QFI as the objective function.\n\n    Parameters\n    ----------\n    &gt; **W:** `matrix`\n        -- Weight matrix.\n    \"\"\"\n    ini_population = (self.psi,)\n    self.alg = QJL.DE(\n        self.max_episode,\n        self.p_num,\n        ini_population,\n        self.c,\n        self.cr,\n    )\n    super().HCRB(W)\n</code></pre>"},{"location":"API/python/classes/#quanestimation.DE_Sopt.QFIM","title":"<code>QFIM(W=[], LDtype='SLD')</code>","text":"<p>Choose QFI or \\(\\mathrm{Tr}(WF^{-1})\\) as the objective function.  In single parameter estimation the objective function is QFI and in  multiparameter estimation it will be \\(\\mathrm{Tr}(WF^{-1})\\).</p>"},{"location":"API/python/classes/#quanestimation.DE_Sopt.QFIM--parameters","title":"Parameters","text":"<p>W: <code>matrix</code>     -- Weight matrix.</p> <p>LDtype: <code>string</code>     -- Types of QFI (QFIM) can be set as the objective function. Options are:     \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD).     \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD).     \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD).</p> Source code in <code>quanestimation/StateOpt/DE_Sopt.py</code> <pre><code>def QFIM(self, W=[], LDtype=\"SLD\"):\n    r\"\"\"\n    Choose QFI or $\\mathrm{Tr}(WF^{-1})$ as the objective function. \n    In single parameter estimation the objective function is QFI and in \n    multiparameter estimation it will be $\\mathrm{Tr}(WF^{-1})$.\n\n    Parameters\n    ----------\n    &gt; **W:** `matrix`\n        -- Weight matrix.\n\n    &gt; **LDtype:** `string`\n        -- Types of QFI (QFIM) can be set as the objective function. Options are:  \n        \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD).  \n        \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD).  \n        \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD).\n    \"\"\"\n    ini_population = (self.psi,)\n    self.alg = QJL.DE(\n        self.max_episode,\n        self.p_num,\n        ini_population,\n        self.c,\n        self.cr,\n    )\n    super().QFIM(W, LDtype)\n</code></pre>"},{"location":"API/python/classes/#measurement-optimization","title":"Measurement Optimization","text":"<p>In QuanEstimation, three measurement optimization scenarios are considered. The first one is to optimize a set of rank-one projective measurement, it can be written in a specific basis \\(\\{|\\phi_i\\rangle\\}\\) with \\(|\\phi_i\\rangle=\\sum_j C_{ij}|j\\rangle\\) in the Hilbert space  as \\(\\{|\\phi_i\\rangle\\langle\\phi_i|\\}\\). In this case, the goal is to search a set of optimal  coefficients \\(C_{ij}\\). The second scenario is to find the optimal linear combination of  an input measurement \\(\\{\\Pi_j\\}\\). The third scenario is to find the optimal rotated  measurement of an input measurement. After rotation, the new measurement is \\(\\{U\\Pi_i U^{\\dagger}\\}\\), where \\(U=\\prod_k \\exp(i s_k\\lambda_k)\\) with \\(\\lambda_k\\) a SU(\\(N\\))  generator and \\(s_k\\) a real number in the regime \\([0,2\\pi]\\). In this scenario, the goal is  to search a set of optimal coefficients \\(s_k\\). Here different algorithms are invoked to  search the optimal measurement include particle swarm optimization (PSO) [1],  differential evolution (DE) [2], and automatic differentiation (AD) [[3]] (#Baydin2018).</p>"},{"location":"API/python/classes/#base_2","title":"Base","text":"<p>Attributes</p> <p>mtype: <code>string</code>      -- The type of scenarios for the measurement optimization. Options are:      \"projection\" (default) -- Optimization of rank-one projective measurements.      \"input\" -- Find the optimal linear combination or the optimal rotated measurement       of a given set of POVM.</p> <p>minput: <code>list</code>      -- In the case of optimization of rank-one projective measurements, the       <code>minput</code> should keep empty. For finding the optimal linear combination and       the optimal rotated measurement of a given set of POVM, the input rule are       <code>minput=[\"LC\", [Pi1,Pi2,...], m]</code> and <code>minput=[\"LC\", [Pi1,Pi2,...]]</code> respectively.      Here <code>[Pi1,Pi2,...]</code> represents a list of input POVM and <code>m</code> is the number of operators       of the output measurement. </p> <p>savefile: <code>bool</code>      -- Whether or not to save all the measurements.      If set <code>True</code> then the measurements and the values of the       objective function obtained in all episodes will be saved during       the training. If set <code>False</code> the measurement in the final       episode and the values of the objective function in all episodes       will be saved.</p> <p>measurement0: <code>list of arrays</code>      -- Initial guesses of measurements.</p> <p>seed: <code>int</code>      -- Random seed.</p> <p>eps: <code>float</code>      -- Machine epsilon.</p> <p>load: <code>bool</code>      -- Whether or not to load measurements in the current location.      If set <code>True</code> then the program will load measurement from \"measurements.csv\"      file in the current location and use it as the initial measurement.</p> <p>dyn_method: <code>string</code>      -- The method for solving the Lindblad dynamcs. Options are:      \"expm\" (default) -- matrix exponential.      \"ode\" -- ordinary differential equation solvers.</p> Source code in <code>quanestimation/MeasurementOpt/MeasurementStruct.py</code> <pre><code>class MeasurementSystem:\n    \"\"\"\n    Attributes\n    ----------\n    &gt; **mtype:** `string`\n        -- The type of scenarios for the measurement optimization. Options are:  \n        \"projection\" (default) -- Optimization of rank-one projective measurements.  \n        \"input\" -- Find the optimal linear combination or the optimal rotated measurement \n        of a given set of POVM.\n\n    &gt; **minput:** `list`\n        -- In the case of optimization of rank-one projective measurements, the \n        `minput` should keep empty. For finding the optimal linear combination and \n        the optimal rotated measurement of a given set of POVM, the input rule are \n        `minput=[\"LC\", [Pi1,Pi2,...], m]` and `minput=[\"LC\", [Pi1,Pi2,...]]` respectively.\n        Here `[Pi1,Pi2,...]` represents a list of input POVM and `m` is the number of operators \n        of the output measurement. \n\n    &gt; **savefile:** `bool`\n        -- Whether or not to save all the measurements.  \n        If set `True` then the measurements and the values of the \n        objective function obtained in all episodes will be saved during \n        the training. If set `False` the measurement in the final \n        episode and the values of the objective function in all episodes \n        will be saved.\n\n   &gt; **measurement0:** `list of arrays`\n        -- Initial guesses of measurements.\n\n    &gt; **seed:** `int`\n        -- Random seed.\n\n    &gt; **eps:** `float`\n        -- Machine epsilon.\n\n    &gt; **load:** `bool`\n        -- Whether or not to load measurements in the current location.  \n        If set `True` then the program will load measurement from \"measurements.csv\"\n        file in the current location and use it as the initial measurement.\n\n    &gt; **dyn_method:** `string`\n        -- The method for solving the Lindblad dynamcs. Options are:\n        \"expm\" (default) -- matrix exponential.\n        \"ode\" -- ordinary differential equation solvers.  \n    \"\"\"\n\n    def __init__(self, mtype, minput, savefile, measurement0, seed, eps, load):\n\n        self.mtype = mtype\n        self.minput = minput\n        self.savefile = savefile\n        self.eps = eps\n        self.seed = seed\n        self.load = load\n        self.measurement0 = measurement0\n\n    def load_save(self, mnum, max_episode):\n        if os.path.exists(\"measurements.dat\"):\n            fl = h5py.File(\"measurements.dat\",'r')\n            dset = fl[\"measurements\"]\n            if self.savefile:\n                mdata = np.array([[np.array(fl[fl[dset[i]][j]]).view('complex') for j in range(mnum)] for i in range(max_episode)])\n            else:\n                mdata = np.array([np.array(fl[dset[j]]).view('complex') for j in range(mnum)])\n            np.save(\"measurements\", mdata)\n        else: pass\n\n    def dynamics(self, tspan, rho0, H0, dH, Hc=[], ctrl=[], decay=[], dyn_method=\"expm\"):\n        r\"\"\"\n        The dynamics of a density matrix is of the form  \n\n        \\begin{align}\n        \\partial_t\\rho &amp;=\\mathcal{L}\\rho \\nonumber \\\\\n        &amp;=-i[H,\\rho]+\\sum_i \\gamma_i\\left(\\Gamma_i\\rho\\Gamma^{\\dagger}_i-\\frac{1}{2}\n        \\left\\{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\right\\}\\right),\n        \\end{align} \n\n        where $\\rho$ is the evolved density matrix, H is the Hamiltonian of the \n        system, $\\Gamma_i$ and $\\gamma_i$ are the $i\\mathrm{th}$ decay \n        operator and corresponding decay rate.\n\n        Parameters\n        ----------\n        &gt; **tspan:** `array`\n            -- Time length for the evolution.\n\n        &gt; **rho0:** `matrix`\n            -- Initial state (density matrix).\n\n        &gt; **H0:** `matrix or list`\n            -- Free Hamiltonian. It is a matrix when the free Hamiltonian is time-\n            independent and a list of length equal to `tspan` when it is time-dependent.\n\n        &gt; **dH:** `list`\n            -- Derivatives of the free Hamiltonian on the unknown parameters to be \n            estimated. For example, dH[0] is the derivative vector on the first \n            parameter.\n\n        &gt; **Hc:** `list`\n            -- Control Hamiltonians.\n\n        &gt; **ctrl:** `list of arrays`\n            -- Control coefficients.\n\n        &gt; **decay:** `list`\n            -- Decay operators and the corresponding decay rates. Its input rule is \n            decay=[[$\\Gamma_1$, $\\gamma_1$], [$\\Gamma_2$,$\\gamma_2$],...], where $\\Gamma_1$ \n            $(\\Gamma_2)$ represents the decay operator and $\\gamma_1$ $(\\gamma_2)$ is the \n            corresponding decay rate.\n\n        &gt; **dyn_method:** `string`\n            -- Setting the method for solving the Lindblad dynamics. Options are:  \n            \"expm\" (default) -- Matrix exponential.  \n            \"ode\" -- Solving the differential equations directly.\n        \"\"\"\n\n        self.tspan = tspan\n        self.rho0 = np.array(rho0, dtype=np.complex128)\n\n        self.dynamics_type = \"dynamics\"\n\n        if len(dH) == 1:\n            self.para_type = \"single_para\"\n        else:\n            self.para_type = \"multi_para\"\n\n        if dyn_method == \"expm\":\n            self.dyn_method = \"Expm\"\n        elif dyn_method == \"ode\":\n            self.dyn_method = \"Ode\"\n\n        if self.mtype == \"projection\":\n            self.M_num = len(self.rho0)\n            QJLType_C = QJL.Vector[QJL.Vector[QJL.ComplexF64]]\n\n            if self.measurement0 == []:\n                np.random.seed(self.seed)\n                M = [[] for i in range(len(self.rho0))]\n                for i in range(len(self.rho0)):\n                    r_ini = 2 * np.random.random(len(self.rho0)) - np.ones(\n                        len(self.rho0)\n                    )\n                    r = r_ini / np.linalg.norm(r_ini)\n                    phi = 2 * np.pi * np.random.random(len(self.rho0))\n                    M[i] = [r[j] * np.exp(1.0j * phi[j]) for j in range(len(self.rho0))]\n                self.C = QJL.convert(QJLType_C, gramschmidt(np.array(M)))\n                self.measurement0 = QJL.Vector([self.C])\n            else:\n                self.C = [self.measurement0[0][i] for i in range(len(self.rho0))]\n                self.C = QJL.convert(QJLType_C, self.C)\n                self.measurement0 = QJL.Vector([self.C])\n            self.opt = QJL.Mopt_Projection(M=self.C, seed=self.seed)\n\n        elif self.mtype == \"input\":\n            if self.minput[0] == \"LC\":\n                self.M_num = self.minput[2]\n                ## optimize the combination of a set of SIC-POVM\n                if self.minput[1] == []:\n                    file_path = os.path.join(\n                        os.path.dirname(os.path.dirname(__file__)),\n                        \"sic_fiducial_vectors/d%d.txt\" % (len(self.rho0)),\n                    )\n                    data = np.loadtxt(file_path)\n                    fiducial = data[:, 0] + data[:, 1] * 1.0j\n                    fiducial = np.array(fiducial).reshape(len(fiducial), 1)\n                    self.povm_basis = sic_povm(fiducial)\n                else:\n                    ## optimize the combination of a set of given POVMs\n                    if type(self.minput[1]) != list:\n                        raise TypeError(\"The given POVMs should be a list!\")\n                    else:\n                        accu = len(str(int(1 / self.eps))) - 1\n                        for i in range(len(self.minput[1])):\n                            val, vec = np.linalg.eig(self.minput[1])\n                            if np.all(val.round(accu) &gt;= 0):\n                                pass\n                            else:\n                                raise TypeError(\n                                    \"The given POVMs should be semidefinite!\"\n                                )\n                        M = np.zeros(\n                            (len(self.rho0), len(self.rho0)), dtype=np.complex128\n                        )\n                        for i in range(len(self.minput[1])):\n                            M += self.minput[1][i]\n                        if np.all(M.round(accu) - np.identity(len(self.rho0)) == 0):\n                            pass\n                        else:\n                            raise TypeError(\n                                \"The sum of the given POVMs should be identity matrix!\"\n                            )\n                        self.povm_basis = [\n                            np.array(x, dtype=np.complex128) for x in self.minput[1]\n                        ]\n\n                if self.measurement0 == []:\n                    np.random.seed(self.seed)\n                    self.B = [\n                        np.random.random(len(self.povm_basis))\n                        for i in range(self.M_num)\n                    ]\n                    self.measurement0 = [self.B]\n                elif len(self.measurement0) &gt;= 1:\n                    self.B = [self.measurement0[0][i] for i in range(self.M_num)]\n                    self.measurement0 = [[m for m in m0] for m0 in self.measurement0]\n\n\n                QJLType_B = QJL.Vector[QJL.Vector[QJL.Float64]]\n                QJLType_pb = QJL.Vector[QJL.Matrix[QJL.ComplexF64]]\n                QJLType_m0 = QJL.Vector[QJL.Vector[QJL.Vector[QJL.ComplexF64]]]\n                self.B = QJL.convert(QJLType_B, self.B)\n                self.povm_basis = QJL.convert(QJLType_pb, self.povm_basis)\n                self.measurement0 = QJL.convert(QJLType_m0, self.measurement0)\n\n                self.opt = QJL.Mopt_LinearComb(\n                    B=self.B, POVM_basis=self.povm_basis, M_num=self.M_num, seed=self.seed\n                )\n\n            elif self.minput[0] == \"rotation\":\n                self.M_num = len(self.minput[1])\n                ## optimize the coefficients of the rotation matrix\n                if type(self.minput[1]) != list:\n                    raise TypeError(\"The given POVMs should be a list!\")\n                else:\n                    if self.minput[1] == []:\n                        raise TypeError(\"The initial POVM should not be empty!\")\n                    accu = len(str(int(1 / self.eps))) - 1\n                    for i in range(len(self.minput[1])):\n                        val, vec = np.linalg.eig(self.minput[1])\n                        if np.all(val.round(accu) &gt;= 0):\n                            pass\n                        else:\n                            raise TypeError(\"The given POVMs should be semidefinite!\")\n                    M = np.zeros((len(self.rho0), len(self.rho0)), dtype=np.complex128)\n                    for i in range(len(self.minput[1])):\n                        M += self.minput[1][i]\n                    if np.all(M.round(accu) - np.identity(len(self.rho0)) == 0):\n                        pass\n                    else:\n                        raise TypeError(\n                            \"The sum of the given POVMs should be identity matrix!\"\n                        )\n                    self.povm_basis = [\n                        np.array(x, dtype=np.complex128) for x in self.minput[1]\n                    ]\n                    self.mtype = \"rotation\"\n\n                if self.measurement0 == []:\n                    np.random.seed(self.seed)\n                    self.s = np.random.random(len(self.rho0) ** 2)\n                    self.measurement0 = [self.s]\n                elif len(self.measurement0) &gt;= 1:\n                    self.s = [\n                        self.measurement0[0][i]\n                        for i in range(len(self.rho0) * len(self.rho0))\n                    ]\n\n                self.s = QJL.Vector(self.s)\n                QJLType_pb = QJL.Vector[QJL.Matrix[QJL.ComplexF64]]\n                self.povm_basis = QJL.convert(QJLType_pb, self.povm_basis)\n                self.opt = QJL.Mopt_Rotation(\n                    s=self.s, POVM_basis=self.povm_basis, Lambda=[], seed=self.seed\n                )\n\n            else:\n                raise ValueError(\n                    \"{!r} is not a valid value for the first input of minput, supported values are 'LC' and 'rotation'.\".format(\n                        self.minput[0]\n                    )\n                )\n        else:\n            raise ValueError(\n                \"{!r} is not a valid value for mtype, supported values are 'projection' and 'input'.\".format(\n                    self.mtype\n                )\n            )\n\n        if Hc == [] or ctrl == []:\n            if type(H0) == np.ndarray:\n                self.freeHamiltonian = np.array(H0, dtype=np.complex128)\n            else:\n                self.freeHamiltonian = [np.array(x, dtype=np.complex128) for x in H0]\n        else:\n            ctrl_num = len(ctrl)\n            Hc_num = len(Hc)\n            if Hc_num &lt; ctrl_num:\n                raise TypeError(\n                    \"There are %d control Hamiltonians but %d coefficients sequences: too many coefficients sequences\"\n                    % (Hc_num, ctrl_num)\n                )\n            elif Hc_num &gt; ctrl_num:\n                warnings.warn(\n                    \"Not enough coefficients sequences: there are %d control Hamiltonians but %d coefficients sequences. The rest of the control sequences are set to be 0.\"\n                    % (Hc_num, ctrl_num),\n                    DeprecationWarning,\n                )\n                for i in range(Hc_num - ctrl_num):\n                    ctrl = np.concatenate((ctrl, np.zeros(len(ctrl[0]))))\n            else: pass\n\n            if len(ctrl[0]) == 1:\n                if type(H0) == np.ndarray:\n                    H0 = np.array(H0, dtype=np.complex128)\n                    Hc = [np.array(x, dtype=np.complex128) for x in Hc]\n                    Htot = H0 + sum([Hc[i] * ctrl[i][0] for i in range(ctrl_num)])\n                    self.freeHamiltonian = np.array(Htot, dtype=np.complex128)\n                else:\n                    H0 = [np.array(x, dtype=np.complex128) for x in H0]\n                    Htot = []\n                    for i in range(len(H0)):\n                        Htot.append(\n                            H0[i] + sum([Hc[i] * ctrl[i][0] for i in range(ctrl_num)])\n                        )\n                    self.freeHamiltonian = [\n                        np.array(x, dtype=np.complex128) for x in Htot\n                    ]\n            else:\n                if type(H0) != np.ndarray:\n                    #### linear interpolation  ####\n                    f = interp1d(self.tspan, H0, axis=0)\n                else: pass\n                number = math.ceil((len(self.tspan) - 1) / len(ctrl[0]))\n                if len(self.tspan) - 1 % len(ctrl[0]) != 0:\n                    tnum = number * len(ctrl[0])\n                    self.tspan = np.linspace(self.tspan[0], self.tspan[-1], tnum + 1)\n                    if type(H0) != np.ndarray:\n                        H0_inter = f(self.tspan)\n                        H0 = [np.array(x, dtype=np.complex128) for x in H0_inter]\n                    else: pass\n                else: pass\n\n                if type(H0) == np.ndarray:\n                    H0 = np.array(H0, dtype=np.complex128)\n                    Hc = [np.array(x, dtype=np.complex128) for x in Hc]\n                    ctrl = [np.array(ctrl[i]).repeat(number) for i in range(len(Hc))]\n                    Htot = []\n                    for i in range(len(ctrl[0])):\n                        S_ctrl = sum([Hc[j] * ctrl[j][i] for j in range(len(ctrl))])\n                        Htot.append(H0 + S_ctrl)\n                    self.freeHamiltonian = [\n                        np.array(x, dtype=np.complex128) for x in Htot\n                    ]\n                else:\n                    H0 = [np.array(x, dtype=np.complex128) for x in H0]\n                    Hc = [np.array(x, dtype=np.complex128) for x in Hc]\n                    ctrl = [np.array(ctrl[i]).repeat(number) for i in range(len(Hc))]\n                    Htot = []\n                    for i in range(len(ctrl[0])):\n                        S_ctrl = sum([Hc[j] * ctrl[j][i] for j in range(len(ctrl))])\n                        Htot.append(H0[i] + S_ctrl)\n                    self.freeHamiltonian = [\n                        np.array(x, dtype=np.complex128) for x in Htot\n                    ]\n\n        if type(dH) != list:\n            raise TypeError(\"The derivative of Hamiltonian should be a list!\")\n\n        if dH == []:\n            dH = [np.zeros((len(self.rho0), len(self.rho0)))]\n        self.Hamiltonian_derivative = [np.array(x, dtype=np.complex128) for x in dH]\n\n        if decay == []:\n            decay_opt = [np.zeros((len(self.rho0), len(self.rho0)))]\n            self.gamma = [0.0]\n        else:\n            decay_opt = [decay[i][0] for i in range(len(decay))]\n            self.gamma = [decay[i][1] for i in range(len(decay))]\n        self.decay_opt = [np.array(x, dtype=np.complex128) for x in decay_opt]\n\n        if any(self.gamma):\n            self.dynamic = QJL.Lindblad(\n                self.freeHamiltonian,\n                self.Hamiltonian_derivative,\n                self.rho0,\n                self.tspan,\n                self.decay_opt,\n                self.gamma,\n                dyn_method = self.dyn_method,\n            )\n        else:\n            self.dynamic = QJL.Lindblad(\n                self.freeHamiltonian,\n                self.Hamiltonian_derivative,\n                self.rho0,\n                self.tspan,\n                dyn_method = self.dyn_method,\n            )\n        self.output = QJL.Output(self.opt, save=self.savefile)\n\n        self.dynamics_type = \"dynamics\"\n\n\n    def Kraus(self, rho0, K, dK):\n        r\"\"\"\n        The parameterization of a state is\n        \\begin{align}\n        \\rho=\\sum_i K_i\\rho_0K_i^{\\dagger},\n        \\end{align} \n\n        where $\\rho$ is the evolved density matrix, $K_i$ is the Kraus operator.\n\n        Parameters\n        ----------\n        &gt; **rho0:** `matrix`\n            -- Initial state (density matrix).\n\n        &gt; **K:** `list`\n            -- Kraus operators.\n\n        &gt; **dK:** `list`\n            -- Derivatives of the Kraus operators on the unknown parameters to be \n            estimated. For example, dK[0] is the derivative vector on the first \n            parameter.\n        \"\"\"\n        k_num = len(K)\n        para_num = len(dK[0])\n        self.para_num = para_num\n        self.dK = [\n            [np.array(dK[i][j], dtype=np.complex128) for j in range(para_num)]\n            for i in range(k_num)\n        ]\n        self.rho0 = np.array(rho0, dtype=np.complex128)\n        self.K = [np.array(x, dtype=np.complex128) for x in K]\n\n        if para_num == 1:\n            self.para_type = \"single_para\"\n        else:\n            self.para_type = \"multi_para\"\n\n        if self.mtype == \"projection\":\n            self.M_num = len(self.rho0)\n            if self.measurement0 == []:\n                np.random.seed(self.seed)\n                M = [[] for i in range(len(self.rho0))]\n                for i in range(len(self.rho0)):\n                    r_ini = 2 * np.random.random(len(self.rho0)) - np.ones(\n                        len(self.rho0)\n                    )\n                    r = r_ini / np.linalg.norm(r_ini)\n                    phi = 2 * np.pi * np.random.random(len(self.rho0))\n                    M[i] = [r[j] * np.exp(1.0j * phi[j]) for j in range(len(self.rho0))]\n                self.C = gramschmidt(np.array(M))\n                self.measurement0 = [self.C]\n            else:\n                self.C = [self.measurement0[0][i] for i in range(len(self.rho0))]\n                self.C = [np.array(x, dtype=np.complex128) for x in self.C]\n            self.opt = QJL.Mopt_Projection(M=self.C, seed=self.seed)\n\n        elif self.mtype == \"input\":\n            if self.minput[0] == \"LC\":\n                self.M_num = self.minput[2]\n                ## optimize the combination of a set of SIC-POVM\n                if self.minput[1] == []:\n                    file_path = os.path.join(\n                        os.path.dirname(os.path.dirname(__file__)),\n                        \"sic_fiducial_vectors/d%d.txt\" % (len(self.rho0)),\n                    )\n                    data = np.loadtxt(file_path)\n                    fiducial = data[:, 0] + data[:, 1] * 1.0j\n                    fiducial = np.array(fiducial).reshape(len(fiducial), 1)\n                    self.povm_basis = sic_povm(fiducial)\n                else:\n                    ## optimize the combination of a set of given POVMs\n                    if type(self.minput[1]) != list:\n                        raise TypeError(\"The given POVMs should be a list!\")\n                    else:\n                        accu = len(str(int(1 / self.eps))) - 1\n                        for i in range(len(self.minput[1])):\n                            val, vec = np.linalg.eig(self.minput[1])\n                            if np.all(val.round(accu) &gt;= 0):\n                                pass\n                            else:\n                                raise TypeError(\n                                    \"The given POVMs should be semidefinite!\"\n                                )\n                        M = np.zeros(\n                            (len(self.rho0), len(self.rho0)), dtype=np.complex128\n                        )\n                        for i in range(len(self.minput[1])):\n                            M += self.minput[1][i]\n                        if np.all(M.round(accu) - np.identity(len(self.rho0)) == 0):\n                            pass\n                        else:\n                            raise TypeError(\n                                \"The sum of the given POVMs should be identity matrix!\"\n                            )\n                        self.povm_basis = [\n                            np.array(x, dtype=np.complex128) for x in self.minput[1]\n                        ]\n\n                if self.measurement0 == []:\n                    np.random.seed(self.seed)\n                    self.B = [\n                        np.random.random(len(self.povm_basis))\n                        for i in range(self.M_num)\n                    ]\n                    self.measurement0 = [np.array(self.B)]\n                elif len(self.measurement0) &gt;= 1:\n                    self.B = [\n                        self.measurement0[0][i] for i in range(len(self.povm_basis))\n                    ]\n                self.opt = QJL.Mopt_LinearComb(\n                    B=self.B, POVM_basis=self.povm_basis, M_num=self.M_num, seed=self.seed\n                )\n\n            elif self.minput[0] == \"rotation\":\n                self.M_num = len(self.minput[1])\n                ## optimize the coefficients of the rotation matrix\n                if type(self.minput[1]) != list:\n                    raise TypeError(\"The given POVMs should be a list!\")\n                else:\n                    if self.minput[1] == []:\n                        raise TypeError(\"The initial POVM should not be empty!\")\n                    accu = len(str(int(1 / self.eps))) - 1\n                    for i in range(len(self.minput[1])):\n                        val, vec = np.linalg.eig(self.minput[1])\n                        if np.all(val.round(accu) &gt;= 0):\n                            pass\n                        else:\n                            raise TypeError(\"The given POVMs should be semidefinite!\")\n                    M = np.zeros((len(self.rho0), len(self.rho0)), dtype=np.complex128)\n                    for i in range(len(self.minput[1])):\n                        M += self.minput[1][i]\n                    if np.all(M.round(accu) - np.identity(len(self.rho0)) == 0):\n                        pass\n                    else:\n                        raise TypeError(\n                            \"The sum of the given POVMs should be identity matrix!\"\n                        )\n                    self.povm_basis = [\n                        np.array(x, dtype=np.complex128) for x in self.minput[1]\n                    ]\n                    self.mtype = \"rotation\"\n\n                if self.measurement0 == []:\n                    np.random.seed(self.seed)\n                    self.s = np.random.random(len(self.rho0) ** 2)\n                    self.measurement0 = [self.s]\n                elif len(self.measurement0) &gt;= 1:\n                    self.s = [\n                        self.measurement0[0][i]\n                        for i in range(len(self.rho0) * len(self.rho0))\n                    ]\n\n                self.opt = QJL.Mopt_Rotation(\n                    s=self.s, POVM_basis=self.povm_basis, Lambda=[], seed=self.seed\n                )\n\n            else:\n                raise ValueError(\n                    \"{!r} is not a valid value for the first input of minput, supported values are 'LC' and 'rotation'.\".format(\n                        self.minput[0]\n                    )\n                )\n        else:\n            raise ValueError(\n                \"{!r} is not a valid value for mtype, supported values are 'projection' and 'input'.\".format(\n                    self.mtype\n                )\n            )\n\n        self.dynamic = QJL.Kraus(self.rho0, self.K, self.dK)\n        self.output = QJL.Output(self.opt, save=self.savefile)\n\n        self.dynamics_type = \"Kraus\"\n\n    def CFIM(self, W=[]):\n        r\"\"\"\n        Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. \n        In single parameter estimation the objective function is CFI and \n        in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$.\n\n        Parameters\n        ----------\n        &gt; **W:** `matrix`\n            -- Weight matrix.\n        \"\"\"\n\n        if self.dynamics_type == \"dynamics\":\n            if W == []:\n                W = np.eye(len(self.Hamiltonian_derivative))\n            self.W = W\n        elif self.dynamics_type == \"Kraus\":\n            if W == []:\n                W = np.eye(self.para_num)\n            self.W = W\n        else:\n            raise ValueError(\n                \"Supported type of dynamics are Lindblad and Kraus.\"\n                )\n\n        self.obj = QJL.CFIM_obj(\n            [], self.W, self.eps, self.para_type\n        )  #### m=[]\n        system = QJL.QuanEstSystem(\n            self.opt, self.alg, self.obj, self.dynamic, self.output\n        )\n        QJL.run(system)\n        max_num = self.max_episode if type(self.max_episode) == int else self.max_episode[0]\n        self.load_save(self.M_num, max_num)\n</code></pre>"},{"location":"API/python/classes/#quanestimation.MeasurementSystem.CFIM","title":"<code>CFIM(W=[])</code>","text":"<p>Choose CFI or \\(\\mathrm{Tr}(WI^{-1})\\) as the objective function.  In single parameter estimation the objective function is CFI and  in multiparameter estimation it will be \\(\\mathrm{Tr}(WI^{-1})\\).</p>"},{"location":"API/python/classes/#quanestimation.MeasurementSystem.CFIM--parameters","title":"Parameters","text":"<p>W: <code>matrix</code>     -- Weight matrix.</p> Source code in <code>quanestimation/MeasurementOpt/MeasurementStruct.py</code> <pre><code>def CFIM(self, W=[]):\n    r\"\"\"\n    Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. \n    In single parameter estimation the objective function is CFI and \n    in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$.\n\n    Parameters\n    ----------\n    &gt; **W:** `matrix`\n        -- Weight matrix.\n    \"\"\"\n\n    if self.dynamics_type == \"dynamics\":\n        if W == []:\n            W = np.eye(len(self.Hamiltonian_derivative))\n        self.W = W\n    elif self.dynamics_type == \"Kraus\":\n        if W == []:\n            W = np.eye(self.para_num)\n        self.W = W\n    else:\n        raise ValueError(\n            \"Supported type of dynamics are Lindblad and Kraus.\"\n            )\n\n    self.obj = QJL.CFIM_obj(\n        [], self.W, self.eps, self.para_type\n    )  #### m=[]\n    system = QJL.QuanEstSystem(\n        self.opt, self.alg, self.obj, self.dynamic, self.output\n    )\n    QJL.run(system)\n    max_num = self.max_episode if type(self.max_episode) == int else self.max_episode[0]\n    self.load_save(self.M_num, max_num)\n</code></pre>"},{"location":"API/python/classes/#quanestimation.MeasurementSystem.Kraus","title":"<code>Kraus(rho0, K, dK)</code>","text":"<p>The parameterization of a state is \\begin{align} \\rho=\\sum_i K_i\\rho_0K_i^{\\dagger}, \\end{align} </p> <p>where \\(\\rho\\) is the evolved density matrix, \\(K_i\\) is the Kraus operator.</p>"},{"location":"API/python/classes/#quanestimation.MeasurementSystem.Kraus--parameters","title":"Parameters","text":"<p>rho0: <code>matrix</code>     -- Initial state (density matrix).</p> <p>K: <code>list</code>     -- Kraus operators.</p> <p>dK: <code>list</code>     -- Derivatives of the Kraus operators on the unknown parameters to be      estimated. For example, dK[0] is the derivative vector on the first      parameter.</p> Source code in <code>quanestimation/MeasurementOpt/MeasurementStruct.py</code> <pre><code>def Kraus(self, rho0, K, dK):\n    r\"\"\"\n    The parameterization of a state is\n    \\begin{align}\n    \\rho=\\sum_i K_i\\rho_0K_i^{\\dagger},\n    \\end{align} \n\n    where $\\rho$ is the evolved density matrix, $K_i$ is the Kraus operator.\n\n    Parameters\n    ----------\n    &gt; **rho0:** `matrix`\n        -- Initial state (density matrix).\n\n    &gt; **K:** `list`\n        -- Kraus operators.\n\n    &gt; **dK:** `list`\n        -- Derivatives of the Kraus operators on the unknown parameters to be \n        estimated. For example, dK[0] is the derivative vector on the first \n        parameter.\n    \"\"\"\n    k_num = len(K)\n    para_num = len(dK[0])\n    self.para_num = para_num\n    self.dK = [\n        [np.array(dK[i][j], dtype=np.complex128) for j in range(para_num)]\n        for i in range(k_num)\n    ]\n    self.rho0 = np.array(rho0, dtype=np.complex128)\n    self.K = [np.array(x, dtype=np.complex128) for x in K]\n\n    if para_num == 1:\n        self.para_type = \"single_para\"\n    else:\n        self.para_type = \"multi_para\"\n\n    if self.mtype == \"projection\":\n        self.M_num = len(self.rho0)\n        if self.measurement0 == []:\n            np.random.seed(self.seed)\n            M = [[] for i in range(len(self.rho0))]\n            for i in range(len(self.rho0)):\n                r_ini = 2 * np.random.random(len(self.rho0)) - np.ones(\n                    len(self.rho0)\n                )\n                r = r_ini / np.linalg.norm(r_ini)\n                phi = 2 * np.pi * np.random.random(len(self.rho0))\n                M[i] = [r[j] * np.exp(1.0j * phi[j]) for j in range(len(self.rho0))]\n            self.C = gramschmidt(np.array(M))\n            self.measurement0 = [self.C]\n        else:\n            self.C = [self.measurement0[0][i] for i in range(len(self.rho0))]\n            self.C = [np.array(x, dtype=np.complex128) for x in self.C]\n        self.opt = QJL.Mopt_Projection(M=self.C, seed=self.seed)\n\n    elif self.mtype == \"input\":\n        if self.minput[0] == \"LC\":\n            self.M_num = self.minput[2]\n            ## optimize the combination of a set of SIC-POVM\n            if self.minput[1] == []:\n                file_path = os.path.join(\n                    os.path.dirname(os.path.dirname(__file__)),\n                    \"sic_fiducial_vectors/d%d.txt\" % (len(self.rho0)),\n                )\n                data = np.loadtxt(file_path)\n                fiducial = data[:, 0] + data[:, 1] * 1.0j\n                fiducial = np.array(fiducial).reshape(len(fiducial), 1)\n                self.povm_basis = sic_povm(fiducial)\n            else:\n                ## optimize the combination of a set of given POVMs\n                if type(self.minput[1]) != list:\n                    raise TypeError(\"The given POVMs should be a list!\")\n                else:\n                    accu = len(str(int(1 / self.eps))) - 1\n                    for i in range(len(self.minput[1])):\n                        val, vec = np.linalg.eig(self.minput[1])\n                        if np.all(val.round(accu) &gt;= 0):\n                            pass\n                        else:\n                            raise TypeError(\n                                \"The given POVMs should be semidefinite!\"\n                            )\n                    M = np.zeros(\n                        (len(self.rho0), len(self.rho0)), dtype=np.complex128\n                    )\n                    for i in range(len(self.minput[1])):\n                        M += self.minput[1][i]\n                    if np.all(M.round(accu) - np.identity(len(self.rho0)) == 0):\n                        pass\n                    else:\n                        raise TypeError(\n                            \"The sum of the given POVMs should be identity matrix!\"\n                        )\n                    self.povm_basis = [\n                        np.array(x, dtype=np.complex128) for x in self.minput[1]\n                    ]\n\n            if self.measurement0 == []:\n                np.random.seed(self.seed)\n                self.B = [\n                    np.random.random(len(self.povm_basis))\n                    for i in range(self.M_num)\n                ]\n                self.measurement0 = [np.array(self.B)]\n            elif len(self.measurement0) &gt;= 1:\n                self.B = [\n                    self.measurement0[0][i] for i in range(len(self.povm_basis))\n                ]\n            self.opt = QJL.Mopt_LinearComb(\n                B=self.B, POVM_basis=self.povm_basis, M_num=self.M_num, seed=self.seed\n            )\n\n        elif self.minput[0] == \"rotation\":\n            self.M_num = len(self.minput[1])\n            ## optimize the coefficients of the rotation matrix\n            if type(self.minput[1]) != list:\n                raise TypeError(\"The given POVMs should be a list!\")\n            else:\n                if self.minput[1] == []:\n                    raise TypeError(\"The initial POVM should not be empty!\")\n                accu = len(str(int(1 / self.eps))) - 1\n                for i in range(len(self.minput[1])):\n                    val, vec = np.linalg.eig(self.minput[1])\n                    if np.all(val.round(accu) &gt;= 0):\n                        pass\n                    else:\n                        raise TypeError(\"The given POVMs should be semidefinite!\")\n                M = np.zeros((len(self.rho0), len(self.rho0)), dtype=np.complex128)\n                for i in range(len(self.minput[1])):\n                    M += self.minput[1][i]\n                if np.all(M.round(accu) - np.identity(len(self.rho0)) == 0):\n                    pass\n                else:\n                    raise TypeError(\n                        \"The sum of the given POVMs should be identity matrix!\"\n                    )\n                self.povm_basis = [\n                    np.array(x, dtype=np.complex128) for x in self.minput[1]\n                ]\n                self.mtype = \"rotation\"\n\n            if self.measurement0 == []:\n                np.random.seed(self.seed)\n                self.s = np.random.random(len(self.rho0) ** 2)\n                self.measurement0 = [self.s]\n            elif len(self.measurement0) &gt;= 1:\n                self.s = [\n                    self.measurement0[0][i]\n                    for i in range(len(self.rho0) * len(self.rho0))\n                ]\n\n            self.opt = QJL.Mopt_Rotation(\n                s=self.s, POVM_basis=self.povm_basis, Lambda=[], seed=self.seed\n            )\n\n        else:\n            raise ValueError(\n                \"{!r} is not a valid value for the first input of minput, supported values are 'LC' and 'rotation'.\".format(\n                    self.minput[0]\n                )\n            )\n    else:\n        raise ValueError(\n            \"{!r} is not a valid value for mtype, supported values are 'projection' and 'input'.\".format(\n                self.mtype\n            )\n        )\n\n    self.dynamic = QJL.Kraus(self.rho0, self.K, self.dK)\n    self.output = QJL.Output(self.opt, save=self.savefile)\n\n    self.dynamics_type = \"Kraus\"\n</code></pre>"},{"location":"API/python/classes/#quanestimation.MeasurementSystem.dynamics","title":"<code>dynamics(tspan, rho0, H0, dH, Hc=[], ctrl=[], decay=[], dyn_method='expm')</code>","text":"<p>The dynamics of a density matrix is of the form  </p> \\[\\begin{align} \\partial_t\\rho &amp;=\\mathcal{L}\\rho \\nonumber \\\\ &amp;=-i[H,\\rho]+\\sum_i \\gamma_i\\left(\\Gamma_i\\rho\\Gamma^{\\dagger}_i-\\frac{1}{2} \\left\\{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\right\\}\\right), \\end{align}\\] <p>where \\(\\rho\\) is the evolved density matrix, H is the Hamiltonian of the  system, \\(\\Gamma_i\\) and \\(\\gamma_i\\) are the \\(i\\mathrm{th}\\) decay  operator and corresponding decay rate.</p>"},{"location":"API/python/classes/#quanestimation.MeasurementSystem.dynamics--parameters","title":"Parameters","text":"<p>tspan: <code>array</code>     -- Time length for the evolution.</p> <p>rho0: <code>matrix</code>     -- Initial state (density matrix).</p> <p>H0: <code>matrix or list</code>     -- Free Hamiltonian. It is a matrix when the free Hamiltonian is time-     independent and a list of length equal to <code>tspan</code> when it is time-dependent.</p> <p>dH: <code>list</code>     -- Derivatives of the free Hamiltonian on the unknown parameters to be      estimated. For example, dH[0] is the derivative vector on the first      parameter.</p> <p>Hc: <code>list</code>     -- Control Hamiltonians.</p> <p>ctrl: <code>list of arrays</code>     -- Control coefficients.</p> <p>decay: <code>list</code>     -- Decay operators and the corresponding decay rates. Its input rule is      decay=[[\\(\\Gamma_1\\), \\(\\gamma_1\\)], [\\(\\Gamma_2\\),\\(\\gamma_2\\)],...], where \\(\\Gamma_1\\) \\((\\Gamma_2)\\) represents the decay operator and \\(\\gamma_1\\) \\((\\gamma_2)\\) is the      corresponding decay rate.</p> <p>dyn_method: <code>string</code>     -- Setting the method for solving the Lindblad dynamics. Options are:     \"expm\" (default) -- Matrix exponential.     \"ode\" -- Solving the differential equations directly.</p> Source code in <code>quanestimation/MeasurementOpt/MeasurementStruct.py</code> <pre><code>def dynamics(self, tspan, rho0, H0, dH, Hc=[], ctrl=[], decay=[], dyn_method=\"expm\"):\n    r\"\"\"\n    The dynamics of a density matrix is of the form  \n\n    \\begin{align}\n    \\partial_t\\rho &amp;=\\mathcal{L}\\rho \\nonumber \\\\\n    &amp;=-i[H,\\rho]+\\sum_i \\gamma_i\\left(\\Gamma_i\\rho\\Gamma^{\\dagger}_i-\\frac{1}{2}\n    \\left\\{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\right\\}\\right),\n    \\end{align} \n\n    where $\\rho$ is the evolved density matrix, H is the Hamiltonian of the \n    system, $\\Gamma_i$ and $\\gamma_i$ are the $i\\mathrm{th}$ decay \n    operator and corresponding decay rate.\n\n    Parameters\n    ----------\n    &gt; **tspan:** `array`\n        -- Time length for the evolution.\n\n    &gt; **rho0:** `matrix`\n        -- Initial state (density matrix).\n\n    &gt; **H0:** `matrix or list`\n        -- Free Hamiltonian. It is a matrix when the free Hamiltonian is time-\n        independent and a list of length equal to `tspan` when it is time-dependent.\n\n    &gt; **dH:** `list`\n        -- Derivatives of the free Hamiltonian on the unknown parameters to be \n        estimated. For example, dH[0] is the derivative vector on the first \n        parameter.\n\n    &gt; **Hc:** `list`\n        -- Control Hamiltonians.\n\n    &gt; **ctrl:** `list of arrays`\n        -- Control coefficients.\n\n    &gt; **decay:** `list`\n        -- Decay operators and the corresponding decay rates. Its input rule is \n        decay=[[$\\Gamma_1$, $\\gamma_1$], [$\\Gamma_2$,$\\gamma_2$],...], where $\\Gamma_1$ \n        $(\\Gamma_2)$ represents the decay operator and $\\gamma_1$ $(\\gamma_2)$ is the \n        corresponding decay rate.\n\n    &gt; **dyn_method:** `string`\n        -- Setting the method for solving the Lindblad dynamics. Options are:  \n        \"expm\" (default) -- Matrix exponential.  \n        \"ode\" -- Solving the differential equations directly.\n    \"\"\"\n\n    self.tspan = tspan\n    self.rho0 = np.array(rho0, dtype=np.complex128)\n\n    self.dynamics_type = \"dynamics\"\n\n    if len(dH) == 1:\n        self.para_type = \"single_para\"\n    else:\n        self.para_type = \"multi_para\"\n\n    if dyn_method == \"expm\":\n        self.dyn_method = \"Expm\"\n    elif dyn_method == \"ode\":\n        self.dyn_method = \"Ode\"\n\n    if self.mtype == \"projection\":\n        self.M_num = len(self.rho0)\n        QJLType_C = QJL.Vector[QJL.Vector[QJL.ComplexF64]]\n\n        if self.measurement0 == []:\n            np.random.seed(self.seed)\n            M = [[] for i in range(len(self.rho0))]\n            for i in range(len(self.rho0)):\n                r_ini = 2 * np.random.random(len(self.rho0)) - np.ones(\n                    len(self.rho0)\n                )\n                r = r_ini / np.linalg.norm(r_ini)\n                phi = 2 * np.pi * np.random.random(len(self.rho0))\n                M[i] = [r[j] * np.exp(1.0j * phi[j]) for j in range(len(self.rho0))]\n            self.C = QJL.convert(QJLType_C, gramschmidt(np.array(M)))\n            self.measurement0 = QJL.Vector([self.C])\n        else:\n            self.C = [self.measurement0[0][i] for i in range(len(self.rho0))]\n            self.C = QJL.convert(QJLType_C, self.C)\n            self.measurement0 = QJL.Vector([self.C])\n        self.opt = QJL.Mopt_Projection(M=self.C, seed=self.seed)\n\n    elif self.mtype == \"input\":\n        if self.minput[0] == \"LC\":\n            self.M_num = self.minput[2]\n            ## optimize the combination of a set of SIC-POVM\n            if self.minput[1] == []:\n                file_path = os.path.join(\n                    os.path.dirname(os.path.dirname(__file__)),\n                    \"sic_fiducial_vectors/d%d.txt\" % (len(self.rho0)),\n                )\n                data = np.loadtxt(file_path)\n                fiducial = data[:, 0] + data[:, 1] * 1.0j\n                fiducial = np.array(fiducial).reshape(len(fiducial), 1)\n                self.povm_basis = sic_povm(fiducial)\n            else:\n                ## optimize the combination of a set of given POVMs\n                if type(self.minput[1]) != list:\n                    raise TypeError(\"The given POVMs should be a list!\")\n                else:\n                    accu = len(str(int(1 / self.eps))) - 1\n                    for i in range(len(self.minput[1])):\n                        val, vec = np.linalg.eig(self.minput[1])\n                        if np.all(val.round(accu) &gt;= 0):\n                            pass\n                        else:\n                            raise TypeError(\n                                \"The given POVMs should be semidefinite!\"\n                            )\n                    M = np.zeros(\n                        (len(self.rho0), len(self.rho0)), dtype=np.complex128\n                    )\n                    for i in range(len(self.minput[1])):\n                        M += self.minput[1][i]\n                    if np.all(M.round(accu) - np.identity(len(self.rho0)) == 0):\n                        pass\n                    else:\n                        raise TypeError(\n                            \"The sum of the given POVMs should be identity matrix!\"\n                        )\n                    self.povm_basis = [\n                        np.array(x, dtype=np.complex128) for x in self.minput[1]\n                    ]\n\n            if self.measurement0 == []:\n                np.random.seed(self.seed)\n                self.B = [\n                    np.random.random(len(self.povm_basis))\n                    for i in range(self.M_num)\n                ]\n                self.measurement0 = [self.B]\n            elif len(self.measurement0) &gt;= 1:\n                self.B = [self.measurement0[0][i] for i in range(self.M_num)]\n                self.measurement0 = [[m for m in m0] for m0 in self.measurement0]\n\n\n            QJLType_B = QJL.Vector[QJL.Vector[QJL.Float64]]\n            QJLType_pb = QJL.Vector[QJL.Matrix[QJL.ComplexF64]]\n            QJLType_m0 = QJL.Vector[QJL.Vector[QJL.Vector[QJL.ComplexF64]]]\n            self.B = QJL.convert(QJLType_B, self.B)\n            self.povm_basis = QJL.convert(QJLType_pb, self.povm_basis)\n            self.measurement0 = QJL.convert(QJLType_m0, self.measurement0)\n\n            self.opt = QJL.Mopt_LinearComb(\n                B=self.B, POVM_basis=self.povm_basis, M_num=self.M_num, seed=self.seed\n            )\n\n        elif self.minput[0] == \"rotation\":\n            self.M_num = len(self.minput[1])\n            ## optimize the coefficients of the rotation matrix\n            if type(self.minput[1]) != list:\n                raise TypeError(\"The given POVMs should be a list!\")\n            else:\n                if self.minput[1] == []:\n                    raise TypeError(\"The initial POVM should not be empty!\")\n                accu = len(str(int(1 / self.eps))) - 1\n                for i in range(len(self.minput[1])):\n                    val, vec = np.linalg.eig(self.minput[1])\n                    if np.all(val.round(accu) &gt;= 0):\n                        pass\n                    else:\n                        raise TypeError(\"The given POVMs should be semidefinite!\")\n                M = np.zeros((len(self.rho0), len(self.rho0)), dtype=np.complex128)\n                for i in range(len(self.minput[1])):\n                    M += self.minput[1][i]\n                if np.all(M.round(accu) - np.identity(len(self.rho0)) == 0):\n                    pass\n                else:\n                    raise TypeError(\n                        \"The sum of the given POVMs should be identity matrix!\"\n                    )\n                self.povm_basis = [\n                    np.array(x, dtype=np.complex128) for x in self.minput[1]\n                ]\n                self.mtype = \"rotation\"\n\n            if self.measurement0 == []:\n                np.random.seed(self.seed)\n                self.s = np.random.random(len(self.rho0) ** 2)\n                self.measurement0 = [self.s]\n            elif len(self.measurement0) &gt;= 1:\n                self.s = [\n                    self.measurement0[0][i]\n                    for i in range(len(self.rho0) * len(self.rho0))\n                ]\n\n            self.s = QJL.Vector(self.s)\n            QJLType_pb = QJL.Vector[QJL.Matrix[QJL.ComplexF64]]\n            self.povm_basis = QJL.convert(QJLType_pb, self.povm_basis)\n            self.opt = QJL.Mopt_Rotation(\n                s=self.s, POVM_basis=self.povm_basis, Lambda=[], seed=self.seed\n            )\n\n        else:\n            raise ValueError(\n                \"{!r} is not a valid value for the first input of minput, supported values are 'LC' and 'rotation'.\".format(\n                    self.minput[0]\n                )\n            )\n    else:\n        raise ValueError(\n            \"{!r} is not a valid value for mtype, supported values are 'projection' and 'input'.\".format(\n                self.mtype\n            )\n        )\n\n    if Hc == [] or ctrl == []:\n        if type(H0) == np.ndarray:\n            self.freeHamiltonian = np.array(H0, dtype=np.complex128)\n        else:\n            self.freeHamiltonian = [np.array(x, dtype=np.complex128) for x in H0]\n    else:\n        ctrl_num = len(ctrl)\n        Hc_num = len(Hc)\n        if Hc_num &lt; ctrl_num:\n            raise TypeError(\n                \"There are %d control Hamiltonians but %d coefficients sequences: too many coefficients sequences\"\n                % (Hc_num, ctrl_num)\n            )\n        elif Hc_num &gt; ctrl_num:\n            warnings.warn(\n                \"Not enough coefficients sequences: there are %d control Hamiltonians but %d coefficients sequences. The rest of the control sequences are set to be 0.\"\n                % (Hc_num, ctrl_num),\n                DeprecationWarning,\n            )\n            for i in range(Hc_num - ctrl_num):\n                ctrl = np.concatenate((ctrl, np.zeros(len(ctrl[0]))))\n        else: pass\n\n        if len(ctrl[0]) == 1:\n            if type(H0) == np.ndarray:\n                H0 = np.array(H0, dtype=np.complex128)\n                Hc = [np.array(x, dtype=np.complex128) for x in Hc]\n                Htot = H0 + sum([Hc[i] * ctrl[i][0] for i in range(ctrl_num)])\n                self.freeHamiltonian = np.array(Htot, dtype=np.complex128)\n            else:\n                H0 = [np.array(x, dtype=np.complex128) for x in H0]\n                Htot = []\n                for i in range(len(H0)):\n                    Htot.append(\n                        H0[i] + sum([Hc[i] * ctrl[i][0] for i in range(ctrl_num)])\n                    )\n                self.freeHamiltonian = [\n                    np.array(x, dtype=np.complex128) for x in Htot\n                ]\n        else:\n            if type(H0) != np.ndarray:\n                #### linear interpolation  ####\n                f = interp1d(self.tspan, H0, axis=0)\n            else: pass\n            number = math.ceil((len(self.tspan) - 1) / len(ctrl[0]))\n            if len(self.tspan) - 1 % len(ctrl[0]) != 0:\n                tnum = number * len(ctrl[0])\n                self.tspan = np.linspace(self.tspan[0], self.tspan[-1], tnum + 1)\n                if type(H0) != np.ndarray:\n                    H0_inter = f(self.tspan)\n                    H0 = [np.array(x, dtype=np.complex128) for x in H0_inter]\n                else: pass\n            else: pass\n\n            if type(H0) == np.ndarray:\n                H0 = np.array(H0, dtype=np.complex128)\n                Hc = [np.array(x, dtype=np.complex128) for x in Hc]\n                ctrl = [np.array(ctrl[i]).repeat(number) for i in range(len(Hc))]\n                Htot = []\n                for i in range(len(ctrl[0])):\n                    S_ctrl = sum([Hc[j] * ctrl[j][i] for j in range(len(ctrl))])\n                    Htot.append(H0 + S_ctrl)\n                self.freeHamiltonian = [\n                    np.array(x, dtype=np.complex128) for x in Htot\n                ]\n            else:\n                H0 = [np.array(x, dtype=np.complex128) for x in H0]\n                Hc = [np.array(x, dtype=np.complex128) for x in Hc]\n                ctrl = [np.array(ctrl[i]).repeat(number) for i in range(len(Hc))]\n                Htot = []\n                for i in range(len(ctrl[0])):\n                    S_ctrl = sum([Hc[j] * ctrl[j][i] for j in range(len(ctrl))])\n                    Htot.append(H0[i] + S_ctrl)\n                self.freeHamiltonian = [\n                    np.array(x, dtype=np.complex128) for x in Htot\n                ]\n\n    if type(dH) != list:\n        raise TypeError(\"The derivative of Hamiltonian should be a list!\")\n\n    if dH == []:\n        dH = [np.zeros((len(self.rho0), len(self.rho0)))]\n    self.Hamiltonian_derivative = [np.array(x, dtype=np.complex128) for x in dH]\n\n    if decay == []:\n        decay_opt = [np.zeros((len(self.rho0), len(self.rho0)))]\n        self.gamma = [0.0]\n    else:\n        decay_opt = [decay[i][0] for i in range(len(decay))]\n        self.gamma = [decay[i][1] for i in range(len(decay))]\n    self.decay_opt = [np.array(x, dtype=np.complex128) for x in decay_opt]\n\n    if any(self.gamma):\n        self.dynamic = QJL.Lindblad(\n            self.freeHamiltonian,\n            self.Hamiltonian_derivative,\n            self.rho0,\n            self.tspan,\n            self.decay_opt,\n            self.gamma,\n            dyn_method = self.dyn_method,\n        )\n    else:\n        self.dynamic = QJL.Lindblad(\n            self.freeHamiltonian,\n            self.Hamiltonian_derivative,\n            self.rho0,\n            self.tspan,\n            dyn_method = self.dyn_method,\n        )\n    self.output = QJL.Output(self.opt, save=self.savefile)\n\n    self.dynamics_type = \"dynamics\"\n</code></pre>"},{"location":"API/python/classes/#measurement-optimization-with-ad","title":"Measurement optimization with AD","text":"<p>             Bases: <code>MeasurementSystem</code></p>"},{"location":"API/python/classes/#quanestimation.AD_Mopt--attributes","title":"Attributes","text":"<p>savefile: <code>bool</code>     -- Whether or not to save all the measurements.     If set <code>True</code> then the measurements and the values of the      objective function obtained in all episodes will be saved during      the training. If set <code>False</code> the measurement in the final      episode and the values of the objective function in all episodes      will be saved.</p> <p>Adam: <code>bool</code>     -- Whether or not to use Adam for updating measurements.</p> <p>measurement0: <code>list of arrays</code>     -- Initial guesses of measurements.</p> <p>max_episode: <code>int</code>     -- The number of episodes.</p> <p>epsilon: <code>float</code>     -- Learning rate.</p> <p>beta1: <code>float</code>     -- The exponential decay rate for the first moment estimates.</p> <p>beta2: <code>float</code>     -- The exponential decay rate for the second moment estimates.</p> <p>eps: <code>float</code>     -- Machine epsilon.</p> <p>load: <code>bool</code>     -- Whether or not to load measurements in the current location.     If set <code>True</code> then the program will load measurement from \"measurements.csv\"     file in the current location and use it as the initial measurement.</p> Source code in <code>quanestimation/MeasurementOpt/AD_Mopt.py</code> <pre><code>class AD_Mopt(Measurement.MeasurementSystem):\n    \"\"\"\n    Attributes\n    ----------\n    &gt; **savefile:** `bool`\n        -- Whether or not to save all the measurements.  \n        If set `True` then the measurements and the values of the \n        objective function obtained in all episodes will be saved during \n        the training. If set `False` the measurement in the final \n        episode and the values of the objective function in all episodes \n        will be saved.\n\n    &gt; **Adam:** `bool`\n        -- Whether or not to use Adam for updating measurements.\n\n    &gt; **measurement0:** `list of arrays`\n        -- Initial guesses of measurements.\n\n    &gt; **max_episode:** `int`\n        -- The number of episodes.\n\n    &gt; **epsilon:** `float`\n        -- Learning rate.\n\n    &gt; **beta1:** `float`\n        -- The exponential decay rate for the first moment estimates.\n\n    &gt; **beta2:** `float`\n        -- The exponential decay rate for the second moment estimates.\n\n    &gt; **eps:** `float`\n        -- Machine epsilon.\n\n    &gt; **load:** `bool`\n        -- Whether or not to load measurements in the current location.  \n        If set `True` then the program will load measurement from \"measurements.csv\"\n        file in the current location and use it as the initial measurement.\n    \"\"\"\n\n    def __init__(\n        self,\n        mtype,\n        minput,\n        savefile=False,\n        Adam=False,\n        measurement0=[],\n        max_episode=300,\n        epsilon=0.01,\n        beta1=0.90,\n        beta2=0.99,\n        seed=1234,\n        eps=1e-8,\n        load=False,\n    ):\n\n        Measurement.MeasurementSystem.__init__(\n            self, mtype, minput, savefile, measurement0, seed, eps, load \n        )\n\n        self.Adam = Adam\n        self.max_episode = max_episode\n        self.epsilon = epsilon\n        self.beta1 = beta1\n        self.beta2 = beta2\n        self.mt = 0.0\n        self.vt = 0.0\n        self.seed = seed\n\n        if self.Adam:\n            self.alg = QJL.AD(\n                self.max_episode, self.epsilon, self.beta1, self.beta2\n            )\n        else:\n            self.alg = QJL.AD(self.max_episode, self.epsilon)\n\n    def CFIM(self, W=[]):\n        r\"\"\"\n        Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. \n        In single parameter estimation the objective function is CFI and \n        in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$.\n\n        Parameters\n        ----------\n        &gt; **W:** `matrix`\n            -- Weight matrix.\n        \"\"\"\n\n        if self.mtype == \"projection\":\n            raise ValueError(\n                \"AD is not available when mtype is projection. Supported methods are 'PSO' and 'DE'.\",\n            )\n        else:\n            super().CFIM(W)\n</code></pre>"},{"location":"API/python/classes/#quanestimation.AD_Mopt.CFIM","title":"<code>CFIM(W=[])</code>","text":"<p>Choose CFI or \\(\\mathrm{Tr}(WI^{-1})\\) as the objective function.  In single parameter estimation the objective function is CFI and  in multiparameter estimation it will be \\(\\mathrm{Tr}(WI^{-1})\\).</p>"},{"location":"API/python/classes/#quanestimation.AD_Mopt.CFIM--parameters","title":"Parameters","text":"<p>W: <code>matrix</code>     -- Weight matrix.</p> Source code in <code>quanestimation/MeasurementOpt/AD_Mopt.py</code> <pre><code>def CFIM(self, W=[]):\n    r\"\"\"\n    Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. \n    In single parameter estimation the objective function is CFI and \n    in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$.\n\n    Parameters\n    ----------\n    &gt; **W:** `matrix`\n        -- Weight matrix.\n    \"\"\"\n\n    if self.mtype == \"projection\":\n        raise ValueError(\n            \"AD is not available when mtype is projection. Supported methods are 'PSO' and 'DE'.\",\n        )\n    else:\n        super().CFIM(W)\n</code></pre>"},{"location":"API/python/classes/#measurement-optimization-with-pso","title":"Measurement Optimization with PSO","text":"<p>             Bases: <code>MeasurementSystem</code></p>"},{"location":"API/python/classes/#quanestimation.PSO_Mopt--attributes","title":"Attributes","text":"<p>savefile: <code>bool</code>     -- Whether or not to save all the measurements.     If set <code>True</code> then the measurements and the values of the      objective function obtained in all episodes will be saved during      the training. If set <code>False</code> the measurement in the final      episode and the values of the objective function in all episodes      will be saved.</p> <p>p_num: <code>int</code>     -- The number of particles.</p> <p>measurement0: <code>list of arrays</code>     -- Initial guesses of measurements.</p> <p>max_episode: <code>int or list</code>     -- If it is an integer, for example max_episode=1000, it means the      program will continuously run 1000 episodes. However, if it is an     array, for example max_episode=[1000,100], the program will run      1000 episodes in total but replace measurements of all  the particles      with global best every 100 episodes.</p> <p>c0: <code>float</code>     -- The damping factor that assists convergence, also known as inertia weight.</p> <p>c1: <code>float</code>     -- The exploitation weight that attracts the particle to its best previous      position, also known as cognitive learning factor.</p> <p>c2: <code>float</code>     -- The exploitation weight that attracts the particle to the best position     in the neighborhood, also known as social learning factor.</p> <p>seed: <code>int</code>     -- Random seed.</p> <p>eps: <code>float</code>     -- Machine epsilon.</p> <p>load: <code>bool</code>     -- Whether or not to load measurements in the current location.     If set <code>True</code> then the program will load measurement from \"measurements.csv\"     file in the current location and use it as the initial measurement.</p> Source code in <code>quanestimation/MeasurementOpt/PSO_Mopt.py</code> <pre><code>class PSO_Mopt(Measurement.MeasurementSystem):\n    \"\"\"\n    Attributes\n    ----------\n    &gt; **savefile:** `bool`\n        -- Whether or not to save all the measurements.  \n        If set `True` then the measurements and the values of the \n        objective function obtained in all episodes will be saved during \n        the training. If set `False` the measurement in the final \n        episode and the values of the objective function in all episodes \n        will be saved.\n\n    &gt; **p_num:** `int`\n        -- The number of particles.\n\n    &gt; **measurement0:** `list of arrays`\n        -- Initial guesses of measurements.\n\n    &gt; **max_episode:** `int or list`\n        -- If it is an integer, for example max_episode=1000, it means the \n        program will continuously run 1000 episodes. However, if it is an\n        array, for example max_episode=[1000,100], the program will run \n        1000 episodes in total but replace measurements of all  the particles \n        with global best every 100 episodes.\n\n    &gt; **c0:** `float`\n        -- The damping factor that assists convergence, also known as inertia weight.\n\n    &gt; **c1:** `float`\n        -- The exploitation weight that attracts the particle to its best previous \n        position, also known as cognitive learning factor.\n\n    &gt; **c2:** `float`\n        -- The exploitation weight that attracts the particle to the best position  \n        in the neighborhood, also known as social learning factor.\n\n    &gt; **seed:** `int`\n        -- Random seed.\n\n    &gt; **eps:** `float`\n        -- Machine epsilon.\n\n    &gt; **load:** `bool`\n        -- Whether or not to load measurements in the current location.  \n        If set `True` then the program will load measurement from \"measurements.csv\"\n        file in the current location and use it as the initial measurement.\n    \"\"\"\n\n    def __init__(\n        self,\n        mtype,\n        minput,\n        savefile=False,\n        p_num=10,\n        measurement0=[],\n        max_episode=[1000, 100],\n        c0=1.0,\n        c1=2.0,\n        c2=2.0,\n        seed=1234,\n        eps=1e-8,\n        load=False,\n    ):\n\n        Measurement.MeasurementSystem.__init__(\n            self, mtype, minput, savefile, measurement0, seed, eps, load\n        )\n\n        self.p_num = p_num\n        is_int = isinstance(max_episode, int)\n        self.max_episode = max_episode if is_int else QJL.Vector[QJL.Int64](max_episode)\n        self.c0 = c0\n        self.c1 = c1\n        self.c2 = c2\n        self.seed = seed\n\n    def CFIM(self, W=[]):\n        r\"\"\"\n        Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. \n        In single parameter estimation the objective function is CFI and \n        in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$.\n\n        Parameters\n        ----------\n        &gt; **W:** `matrix`\n            -- Weight matrix.\n        \"\"\"\n        ini_particle = (self.measurement0,)\n        self.alg = QJL.PSO(\n            self.max_episode,\n            self.p_num,\n            ini_particle,\n            self.c0,\n            self.c1,\n            self.c2,\n        )\n\n        super().CFIM(W)\n</code></pre>"},{"location":"API/python/classes/#quanestimation.PSO_Mopt.CFIM","title":"<code>CFIM(W=[])</code>","text":"<p>Choose CFI or \\(\\mathrm{Tr}(WI^{-1})\\) as the objective function.  In single parameter estimation the objective function is CFI and  in multiparameter estimation it will be \\(\\mathrm{Tr}(WI^{-1})\\).</p>"},{"location":"API/python/classes/#quanestimation.PSO_Mopt.CFIM--parameters","title":"Parameters","text":"<p>W: <code>matrix</code>     -- Weight matrix.</p> Source code in <code>quanestimation/MeasurementOpt/PSO_Mopt.py</code> <pre><code>def CFIM(self, W=[]):\n    r\"\"\"\n    Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. \n    In single parameter estimation the objective function is CFI and \n    in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$.\n\n    Parameters\n    ----------\n    &gt; **W:** `matrix`\n        -- Weight matrix.\n    \"\"\"\n    ini_particle = (self.measurement0,)\n    self.alg = QJL.PSO(\n        self.max_episode,\n        self.p_num,\n        ini_particle,\n        self.c0,\n        self.c1,\n        self.c2,\n    )\n\n    super().CFIM(W)\n</code></pre>"},{"location":"API/python/classes/#measurement-optimization-with-de","title":"Measurement Optimization with DE","text":"<p>             Bases: <code>MeasurementSystem</code></p>"},{"location":"API/python/classes/#quanestimation.DE_Mopt--attributes","title":"Attributes","text":"<p>savefile: <code>bool</code>     -- Whether or not to save all the measurements.     If set <code>True</code> then the measurements and the values of the      objective function obtained in all episodes will be saved during      the training. If set <code>False</code> the measurement in the final      episode and the values of the objective function in all episodes      will be saved.</p> <p>p_num: <code>int</code>     -- The number of populations.</p> <p>measurement0: <code>list of arrays</code>     -- Initial guesses of measurements.</p> <p>max_episode: <code>int</code>     -- The number of episodes.</p> <p>c: <code>float</code>     -- Mutation constant.</p> <p>cr: <code>float</code>     -- Crossover constant.</p> <p>seed: <code>int</code>     -- Random seed.</p> <p>eps: <code>float</code>     -- Machine epsilon.</p> <p>load: <code>bool</code>     -- Whether or not to load measurements in the current location.     If set <code>True</code> then the program will load measurement from \"measurements.csv\"     file in the current location and use it as the initial measurement.</p> Source code in <code>quanestimation/MeasurementOpt/DE_Mopt.py</code> <pre><code>class DE_Mopt(Measurement.MeasurementSystem):\n    \"\"\"\n    Attributes\n    ----------\n    &gt; **savefile:** `bool`\n        -- Whether or not to save all the measurements.  \n        If set `True` then the measurements and the values of the \n        objective function obtained in all episodes will be saved during \n        the training. If set `False` the measurement in the final \n        episode and the values of the objective function in all episodes \n        will be saved.\n\n    &gt; **p_num:** `int`\n        -- The number of populations.\n\n    &gt; **measurement0:** `list of arrays`\n        -- Initial guesses of measurements.\n\n    &gt; **max_episode:** `int`\n        -- The number of episodes.\n\n    &gt; **c:** `float`\n        -- Mutation constant.\n\n    &gt; **cr:** `float`\n        -- Crossover constant.\n\n    &gt; **seed:** `int`\n        -- Random seed.\n\n    &gt; **eps:** `float`\n        -- Machine epsilon.\n\n    &gt; **load:** `bool`\n        -- Whether or not to load measurements in the current location.  \n        If set `True` then the program will load measurement from \"measurements.csv\"\n        file in the current location and use it as the initial measurement.\n    \"\"\"\n\n    def __init__(\n        self,\n        mtype,\n        minput,\n        savefile=False,\n        p_num=10,\n        measurement0=[],\n        max_episode=1000,\n        c=1.0,\n        cr=0.5,\n        seed=1234,\n        eps=1e-8,\n        load=False,\n    ):\n\n        Measurement.MeasurementSystem.__init__(\n            self, mtype, minput, savefile, measurement0, seed, eps, load\n        )\n\n        self.p_num = p_num\n        self.max_episode = max_episode\n        self.c = c\n        self.cr = cr\n\n    def CFIM(self, W=[]):\n        r\"\"\"\n        Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. \n        In single parameter estimation the objective function is CFI and \n        in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$.\n\n        Parameters\n        ----------\n        &gt; **W:** `matrix`\n            -- Weight matrix.\n        \"\"\"\n        ini_population = (self.measurement0,)\n        self.alg = QJL.DE(\n            self.max_episode,\n            self.p_num,\n            ini_population,\n            self.c,\n            self.cr,\n        )\n        super().CFIM(W)\n</code></pre>"},{"location":"API/python/classes/#quanestimation.DE_Mopt.CFIM","title":"<code>CFIM(W=[])</code>","text":"<p>Choose CFI or \\(\\mathrm{Tr}(WI^{-1})\\) as the objective function.  In single parameter estimation the objective function is CFI and  in multiparameter estimation it will be \\(\\mathrm{Tr}(WI^{-1})\\).</p>"},{"location":"API/python/classes/#quanestimation.DE_Mopt.CFIM--parameters","title":"Parameters","text":"<p>W: <code>matrix</code>     -- Weight matrix.</p> Source code in <code>quanestimation/MeasurementOpt/DE_Mopt.py</code> <pre><code>def CFIM(self, W=[]):\n    r\"\"\"\n    Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. \n    In single parameter estimation the objective function is CFI and \n    in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$.\n\n    Parameters\n    ----------\n    &gt; **W:** `matrix`\n        -- Weight matrix.\n    \"\"\"\n    ini_population = (self.measurement0,)\n    self.alg = QJL.DE(\n        self.max_episode,\n        self.p_num,\n        ini_population,\n        self.c,\n        self.cr,\n    )\n    super().CFIM(W)\n</code></pre>"},{"location":"API/python/classes/#comprehensive-optimization","title":"Comprehensive Optimization","text":"<p>In order to obtain the optimal parameter estimation schemes, it is necessary to simultaneously optimize the probe state, control and measurement. The comprehensive optimization for the probe state and measurement (SM), the probe state and control (SC), the control and measurement (CM) and the probe state,  control and measurement (SCM) are proposed for this. In QuanEstimation, the  comprehensive optimization algorithms are particle swarm optimization (PSO),  differential evolution (DE), and automatic differentiation (AD).</p>"},{"location":"API/python/classes/#base_3","title":"Base","text":""},{"location":"API/python/classes/#quanestimation.ComprehensiveSystem--attributes","title":"Attributes","text":"<p>savefile: <code>bool</code>     -- Whether or not to save all the optimized variables (probe states,      control coefficients and measurements).     If set <code>True</code> then the optimized variables and the values of the      objective function obtained in all episodes will be saved during      the training. If set <code>False</code> the optimized variables in the final      episode and the values of the objective function in all episodes      will be saved.</p> <p>psi0: <code>list of arrays</code>     -- Initial guesses of states.</p> <p>ctrl0: <code>list of arrays</code>     -- Initial guesses of control coefficients.</p> <p>measurement0: <code>list of arrays</code>     -- Initial guesses of measurements.</p> <p>seed: <code>int</code>     -- Random seed.</p> <p>eps: <code>float</code>     -- Machine epsilon.</p> Source code in <code>quanestimation/ComprehensiveOpt/ComprehensiveStruct.py</code> <pre><code>class ComprehensiveSystem:\n    \"\"\"\n    Attributes\n    ----------\n    &gt; **savefile:** `bool`\n        -- Whether or not to save all the optimized variables (probe states, \n        control coefficients and measurements).  \n        If set `True` then the optimized variables and the values of the \n        objective function obtained in all episodes will be saved during \n        the training. If set `False` the optimized variables in the final \n        episode and the values of the objective function in all episodes \n        will be saved.\n\n    &gt; **psi0:** `list of arrays`\n        -- Initial guesses of states.\n\n    &gt; **ctrl0:** `list of arrays`\n        -- Initial guesses of control coefficients.\n\n    &gt; **measurement0:** `list of arrays`\n        -- Initial guesses of measurements.\n\n    &gt; **seed:** `int`\n        -- Random seed.\n\n    &gt; **eps:** `float`\n        -- Machine epsilon.\n    \"\"\"\n\n    def __init__(self, savefile, psi0, ctrl0, measurement0, seed, eps):\n\n        self.savefile = savefile\n        self.ctrl0 = ctrl0\n        self.psi0 = psi0\n        self.eps = eps\n        self.seed = seed\n        self.measurement0 = measurement0\n\n    def load_save_ctrls(self, cnum, max_episode):\n        if os.path.exists(\"controls.dat\"):\n            fl = h5py.File(\"controls.dat\",'r')\n            dset = fl[\"controls\"]\n            if self.savefile:\n                controls = np.array([[np.array(fl[fl[dset[i]][j]]) for j in range(cnum)] for i in range(max_episode)])\n            else:\n                controls = np.array([np.array(fl[dset[j]]) for j in range(cnum)])\n            np.save(\"controls\", controls)\n        else: pass\n\n    def load_save_ctrls_alt(self, cnum, max_episode):\n        if os.path.exists(\"controls.dat\"):\n            fl = h5py.File(\"controls.dat\",'r')\n            dset = fl[\"controls\"]\n            if self.savefile:\n                controls = np.array([[np.array(fl[fl[dset[i]][j]]) for j in range(cnum)] for i in range(max_episode)])\n            else:\n                controls = np.array([dset[:,i] for i in range(cnum)])\n            np.save(\"controls\", controls)\n        else: pass\n\n    def load_save_states(self, max_episode):\n        if os.path.exists(\"states.dat\"):\n            fl = h5py.File(\"states.dat\",'r')\n            dset = fl[\"states\"]\n            if self.savefile:\n                psi = np.array([np.array(fl[dset[i]]).view('complex') for i in range(max_episode)])\n            else:\n                psi = np.array(dset).view('complex')\n            np.save(\"states\", psi)\n        else: pass\n\n    def load_save_meas(self, mnum, max_episode):\n        if os.path.exists(\"measurements.dat\"):\n            fl = h5py.File(\"measurements.dat\",'r')\n            dset = fl[\"measurements\"]\n            if self.savefile:\n                mdata = np.array([[np.array(fl[fl[dset[i]][j]]).view('complex') for j in range(mnum)] for i in range(max_episode)])\n            else:\n                mdata = np.array([np.array(fl[dset[j]]).view('complex') for j in range(mnum)])\n            np.save(\"measurements\", mdata)\n        else: pass\n\n    def dynamics(self, tspan, H0, dH, Hc=[], ctrl=[], decay=[], ctrl_bound=[], dyn_method=\"expm\"):\n        r\"\"\"\n        The dynamics of a density matrix is of the form \n\n        \\begin{align}\n        \\partial_t\\rho &amp;=\\mathcal{L}\\rho \\nonumber \\\\\n        &amp;=-i[H,\\rho]+\\sum_i \\gamma_i\\left(\\Gamma_i\\rho\\Gamma^{\\dagger}_i-\\frac{1}{2}\n        \\left\\{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\right\\}\\right),\n        \\end{align} \n\n        where $\\rho$ is the evolved density matrix, H is the Hamiltonian of the \n        system, $\\Gamma_i$ and $\\gamma_i$ are the $i\\mathrm{th}$ decay \n        operator and corresponding decay rate.\n\n        Parameters\n        ----------\n        &gt; **tspan:** `array`\n            -- Time length for the evolution.\n\n        &gt; **H0:** `matrix or list`\n            -- Free Hamiltonian. It is a matrix when the free Hamiltonian is time-\n            independent and a list of length equal to `tspan` when it is time-dependent.\n\n        &gt; **dH:** `list`\n            -- Derivatives of the free Hamiltonian on the unknown parameters to be \n            estimated. For example, dH[0] is the derivative vector on the first \n            parameter.\n\n        &gt; **Hc:** `list`\n            -- Control Hamiltonians.\n\n        &gt; **ctrl:** `list of arrays`\n            -- Control coefficients.\n\n        &gt; **decay:** `list`\n            -- Decay operators and the corresponding decay rates. Its input rule is \n            decay=[[$\\Gamma_1$, $\\gamma_1$], [$\\Gamma_2$,$\\gamma_2$],...], where $\\Gamma_1$ \n            $(\\Gamma_2)$ represents the decay operator and $\\gamma_1$ $(\\gamma_2)$ is the \n            corresponding decay rate.\n\n        &gt; **ctrl_bound:** `array`\n            -- Lower and upper bounds of the control coefficients.\n            `ctrl_bound[0]` represents the lower bound of the control coefficients and\n            `ctrl_bound[1]` represents the upper bound of the control coefficients.\n\n        &gt; **dyn_method:** `string`\n            -- Setting the method for solving the Lindblad dynamics. Options are:  \n            \"expm\" (default) -- Matrix exponential.  \n            \"ode\" -- Solving the differential equations directly. \n        \"\"\"\n\n        self.tspan = tspan\n        self.ctrl = ctrl\n        self.Hc = Hc\n\n        if dyn_method == \"expm\":\n            self.dyn_method = \"Expm\"\n        elif dyn_method == \"ode\":\n            self.dyn_method = \"Ode\"\n\n        if type(H0) == np.ndarray:\n            self.freeHamiltonian = np.array(H0, dtype=np.complex128)\n            self.dim = len(self.freeHamiltonian)\n        else:\n            self.freeHamiltonian = [np.array(x, dtype=np.complex128) for x in H0[:-1]]\n            self.dim = len(self.freeHamiltonian[0])\n\n        QJLType_psi = QJL.Vector[QJL.Vector[QJL.ComplexF64]]\n        if self.psi0 == []:\n            np.random.seed(self.seed)\n            r_ini = 2 * np.random.random(self.dim) - np.ones(self.dim)\n            r = r_ini / np.linalg.norm(r_ini)\n            phi = 2 * np.pi * np.random.random(self.dim)\n            psi = np.array([r[i] * np.exp(1.0j * phi[i]) for i in range(self.dim)])\n            self.psi0 = np.array(psi)\n            self.psi = QJL.convert(QJLType_psi, [self.psi0]) # Initial guesses of states (a list of arrays)\n        else:\n            self.psi0 = np.array(self.psi0[0], dtype=np.complex128)\n            self.psi = QJL.convert(QJLType_psi, self.psi)\n\n        if Hc == []:\n            Hc = [np.zeros((self.dim, self.dim))]\n        self.control_Hamiltonian = [np.array(x, dtype=np.complex128) for x in Hc]\n\n        if type(dH) != list:\n            raise TypeError(\"The derivative of Hamiltonian should be a list!\")\n\n        if dH == []:\n            dH = [np.zeros((self.dim, self.dim))]\n        self.Hamiltonian_derivative = [np.array(x, dtype=np.complex128) for x in dH]\n\n        if len(dH) == 1:\n            self.para_type = \"single_para\"\n        else:\n            self.para_type = \"multi_para\"\n\n        if decay == []:\n            decay_opt = [np.zeros((self.dim, self.dim))]\n            self.gamma = [0.0]\n        else:\n            decay_opt = [decay[i][0] for i in range(len(decay))]\n            self.gamma = [decay[i][1] for i in range(len(decay))]\n        self.decay_opt = [np.array(x, dtype=np.complex128) for x in decay_opt]\n\n        if ctrl_bound == []:\n            self.ctrl_bound = [-np.inf, np.inf]\n        else:\n            self.ctrl_bound = [float(ctrl_bound[0]), float(ctrl_bound[1])]\n\n        if self.ctrl0 == []:\n            if ctrl_bound == []:\n                ctrl0 = [\n                    2 * np.random.random(len(self.tspan) - 1)\n                    - np.ones(len(self.tspan) - 1)\n                    for i in range(len(self.control_Hamiltonian))\n                ]\n            else:\n                a = ctrl_bound[0]\n                b = ctrl_bound[1]\n                ctrl0 = [\n                    (b - a) * np.random.random(len(self.tspan) - 1)\n                    + a * np.ones(len(self.tspan) - 1)\n                    for i in range(len(self.control_Hamiltonian))\n                ]\n            self.control_coefficients = ctrl0\n            self.ctrl0 = [np.array(ctrl0)]\n\n        elif len(self.ctrl0) &gt;= 1:\n            self.control_coefficients = [\n                self.ctrl0[0][i] for i in range(len(self.control_Hamiltonian))\n            ]\n\n        ctrl_num = len(self.control_coefficients)\n        Hc_num = len(self.control_Hamiltonian)\n        if Hc_num &lt; ctrl_num:\n            raise TypeError(\n                \"There are %d control Hamiltonians but %d coefficients sequences: \\\n                                too many coefficients sequences\"\n                % (Hc_num, ctrl_num)\n            )\n        elif Hc_num &gt; ctrl_num:\n            warnings.warn(\n                \"Not enough coefficients sequences: there are %d control Hamiltonians \\\n                            but %d coefficients sequences. The rest of the control sequences are\\\n                            set to be 0.\"\n                % (Hc_num, ctrl_num),\n                DeprecationWarning,\n            )\n            for i in range(Hc_num - ctrl_num):\n                self.control_coefficients = np.concatenate(\n                    (\n                        self.control_coefficients,\n                        np.zeros(len(self.control_coefficients[0])),\n                    )\n                )\n        else: pass\n\n        # ## TODO\n        QJLType_ctrl = QJL.Vector[QJL.Vector[QJL.Vector[QJL.Float64]]] \n        self.ctrl0 = QJL.convert(QJLType_ctrl, [[c for c in ctrls ]for ctrls in self.ctrl0])\n\n        QJLType_C = QJL.Vector[QJL.Vector[QJL.ComplexF64]]\n        if self.measurement0 == []:\n            np.random.seed(self.seed)\n            M = [[] for i in range(self.dim)]\n            for i in range(self.dim):\n                r_ini = 2 * np.random.random(self.dim) - np.ones(self.dim)\n                r = r_ini / np.linalg.norm(r_ini)\n                phi = 2 * np.pi * np.random.random(self.dim)\n                M[i] = [r[j] * np.exp(1.0j * phi[j]) for j in range(self.dim)]\n            self.C = QJL.convert(QJLType_C, gramschmidt(np.array(M)))\n            self.measurement0 = QJL.Vector([self.C])\n        else:\n            self.C = [self.measurement0[0][i] for i in range(len(self.rho0))]\n            self.C = QJL.convert(QJLType_C, self.C)\n            self.measurement0 = QJL.Vector([self.C])\n\n        if type(H0) != np.ndarray:\n            #### linear interpolation  ####\n            f = interp1d(self.tspan, H0, axis=0)\n        else: pass\n        number = math.ceil((len(self.tspan) - 1) / len(self.control_coefficients[0]))\n        if len(self.tspan) - 1 % len(self.control_coefficients[0]) != 0:\n            tnum = number * len(self.control_coefficients[0])\n            self.tspan = np.linspace(self.tspan[0], self.tspan[-1], tnum + 1)\n            if type(H0) != np.ndarray:\n                H0_inter = f(self.tspan)\n                self.freeHamiltonian = [np.array(x, dtype=np.complex128) for x in H0_inter[:-1]]\n            else: pass\n        else: pass\n\n        self.dynamics_type = \"dynamics\"\n\n    def Kraus(self, K, dK):\n        r\"\"\"\n        The parameterization of a state is\n        \\begin{align}\n        \\rho=\\sum_i K_i\\rho_0K_i^{\\dagger},\n        \\end{align} \n\n        where $\\rho$ is the evolved density matrix, $K_i$ is the Kraus operator.\n\n        Parameters\n        ----------\n        &gt; **K:** `list`\n            -- Kraus operators.\n\n        &gt; **dK:** `list`\n            -- Derivatives of the Kraus operators on the unknown parameters to be \n            estimated. For example, dK[0] is the derivative vector on the first \n            parameter.\n        \"\"\"\n\n        k_num = len(K)\n        para_num = len(dK[0])\n        self.para_num = para_num\n        dK_tp = [\n            [np.array(dK[i][j], dtype=np.complex128) for j in range(para_num)]\n            for i in range(k_num)\n        ]\n        self.K = [np.array(x, dtype=np.complex128) for x in K]\n        self.dK = dK_tp\n\n        if para_num == 1:\n            self.para_type = \"single_para\"\n        else:\n            self.para_type = \"multi_para\"\n\n        self.dim = len(K[0])\n        QJLType_psi = QJL.Vector[QJL.Vector[QJL.ComplexF64]]\n        if self.psi0 == []:\n            np.random.seed(self.seed)\n            r_ini = 2 * np.random.random(self.dim) - np.ones(self.dim)\n            r = r_ini / np.linalg.norm(r_ini)\n            phi = 2 * np.pi * np.random.random(self.dim)\n            psi = np.array([r[i] * np.exp(1.0j * phi[i]) for i in range(self.dim)])\n            self.psi0 = np.array(psi)\n            self.psi = QJL.convert(QJLType_psi, [self.psi0]) # Initial guesses of states (a list of arrays)\n        else:\n            self.psi0 = np.array(self.psi0[0], dtype=np.complex128)\n            self.psi = QJL.convert(QJLType_psi, self.psi)\n\n        if self.measurement0 == []:\n            np.random.seed(self.seed)\n            M = [[] for i in range(self.dim)]\n            for i in range(self.dim):\n                r_ini = 2 * np.random.random(self.dim) - np.ones(self.dim)\n                r = r_ini / np.linalg.norm(r_ini)\n                phi = 2 * np.pi * np.random.random(self.dim)\n                M[i] = [r[i] * np.exp(1.0j * phi[i]) for i in range(self.dim)]\n            self.C = gramschmidt(np.array(M))\n            self.measurement0 = [np.array([self.C[i] for i in range(len(self.psi))])]\n        elif len(self.measurement0) &gt;= 1:\n            self.C = [self.measurement0[0][i] for i in range(len(self.psi))]\n            self.C = [np.array(x, dtype=np.complex128) for x in self.C]\n\n        self.dynamic = QJL.Kraus(list(self.psi0), self.K, self.dK)\n\n        self.dynamics_type = \"Kraus\"\n\n    def SC(self, W=[], M=[], target=\"QFIM\", LDtype=\"SLD\"):\n        \"\"\"\n        Comprehensive optimization of the probe state and control (SC).\n\n        Parameters\n        ----------\n        &gt; **W:** `matrix`\n            -- Weight matrix.\n\n        &gt; **M:** `list of matrices`\n            -- A set of positive operator-valued measure (POVM). The default measurement \n            is a set of rank-one symmetric informationally complete POVM (SIC-POVM).\n\n        &gt; **target:** `string`\n            -- Objective functions for comprehensive optimization. Options are:  \n            \"QFIM\" (default) -- choose QFI (QFIM) as the objective function.  \n            \"CFIM\" -- choose CFI (CFIM) as the objective function.  \n            \"HCRB\" -- choose HCRB as the objective function.  \n\n        &gt; **LDtype:** `string`\n            -- Types of QFI (QFIM) can be set as the objective function. Options are:  \n            \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD).  \n            \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD).  \n            \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). \n\n        **Note:** \n            SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state \n            which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/\n            solutions.html).\n        \"\"\"\n\n        if self.dynamics_type != \"dynamics\":\n            raise ValueError(\n                \"Supported type of dynamics is Lindblad.\"\n                )\n\n        if W == []:\n            W = np.eye(len(self.Hamiltonian_derivative))\n        self.W = W\n\n        if M != []:\n            M = [np.array(x, dtype=np.complex128) for x in M]\n            self.obj = QJL.CFIM_obj(M, self.W, self.eps, self.para_type)\n        else:\n            if target == \"HCRB\":\n                if self.para_type == \"single_para\":\n                    print(\n                        \"Program terminated. In the single-parameter scenario, the HCRB is equivalent to the QFI. Please choose 'QFIM' as the objective function\"\n                    )\n                else:\n                    self.obj = QJL.HCRB_obj(self.W, self.eps, self.para_type)\n            elif target == \"QFIM\" and (\n                LDtype == \"SLD\" or LDtype == \"RLD\" or LDtype == \"LLD\"\n            ):\n                self.obj = QJL.QFIM_obj(\n                    self.W, self.eps, self.para_type, LDtype\n                )\n            elif target == \"CFIM\":\n                M = SIC(len(self.psi))\n                self.obj = QJL.CFIM_obj(M, self.W, self.eps, self.para_type)\n            else:\n                raise ValueError(\n                    \"Please enter the correct values for target and LDtype. Supported target are 'QFIM', 'CFIM' and 'HCRB', supported LDtype are 'SLD', 'RLD' and 'LLD'.\"\n                )\n\n        self.opt = QJL.StateControlOpt(\n            psi=self.psi, ctrl=self.control_coefficients, ctrl_bound=self.ctrl_bound, seed=self.seed\n        )\n        self.output = QJL.Output(self.opt, save=self.savefile)\n\n        self.dynamic = QJL.Lindblad(\n            self.freeHamiltonian,\n            self.Hamiltonian_derivative,\n            self.control_Hamiltonian,\n            self.control_coefficients,\n            list(self.psi0),\n            self.tspan,\n            self.decay_opt,\n            self.gamma,\n            dyn_method = self.dyn_method,\n            )\n        system = QJL.QuanEstSystem(\n            self.opt, self.alg, self.obj, self.dynamic, self.output\n        )\n        QJL.run(system)\n\n        max_num = self.max_episode if type(self.max_episode) == int else self.max_episode[0]\n        self.load_save_states(max_num)\n        self.load_save_ctrls(len(self.control_Hamiltonian), max_num)\n\n    def CM(self, rho0, W=[]):\n        \"\"\"\n        Comprehensive optimization of the control and measurement (CM).\n\n        Parameters\n        ----------\n        &gt; **rho0:** `matrix`\n            -- Initial state (density matrix).\n\n        &gt; **W:** `matrix`\n            -- Weight matrix.\n        \"\"\"\n\n        if self.dynamics_type != \"dynamics\":\n            raise ValueError(\n                \"Supported type of dynamics is Lindblad.\"\n                )\n\n        if W == []:\n            W = np.eye(len(self.Hamiltonian_derivative))\n        self.W = W\n\n        self.rho0 = np.array(rho0, dtype=np.complex128)\n\n        self.obj = QJL.CFIM_obj([], self.W, self.eps, self.para_type)\n        self.opt = QJL.ControlMeasurementOpt(\n            ctrl=self.control_coefficients, M=self.C, ctrl_bound=self.ctrl_bound, seed=self.seed\n        )\n        self.output = QJL.Output(self.opt, save=self.savefile)\n\n        self.dynamic = QJL.Lindblad(\n            self.freeHamiltonian,\n            self.Hamiltonian_derivative,\n            self.control_Hamiltonian,\n            self.control_coefficients,\n            self.rho0,\n            self.tspan,\n            self.decay_opt,\n            self.gamma,\n            dyn_method =self.dyn_method,\n            )\n\n        system = QJL.QuanEstSystem(\n            self.opt, self.alg, self.obj, self.dynamic, self.output\n        )\n        QJL.run(system)\n\n        max_num = self.max_episode if type(self.max_episode) == int else self.max_episode[0]\n        self.load_save_ctrls_alt(len(self.control_Hamiltonian), max_num)\n        self.load_save_meas(self.dim, max_num)\n\n    def SM(self, W=[]):\n        \"\"\"\n        Comprehensive optimization of the probe state and measurement (SM).\n\n        Parameters\n        ----------\n        &gt; **W:** `matrix`\n            -- Weight matrix.\n        \"\"\"\n\n        if self.dynamics_type == \"dynamics\":\n            if W == []:\n                W = np.eye(len(self.Hamiltonian_derivative))\n            self.W = W\n\n            if self.Hc == [] or self.ctrl == []:\n                freeHamiltonian = self.freeHamiltonian\n            else:\n                ctrl_num = len(self.ctrl)\n                Hc_num = len(self.control_Hamiltonian)\n                if Hc_num &lt; ctrl_num:\n                    raise TypeError(\n                        \"There are %d control Hamiltonians but %d coefficients sequences: \\\n                                 too many coefficients sequences.\"\n                        % (Hc_num, ctrl_num)\n                    )\n                elif Hc_num &gt; ctrl_num:\n                    warnings.warn(\n                        \"Not enough coefficients sequences: there are %d control Hamiltonians \\\n                               but %d coefficients sequences. The rest of the control sequences are\\\n                               set to be 0.\"\n                        % (Hc_num, ctrl_num),\n                        DeprecationWarning,\n                    )\n                    for i in range(Hc_num - ctrl_num):\n                        self.ctrl = np.concatenate(\n                            (self.ctrl, np.zeros(len(self.ctrl[0])))\n                        )\n                else:\n                    pass\n\n                if len(self.ctrl[0]) == 1:\n                    if type(self.freeHamiltonian) == np.ndarray:\n                        H0 = np.array(self.freeHamiltonian, dtype=np.complex128)\n                        Hc = [\n                            np.array(x, dtype=np.complex128)\n                            for x in self.control_Hamiltonian\n                        ]\n                        Htot = H0 + sum(\n                            [\n                                self.control_Hamiltonian[i] * self.ctrl[i][0]\n                                for i in range(ctrl_num)\n                            ]\n                        )\n                        freeHamiltonian = np.array(Htot, dtype=np.complex128)\n                    else:\n                        H0 = [\n                            np.array(x, dtype=np.complex128)\n                            for x in self.freeHamiltonian\n                        ]\n                        Htot = []\n                        for i in range(len(H0)):\n                            Htot.append(\n                                H0[i]\n                                + sum(\n                                    [\n                                        self.control_Hamiltonian[i] * self.ctrl[i][0]\n                                        for i in range(ctrl_num)\n                                    ]\n                                )\n                            )\n                        freeHamiltonian = [\n                            np.array(x, dtype=np.complex128) for x in Htot\n                        ]\n                else:\n                    if type(self.freeHamiltonian) != np.ndarray:\n                        #### linear interpolation  ####\n                        f = interp1d(self.tspan, self.freeHamiltonian, axis=0)\n                    else: pass\n                    number = math.ceil((len(self.tspan) - 1) / len(self.ctrl[0]))\n                    if len(self.tspan) - 1 % len(self.ctrl[0]) != 0:\n                        tnum = number * len(self.ctrl[0])\n                        self.tspan = np.linspace(\n                            self.tspan[0], self.tspan[-1], tnum + 1\n                        )\n                        if type(self.freeHamiltonian) != np.ndarray:\n                            H0_inter = f(self.tspan)\n                            self.freeHamiltonian = [np.array(x, dtype=np.complex128) for x in H0_inter]\n                        else: pass\n                    else: pass\n\n                    if type(self.freeHamiltonian) == np.ndarray:\n                        H0 = np.array(self.freeHamiltonian, dtype=np.complex128)\n                        Hc = [\n                            np.array(x, dtype=np.complex128)\n                            for x in self.control_Hamiltonian\n                        ]\n                        self.ctrl = [np.array(self.ctrl[i]).repeat(number) for i in range(len(Hc))]\n                        Htot = []\n                        for i in range(len(self.ctrl[0])):\n                            S_ctrl = sum(\n                                [Hc[j] * self.ctrl[j][i] for j in range(len(self.ctrl))]\n                            )\n                            Htot.append(H0 + S_ctrl)\n                        freeHamiltonian = [\n                            np.array(x, dtype=np.complex128) for x in Htot\n                        ]\n                    else:\n                        H0 = [\n                            np.array(x, dtype=np.complex128)\n                            for x in self.freeHamiltonian\n                        ]\n                        Hc = [\n                            np.array(x, dtype=np.complex128)\n                            for x in self.control_Hamiltonian\n                        ]\n                        self.ctrl = [np.array(self.ctrl[i]).repeat(number) for i in range(len(Hc))]\n                        Htot = []\n                        for i in range(len(self.ctrl[0])):\n                            S_ctrl = sum(\n                                [Hc[j] * self.ctrl[j][i] for j in range(len(self.ctrl))]\n                            )\n                            Htot.append(H0[i] + S_ctrl)\n                        freeHamiltonian = [\n                            np.array(x, dtype=np.complex128) for x in Htot\n                        ]\n\n            self.dynamic = QJL.Lindblad(\n                freeHamiltonian,\n                self.Hamiltonian_derivative,\n                list(self.psi0),\n                self.tspan,\n                self.decay_opt,\n                self.gamma,\n                dyn_method = self.dyn_method,\n            )\n        elif self.dynamics_type == \"Kraus\":\n            if W == []:\n                W = np.eye(self.para_num)\n            self.W = W\n        else:\n            raise ValueError(\n                \"Supported type of dynamics are Lindblad and Kraus.\"\n                )\n\n        self.obj = QJL.CFIM_obj([], self.W, self.eps, self.para_type)\n        self.opt = QJL.StateMeasurementOpt(psi=list(self.psi), M=self.C, seed=self.seed)\n        self.output = QJL.Output(self.opt, save=self.savefile)\n\n        system = QJL.QuanEstSystem(\n            self.opt, self.alg, self.obj, self.dynamic, self.output\n        )\n        QJL.run(system)\n\n        max_num = self.max_episode if type(self.max_episode) == int else self.max_episode[0]\n        self.load_save_states(max_num)\n        self.load_save_meas(self.dim, max_num)\n\n    def SCM(self, W=[]):\n        \"\"\"\n        Comprehensive optimization of the probe state, control and measurement (SCM).\n\n        Parameters\n        ----------\n        &gt; **W:** `matrix`\n            -- Weight matrix.\n        \"\"\"\n\n        if self.dynamics_type != \"dynamics\":\n            raise ValueError(\n                \"Supported type of dynamics is Lindblad.\"\n                )\n        if W == []:\n            W = np.eye(len(self.Hamiltonian_derivative))\n        self.W = W\n\n        self.obj = QJL.CFIM_obj([], self.W, self.eps, self.para_type)\n        self.opt = QJL.StateControlMeasurementOpt(\n            psi=self.psi, ctrl=self.control_coefficients, M=self.C, ctrl_bound=self.ctrl_bound, seed=self.seed\n        )\n        self.output = QJL.Output(self.opt, save=self.savefile)\n\n        self.dynamic = QJL.Lindblad(\n            self.freeHamiltonian,\n            self.Hamiltonian_derivative,\n            self.control_Hamiltonian,\n            self.control_coefficients,\n            list(self.psi0),\n            self.tspan,\n            self.decay_opt,\n            self.gamma,\n            )\n\n        system = QJL.QuanEstSystem(\n            self.opt, self.alg, self.obj, self.dynamic, self.output\n        )\n        QJL.run(system)\n\n        max_num = self.max_episode if type(self.max_episode) == int else self.max_episode[0]\n        self.load_save_states(max_num)\n        self.load_save_ctrls(len(self.control_Hamiltonian), max_num)\n        self.load_save_meas(self.dim, max_num)\n</code></pre>"},{"location":"API/python/classes/#quanestimation.ComprehensiveSystem.CM","title":"<code>CM(rho0, W=[])</code>","text":"<p>Comprehensive optimization of the control and measurement (CM).</p>"},{"location":"API/python/classes/#quanestimation.ComprehensiveSystem.CM--parameters","title":"Parameters","text":"<p>rho0: <code>matrix</code>     -- Initial state (density matrix).</p> <p>W: <code>matrix</code>     -- Weight matrix.</p> Source code in <code>quanestimation/ComprehensiveOpt/ComprehensiveStruct.py</code> <pre><code>def CM(self, rho0, W=[]):\n    \"\"\"\n    Comprehensive optimization of the control and measurement (CM).\n\n    Parameters\n    ----------\n    &gt; **rho0:** `matrix`\n        -- Initial state (density matrix).\n\n    &gt; **W:** `matrix`\n        -- Weight matrix.\n    \"\"\"\n\n    if self.dynamics_type != \"dynamics\":\n        raise ValueError(\n            \"Supported type of dynamics is Lindblad.\"\n            )\n\n    if W == []:\n        W = np.eye(len(self.Hamiltonian_derivative))\n    self.W = W\n\n    self.rho0 = np.array(rho0, dtype=np.complex128)\n\n    self.obj = QJL.CFIM_obj([], self.W, self.eps, self.para_type)\n    self.opt = QJL.ControlMeasurementOpt(\n        ctrl=self.control_coefficients, M=self.C, ctrl_bound=self.ctrl_bound, seed=self.seed\n    )\n    self.output = QJL.Output(self.opt, save=self.savefile)\n\n    self.dynamic = QJL.Lindblad(\n        self.freeHamiltonian,\n        self.Hamiltonian_derivative,\n        self.control_Hamiltonian,\n        self.control_coefficients,\n        self.rho0,\n        self.tspan,\n        self.decay_opt,\n        self.gamma,\n        dyn_method =self.dyn_method,\n        )\n\n    system = QJL.QuanEstSystem(\n        self.opt, self.alg, self.obj, self.dynamic, self.output\n    )\n    QJL.run(system)\n\n    max_num = self.max_episode if type(self.max_episode) == int else self.max_episode[0]\n    self.load_save_ctrls_alt(len(self.control_Hamiltonian), max_num)\n    self.load_save_meas(self.dim, max_num)\n</code></pre>"},{"location":"API/python/classes/#quanestimation.ComprehensiveSystem.Kraus","title":"<code>Kraus(K, dK)</code>","text":"<p>The parameterization of a state is \\begin{align} \\rho=\\sum_i K_i\\rho_0K_i^{\\dagger}, \\end{align} </p> <p>where \\(\\rho\\) is the evolved density matrix, \\(K_i\\) is the Kraus operator.</p>"},{"location":"API/python/classes/#quanestimation.ComprehensiveSystem.Kraus--parameters","title":"Parameters","text":"<p>K: <code>list</code>     -- Kraus operators.</p> <p>dK: <code>list</code>     -- Derivatives of the Kraus operators on the unknown parameters to be      estimated. For example, dK[0] is the derivative vector on the first      parameter.</p> Source code in <code>quanestimation/ComprehensiveOpt/ComprehensiveStruct.py</code> <pre><code>def Kraus(self, K, dK):\n    r\"\"\"\n    The parameterization of a state is\n    \\begin{align}\n    \\rho=\\sum_i K_i\\rho_0K_i^{\\dagger},\n    \\end{align} \n\n    where $\\rho$ is the evolved density matrix, $K_i$ is the Kraus operator.\n\n    Parameters\n    ----------\n    &gt; **K:** `list`\n        -- Kraus operators.\n\n    &gt; **dK:** `list`\n        -- Derivatives of the Kraus operators on the unknown parameters to be \n        estimated. For example, dK[0] is the derivative vector on the first \n        parameter.\n    \"\"\"\n\n    k_num = len(K)\n    para_num = len(dK[0])\n    self.para_num = para_num\n    dK_tp = [\n        [np.array(dK[i][j], dtype=np.complex128) for j in range(para_num)]\n        for i in range(k_num)\n    ]\n    self.K = [np.array(x, dtype=np.complex128) for x in K]\n    self.dK = dK_tp\n\n    if para_num == 1:\n        self.para_type = \"single_para\"\n    else:\n        self.para_type = \"multi_para\"\n\n    self.dim = len(K[0])\n    QJLType_psi = QJL.Vector[QJL.Vector[QJL.ComplexF64]]\n    if self.psi0 == []:\n        np.random.seed(self.seed)\n        r_ini = 2 * np.random.random(self.dim) - np.ones(self.dim)\n        r = r_ini / np.linalg.norm(r_ini)\n        phi = 2 * np.pi * np.random.random(self.dim)\n        psi = np.array([r[i] * np.exp(1.0j * phi[i]) for i in range(self.dim)])\n        self.psi0 = np.array(psi)\n        self.psi = QJL.convert(QJLType_psi, [self.psi0]) # Initial guesses of states (a list of arrays)\n    else:\n        self.psi0 = np.array(self.psi0[0], dtype=np.complex128)\n        self.psi = QJL.convert(QJLType_psi, self.psi)\n\n    if self.measurement0 == []:\n        np.random.seed(self.seed)\n        M = [[] for i in range(self.dim)]\n        for i in range(self.dim):\n            r_ini = 2 * np.random.random(self.dim) - np.ones(self.dim)\n            r = r_ini / np.linalg.norm(r_ini)\n            phi = 2 * np.pi * np.random.random(self.dim)\n            M[i] = [r[i] * np.exp(1.0j * phi[i]) for i in range(self.dim)]\n        self.C = gramschmidt(np.array(M))\n        self.measurement0 = [np.array([self.C[i] for i in range(len(self.psi))])]\n    elif len(self.measurement0) &gt;= 1:\n        self.C = [self.measurement0[0][i] for i in range(len(self.psi))]\n        self.C = [np.array(x, dtype=np.complex128) for x in self.C]\n\n    self.dynamic = QJL.Kraus(list(self.psi0), self.K, self.dK)\n\n    self.dynamics_type = \"Kraus\"\n</code></pre>"},{"location":"API/python/classes/#quanestimation.ComprehensiveSystem.SC","title":"<code>SC(W=[], M=[], target='QFIM', LDtype='SLD')</code>","text":"<p>Comprehensive optimization of the probe state and control (SC).</p>"},{"location":"API/python/classes/#quanestimation.ComprehensiveSystem.SC--parameters","title":"Parameters","text":"<p>W: <code>matrix</code>     -- Weight matrix.</p> <p>M: <code>list of matrices</code>     -- A set of positive operator-valued measure (POVM). The default measurement      is a set of rank-one symmetric informationally complete POVM (SIC-POVM).</p> <p>target: <code>string</code>     -- Objective functions for comprehensive optimization. Options are:     \"QFIM\" (default) -- choose QFI (QFIM) as the objective function.     \"CFIM\" -- choose CFI (CFIM) as the objective function.     \"HCRB\" -- choose HCRB as the objective function.  </p> <p>LDtype: <code>string</code>     -- Types of QFI (QFIM) can be set as the objective function. Options are:     \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD).     \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD).     \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). </p> <p>Note:      SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state      which can be downloaded from here.</p> Source code in <code>quanestimation/ComprehensiveOpt/ComprehensiveStruct.py</code> <pre><code>def SC(self, W=[], M=[], target=\"QFIM\", LDtype=\"SLD\"):\n    \"\"\"\n    Comprehensive optimization of the probe state and control (SC).\n\n    Parameters\n    ----------\n    &gt; **W:** `matrix`\n        -- Weight matrix.\n\n    &gt; **M:** `list of matrices`\n        -- A set of positive operator-valued measure (POVM). The default measurement \n        is a set of rank-one symmetric informationally complete POVM (SIC-POVM).\n\n    &gt; **target:** `string`\n        -- Objective functions for comprehensive optimization. Options are:  \n        \"QFIM\" (default) -- choose QFI (QFIM) as the objective function.  \n        \"CFIM\" -- choose CFI (CFIM) as the objective function.  \n        \"HCRB\" -- choose HCRB as the objective function.  \n\n    &gt; **LDtype:** `string`\n        -- Types of QFI (QFIM) can be set as the objective function. Options are:  \n        \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD).  \n        \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD).  \n        \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). \n\n    **Note:** \n        SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state \n        which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/\n        solutions.html).\n    \"\"\"\n\n    if self.dynamics_type != \"dynamics\":\n        raise ValueError(\n            \"Supported type of dynamics is Lindblad.\"\n            )\n\n    if W == []:\n        W = np.eye(len(self.Hamiltonian_derivative))\n    self.W = W\n\n    if M != []:\n        M = [np.array(x, dtype=np.complex128) for x in M]\n        self.obj = QJL.CFIM_obj(M, self.W, self.eps, self.para_type)\n    else:\n        if target == \"HCRB\":\n            if self.para_type == \"single_para\":\n                print(\n                    \"Program terminated. In the single-parameter scenario, the HCRB is equivalent to the QFI. Please choose 'QFIM' as the objective function\"\n                )\n            else:\n                self.obj = QJL.HCRB_obj(self.W, self.eps, self.para_type)\n        elif target == \"QFIM\" and (\n            LDtype == \"SLD\" or LDtype == \"RLD\" or LDtype == \"LLD\"\n        ):\n            self.obj = QJL.QFIM_obj(\n                self.W, self.eps, self.para_type, LDtype\n            )\n        elif target == \"CFIM\":\n            M = SIC(len(self.psi))\n            self.obj = QJL.CFIM_obj(M, self.W, self.eps, self.para_type)\n        else:\n            raise ValueError(\n                \"Please enter the correct values for target and LDtype. Supported target are 'QFIM', 'CFIM' and 'HCRB', supported LDtype are 'SLD', 'RLD' and 'LLD'.\"\n            )\n\n    self.opt = QJL.StateControlOpt(\n        psi=self.psi, ctrl=self.control_coefficients, ctrl_bound=self.ctrl_bound, seed=self.seed\n    )\n    self.output = QJL.Output(self.opt, save=self.savefile)\n\n    self.dynamic = QJL.Lindblad(\n        self.freeHamiltonian,\n        self.Hamiltonian_derivative,\n        self.control_Hamiltonian,\n        self.control_coefficients,\n        list(self.psi0),\n        self.tspan,\n        self.decay_opt,\n        self.gamma,\n        dyn_method = self.dyn_method,\n        )\n    system = QJL.QuanEstSystem(\n        self.opt, self.alg, self.obj, self.dynamic, self.output\n    )\n    QJL.run(system)\n\n    max_num = self.max_episode if type(self.max_episode) == int else self.max_episode[0]\n    self.load_save_states(max_num)\n    self.load_save_ctrls(len(self.control_Hamiltonian), max_num)\n</code></pre>"},{"location":"API/python/classes/#quanestimation.ComprehensiveSystem.SCM","title":"<code>SCM(W=[])</code>","text":"<p>Comprehensive optimization of the probe state, control and measurement (SCM).</p>"},{"location":"API/python/classes/#quanestimation.ComprehensiveSystem.SCM--parameters","title":"Parameters","text":"<p>W: <code>matrix</code>     -- Weight matrix.</p> Source code in <code>quanestimation/ComprehensiveOpt/ComprehensiveStruct.py</code> <pre><code>def SCM(self, W=[]):\n    \"\"\"\n    Comprehensive optimization of the probe state, control and measurement (SCM).\n\n    Parameters\n    ----------\n    &gt; **W:** `matrix`\n        -- Weight matrix.\n    \"\"\"\n\n    if self.dynamics_type != \"dynamics\":\n        raise ValueError(\n            \"Supported type of dynamics is Lindblad.\"\n            )\n    if W == []:\n        W = np.eye(len(self.Hamiltonian_derivative))\n    self.W = W\n\n    self.obj = QJL.CFIM_obj([], self.W, self.eps, self.para_type)\n    self.opt = QJL.StateControlMeasurementOpt(\n        psi=self.psi, ctrl=self.control_coefficients, M=self.C, ctrl_bound=self.ctrl_bound, seed=self.seed\n    )\n    self.output = QJL.Output(self.opt, save=self.savefile)\n\n    self.dynamic = QJL.Lindblad(\n        self.freeHamiltonian,\n        self.Hamiltonian_derivative,\n        self.control_Hamiltonian,\n        self.control_coefficients,\n        list(self.psi0),\n        self.tspan,\n        self.decay_opt,\n        self.gamma,\n        )\n\n    system = QJL.QuanEstSystem(\n        self.opt, self.alg, self.obj, self.dynamic, self.output\n    )\n    QJL.run(system)\n\n    max_num = self.max_episode if type(self.max_episode) == int else self.max_episode[0]\n    self.load_save_states(max_num)\n    self.load_save_ctrls(len(self.control_Hamiltonian), max_num)\n    self.load_save_meas(self.dim, max_num)\n</code></pre>"},{"location":"API/python/classes/#quanestimation.ComprehensiveSystem.SM","title":"<code>SM(W=[])</code>","text":"<p>Comprehensive optimization of the probe state and measurement (SM).</p>"},{"location":"API/python/classes/#quanestimation.ComprehensiveSystem.SM--parameters","title":"Parameters","text":"<p>W: <code>matrix</code>     -- Weight matrix.</p> Source code in <code>quanestimation/ComprehensiveOpt/ComprehensiveStruct.py</code> <pre><code>def SM(self, W=[]):\n    \"\"\"\n    Comprehensive optimization of the probe state and measurement (SM).\n\n    Parameters\n    ----------\n    &gt; **W:** `matrix`\n        -- Weight matrix.\n    \"\"\"\n\n    if self.dynamics_type == \"dynamics\":\n        if W == []:\n            W = np.eye(len(self.Hamiltonian_derivative))\n        self.W = W\n\n        if self.Hc == [] or self.ctrl == []:\n            freeHamiltonian = self.freeHamiltonian\n        else:\n            ctrl_num = len(self.ctrl)\n            Hc_num = len(self.control_Hamiltonian)\n            if Hc_num &lt; ctrl_num:\n                raise TypeError(\n                    \"There are %d control Hamiltonians but %d coefficients sequences: \\\n                             too many coefficients sequences.\"\n                    % (Hc_num, ctrl_num)\n                )\n            elif Hc_num &gt; ctrl_num:\n                warnings.warn(\n                    \"Not enough coefficients sequences: there are %d control Hamiltonians \\\n                           but %d coefficients sequences. The rest of the control sequences are\\\n                           set to be 0.\"\n                    % (Hc_num, ctrl_num),\n                    DeprecationWarning,\n                )\n                for i in range(Hc_num - ctrl_num):\n                    self.ctrl = np.concatenate(\n                        (self.ctrl, np.zeros(len(self.ctrl[0])))\n                    )\n            else:\n                pass\n\n            if len(self.ctrl[0]) == 1:\n                if type(self.freeHamiltonian) == np.ndarray:\n                    H0 = np.array(self.freeHamiltonian, dtype=np.complex128)\n                    Hc = [\n                        np.array(x, dtype=np.complex128)\n                        for x in self.control_Hamiltonian\n                    ]\n                    Htot = H0 + sum(\n                        [\n                            self.control_Hamiltonian[i] * self.ctrl[i][0]\n                            for i in range(ctrl_num)\n                        ]\n                    )\n                    freeHamiltonian = np.array(Htot, dtype=np.complex128)\n                else:\n                    H0 = [\n                        np.array(x, dtype=np.complex128)\n                        for x in self.freeHamiltonian\n                    ]\n                    Htot = []\n                    for i in range(len(H0)):\n                        Htot.append(\n                            H0[i]\n                            + sum(\n                                [\n                                    self.control_Hamiltonian[i] * self.ctrl[i][0]\n                                    for i in range(ctrl_num)\n                                ]\n                            )\n                        )\n                    freeHamiltonian = [\n                        np.array(x, dtype=np.complex128) for x in Htot\n                    ]\n            else:\n                if type(self.freeHamiltonian) != np.ndarray:\n                    #### linear interpolation  ####\n                    f = interp1d(self.tspan, self.freeHamiltonian, axis=0)\n                else: pass\n                number = math.ceil((len(self.tspan) - 1) / len(self.ctrl[0]))\n                if len(self.tspan) - 1 % len(self.ctrl[0]) != 0:\n                    tnum = number * len(self.ctrl[0])\n                    self.tspan = np.linspace(\n                        self.tspan[0], self.tspan[-1], tnum + 1\n                    )\n                    if type(self.freeHamiltonian) != np.ndarray:\n                        H0_inter = f(self.tspan)\n                        self.freeHamiltonian = [np.array(x, dtype=np.complex128) for x in H0_inter]\n                    else: pass\n                else: pass\n\n                if type(self.freeHamiltonian) == np.ndarray:\n                    H0 = np.array(self.freeHamiltonian, dtype=np.complex128)\n                    Hc = [\n                        np.array(x, dtype=np.complex128)\n                        for x in self.control_Hamiltonian\n                    ]\n                    self.ctrl = [np.array(self.ctrl[i]).repeat(number) for i in range(len(Hc))]\n                    Htot = []\n                    for i in range(len(self.ctrl[0])):\n                        S_ctrl = sum(\n                            [Hc[j] * self.ctrl[j][i] for j in range(len(self.ctrl))]\n                        )\n                        Htot.append(H0 + S_ctrl)\n                    freeHamiltonian = [\n                        np.array(x, dtype=np.complex128) for x in Htot\n                    ]\n                else:\n                    H0 = [\n                        np.array(x, dtype=np.complex128)\n                        for x in self.freeHamiltonian\n                    ]\n                    Hc = [\n                        np.array(x, dtype=np.complex128)\n                        for x in self.control_Hamiltonian\n                    ]\n                    self.ctrl = [np.array(self.ctrl[i]).repeat(number) for i in range(len(Hc))]\n                    Htot = []\n                    for i in range(len(self.ctrl[0])):\n                        S_ctrl = sum(\n                            [Hc[j] * self.ctrl[j][i] for j in range(len(self.ctrl))]\n                        )\n                        Htot.append(H0[i] + S_ctrl)\n                    freeHamiltonian = [\n                        np.array(x, dtype=np.complex128) for x in Htot\n                    ]\n\n        self.dynamic = QJL.Lindblad(\n            freeHamiltonian,\n            self.Hamiltonian_derivative,\n            list(self.psi0),\n            self.tspan,\n            self.decay_opt,\n            self.gamma,\n            dyn_method = self.dyn_method,\n        )\n    elif self.dynamics_type == \"Kraus\":\n        if W == []:\n            W = np.eye(self.para_num)\n        self.W = W\n    else:\n        raise ValueError(\n            \"Supported type of dynamics are Lindblad and Kraus.\"\n            )\n\n    self.obj = QJL.CFIM_obj([], self.W, self.eps, self.para_type)\n    self.opt = QJL.StateMeasurementOpt(psi=list(self.psi), M=self.C, seed=self.seed)\n    self.output = QJL.Output(self.opt, save=self.savefile)\n\n    system = QJL.QuanEstSystem(\n        self.opt, self.alg, self.obj, self.dynamic, self.output\n    )\n    QJL.run(system)\n\n    max_num = self.max_episode if type(self.max_episode) == int else self.max_episode[0]\n    self.load_save_states(max_num)\n    self.load_save_meas(self.dim, max_num)\n</code></pre>"},{"location":"API/python/classes/#quanestimation.ComprehensiveSystem.dynamics","title":"<code>dynamics(tspan, H0, dH, Hc=[], ctrl=[], decay=[], ctrl_bound=[], dyn_method='expm')</code>","text":"<p>The dynamics of a density matrix is of the form </p> \\[\\begin{align} \\partial_t\\rho &amp;=\\mathcal{L}\\rho \\nonumber \\\\ &amp;=-i[H,\\rho]+\\sum_i \\gamma_i\\left(\\Gamma_i\\rho\\Gamma^{\\dagger}_i-\\frac{1}{2} \\left\\{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\right\\}\\right), \\end{align}\\] <p>where \\(\\rho\\) is the evolved density matrix, H is the Hamiltonian of the  system, \\(\\Gamma_i\\) and \\(\\gamma_i\\) are the \\(i\\mathrm{th}\\) decay  operator and corresponding decay rate.</p>"},{"location":"API/python/classes/#quanestimation.ComprehensiveSystem.dynamics--parameters","title":"Parameters","text":"<p>tspan: <code>array</code>     -- Time length for the evolution.</p> <p>H0: <code>matrix or list</code>     -- Free Hamiltonian. It is a matrix when the free Hamiltonian is time-     independent and a list of length equal to <code>tspan</code> when it is time-dependent.</p> <p>dH: <code>list</code>     -- Derivatives of the free Hamiltonian on the unknown parameters to be      estimated. For example, dH[0] is the derivative vector on the first      parameter.</p> <p>Hc: <code>list</code>     -- Control Hamiltonians.</p> <p>ctrl: <code>list of arrays</code>     -- Control coefficients.</p> <p>decay: <code>list</code>     -- Decay operators and the corresponding decay rates. Its input rule is      decay=[[\\(\\Gamma_1\\), \\(\\gamma_1\\)], [\\(\\Gamma_2\\),\\(\\gamma_2\\)],...], where \\(\\Gamma_1\\) \\((\\Gamma_2)\\) represents the decay operator and \\(\\gamma_1\\) \\((\\gamma_2)\\) is the      corresponding decay rate.</p> <p>ctrl_bound: <code>array</code>     -- Lower and upper bounds of the control coefficients.     <code>ctrl_bound[0]</code> represents the lower bound of the control coefficients and     <code>ctrl_bound[1]</code> represents the upper bound of the control coefficients.</p> <p>dyn_method: <code>string</code>     -- Setting the method for solving the Lindblad dynamics. Options are:     \"expm\" (default) -- Matrix exponential.     \"ode\" -- Solving the differential equations directly.</p> Source code in <code>quanestimation/ComprehensiveOpt/ComprehensiveStruct.py</code> <pre><code>def dynamics(self, tspan, H0, dH, Hc=[], ctrl=[], decay=[], ctrl_bound=[], dyn_method=\"expm\"):\n    r\"\"\"\n    The dynamics of a density matrix is of the form \n\n    \\begin{align}\n    \\partial_t\\rho &amp;=\\mathcal{L}\\rho \\nonumber \\\\\n    &amp;=-i[H,\\rho]+\\sum_i \\gamma_i\\left(\\Gamma_i\\rho\\Gamma^{\\dagger}_i-\\frac{1}{2}\n    \\left\\{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\right\\}\\right),\n    \\end{align} \n\n    where $\\rho$ is the evolved density matrix, H is the Hamiltonian of the \n    system, $\\Gamma_i$ and $\\gamma_i$ are the $i\\mathrm{th}$ decay \n    operator and corresponding decay rate.\n\n    Parameters\n    ----------\n    &gt; **tspan:** `array`\n        -- Time length for the evolution.\n\n    &gt; **H0:** `matrix or list`\n        -- Free Hamiltonian. It is a matrix when the free Hamiltonian is time-\n        independent and a list of length equal to `tspan` when it is time-dependent.\n\n    &gt; **dH:** `list`\n        -- Derivatives of the free Hamiltonian on the unknown parameters to be \n        estimated. For example, dH[0] is the derivative vector on the first \n        parameter.\n\n    &gt; **Hc:** `list`\n        -- Control Hamiltonians.\n\n    &gt; **ctrl:** `list of arrays`\n        -- Control coefficients.\n\n    &gt; **decay:** `list`\n        -- Decay operators and the corresponding decay rates. Its input rule is \n        decay=[[$\\Gamma_1$, $\\gamma_1$], [$\\Gamma_2$,$\\gamma_2$],...], where $\\Gamma_1$ \n        $(\\Gamma_2)$ represents the decay operator and $\\gamma_1$ $(\\gamma_2)$ is the \n        corresponding decay rate.\n\n    &gt; **ctrl_bound:** `array`\n        -- Lower and upper bounds of the control coefficients.\n        `ctrl_bound[0]` represents the lower bound of the control coefficients and\n        `ctrl_bound[1]` represents the upper bound of the control coefficients.\n\n    &gt; **dyn_method:** `string`\n        -- Setting the method for solving the Lindblad dynamics. Options are:  \n        \"expm\" (default) -- Matrix exponential.  \n        \"ode\" -- Solving the differential equations directly. \n    \"\"\"\n\n    self.tspan = tspan\n    self.ctrl = ctrl\n    self.Hc = Hc\n\n    if dyn_method == \"expm\":\n        self.dyn_method = \"Expm\"\n    elif dyn_method == \"ode\":\n        self.dyn_method = \"Ode\"\n\n    if type(H0) == np.ndarray:\n        self.freeHamiltonian = np.array(H0, dtype=np.complex128)\n        self.dim = len(self.freeHamiltonian)\n    else:\n        self.freeHamiltonian = [np.array(x, dtype=np.complex128) for x in H0[:-1]]\n        self.dim = len(self.freeHamiltonian[0])\n\n    QJLType_psi = QJL.Vector[QJL.Vector[QJL.ComplexF64]]\n    if self.psi0 == []:\n        np.random.seed(self.seed)\n        r_ini = 2 * np.random.random(self.dim) - np.ones(self.dim)\n        r = r_ini / np.linalg.norm(r_ini)\n        phi = 2 * np.pi * np.random.random(self.dim)\n        psi = np.array([r[i] * np.exp(1.0j * phi[i]) for i in range(self.dim)])\n        self.psi0 = np.array(psi)\n        self.psi = QJL.convert(QJLType_psi, [self.psi0]) # Initial guesses of states (a list of arrays)\n    else:\n        self.psi0 = np.array(self.psi0[0], dtype=np.complex128)\n        self.psi = QJL.convert(QJLType_psi, self.psi)\n\n    if Hc == []:\n        Hc = [np.zeros((self.dim, self.dim))]\n    self.control_Hamiltonian = [np.array(x, dtype=np.complex128) for x in Hc]\n\n    if type(dH) != list:\n        raise TypeError(\"The derivative of Hamiltonian should be a list!\")\n\n    if dH == []:\n        dH = [np.zeros((self.dim, self.dim))]\n    self.Hamiltonian_derivative = [np.array(x, dtype=np.complex128) for x in dH]\n\n    if len(dH) == 1:\n        self.para_type = \"single_para\"\n    else:\n        self.para_type = \"multi_para\"\n\n    if decay == []:\n        decay_opt = [np.zeros((self.dim, self.dim))]\n        self.gamma = [0.0]\n    else:\n        decay_opt = [decay[i][0] for i in range(len(decay))]\n        self.gamma = [decay[i][1] for i in range(len(decay))]\n    self.decay_opt = [np.array(x, dtype=np.complex128) for x in decay_opt]\n\n    if ctrl_bound == []:\n        self.ctrl_bound = [-np.inf, np.inf]\n    else:\n        self.ctrl_bound = [float(ctrl_bound[0]), float(ctrl_bound[1])]\n\n    if self.ctrl0 == []:\n        if ctrl_bound == []:\n            ctrl0 = [\n                2 * np.random.random(len(self.tspan) - 1)\n                - np.ones(len(self.tspan) - 1)\n                for i in range(len(self.control_Hamiltonian))\n            ]\n        else:\n            a = ctrl_bound[0]\n            b = ctrl_bound[1]\n            ctrl0 = [\n                (b - a) * np.random.random(len(self.tspan) - 1)\n                + a * np.ones(len(self.tspan) - 1)\n                for i in range(len(self.control_Hamiltonian))\n            ]\n        self.control_coefficients = ctrl0\n        self.ctrl0 = [np.array(ctrl0)]\n\n    elif len(self.ctrl0) &gt;= 1:\n        self.control_coefficients = [\n            self.ctrl0[0][i] for i in range(len(self.control_Hamiltonian))\n        ]\n\n    ctrl_num = len(self.control_coefficients)\n    Hc_num = len(self.control_Hamiltonian)\n    if Hc_num &lt; ctrl_num:\n        raise TypeError(\n            \"There are %d control Hamiltonians but %d coefficients sequences: \\\n                            too many coefficients sequences\"\n            % (Hc_num, ctrl_num)\n        )\n    elif Hc_num &gt; ctrl_num:\n        warnings.warn(\n            \"Not enough coefficients sequences: there are %d control Hamiltonians \\\n                        but %d coefficients sequences. The rest of the control sequences are\\\n                        set to be 0.\"\n            % (Hc_num, ctrl_num),\n            DeprecationWarning,\n        )\n        for i in range(Hc_num - ctrl_num):\n            self.control_coefficients = np.concatenate(\n                (\n                    self.control_coefficients,\n                    np.zeros(len(self.control_coefficients[0])),\n                )\n            )\n    else: pass\n\n    # ## TODO\n    QJLType_ctrl = QJL.Vector[QJL.Vector[QJL.Vector[QJL.Float64]]] \n    self.ctrl0 = QJL.convert(QJLType_ctrl, [[c for c in ctrls ]for ctrls in self.ctrl0])\n\n    QJLType_C = QJL.Vector[QJL.Vector[QJL.ComplexF64]]\n    if self.measurement0 == []:\n        np.random.seed(self.seed)\n        M = [[] for i in range(self.dim)]\n        for i in range(self.dim):\n            r_ini = 2 * np.random.random(self.dim) - np.ones(self.dim)\n            r = r_ini / np.linalg.norm(r_ini)\n            phi = 2 * np.pi * np.random.random(self.dim)\n            M[i] = [r[j] * np.exp(1.0j * phi[j]) for j in range(self.dim)]\n        self.C = QJL.convert(QJLType_C, gramschmidt(np.array(M)))\n        self.measurement0 = QJL.Vector([self.C])\n    else:\n        self.C = [self.measurement0[0][i] for i in range(len(self.rho0))]\n        self.C = QJL.convert(QJLType_C, self.C)\n        self.measurement0 = QJL.Vector([self.C])\n\n    if type(H0) != np.ndarray:\n        #### linear interpolation  ####\n        f = interp1d(self.tspan, H0, axis=0)\n    else: pass\n    number = math.ceil((len(self.tspan) - 1) / len(self.control_coefficients[0]))\n    if len(self.tspan) - 1 % len(self.control_coefficients[0]) != 0:\n        tnum = number * len(self.control_coefficients[0])\n        self.tspan = np.linspace(self.tspan[0], self.tspan[-1], tnum + 1)\n        if type(H0) != np.ndarray:\n            H0_inter = f(self.tspan)\n            self.freeHamiltonian = [np.array(x, dtype=np.complex128) for x in H0_inter[:-1]]\n        else: pass\n    else: pass\n\n    self.dynamics_type = \"dynamics\"\n</code></pre>"},{"location":"API/python/classes/#comprehensive-optimization-with-ad","title":"Comprehensive optimization with AD","text":"<p>             Bases: <code>ComprehensiveSystem</code></p>"},{"location":"API/python/classes/#quanestimation.AD_Compopt--attributes","title":"Attributes","text":"<p>savefile: <code>bool</code>     -- Whether or not to save all the optimized variables (probe states,      control coefficients and measurements).     If set <code>True</code> then the optimized variables and the values of the      objective function obtained in all episodes will be saved during      the training. If set <code>False</code> the optimized variables in the final      episode and the values of the objective function in all episodes      will be saved.</p> <p>Adam: <code>bool</code>     -- Whether or not to use Adam for updating.</p> <p>psi0: <code>list of arrays</code>     -- Initial guesses of states.</p> <p>ctrl0: <code>list of arrays</code>     -- Initial guesses of control coefficients.</p> <p>measurement0: <code>list of arrays</code>     -- Initial guesses of measurements.</p> <p>max_episode: <code>int</code>     -- The number of episodes.</p> <p>epsilon: <code>float</code>     -- Learning rate.</p> <p>beta1: <code>float</code>     -- The exponential decay rate for the first moment estimates.</p> <p>beta2: <code>float</code>     -- The exponential decay rate for the second moment estimates.</p> <p>seed: <code>int</code>     -- Random seed.</p> <p>eps: <code>float</code>     -- Machine epsilon.</p> Source code in <code>quanestimation/ComprehensiveOpt/AD_Compopt.py</code> <pre><code>class AD_Compopt(Comp.ComprehensiveSystem):\n    \"\"\"\n    Attributes\n    ----------\n    &gt; **savefile:** `bool`\n        -- Whether or not to save all the optimized variables (probe states, \n        control coefficients and measurements).  \n        If set `True` then the optimized variables and the values of the \n        objective function obtained in all episodes will be saved during \n        the training. If set `False` the optimized variables in the final \n        episode and the values of the objective function in all episodes \n        will be saved.\n\n    &gt; **Adam:** `bool`\n        -- Whether or not to use Adam for updating.\n\n    &gt; **psi0:** `list of arrays`\n        -- Initial guesses of states.\n\n    &gt; **ctrl0:** `list of arrays`\n        -- Initial guesses of control coefficients.\n\n    &gt; **measurement0:** `list of arrays`\n        -- Initial guesses of measurements.\n\n    &gt; **max_episode:** `int`\n        -- The number of episodes.\n\n    &gt; **epsilon:** `float`\n        -- Learning rate.\n\n    &gt; **beta1:** `float`\n        -- The exponential decay rate for the first moment estimates.\n\n    &gt; **beta2:** `float`\n        -- The exponential decay rate for the second moment estimates.\n\n    &gt; **seed:** `int`\n        -- Random seed.\n\n    &gt; **eps:** `float`\n        -- Machine epsilon.\n    \"\"\"\n    def __init__(\n        self,\n        savefile=False,\n        Adam=False,\n        psi0=[],\n        ctrl0=[],\n        measurement0=[],\n        max_episode=300,\n        epsilon=0.01,\n        beta1=0.90,\n        beta2=0.99,\n        seed=1234,\n        eps=1e-8,\n    ):\n\n        Comp.ComprehensiveSystem.__init__(\n            self, savefile, psi0, ctrl0, measurement0, seed, eps\n        )\n\n        self.Adam = Adam\n        self.max_episode = max_episode\n        self.epsilon = epsilon\n        self.beta1 = beta1\n        self.beta2 = beta2\n        self.mt = 0.0\n        self.vt = 0.0\n        self.seed = seed\n\n    def SC(self, W=[], M=[], target=\"QFIM\", LDtype=\"SLD\"):\n        \"\"\"\n        Comprehensive optimization of the probe state and control (SC).\n\n        Parameters\n        ----------\n        &gt; **W:** `matrix`\n            -- Weight matrix.\n\n        &gt; **M:** `list of matrices`\n            -- A set of positive operator-valued measure (POVM). The default measurement \n            is a set of rank-one symmetric informationally complete POVM (SIC-POVM).\n\n        &gt; **target:** `string`\n            -- Objective functions for searching the minimum time to reach the given \n            value of the objective function. Options are:  \n            \"QFIM\" (default) -- choose QFI (QFIM) as the objective function.  \n            \"CFIM\" -- choose CFI (CFIM) as the objective function.  \n            \"HCRB\" -- choose HCRB as the objective function.  \n\n        &gt; **LDtype:** `string`\n            -- Types of QFI (QFIM) can be set as the objective function. Options are:  \n            \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD).  \n            \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD).  \n            \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). \n\n        **Note:** AD is only available when target is 'QFIM'.\n        \"\"\"\n        if M != []:\n            raise ValueError(\n                \"AD is not available when target is 'CFIM'. Supported methods are 'PSO' and 'DE'.\",\n            )\n        elif target == \"HCRB\":\n            raise ValueError(\n                \"AD is not available when the target function is HCRB. Supported methods are 'PSO' and 'DE'.\",\n            )\n\n        if self.Adam:\n            self.alg = QJL.QuanEstimation.AD(\n                self.max_episode, self.epsilon, self.beta1, self.beta2\n            )\n        else:\n            self.alg = QJL.QuanEstimation.AD(self.max_episode, self.epsilon)\n\n        super().SC(W, M, target, LDtype)\n</code></pre>"},{"location":"API/python/classes/#quanestimation.AD_Compopt.SC","title":"<code>SC(W=[], M=[], target='QFIM', LDtype='SLD')</code>","text":"<p>Comprehensive optimization of the probe state and control (SC).</p>"},{"location":"API/python/classes/#quanestimation.AD_Compopt.SC--parameters","title":"Parameters","text":"<p>W: <code>matrix</code>     -- Weight matrix.</p> <p>M: <code>list of matrices</code>     -- A set of positive operator-valued measure (POVM). The default measurement      is a set of rank-one symmetric informationally complete POVM (SIC-POVM).</p> <p>target: <code>string</code>     -- Objective functions for searching the minimum time to reach the given      value of the objective function. Options are:     \"QFIM\" (default) -- choose QFI (QFIM) as the objective function.     \"CFIM\" -- choose CFI (CFIM) as the objective function.     \"HCRB\" -- choose HCRB as the objective function.  </p> <p>LDtype: <code>string</code>     -- Types of QFI (QFIM) can be set as the objective function. Options are:     \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD).     \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD).     \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). </p> <p>Note: AD is only available when target is 'QFIM'.</p> Source code in <code>quanestimation/ComprehensiveOpt/AD_Compopt.py</code> <pre><code>def SC(self, W=[], M=[], target=\"QFIM\", LDtype=\"SLD\"):\n    \"\"\"\n    Comprehensive optimization of the probe state and control (SC).\n\n    Parameters\n    ----------\n    &gt; **W:** `matrix`\n        -- Weight matrix.\n\n    &gt; **M:** `list of matrices`\n        -- A set of positive operator-valued measure (POVM). The default measurement \n        is a set of rank-one symmetric informationally complete POVM (SIC-POVM).\n\n    &gt; **target:** `string`\n        -- Objective functions for searching the minimum time to reach the given \n        value of the objective function. Options are:  \n        \"QFIM\" (default) -- choose QFI (QFIM) as the objective function.  \n        \"CFIM\" -- choose CFI (CFIM) as the objective function.  \n        \"HCRB\" -- choose HCRB as the objective function.  \n\n    &gt; **LDtype:** `string`\n        -- Types of QFI (QFIM) can be set as the objective function. Options are:  \n        \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD).  \n        \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD).  \n        \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). \n\n    **Note:** AD is only available when target is 'QFIM'.\n    \"\"\"\n    if M != []:\n        raise ValueError(\n            \"AD is not available when target is 'CFIM'. Supported methods are 'PSO' and 'DE'.\",\n        )\n    elif target == \"HCRB\":\n        raise ValueError(\n            \"AD is not available when the target function is HCRB. Supported methods are 'PSO' and 'DE'.\",\n        )\n\n    if self.Adam:\n        self.alg = QJL.QuanEstimation.AD(\n            self.max_episode, self.epsilon, self.beta1, self.beta2\n        )\n    else:\n        self.alg = QJL.QuanEstimation.AD(self.max_episode, self.epsilon)\n\n    super().SC(W, M, target, LDtype)\n</code></pre>"},{"location":"API/python/classes/#comprehensive-optimization-with-pso","title":"Comprehensive Optimization with PSO","text":"<p>             Bases: <code>ComprehensiveSystem</code></p>"},{"location":"API/python/classes/#quanestimation.PSO_Compopt--attributes","title":"Attributes","text":"<p>savefile: <code>bool</code>     -- Whether or not to save all the optimized variables (probe states,      control coefficients and measurements).     If set <code>True</code> then the optimized variables and the values of the      objective function obtained in all episodes will be saved during      the training. If set <code>False</code> the optimized variables in the final      episode and the values of the objective function in all episodes      will be saved.</p> <p>p_num: <code>int</code>     -- The number of particles.</p> <p>psi0: <code>list of arrays</code>     -- Initial guesses of states.</p> <p>ctrl0: <code>list of arrays</code>     -- Initial guesses of control coefficients.</p> <p>measurement0: <code>list of arrays</code>     -- Initial guesses of measurements.</p> <p>max_episode: <code>int or list</code>     -- If it is an integer, for example max_episode=1000, it means the      program will continuously run 1000 episodes. However, if it is an     array, for example max_episode=[1000,100], the program will run      1000 episodes in total but replace states of all  the particles      with global best every 100 episodes.</p> <p>c0: <code>float</code>     -- The damping factor that assists convergence, also known as inertia weight.</p> <p>c1: <code>float</code>     -- The exploitation weight that attracts the particle to its best previous      position, also known as cognitive learning factor.</p> <p>c2: <code>float</code>     -- The exploitation weight that attracts the particle to the best position     in the neighborhood, also known as social learning factor.</p> <p>seed: <code>int</code>     -- Random seed.</p> <p>eps: <code>float</code>     -- Machine epsilon.</p> Source code in <code>quanestimation/ComprehensiveOpt/PSO_Compopt.py</code> <pre><code>class PSO_Compopt(Comp.ComprehensiveSystem):\n    \"\"\"\n    Attributes\n    ----------\n    &gt; **savefile:** `bool`\n        -- Whether or not to save all the optimized variables (probe states, \n        control coefficients and measurements).  \n        If set `True` then the optimized variables and the values of the \n        objective function obtained in all episodes will be saved during \n        the training. If set `False` the optimized variables in the final \n        episode and the values of the objective function in all episodes \n        will be saved.\n\n    &gt; **p_num:** `int`\n        -- The number of particles.\n\n    &gt; **psi0:** `list of arrays`\n        -- Initial guesses of states.\n\n    &gt; **ctrl0:** `list of arrays`\n        -- Initial guesses of control coefficients.\n\n    &gt; **measurement0:** `list of arrays`\n        -- Initial guesses of measurements.\n\n    &gt; **max_episode:** `int or list`\n        -- If it is an integer, for example max_episode=1000, it means the \n        program will continuously run 1000 episodes. However, if it is an\n        array, for example max_episode=[1000,100], the program will run \n        1000 episodes in total but replace states of all  the particles \n        with global best every 100 episodes.\n\n    &gt; **c0:** `float`\n        -- The damping factor that assists convergence, also known as inertia weight.\n\n    &gt; **c1:** `float`\n        -- The exploitation weight that attracts the particle to its best previous \n        position, also known as cognitive learning factor.\n\n    &gt; **c2:** `float`\n        -- The exploitation weight that attracts the particle to the best position  \n        in the neighborhood, also known as social learning factor.\n\n    &gt; **seed:** `int`\n        -- Random seed.\n\n    &gt; **eps:** `float`\n        -- Machine epsilon.\n    \"\"\"\n\n    def __init__(\n        self,\n        savefile=False,\n        p_num=10,\n        psi0=[],\n        ctrl0=[],\n        measurement0=[],\n        max_episode=[1000, 100],\n        c0=1.0,\n        c1=2.0,\n        c2=2.0,\n        seed=1234,\n        eps=1e-8,\n    ):\n\n        Comp.ComprehensiveSystem.__init__(\n            self, savefile, psi0, ctrl0, measurement0, seed, eps\n        )\n\n        self.p_num = p_num\n        self.max_episode = max_episode\n        self.c0 = c0\n        self.c1 = c1\n        self.c2 = c2\n        self.seed = seed\n\n    def SC(self, W=[], M=[], target=\"QFIM\", LDtype=\"SLD\"):\n        \"\"\"\n        Comprehensive optimization of the probe state and control (SC).\n\n        Parameters\n        ----------\n        &gt; **W:** `matrix`\n            -- Weight matrix.\n\n        &gt; **M:** `list of matrices`\n            -- A set of positive operator-valued measure (POVM). The default measurement \n            is a set of rank-one symmetric informationally complete POVM (SIC-POVM).\n\n        &gt; **target:** `string`\n            -- Objective functions for searching the minimum time to reach the given \n            value of the objective function. Options are:  \n            \"QFIM\" (default) -- choose QFI (QFIM) as the objective function.  \n            \"CFIM\" -- choose CFI (CFIM) as the objective function.  \n            \"HCRB\" -- choose HCRB as the objective function.  \n\n        &gt; **LDtype:** `string`\n            -- Types of QFI (QFIM) can be set as the objective function. Options are:  \n            \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD).  \n            \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD).  \n            \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). \n\n        **Note:** \n            SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state \n            which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/\n            solutions.html).\n        \"\"\"\n        ini_particle = (\n            self.psi, \n            self.ctrl0\n       )\n\n        self.alg = QJL.PSO(\n            QJL.Vector[QJL.Int64](self.max_episode),\n            self.p_num,\n            ini_particle,\n            self.c0,\n            self.c1,\n            self.c2,\n        )\n        super().SC(W, M, target, LDtype)\n\n    def CM(self, rho0, W=[]):\n        \"\"\"\n        Comprehensive optimization of the control and measurement (CM).\n\n        Parameters\n        ----------\n        &gt; **rho0:** `matrix`\n            -- Initial state (density matrix).\n\n        &gt; **W:** `matrix`\n            -- Weight matrix.\n        \"\"\"\n        ini_particle = (self.ctrl0, self.measurement0)\n        self.alg = QJL.PSO(\n            QJL.Vector[QJL.Int64](self.max_episode),\n            self.p_num,\n            ini_particle,\n            self.c0,\n            self.c1,\n            self.c2,\n        )\n\n        super().CM(rho0, W)\n\n    def SM(self, W=[]):\n        \"\"\"\n        Comprehensive optimization of the probe state and measurement (SM).\n\n        Parameters\n        ----------\n        &gt; **W:** `matrix`\n            -- Weight matrix.\n        \"\"\"\n        ini_particle = (self.psi, self.measurement0)\n        self.alg = QJL.PSO(\n            QJL.Vector[QJL.Int64](self.max_episode),\n            self.p_num,\n            ini_particle,\n            self.c0,\n            self.c1,\n            self.c2,\n        )\n\n        super().SM(W)\n\n    def SCM(self, W=[]):\n        \"\"\"\n        Comprehensive optimization of the probe state, the control and measurements (SCM).\n\n        Parameters\n        ----------\n        &gt; **W:** `matrix`\n            -- Weight matrix.\n        \"\"\"\n        ini_particle = (self.psi, self.ctrl0, self.measurement0)\n        self.alg = QJL.PSO(\n            QJL.Vector[QJL.Int64](self.max_episode),\n            self.p_num,\n            ini_particle,\n            self.c0,\n            self.c1,\n            self.c2,\n        )\n\n        super().SCM(W)\n</code></pre>"},{"location":"API/python/classes/#quanestimation.PSO_Compopt.CM","title":"<code>CM(rho0, W=[])</code>","text":"<p>Comprehensive optimization of the control and measurement (CM).</p>"},{"location":"API/python/classes/#quanestimation.PSO_Compopt.CM--parameters","title":"Parameters","text":"<p>rho0: <code>matrix</code>     -- Initial state (density matrix).</p> <p>W: <code>matrix</code>     -- Weight matrix.</p> Source code in <code>quanestimation/ComprehensiveOpt/PSO_Compopt.py</code> <pre><code>def CM(self, rho0, W=[]):\n    \"\"\"\n    Comprehensive optimization of the control and measurement (CM).\n\n    Parameters\n    ----------\n    &gt; **rho0:** `matrix`\n        -- Initial state (density matrix).\n\n    &gt; **W:** `matrix`\n        -- Weight matrix.\n    \"\"\"\n    ini_particle = (self.ctrl0, self.measurement0)\n    self.alg = QJL.PSO(\n        QJL.Vector[QJL.Int64](self.max_episode),\n        self.p_num,\n        ini_particle,\n        self.c0,\n        self.c1,\n        self.c2,\n    )\n\n    super().CM(rho0, W)\n</code></pre>"},{"location":"API/python/classes/#quanestimation.PSO_Compopt.SC","title":"<code>SC(W=[], M=[], target='QFIM', LDtype='SLD')</code>","text":"<p>Comprehensive optimization of the probe state and control (SC).</p>"},{"location":"API/python/classes/#quanestimation.PSO_Compopt.SC--parameters","title":"Parameters","text":"<p>W: <code>matrix</code>     -- Weight matrix.</p> <p>M: <code>list of matrices</code>     -- A set of positive operator-valued measure (POVM). The default measurement      is a set of rank-one symmetric informationally complete POVM (SIC-POVM).</p> <p>target: <code>string</code>     -- Objective functions for searching the minimum time to reach the given      value of the objective function. Options are:     \"QFIM\" (default) -- choose QFI (QFIM) as the objective function.     \"CFIM\" -- choose CFI (CFIM) as the objective function.     \"HCRB\" -- choose HCRB as the objective function.  </p> <p>LDtype: <code>string</code>     -- Types of QFI (QFIM) can be set as the objective function. Options are:     \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD).     \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD).     \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). </p> <p>Note:      SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state      which can be downloaded from here.</p> Source code in <code>quanestimation/ComprehensiveOpt/PSO_Compopt.py</code> <pre><code>def SC(self, W=[], M=[], target=\"QFIM\", LDtype=\"SLD\"):\n    \"\"\"\n    Comprehensive optimization of the probe state and control (SC).\n\n    Parameters\n    ----------\n    &gt; **W:** `matrix`\n        -- Weight matrix.\n\n    &gt; **M:** `list of matrices`\n        -- A set of positive operator-valued measure (POVM). The default measurement \n        is a set of rank-one symmetric informationally complete POVM (SIC-POVM).\n\n    &gt; **target:** `string`\n        -- Objective functions for searching the minimum time to reach the given \n        value of the objective function. Options are:  \n        \"QFIM\" (default) -- choose QFI (QFIM) as the objective function.  \n        \"CFIM\" -- choose CFI (CFIM) as the objective function.  \n        \"HCRB\" -- choose HCRB as the objective function.  \n\n    &gt; **LDtype:** `string`\n        -- Types of QFI (QFIM) can be set as the objective function. Options are:  \n        \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD).  \n        \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD).  \n        \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). \n\n    **Note:** \n        SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state \n        which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/\n        solutions.html).\n    \"\"\"\n    ini_particle = (\n        self.psi, \n        self.ctrl0\n   )\n\n    self.alg = QJL.PSO(\n        QJL.Vector[QJL.Int64](self.max_episode),\n        self.p_num,\n        ini_particle,\n        self.c0,\n        self.c1,\n        self.c2,\n    )\n    super().SC(W, M, target, LDtype)\n</code></pre>"},{"location":"API/python/classes/#quanestimation.PSO_Compopt.SCM","title":"<code>SCM(W=[])</code>","text":"<p>Comprehensive optimization of the probe state, the control and measurements (SCM).</p>"},{"location":"API/python/classes/#quanestimation.PSO_Compopt.SCM--parameters","title":"Parameters","text":"<p>W: <code>matrix</code>     -- Weight matrix.</p> Source code in <code>quanestimation/ComprehensiveOpt/PSO_Compopt.py</code> <pre><code>def SCM(self, W=[]):\n    \"\"\"\n    Comprehensive optimization of the probe state, the control and measurements (SCM).\n\n    Parameters\n    ----------\n    &gt; **W:** `matrix`\n        -- Weight matrix.\n    \"\"\"\n    ini_particle = (self.psi, self.ctrl0, self.measurement0)\n    self.alg = QJL.PSO(\n        QJL.Vector[QJL.Int64](self.max_episode),\n        self.p_num,\n        ini_particle,\n        self.c0,\n        self.c1,\n        self.c2,\n    )\n\n    super().SCM(W)\n</code></pre>"},{"location":"API/python/classes/#quanestimation.PSO_Compopt.SM","title":"<code>SM(W=[])</code>","text":"<p>Comprehensive optimization of the probe state and measurement (SM).</p>"},{"location":"API/python/classes/#quanestimation.PSO_Compopt.SM--parameters","title":"Parameters","text":"<p>W: <code>matrix</code>     -- Weight matrix.</p> Source code in <code>quanestimation/ComprehensiveOpt/PSO_Compopt.py</code> <pre><code>def SM(self, W=[]):\n    \"\"\"\n    Comprehensive optimization of the probe state and measurement (SM).\n\n    Parameters\n    ----------\n    &gt; **W:** `matrix`\n        -- Weight matrix.\n    \"\"\"\n    ini_particle = (self.psi, self.measurement0)\n    self.alg = QJL.PSO(\n        QJL.Vector[QJL.Int64](self.max_episode),\n        self.p_num,\n        ini_particle,\n        self.c0,\n        self.c1,\n        self.c2,\n    )\n\n    super().SM(W)\n</code></pre>"},{"location":"API/python/classes/#comprehensive-optimization-with-de","title":"Comprehensive Optimization with DE","text":"<p>             Bases: <code>ComprehensiveSystem</code></p>"},{"location":"API/python/classes/#quanestimation.DE_Compopt--attributes","title":"Attributes","text":"<p>savefile: <code>bool</code>     -- Whether or not to save all the optimized variables (probe states,      control coefficients and measurements).     If set <code>True</code> then the optimized variables and the values of the      objective function obtained in all episodes will be saved during      the training. If set <code>False</code> the optimized variables in the final      episode and the values of the objective function in all episodes      will be saved.</p> <p>p_num: <code>int</code>     -- The number of populations.</p> <p>psi0: <code>list of arrays</code>     -- Initial guesses of states.</p> <p>ctrl0: <code>list of arrays</code>     -- Initial guesses of control coefficients.</p> <p>measurement0: <code>list of arrays</code>     -- Initial guesses of measurements.</p> <p>max_episode: <code>int</code>     -- The number of episodes.</p> <p>c: <code>float</code>     -- Mutation constant.</p> <p>cr: <code>float</code>     -- Crossover constant.</p> <p>seed: <code>int</code>     -- Random seed.</p> <p>eps: <code>float</code>     -- Machine epsilon.</p> Source code in <code>quanestimation/ComprehensiveOpt/DE_Compopt.py</code> <pre><code>class DE_Compopt(Comp.ComprehensiveSystem):\n    \"\"\"\n    Attributes\n    ----------\n    &gt; **savefile:** `bool`\n        -- Whether or not to save all the optimized variables (probe states, \n        control coefficients and measurements).  \n        If set `True` then the optimized variables and the values of the \n        objective function obtained in all episodes will be saved during \n        the training. If set `False` the optimized variables in the final \n        episode and the values of the objective function in all episodes \n        will be saved.\n\n    &gt; **p_num:** `int`\n        -- The number of populations.\n\n    &gt; **psi0:** `list of arrays`\n        -- Initial guesses of states.\n\n    &gt; **ctrl0:** `list of arrays`\n        -- Initial guesses of control coefficients.\n\n    &gt; **measurement0:** `list of arrays`\n        -- Initial guesses of measurements.\n\n    &gt; **max_episode:** `int`\n        -- The number of episodes.\n\n    &gt; **c:** `float`\n        -- Mutation constant.\n\n    &gt; **cr:** `float`\n        -- Crossover constant.\n\n    &gt; **seed:** `int`\n        -- Random seed.\n\n    &gt; **eps:** `float`\n        -- Machine epsilon.\n    \"\"\"\n    def __init__(\n        self,\n        savefile=False,\n        p_num=10,\n        psi0=[],\n        ctrl0=[],\n        measurement0=[],\n        max_episode=1000,\n        c=1.0,\n        cr=0.5,\n        seed=1234,\n        eps=1e-8,\n    ):\n\n        Comp.ComprehensiveSystem.__init__(\n            self, savefile, psi0, ctrl0, measurement0, seed, eps\n        )\n\n        self.p_num = p_num\n        self.max_episode = max_episode\n        self.c = c\n        self.cr = cr\n        self.seed = seed\n\n    def SC(self, W=[], M=[], target=\"QFIM\", LDtype=\"SLD\"):\n        \"\"\"\n        Comprehensive optimization of the probe state and control (SC).\n\n        Parameters\n        ----------\n        &gt; **W:** `matrix`\n            -- Weight matrix.\n\n        &gt; **M:** `list of matrices`\n            -- A set of positive operator-valued measure (POVM). The default measurement \n            is a set of rank-one symmetric informationally complete POVM (SIC-POVM).\n\n        &gt; **target:** `string`\n            -- Objective functions for searching the minimum time to reach the given \n            value of the objective function. Options are:  \n            \"QFIM\" (default) -- choose QFI (QFIM) as the objective function.  \n            \"CFIM\" -- choose CFI (CFIM) as the objective function.  \n            \"HCRB\" -- choose HCRB as the objective function.  \n\n        &gt; **LDtype:** `string`\n            -- Types of QFI (QFIM) can be set as the objective function. Options are:  \n            \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD).  \n            \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD).  \n            \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). \n\n        **Note:** \n            SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state \n            which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/\n            solutions.html).\n        \"\"\"\n        ini_population = (self.psi, self.ctrl0)\n        self.alg = QJL.DE(\n            self.max_episode,\n            self.p_num,\n            ini_population,\n            self.c,\n            self.cr,\n        )\n\n        super().SC(W, M, target, LDtype)\n\n    def CM(self, rho0, W=[]):\n        \"\"\"\n        Comprehensive optimization of the control and measurement (CM).\n\n        Parameters\n        ----------\n        &gt; **rho0:** `matrix`\n            -- Initial state (density matrix).\n\n        &gt; **W:** `matrix`\n            -- Weight matrix.\n        \"\"\"\n        ini_population = (self.ctrl0, self.measurement0)\n        self.alg = QJL.DE(\n            self.max_episode,\n            self.p_num,\n            ini_population,\n            self.c,\n            self.cr,\n        )\n\n        super().CM(rho0, W)\n\n    def SM(self, W=[]):\n        \"\"\"\n        Comprehensive optimization of the probe state and measurement (SM).\n\n        Parameters\n        ----------\n        &gt; **W:** `matrix`\n            -- Weight matrix.\n        \"\"\"\n        ini_population = (self.psi, self.measurement0)\n        self.alg = QJL.DE(\n            self.max_episode,\n            self.p_num,\n            ini_population,\n            self.c,\n            self.cr,\n        )\n\n        super().SM(W)\n\n    def SCM(self, W=[]):\n        \"\"\"\n        Comprehensive optimization of the probe state, control and measurement (SCM).\n\n        Parameters\n        ----------\n        &gt; **W:** `matrix`\n            -- Weight matrix.\n        \"\"\"\n        ini_population = (self.psi, self.ctrl0, self.measurement0)\n        self.alg = QJL.DE(\n            self.max_episode,\n            self.p_num,\n            ini_population,\n            self.c,\n            self.cr,\n        )\n\n        super().SCM(W)\n</code></pre>"},{"location":"API/python/classes/#quanestimation.DE_Compopt.CM","title":"<code>CM(rho0, W=[])</code>","text":"<p>Comprehensive optimization of the control and measurement (CM).</p>"},{"location":"API/python/classes/#quanestimation.DE_Compopt.CM--parameters","title":"Parameters","text":"<p>rho0: <code>matrix</code>     -- Initial state (density matrix).</p> <p>W: <code>matrix</code>     -- Weight matrix.</p> Source code in <code>quanestimation/ComprehensiveOpt/DE_Compopt.py</code> <pre><code>def CM(self, rho0, W=[]):\n    \"\"\"\n    Comprehensive optimization of the control and measurement (CM).\n\n    Parameters\n    ----------\n    &gt; **rho0:** `matrix`\n        -- Initial state (density matrix).\n\n    &gt; **W:** `matrix`\n        -- Weight matrix.\n    \"\"\"\n    ini_population = (self.ctrl0, self.measurement0)\n    self.alg = QJL.DE(\n        self.max_episode,\n        self.p_num,\n        ini_population,\n        self.c,\n        self.cr,\n    )\n\n    super().CM(rho0, W)\n</code></pre>"},{"location":"API/python/classes/#quanestimation.DE_Compopt.SC","title":"<code>SC(W=[], M=[], target='QFIM', LDtype='SLD')</code>","text":"<p>Comprehensive optimization of the probe state and control (SC).</p>"},{"location":"API/python/classes/#quanestimation.DE_Compopt.SC--parameters","title":"Parameters","text":"<p>W: <code>matrix</code>     -- Weight matrix.</p> <p>M: <code>list of matrices</code>     -- A set of positive operator-valued measure (POVM). The default measurement      is a set of rank-one symmetric informationally complete POVM (SIC-POVM).</p> <p>target: <code>string</code>     -- Objective functions for searching the minimum time to reach the given      value of the objective function. Options are:     \"QFIM\" (default) -- choose QFI (QFIM) as the objective function.     \"CFIM\" -- choose CFI (CFIM) as the objective function.     \"HCRB\" -- choose HCRB as the objective function.  </p> <p>LDtype: <code>string</code>     -- Types of QFI (QFIM) can be set as the objective function. Options are:     \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD).     \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD).     \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). </p> <p>Note:      SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state      which can be downloaded from here.</p> Source code in <code>quanestimation/ComprehensiveOpt/DE_Compopt.py</code> <pre><code>def SC(self, W=[], M=[], target=\"QFIM\", LDtype=\"SLD\"):\n    \"\"\"\n    Comprehensive optimization of the probe state and control (SC).\n\n    Parameters\n    ----------\n    &gt; **W:** `matrix`\n        -- Weight matrix.\n\n    &gt; **M:** `list of matrices`\n        -- A set of positive operator-valued measure (POVM). The default measurement \n        is a set of rank-one symmetric informationally complete POVM (SIC-POVM).\n\n    &gt; **target:** `string`\n        -- Objective functions for searching the minimum time to reach the given \n        value of the objective function. Options are:  \n        \"QFIM\" (default) -- choose QFI (QFIM) as the objective function.  \n        \"CFIM\" -- choose CFI (CFIM) as the objective function.  \n        \"HCRB\" -- choose HCRB as the objective function.  \n\n    &gt; **LDtype:** `string`\n        -- Types of QFI (QFIM) can be set as the objective function. Options are:  \n        \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD).  \n        \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD).  \n        \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD). \n\n    **Note:** \n        SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state \n        which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/\n        solutions.html).\n    \"\"\"\n    ini_population = (self.psi, self.ctrl0)\n    self.alg = QJL.DE(\n        self.max_episode,\n        self.p_num,\n        ini_population,\n        self.c,\n        self.cr,\n    )\n\n    super().SC(W, M, target, LDtype)\n</code></pre>"},{"location":"API/python/classes/#quanestimation.DE_Compopt.SCM","title":"<code>SCM(W=[])</code>","text":"<p>Comprehensive optimization of the probe state, control and measurement (SCM).</p>"},{"location":"API/python/classes/#quanestimation.DE_Compopt.SCM--parameters","title":"Parameters","text":"<p>W: <code>matrix</code>     -- Weight matrix.</p> Source code in <code>quanestimation/ComprehensiveOpt/DE_Compopt.py</code> <pre><code>def SCM(self, W=[]):\n    \"\"\"\n    Comprehensive optimization of the probe state, control and measurement (SCM).\n\n    Parameters\n    ----------\n    &gt; **W:** `matrix`\n        -- Weight matrix.\n    \"\"\"\n    ini_population = (self.psi, self.ctrl0, self.measurement0)\n    self.alg = QJL.DE(\n        self.max_episode,\n        self.p_num,\n        ini_population,\n        self.c,\n        self.cr,\n    )\n\n    super().SCM(W)\n</code></pre>"},{"location":"API/python/classes/#quanestimation.DE_Compopt.SM","title":"<code>SM(W=[])</code>","text":"<p>Comprehensive optimization of the probe state and measurement (SM).</p>"},{"location":"API/python/classes/#quanestimation.DE_Compopt.SM--parameters","title":"Parameters","text":"<p>W: <code>matrix</code>     -- Weight matrix.</p> Source code in <code>quanestimation/ComprehensiveOpt/DE_Compopt.py</code> <pre><code>def SM(self, W=[]):\n    \"\"\"\n    Comprehensive optimization of the probe state and measurement (SM).\n\n    Parameters\n    ----------\n    &gt; **W:** `matrix`\n        -- Weight matrix.\n    \"\"\"\n    ini_population = (self.psi, self.measurement0)\n    self.alg = QJL.DE(\n        self.max_episode,\n        self.p_num,\n        ini_population,\n        self.c,\n        self.cr,\n    )\n\n    super().SM(W)\n</code></pre>"},{"location":"API/python/classes/#adaptive-measurement-schemes","title":"Adaptive measurement schemes","text":"<p>In QuanEstimation, the Hamiltonian of the adaptive system should be written as \\(H(\\textbf{x}+\\textbf{u})\\) with \\(\\textbf{x}\\) the unknown parameters and \\(\\textbf{u}\\)  the tunable parameters. The tunable parameters \\(\\textbf{u}\\) are used to let the  Hamiltonian work at the optimal point \\(\\textbf{x}_{\\mathrm{opt}}\\). </p>"},{"location":"API/python/classes/#adaptive-measurement","title":"Adaptive measurement","text":""},{"location":"API/python/classes/#quanestimation.Adapt--attributes","title":"Attributes","text":"<p>x: <code>list</code>     -- The regimes of the parameters for the integral.</p> <p>p: <code>multidimensional array</code>     -- The prior distribution.</p> <p>rho0: <code>matrix</code>     -- Initial state (density matrix).</p> <p>method: <code>string</code>     -- Choose the method for updating the tunable parameters (u). Options are:     \"FOP\" (default) -- Fix optimal point.     \"MI\" -- mutual information.</p> <p>savefile: <code>bool</code>     -- Whether or not to save all the posterior distributions.     If set <code>True</code> then three files \"pout.npy\", \"xout.npy\" and \"y.npy\" will be      generated including the posterior distributions, the estimated values, and     the experimental results in the iterations. If set <code>False</code> the posterior      distribution in the final iteration, the estimated values and the experimental      results in all iterations will be saved in \"pout.npy\", \"xout.npy\" and \"y.npy\". </p> <p>max_episode: <code>int</code>     -- The number of episodes.</p> <p>eps: <code>float</code>     -- Machine epsilon.</p> Source code in <code>quanestimation/AdaptiveScheme/Adapt.py</code> <pre><code>class Adapt:\n    \"\"\"\n    Attributes\n    ----------\n    &gt; **x:** `list`\n        -- The regimes of the parameters for the integral.\n\n    &gt; **p:** `multidimensional array`\n        -- The prior distribution.\n\n    &gt; **rho0:** `matrix`\n        -- Initial state (density matrix).\n\n    &gt; **method:** `string`\n        -- Choose the method for updating the tunable parameters (u). Options are:  \n        \"FOP\" (default) -- Fix optimal point.  \n        \"MI\" -- mutual information.\n\n    &gt; **savefile:** `bool`\n        -- Whether or not to save all the posterior distributions.  \n        If set `True` then three files \"pout.npy\", \"xout.npy\" and \"y.npy\" will be \n        generated including the posterior distributions, the estimated values, and\n        the experimental results in the iterations. If set `False` the posterior \n        distribution in the final iteration, the estimated values and the experimental \n        results in all iterations will be saved in \"pout.npy\", \"xout.npy\" and \"y.npy\". \n\n    &gt; **max_episode:** `int`\n        -- The number of episodes.\n\n    &gt; **eps:** `float`\n        -- Machine epsilon.\n    \"\"\"\n\n    def __init__(self, x, p, rho0, method=\"FOP\", savefile=False, max_episode=1000, eps=1e-8):\n\n        self.x = x\n        self.p = p\n        self.rho0 = np.array(rho0, dtype=np.complex128)\n        self.max_episode = max_episode\n        self.eps = eps\n        self.para_num = len(x)\n        self.savefile = savefile\n        self.method = method\n\n    def dynamics(self, tspan, H, dH, Hc=[], ctrl=[], decay=[], dyn_method=\"expm\"):\n        r\"\"\"\n        Dynamics of the density matrix of the form \n\n        \\begin{align}\n        \\partial_t\\rho &amp;=\\mathcal{L}\\rho \\nonumber \\\\\n        &amp;=-i[H,\\rho]+\\sum_i \\gamma_i\\left(\\Gamma_i\\rho\\Gamma^{\\dagger}_i-\\frac{1}{2}\n        \\left\\{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\right\\}\\right),\n        \\end{align} \n\n        where $\\rho$ is the evolved density matrix, H is the Hamiltonian of the \n        system, $\\Gamma_i$ and $\\gamma_i$ are the $i\\mathrm{th}$ decay \n        operator and decay rate.\n\n        Parameters\n        ----------\n        &gt; **tspan:** `array`\n            -- Time length for the evolution.\n\n        &gt; **H0:** `multidimensional list`\n            -- Free Hamiltonian with respect to the values in x.\n\n        &gt; **dH:** `multidimensional list`\n            -- Derivatives of the free Hamiltonian with respect to the unknown parameters \n            to be estimated.\n\n        &gt; **Hc:** `list`\n            -- Control Hamiltonians.\n\n        &gt; **ctrl:** `list`\n            -- Control coefficients.\n\n        &gt; **decay:** `list`\n            -- Decay operators and the corresponding decay rates. Its input rule is \n            `decay=[[Gamma1, gamma1], [Gamma2,gamma2],...]`, where `Gamma1 (Gamma2)` \n            represents the decay operator and `gamma1 (gamma2)` is the corresponding \n            decay rate.\n\n        &gt; **dyn_method:** `string`\n            -- Setting the method for solving the Lindblad dynamics. Options are:  \n            \"expm\" (default) -- Matrix exponential.  \n            \"ode\" -- Solving the differential equations directly.\n        \"\"\"\n\n        self.tspan = tspan\n        self.H = H\n        self.dH = dH\n        self.Hc = Hc\n        self.ctrl = ctrl\n        self.decay = decay\n\n        self.dynamic_type = \"dynamics\"\n        self.dyn_method = dyn_method\n\n    def Kraus(self, K, dK):\n        r\"\"\"\n        Dynamics of the density matrix of the form \n        \\begin{align}\n        \\rho=\\sum_i K_i\\rho_0K_i^{\\dagger}\n        \\end{align}\n\n        where $\\rho$ is the evolved density matrix, $K_i$ is the Kraus operator.\n\n        Parameters\n        ----------\n        &gt; **K:** `multidimensional list`\n            -- Kraus operator(s) with respect to the values in x.\n\n        &gt; **dK:** `multidimensional list`\n            -- Derivatives of the Kraus operator(s) with respect to the unknown parameters \n            to be estimated.\n        \"\"\"\n\n        self.K = K\n        self.dK = dK\n\n        self.dynamic_type = \"Kraus\"\n\n    def CFIM(self, M=[], W=[]):\n        r\"\"\"\n        Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. \n        In single parameter estimation the objective function is CFI and \n        in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$.\n\n        Parameters\n        ----------\n        &gt; **W:** `matrix`\n            -- Weight matrix.\n\n        &gt; **M:** `list of matrices`\n            -- A set of positive operator-valued measure (POVM). The default measurement \n            is a set of rank-one symmetric informationally complete POVM (SIC-POVM).\n\n        **Note:** \n            SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state \n            which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/\n            solutions.html).\n        \"\"\"\n\n        if M == []:\n            M = SIC(len(self.rho0))\n        if W == []:\n            W = np.eye(len(self.x))\n        self.W = W\n\n        if self.dynamic_type == \"dynamics\":\n            adaptive_dynamics(\n                self.x,\n                self.p,\n                M,\n                self.tspan,\n                self.rho0,\n                self.H,\n                self.dH,\n                self.decay,\n                self.Hc,\n                self.ctrl,\n                W,\n                self.max_episode,\n                self.eps,\n                self.savefile,\n                self.method,\n                dyn_method=self.dyn_method,\n            )\n        elif self.dynamic_type == \"Kraus\":\n            adaptive_Kraus(\n                self.x,\n                self.p,\n                M,\n                self.rho0,\n                self.K,\n                self.dK,\n                W,\n                self.max_episode,\n                self.eps,\n                self.savefile,\n                self.method\n            )\n        else:\n            raise ValueError(\n                \"{!r} is not a valid value for type of dynamics, supported values are 'dynamics' and 'Kraus'.\".format(\n                    self.dynamic_type\n                )\n            )\n\n    def Mopt(self, W=[]):\n        r\"\"\"\n        Measurement optimization for the optimal x.\n\n        Parameters\n        ----------\n        &gt; **W:** `matrix`\n            -- Weight matrix.\n        \"\"\"\n\n        if W == []:\n            W = np.identity(self.para_num)\n        else:\n            W = W\n\n        if self.dynamic_type == \"dynamics\":\n            if self.para_num == 1:\n                F = []\n                if self.dyn_method == \"expm\":\n                    for i in range(len(self.H)):\n                        dynamics = Lindblad(\n                            self.tspan,\n                            self.rho0,\n                            self.H[i],\n                            self.dH[i],\n                            decay=self.decay,\n                            Hc=self.Hc,\n                            ctrl=self.ctrl,\n                        )\n                        rho_tp, drho_tp = dynamics.expm()\n                        rho, drho = rho_tp[-1], drho_tp[-1]\n                        F_tp = QFIM(rho, drho)\n                        F.append(F_tp)\n                elif self.dyn_method == \"ode\":\n                    for i in range(len(self.H)):\n                        dynamics = Lindblad(\n                            self.tspan,\n                            self.rho0,\n                            self.H[i],\n                            self.dH[i],\n                            decay=self.decay,\n                            Hc=self.Hc,\n                            ctrl=self.ctrl,\n                        )\n                        rho_tp, drho_tp = dynamics.ode()\n                        rho, drho = rho_tp[-1], drho_tp[-1]\n                        F_tp = QFIM(rho, drho)\n                        F.append(F_tp)\n                idx = np.argmax(F)\n                H_res, dH_res = self.H[idx], self.dH[idx]\n            else:\n                p_ext = extract_ele(self.p, self.para_num)\n                H_ext = extract_ele(self.H, self.para_num)\n                dH_ext = extract_ele(self.dH, self.para_num)\n\n                p_list, H_list, dH_list = [], [], []\n                for p_ele, H_ele, dH_ele in zip(p_ext, H_ext, dH_ext):\n                    p_list.append(p_ele)\n                    H_list.append(H_ele)\n                    dH_list.append(dH_ele)\n\n                F = []\n                if self.dyn_method == \"expm\":\n                    for i in range(len(p_list)):\n                        dynamics = Lindblad(\n                            self.tspan,\n                            self.rho0,\n                            self.H_list[i],\n                            self.dH_list[i],\n                            decay=self.decay,\n                            Hc=self.Hc,\n                            ctrl=self.ctrl,\n                        )\n                        rho_tp, drho_tp = dynamics.expm()\n                        rho, drho = rho_tp[-1], drho_tp[-1]\n                        F_tp = QFIM(rho, drho)\n                        if np.linalg.det(F_tp) &lt; self.eps:\n                            F.append(self.eps)\n                        else:\n                            F.append(1.0 / np.trace(np.dot(W, np.linalg.inv(F_tp))))\n                elif self.dyn_method == \"ode\":\n                    for i in range(len(p_list)):\n                        dynamics = Lindblad(\n                            self.tspan,\n                            self.rho0,\n                            self.H_list[i],\n                            self.dH_list[i],\n                            decay=self.decay,\n                            Hc=self.Hc,\n                            ctrl=self.ctrl,\n                        )\n                        rho_tp, drho_tp = dynamics.ode()\n                        rho, drho = rho_tp[-1], drho_tp[-1]\n                        F_tp = QFIM(rho, drho)\n                        if np.linalg.det(F_tp) &lt; self.eps:\n                            F.append(self.eps)\n                        else:\n                            F.append(1.0 / np.trace(np.dot(W, np.linalg.inv(F_tp))))\n                idx = np.argmax(F)\n                H_res, dH_res = self.H_list[idx], self.dH_list[idx]\n            m = MeasurementOpt(mtype=\"projection\", minput=[], method=\"DE\")\n            m.dynamics(\n                self.tspan,\n                self.rho0,\n                H_res,\n                dH_res,\n                Hc=self.Hc,\n                ctrl=self.ctrl,\n                decay=self.decay,\n                dyn_method=self.dyn_method,\n            )\n            m.CFIM(W=W)\n        elif self.dynamic_type == \"Kraus\":\n            if self.para_num == 1:\n                F = []\n                for hi in range(len(self.K)):\n                    rho_tp = sum(\n                        [np.dot(Ki, np.dot(self.rho0, Ki.conj().T)) for Ki in self.K[hi]]\n                    )\n                    drho_tp = sum(\n                        [\n                            np.dot(dKi, np.dot(self.rho0, Ki.conj().T))\n                            + np.dot(Ki, np.dot(self.rho0, dKi.conj().T))\n                            for (Ki, dKi) in zip(self.K[hi], self.dK[hi])\n                        ]\n                    )\n                    F_tp = QFIM(rho_tp, drho_tp)\n                    F.append(F_tp)\n\n                idx = np.argmax(F)\n                K_res, dK_res = self.K[idx], self.dK[idx]\n            else:\n                p_shape = np.shape(self.p)\n\n                p_ext = extract_ele(self.p, self.para_num)\n                K_ext = extract_ele(self.K, self.para_num)\n                dK_ext = extract_ele(self.dK, self.para_num)\n\n                p_list, K_list, dK_list = [], [], []\n                for K_ele, dK_ele in zip(K_ext, dK_ext):\n                    p_list.append(p_ele)\n                    K_list.append(K_ele)\n                    dK_list.append(dK_ele)\n                F = []\n                for hi in range(len(p_list)):\n                    rho_tp = sum(\n                        [np.dot(Ki, np.dot(self.rho0, Ki.conj().T)) for Ki in K_list[hi]]\n                    )\n                    dK_reshape = [\n                        [dK_list[hi][i][j] for i in range(self.k_num)]\n                        for j in range(self.para_num)\n                    ]\n                    drho_tp = [\n                        sum(\n                            [\n                                np.dot(dKi, np.dot(self.rho0, Ki.conj().T))\n                                + np.dot(Ki, np.dot(self.rho0, dKi.conj().T))\n                                for (Ki, dKi) in zip(K_list[hi], dKj)\n                            ]\n                        )\n                        for dKj in dK_reshape\n                    ]\n                    F_tp = QFIM(rho_tp, drho_tp)\n                    if np.linalg.det(F_tp) &lt; self.eps:\n                        F.append(self.eps)\n                    else:\n                        F.append(1.0 / np.trace(np.dot(W, np.linalg.inv(F_tp))))\n                F = np.array(F).reshape(p_shape)\n                idx = np.where(np.array(F) == np.max(np.array(F)))\n                K_res, dK_res = self.K_list[idx], self.dK_list[idx]\n            m = MeasurementOpt(mtype=\"projection\", minput=[], method=\"DE\")\n            m.Kraus(self.rho0, K_res, dK_res, decay=self.decay)\n            m.CFIM(W=W)\n        else:\n            raise ValueError(\n                \"{!r} is not a valid value for type of dynamics, supported values are 'dynamics' and 'Kraus'.\".format(\n                    self.dynamic_type\n                )\n            )\n</code></pre>"},{"location":"API/python/classes/#quanestimation.Adapt.CFIM","title":"<code>CFIM(M=[], W=[])</code>","text":"<p>Choose CFI or \\(\\mathrm{Tr}(WI^{-1})\\) as the objective function.  In single parameter estimation the objective function is CFI and  in multiparameter estimation it will be \\(\\mathrm{Tr}(WI^{-1})\\).</p>"},{"location":"API/python/classes/#quanestimation.Adapt.CFIM--parameters","title":"Parameters","text":"<p>W: <code>matrix</code>     -- Weight matrix.</p> <p>M: <code>list of matrices</code>     -- A set of positive operator-valued measure (POVM). The default measurement      is a set of rank-one symmetric informationally complete POVM (SIC-POVM).</p> <p>Note:      SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state      which can be downloaded from here.</p> Source code in <code>quanestimation/AdaptiveScheme/Adapt.py</code> <pre><code>def CFIM(self, M=[], W=[]):\n    r\"\"\"\n    Choose CFI or $\\mathrm{Tr}(WI^{-1})$ as the objective function. \n    In single parameter estimation the objective function is CFI and \n    in multiparameter estimation it will be $\\mathrm{Tr}(WI^{-1})$.\n\n    Parameters\n    ----------\n    &gt; **W:** `matrix`\n        -- Weight matrix.\n\n    &gt; **M:** `list of matrices`\n        -- A set of positive operator-valued measure (POVM). The default measurement \n        is a set of rank-one symmetric informationally complete POVM (SIC-POVM).\n\n    **Note:** \n        SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state \n        which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/\n        solutions.html).\n    \"\"\"\n\n    if M == []:\n        M = SIC(len(self.rho0))\n    if W == []:\n        W = np.eye(len(self.x))\n    self.W = W\n\n    if self.dynamic_type == \"dynamics\":\n        adaptive_dynamics(\n            self.x,\n            self.p,\n            M,\n            self.tspan,\n            self.rho0,\n            self.H,\n            self.dH,\n            self.decay,\n            self.Hc,\n            self.ctrl,\n            W,\n            self.max_episode,\n            self.eps,\n            self.savefile,\n            self.method,\n            dyn_method=self.dyn_method,\n        )\n    elif self.dynamic_type == \"Kraus\":\n        adaptive_Kraus(\n            self.x,\n            self.p,\n            M,\n            self.rho0,\n            self.K,\n            self.dK,\n            W,\n            self.max_episode,\n            self.eps,\n            self.savefile,\n            self.method\n        )\n    else:\n        raise ValueError(\n            \"{!r} is not a valid value for type of dynamics, supported values are 'dynamics' and 'Kraus'.\".format(\n                self.dynamic_type\n            )\n        )\n</code></pre>"},{"location":"API/python/classes/#quanestimation.Adapt.Kraus","title":"<code>Kraus(K, dK)</code>","text":"<p>Dynamics of the density matrix of the form  \\begin{align} \\rho=\\sum_i K_i\\rho_0K_i^{\\dagger} \\end{align}</p> <p>where \\(\\rho\\) is the evolved density matrix, \\(K_i\\) is the Kraus operator.</p>"},{"location":"API/python/classes/#quanestimation.Adapt.Kraus--parameters","title":"Parameters","text":"<p>K: <code>multidimensional list</code>     -- Kraus operator(s) with respect to the values in x.</p> <p>dK: <code>multidimensional list</code>     -- Derivatives of the Kraus operator(s) with respect to the unknown parameters      to be estimated.</p> Source code in <code>quanestimation/AdaptiveScheme/Adapt.py</code> <pre><code>def Kraus(self, K, dK):\n    r\"\"\"\n    Dynamics of the density matrix of the form \n    \\begin{align}\n    \\rho=\\sum_i K_i\\rho_0K_i^{\\dagger}\n    \\end{align}\n\n    where $\\rho$ is the evolved density matrix, $K_i$ is the Kraus operator.\n\n    Parameters\n    ----------\n    &gt; **K:** `multidimensional list`\n        -- Kraus operator(s) with respect to the values in x.\n\n    &gt; **dK:** `multidimensional list`\n        -- Derivatives of the Kraus operator(s) with respect to the unknown parameters \n        to be estimated.\n    \"\"\"\n\n    self.K = K\n    self.dK = dK\n\n    self.dynamic_type = \"Kraus\"\n</code></pre>"},{"location":"API/python/classes/#quanestimation.Adapt.Mopt","title":"<code>Mopt(W=[])</code>","text":"<p>Measurement optimization for the optimal x.</p>"},{"location":"API/python/classes/#quanestimation.Adapt.Mopt--parameters","title":"Parameters","text":"<p>W: <code>matrix</code>     -- Weight matrix.</p> Source code in <code>quanestimation/AdaptiveScheme/Adapt.py</code> <pre><code>def Mopt(self, W=[]):\n    r\"\"\"\n    Measurement optimization for the optimal x.\n\n    Parameters\n    ----------\n    &gt; **W:** `matrix`\n        -- Weight matrix.\n    \"\"\"\n\n    if W == []:\n        W = np.identity(self.para_num)\n    else:\n        W = W\n\n    if self.dynamic_type == \"dynamics\":\n        if self.para_num == 1:\n            F = []\n            if self.dyn_method == \"expm\":\n                for i in range(len(self.H)):\n                    dynamics = Lindblad(\n                        self.tspan,\n                        self.rho0,\n                        self.H[i],\n                        self.dH[i],\n                        decay=self.decay,\n                        Hc=self.Hc,\n                        ctrl=self.ctrl,\n                    )\n                    rho_tp, drho_tp = dynamics.expm()\n                    rho, drho = rho_tp[-1], drho_tp[-1]\n                    F_tp = QFIM(rho, drho)\n                    F.append(F_tp)\n            elif self.dyn_method == \"ode\":\n                for i in range(len(self.H)):\n                    dynamics = Lindblad(\n                        self.tspan,\n                        self.rho0,\n                        self.H[i],\n                        self.dH[i],\n                        decay=self.decay,\n                        Hc=self.Hc,\n                        ctrl=self.ctrl,\n                    )\n                    rho_tp, drho_tp = dynamics.ode()\n                    rho, drho = rho_tp[-1], drho_tp[-1]\n                    F_tp = QFIM(rho, drho)\n                    F.append(F_tp)\n            idx = np.argmax(F)\n            H_res, dH_res = self.H[idx], self.dH[idx]\n        else:\n            p_ext = extract_ele(self.p, self.para_num)\n            H_ext = extract_ele(self.H, self.para_num)\n            dH_ext = extract_ele(self.dH, self.para_num)\n\n            p_list, H_list, dH_list = [], [], []\n            for p_ele, H_ele, dH_ele in zip(p_ext, H_ext, dH_ext):\n                p_list.append(p_ele)\n                H_list.append(H_ele)\n                dH_list.append(dH_ele)\n\n            F = []\n            if self.dyn_method == \"expm\":\n                for i in range(len(p_list)):\n                    dynamics = Lindblad(\n                        self.tspan,\n                        self.rho0,\n                        self.H_list[i],\n                        self.dH_list[i],\n                        decay=self.decay,\n                        Hc=self.Hc,\n                        ctrl=self.ctrl,\n                    )\n                    rho_tp, drho_tp = dynamics.expm()\n                    rho, drho = rho_tp[-1], drho_tp[-1]\n                    F_tp = QFIM(rho, drho)\n                    if np.linalg.det(F_tp) &lt; self.eps:\n                        F.append(self.eps)\n                    else:\n                        F.append(1.0 / np.trace(np.dot(W, np.linalg.inv(F_tp))))\n            elif self.dyn_method == \"ode\":\n                for i in range(len(p_list)):\n                    dynamics = Lindblad(\n                        self.tspan,\n                        self.rho0,\n                        self.H_list[i],\n                        self.dH_list[i],\n                        decay=self.decay,\n                        Hc=self.Hc,\n                        ctrl=self.ctrl,\n                    )\n                    rho_tp, drho_tp = dynamics.ode()\n                    rho, drho = rho_tp[-1], drho_tp[-1]\n                    F_tp = QFIM(rho, drho)\n                    if np.linalg.det(F_tp) &lt; self.eps:\n                        F.append(self.eps)\n                    else:\n                        F.append(1.0 / np.trace(np.dot(W, np.linalg.inv(F_tp))))\n            idx = np.argmax(F)\n            H_res, dH_res = self.H_list[idx], self.dH_list[idx]\n        m = MeasurementOpt(mtype=\"projection\", minput=[], method=\"DE\")\n        m.dynamics(\n            self.tspan,\n            self.rho0,\n            H_res,\n            dH_res,\n            Hc=self.Hc,\n            ctrl=self.ctrl,\n            decay=self.decay,\n            dyn_method=self.dyn_method,\n        )\n        m.CFIM(W=W)\n    elif self.dynamic_type == \"Kraus\":\n        if self.para_num == 1:\n            F = []\n            for hi in range(len(self.K)):\n                rho_tp = sum(\n                    [np.dot(Ki, np.dot(self.rho0, Ki.conj().T)) for Ki in self.K[hi]]\n                )\n                drho_tp = sum(\n                    [\n                        np.dot(dKi, np.dot(self.rho0, Ki.conj().T))\n                        + np.dot(Ki, np.dot(self.rho0, dKi.conj().T))\n                        for (Ki, dKi) in zip(self.K[hi], self.dK[hi])\n                    ]\n                )\n                F_tp = QFIM(rho_tp, drho_tp)\n                F.append(F_tp)\n\n            idx = np.argmax(F)\n            K_res, dK_res = self.K[idx], self.dK[idx]\n        else:\n            p_shape = np.shape(self.p)\n\n            p_ext = extract_ele(self.p, self.para_num)\n            K_ext = extract_ele(self.K, self.para_num)\n            dK_ext = extract_ele(self.dK, self.para_num)\n\n            p_list, K_list, dK_list = [], [], []\n            for K_ele, dK_ele in zip(K_ext, dK_ext):\n                p_list.append(p_ele)\n                K_list.append(K_ele)\n                dK_list.append(dK_ele)\n            F = []\n            for hi in range(len(p_list)):\n                rho_tp = sum(\n                    [np.dot(Ki, np.dot(self.rho0, Ki.conj().T)) for Ki in K_list[hi]]\n                )\n                dK_reshape = [\n                    [dK_list[hi][i][j] for i in range(self.k_num)]\n                    for j in range(self.para_num)\n                ]\n                drho_tp = [\n                    sum(\n                        [\n                            np.dot(dKi, np.dot(self.rho0, Ki.conj().T))\n                            + np.dot(Ki, np.dot(self.rho0, dKi.conj().T))\n                            for (Ki, dKi) in zip(K_list[hi], dKj)\n                        ]\n                    )\n                    for dKj in dK_reshape\n                ]\n                F_tp = QFIM(rho_tp, drho_tp)\n                if np.linalg.det(F_tp) &lt; self.eps:\n                    F.append(self.eps)\n                else:\n                    F.append(1.0 / np.trace(np.dot(W, np.linalg.inv(F_tp))))\n            F = np.array(F).reshape(p_shape)\n            idx = np.where(np.array(F) == np.max(np.array(F)))\n            K_res, dK_res = self.K_list[idx], self.dK_list[idx]\n        m = MeasurementOpt(mtype=\"projection\", minput=[], method=\"DE\")\n        m.Kraus(self.rho0, K_res, dK_res, decay=self.decay)\n        m.CFIM(W=W)\n    else:\n        raise ValueError(\n            \"{!r} is not a valid value for type of dynamics, supported values are 'dynamics' and 'Kraus'.\".format(\n                self.dynamic_type\n            )\n        )\n</code></pre>"},{"location":"API/python/classes/#quanestimation.Adapt.dynamics","title":"<code>dynamics(tspan, H, dH, Hc=[], ctrl=[], decay=[], dyn_method='expm')</code>","text":"<p>Dynamics of the density matrix of the form </p> \\[\\begin{align} \\partial_t\\rho &amp;=\\mathcal{L}\\rho \\nonumber \\\\ &amp;=-i[H,\\rho]+\\sum_i \\gamma_i\\left(\\Gamma_i\\rho\\Gamma^{\\dagger}_i-\\frac{1}{2} \\left\\{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\right\\}\\right), \\end{align}\\] <p>where \\(\\rho\\) is the evolved density matrix, H is the Hamiltonian of the  system, \\(\\Gamma_i\\) and \\(\\gamma_i\\) are the \\(i\\mathrm{th}\\) decay  operator and decay rate.</p>"},{"location":"API/python/classes/#quanestimation.Adapt.dynamics--parameters","title":"Parameters","text":"<p>tspan: <code>array</code>     -- Time length for the evolution.</p> <p>H0: <code>multidimensional list</code>     -- Free Hamiltonian with respect to the values in x.</p> <p>dH: <code>multidimensional list</code>     -- Derivatives of the free Hamiltonian with respect to the unknown parameters      to be estimated.</p> <p>Hc: <code>list</code>     -- Control Hamiltonians.</p> <p>ctrl: <code>list</code>     -- Control coefficients.</p> <p>decay: <code>list</code>     -- Decay operators and the corresponding decay rates. Its input rule is      <code>decay=[[Gamma1, gamma1], [Gamma2,gamma2],...]</code>, where <code>Gamma1 (Gamma2)</code>      represents the decay operator and <code>gamma1 (gamma2)</code> is the corresponding      decay rate.</p> <p>dyn_method: <code>string</code>     -- Setting the method for solving the Lindblad dynamics. Options are:     \"expm\" (default) -- Matrix exponential.     \"ode\" -- Solving the differential equations directly.</p> Source code in <code>quanestimation/AdaptiveScheme/Adapt.py</code> <pre><code>def dynamics(self, tspan, H, dH, Hc=[], ctrl=[], decay=[], dyn_method=\"expm\"):\n    r\"\"\"\n    Dynamics of the density matrix of the form \n\n    \\begin{align}\n    \\partial_t\\rho &amp;=\\mathcal{L}\\rho \\nonumber \\\\\n    &amp;=-i[H,\\rho]+\\sum_i \\gamma_i\\left(\\Gamma_i\\rho\\Gamma^{\\dagger}_i-\\frac{1}{2}\n    \\left\\{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\right\\}\\right),\n    \\end{align} \n\n    where $\\rho$ is the evolved density matrix, H is the Hamiltonian of the \n    system, $\\Gamma_i$ and $\\gamma_i$ are the $i\\mathrm{th}$ decay \n    operator and decay rate.\n\n    Parameters\n    ----------\n    &gt; **tspan:** `array`\n        -- Time length for the evolution.\n\n    &gt; **H0:** `multidimensional list`\n        -- Free Hamiltonian with respect to the values in x.\n\n    &gt; **dH:** `multidimensional list`\n        -- Derivatives of the free Hamiltonian with respect to the unknown parameters \n        to be estimated.\n\n    &gt; **Hc:** `list`\n        -- Control Hamiltonians.\n\n    &gt; **ctrl:** `list`\n        -- Control coefficients.\n\n    &gt; **decay:** `list`\n        -- Decay operators and the corresponding decay rates. Its input rule is \n        `decay=[[Gamma1, gamma1], [Gamma2,gamma2],...]`, where `Gamma1 (Gamma2)` \n        represents the decay operator and `gamma1 (gamma2)` is the corresponding \n        decay rate.\n\n    &gt; **dyn_method:** `string`\n        -- Setting the method for solving the Lindblad dynamics. Options are:  \n        \"expm\" (default) -- Matrix exponential.  \n        \"ode\" -- Solving the differential equations directly.\n    \"\"\"\n\n    self.tspan = tspan\n    self.H = H\n    self.dH = dH\n    self.Hc = Hc\n    self.ctrl = ctrl\n    self.decay = decay\n\n    self.dynamic_type = \"dynamics\"\n    self.dyn_method = dyn_method\n</code></pre>"},{"location":"API/python/classes/#quanestimation.Adapt_MZI--attributes","title":"Attributes","text":"<p>x: <code>list</code>     -- The regimes of the parameters for the integral.</p> <p>p: <code>multidimensional array</code>     -- The prior distribution.</p> <p>rho0: <code>matrix</code>     -- Initial state (density matrix).</p> Source code in <code>quanestimation/AdaptiveScheme/Adapt_MZI.py</code> <pre><code>class Adapt_MZI:\n    \"\"\"\n    Attributes\n    ----------\n    &gt; **x:** `list`\n        -- The regimes of the parameters for the integral.\n\n    &gt; **p:** `multidimensional array`\n        -- The prior distribution.\n\n    &gt; **rho0:** `matrix`\n        -- Initial state (density matrix).\n\n    \"\"\"\n    def __init__(self, x, p, rho0):\n\n        self.x = x\n        self.p = p\n        self.rho0 = rho0\n        self.N = int(np.sqrt(len(rho0))) - 1\n        # self.a = annihilation(self.N + 1)\n\n    def general(self):\n        self.MZI_type = \"general\"\n\n    def online(self, target=\"sharpness\", output=\"phi\"):\n        \"\"\"\n        Parameters\n        ----------\n        &gt; **target:** `string`\n            -- Setting the target function for calculating the tunable phase. Options are:  \n            \"sharpness\" (default) -- Sharpness.  \n            \"MI\" -- Mutual information. \n\n        &gt; **output:** `string`\n            -- The output the class. Options are:  \n            \"phi\" (default) -- The tunable phase.  \n            \"dphi\" -- Phase difference. \n        \"\"\"\n        phi = QJL.adaptMZI_online(\n            self.x, self.p, self.rho0, output, target\n        )\n\n    def offline(\n        self,\n        target=\"sharpness\",\n        method=\"DE\",\n        p_num=10,\n        deltaphi0=[],\n        c=1.0,\n        cr=0.5,\n        c0=1.0,\n        c1=2.0,\n        c2=2.0,\n        seed=1234,\n        max_episode=1000,\n        eps=1e-8,\n    ):\n        \"\"\"\n        Parameters\n        ----------\n        &gt; **target:** `string`\n            -- Setting the target function for calculating the tunable phase. Options are:  \n            \"sharpness\" (default) -- Sharpness.  \n            \"MI\" -- Mutual information. \n\n        &gt; **method:** `string`\n            -- The method for the adaptive phase estimation. Options are:  \n            \"DE\" (default) -- DE algorithm for the adaptive phase estimation.    \n            \"PSO\" -- PSO algorithm for the adaptive phase estimation.\n\n        If the `method=DE`, the parameters are:\n        &gt; **p_num:** `int`\n            -- The number of populations.\n\n        &gt; **deltaphi0:** `list`\n            -- Initial guesses of phase difference.\n\n        &gt; **max_episode:** `int`\n            -- The number of episodes.\n\n        &gt; **c:** `float`\n            -- Mutation constant.\n\n        &gt; **cr:** `float`\n            -- Crossover constant.\n\n        &gt; **seed:** `int`\n            -- Random seed.\n\n        &gt; **eps:** `float`\n            -- Machine epsilon.\n\n        If the `method=PSO`, the parameters are:\n\n        &gt; **deltaphi0:** `list`\n            -- Initial guesses of phase difference.\n\n        &gt; **max_episode:** `int or list`\n            -- If it is an integer, for example max_episode=1000, it means the \n            program will continuously run 1000 episodes. However, if it is an\n            array, for example max_episode=[1000,100], the program will run \n            1000 episodes in total but replace states of all  the particles \n            with global best every 100 episodes.\n\n        &gt; **c0:** `float`\n            -- The damping factor that assists convergence, also known as inertia weight.\n\n        &gt; **c1:** `float`\n            -- The exploitation weight that attracts the particle to its best previous \n            position, also known as cognitive learning factor.\n\n        &gt; **c2:** `float`\n            -- The exploitation weight that attracts the particle to the best position  \n            in the neighborhood, also known as social learning factor.\n\n        &gt; **eps:** `float`\n            -- Machine epsilon.\n        \"\"\"\n        comb_tp = brgd(self.N)\n        comb = [\n            np.array([int(list(comb_tp[i])[j]) for j in range(self.N)])\n            for i in range(2**self.N)\n        ]\n\n        if method == \"DE\":\n            QJL.DE_deltaphiOpt(\n                self.x,\n                self.p,\n                self.rho0,\n                comb,\n                p_num,\n                deltaphi0,\n                c,\n                cr,\n                seed,\n                max_episode,\n                target,\n                eps,\n            )\n        elif method == \"PSO\":\n            QJL.PSO_deltaphiOpt(\n                self.x,\n                self.p,\n                self.rho0,\n                comb,\n                p_num,\n                deltaphi0,\n                c0,\n                c1,\n                c2,\n                seed,\n                max_episode,\n                target,\n                eps,\n            )\n        else:\n            raise ValueError(\n                \"{!r} is not a valid value for method, supported values are 'DE' and 'PSO'.\".format(\n                    method\n                )\n            )\n</code></pre>"},{"location":"API/python/classes/#quanestimation.Adapt_MZI.offline","title":"<code>offline(target='sharpness', method='DE', p_num=10, deltaphi0=[], c=1.0, cr=0.5, c0=1.0, c1=2.0, c2=2.0, seed=1234, max_episode=1000, eps=1e-08)</code>","text":""},{"location":"API/python/classes/#quanestimation.Adapt_MZI.offline--parameters","title":"Parameters","text":"<p>target: <code>string</code>     -- Setting the target function for calculating the tunable phase. Options are:     \"sharpness\" (default) -- Sharpness.     \"MI\" -- Mutual information. </p> <p>method: <code>string</code>     -- The method for the adaptive phase estimation. Options are:     \"DE\" (default) -- DE algorithm for the adaptive phase estimation.       \"PSO\" -- PSO algorithm for the adaptive phase estimation.</p> <p>If the <code>method=DE</code>, the parameters are:</p> <p>p_num: <code>int</code>     -- The number of populations.</p> <p>deltaphi0: <code>list</code>     -- Initial guesses of phase difference.</p> <p>max_episode: <code>int</code>     -- The number of episodes.</p> <p>c: <code>float</code>     -- Mutation constant.</p> <p>cr: <code>float</code>     -- Crossover constant.</p> <p>seed: <code>int</code>     -- Random seed.</p> <p>eps: <code>float</code>     -- Machine epsilon.</p> <p>If the <code>method=PSO</code>, the parameters are:</p> <p>deltaphi0: <code>list</code>     -- Initial guesses of phase difference.</p> <p>max_episode: <code>int or list</code>     -- If it is an integer, for example max_episode=1000, it means the      program will continuously run 1000 episodes. However, if it is an     array, for example max_episode=[1000,100], the program will run      1000 episodes in total but replace states of all  the particles      with global best every 100 episodes.</p> <p>c0: <code>float</code>     -- The damping factor that assists convergence, also known as inertia weight.</p> <p>c1: <code>float</code>     -- The exploitation weight that attracts the particle to its best previous      position, also known as cognitive learning factor.</p> <p>c2: <code>float</code>     -- The exploitation weight that attracts the particle to the best position     in the neighborhood, also known as social learning factor.</p> <p>eps: <code>float</code>     -- Machine epsilon.</p> Source code in <code>quanestimation/AdaptiveScheme/Adapt_MZI.py</code> <pre><code>def offline(\n    self,\n    target=\"sharpness\",\n    method=\"DE\",\n    p_num=10,\n    deltaphi0=[],\n    c=1.0,\n    cr=0.5,\n    c0=1.0,\n    c1=2.0,\n    c2=2.0,\n    seed=1234,\n    max_episode=1000,\n    eps=1e-8,\n):\n    \"\"\"\n    Parameters\n    ----------\n    &gt; **target:** `string`\n        -- Setting the target function for calculating the tunable phase. Options are:  \n        \"sharpness\" (default) -- Sharpness.  \n        \"MI\" -- Mutual information. \n\n    &gt; **method:** `string`\n        -- The method for the adaptive phase estimation. Options are:  \n        \"DE\" (default) -- DE algorithm for the adaptive phase estimation.    \n        \"PSO\" -- PSO algorithm for the adaptive phase estimation.\n\n    If the `method=DE`, the parameters are:\n    &gt; **p_num:** `int`\n        -- The number of populations.\n\n    &gt; **deltaphi0:** `list`\n        -- Initial guesses of phase difference.\n\n    &gt; **max_episode:** `int`\n        -- The number of episodes.\n\n    &gt; **c:** `float`\n        -- Mutation constant.\n\n    &gt; **cr:** `float`\n        -- Crossover constant.\n\n    &gt; **seed:** `int`\n        -- Random seed.\n\n    &gt; **eps:** `float`\n        -- Machine epsilon.\n\n    If the `method=PSO`, the parameters are:\n\n    &gt; **deltaphi0:** `list`\n        -- Initial guesses of phase difference.\n\n    &gt; **max_episode:** `int or list`\n        -- If it is an integer, for example max_episode=1000, it means the \n        program will continuously run 1000 episodes. However, if it is an\n        array, for example max_episode=[1000,100], the program will run \n        1000 episodes in total but replace states of all  the particles \n        with global best every 100 episodes.\n\n    &gt; **c0:** `float`\n        -- The damping factor that assists convergence, also known as inertia weight.\n\n    &gt; **c1:** `float`\n        -- The exploitation weight that attracts the particle to its best previous \n        position, also known as cognitive learning factor.\n\n    &gt; **c2:** `float`\n        -- The exploitation weight that attracts the particle to the best position  \n        in the neighborhood, also known as social learning factor.\n\n    &gt; **eps:** `float`\n        -- Machine epsilon.\n    \"\"\"\n    comb_tp = brgd(self.N)\n    comb = [\n        np.array([int(list(comb_tp[i])[j]) for j in range(self.N)])\n        for i in range(2**self.N)\n    ]\n\n    if method == \"DE\":\n        QJL.DE_deltaphiOpt(\n            self.x,\n            self.p,\n            self.rho0,\n            comb,\n            p_num,\n            deltaphi0,\n            c,\n            cr,\n            seed,\n            max_episode,\n            target,\n            eps,\n        )\n    elif method == \"PSO\":\n        QJL.PSO_deltaphiOpt(\n            self.x,\n            self.p,\n            self.rho0,\n            comb,\n            p_num,\n            deltaphi0,\n            c0,\n            c1,\n            c2,\n            seed,\n            max_episode,\n            target,\n            eps,\n        )\n    else:\n        raise ValueError(\n            \"{!r} is not a valid value for method, supported values are 'DE' and 'PSO'.\".format(\n                method\n            )\n        )\n</code></pre>"},{"location":"API/python/classes/#quanestimation.Adapt_MZI.online","title":"<code>online(target='sharpness', output='phi')</code>","text":""},{"location":"API/python/classes/#quanestimation.Adapt_MZI.online--parameters","title":"Parameters","text":"<p>target: <code>string</code>     -- Setting the target function for calculating the tunable phase. Options are:     \"sharpness\" (default) -- Sharpness.     \"MI\" -- Mutual information. </p> <p>output: <code>string</code>     -- The output the class. Options are:     \"phi\" (default) -- The tunable phase.     \"dphi\" -- Phase difference.</p> Source code in <code>quanestimation/AdaptiveScheme/Adapt_MZI.py</code> <pre><code>def online(self, target=\"sharpness\", output=\"phi\"):\n    \"\"\"\n    Parameters\n    ----------\n    &gt; **target:** `string`\n        -- Setting the target function for calculating the tunable phase. Options are:  \n        \"sharpness\" (default) -- Sharpness.  \n        \"MI\" -- Mutual information. \n\n    &gt; **output:** `string`\n        -- The output the class. Options are:  \n        \"phi\" (default) -- The tunable phase.  \n        \"dphi\" -- Phase difference. \n    \"\"\"\n    phi = QJL.adaptMZI_online(\n        self.x, self.p, self.rho0, output, target\n    )\n</code></pre>"},{"location":"API/python/functions/","title":"Python Functions","text":""},{"location":"API/python/functions/#kraus","title":"Kraus","text":"<p>Parameterization of a quantum state using Kraus operators.</p> <p>The evolved density matrix \\(\\rho\\) is given by</p> \\[\\begin{aligned}     \\rho=\\sum_i K_i \\rho_0 K_i^{\\dagger}, \\end{aligned}\\] <p>where \\(\\rho_0\\) is the initial density matrix and \\(K_i\\) are the Kraus operators.</p> <p>Parameters:</p> Name Type Description Default <code>rho0</code> <code>array</code> <p>Initial density matrix.</p> required <code>K</code> <code>list</code> <p>Kraus operators.</p> required <code>dK</code> <code>list</code> <p>Derivatives of the Kraus operators with respect to the unknown parameters to be  estimated. This is a nested list where the first index corresponds to the Kraus operator  and the second index corresponds to the parameter. For example, <code>dK[0][1]</code> is the derivative  of the second Kraus operator with respect to the first parameter.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>rho (np.array):      Evolved density matrix.</p> <p>drho (list):      Derivatives of the evolved density matrix with respect to the unknown parameters.     Each element in the list is a matrix representing the partial derivative of \\(\\rho\\) with      respect to one parameter.</p> Source code in <code>quanestimation/Parameterization/NonDynamics.py</code> <pre><code>def Kraus(rho0, K, dK):\n    r\"\"\"\n    Parameterization of a quantum state using Kraus operators.\n\n    The evolved density matrix $\\rho$ is given by\n\n    \\begin{aligned}\n        \\rho=\\sum_i K_i \\rho_0 K_i^{\\dagger},\n    \\end{aligned}\n\n    where $\\rho_0$ is the initial density matrix and $K_i$ are the Kraus operators.\n\n    Args: \n        rho0 (np.array): \n            Initial density matrix.\n        K (list): \n            Kraus operators.\n        dK (list): \n            Derivatives of the Kraus operators with respect to the unknown parameters to be \n            estimated. This is a nested list where the first index corresponds to the Kraus operator \n            and the second index corresponds to the parameter. For example, `dK[0][1]` is the derivative \n            of the second Kraus operator with respect to the first parameter.\n\n    Returns:\n        (tuple):\n            rho (np.array): \n                Evolved density matrix.\n\n            drho (list): \n                Derivatives of the evolved density matrix with respect to the unknown parameters.  \n                Each element in the list is a matrix representing the partial derivative of $\\rho$ with \n                respect to one parameter.\n    \"\"\"\n\n    k_num = len(K)\n    para_num = len(dK[0])\n    dK_reshape = [[dK[i][j] for i in range(k_num)] for j in range(para_num)]\n\n    rho = sum([np.dot(Ki, np.dot(rho0, Ki.conj().T)) for Ki in K])\n    drho = [sum([(np.dot(dKi, np.dot(rho0, Ki.conj().T))+ np.dot(Ki, np.dot(rho0, dKi.conj().T))) for (Ki, dKi) in zip(K, dKj)]) for dKj in dK_reshape]\n\n    return rho, drho\n</code></pre>"},{"location":"API/python/functions/#metrological-resources","title":"Metrological resources","text":""},{"location":"API/python/functions/#spin-squeezing","title":"Spin squeezing","text":"<p>Calculation of the spin squeezing parameter for a density matrix.</p> <p>The spin squeezing parameter \\(\\xi\\) given by Kitagawa and Ueda is defined as:</p> \\[ \\xi^2 = \\frac{N(\\Delta J_{\\vec{n}_1})^2}{\\langle J_{\\vec{n}_3}\\rangle^2} \\] <p>where \\(J_{\\vec{n}_i}\\) are the collective spin operators.</p> <p>The spin squeezing parameter \\(\\xi\\) given by Wineland etal. is defined as:</p> \\[ \\xi^2 = \\left(\\frac{j}{\\langle \\vec{J}\\rangle}\\right)^2 \\frac{N(\\Delta J_{\\vec{n}_1})^2}{\\langle J_{\\vec{n}_3}\\rangle^2} \\] <p>Parameters:</p> Name Type Description Default <code>rho</code> <code>array</code> <p>Density matrix.</p> required <code>basis</code> <code>str</code> <p>Basis to use: \"Dicke\" (default) or \"Pauli\".</p> <code>'Dicke'</code> <code>output</code> <code>str</code> <p>Type of spin squeezing to calculate:     - \"KU\": Kitagawa-Ueda squeezing parameter.     - \"WBIMH\": Wineland et al. squeezing parameter.  </p> <code>'KU'</code> <p>Returns:</p> Type Description <code>float</code> <p>Spin squeezing parameter.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>basis</code> has invalid value.  </p> <code>ValueError</code> <p>If <code>output</code> has invalid value.</p> Source code in <code>quanestimation/Resource/Resource.py</code> <pre><code>def SpinSqueezing(rho, basis=\"Dicke\", output=\"KU\"):\n    r\"\"\"\n    Calculation of the spin squeezing parameter for a density matrix.\n\n    The spin squeezing parameter $\\xi$ given by Kitagawa and Ueda is defined as:\n\n    $$\n    \\xi^2 = \\frac{N(\\Delta J_{\\vec{n}_1})^2}{\\langle J_{\\vec{n}_3}\\rangle^2}\n    $$\n\n    where $J_{\\vec{n}_i}$ are the collective spin operators.\n\n    The spin squeezing parameter $\\xi$ given by Wineland etal. is defined as:\n\n    $$\n    \\xi^2 = \\left(\\frac{j}{\\langle \\vec{J}\\rangle}\\right)^2 \\frac{N(\\Delta J_{\\vec{n}_1})^2}{\\langle J_{\\vec{n}_3}\\rangle^2}\n    $$\n\n    Args:\n        rho (np.array): \n            Density matrix.\n        basis (str, optional): \n            Basis to use: \"Dicke\" (default) or \"Pauli\".\n        output (str, optional): \n            Type of spin squeezing to calculate:  \n                - \"KU\": Kitagawa-Ueda squeezing parameter.  \n                - \"WBIMH\": Wineland et al. squeezing parameter.  \n\n    Returns:\n        (float): \n            Spin squeezing parameter.\n\n    Raises:\n        ValueError: If `basis` has invalid value.  \n        ValueError: If `output` has invalid value.  \n    \"\"\"\n\n    if basis == \"Pauli\":\n        N = int(np.log(len(rho)) / np.log(2))\n        j = N / 2\n        coef = 4.0 / float(N)\n        sp = np.array([[0.0, 1.0], [0.0, 0.0]])\n        sz = np.array([[1., 0.], [0., -1.]])\n        jp = []\n        jz = []\n        for i in range(N):\n            if i == 0:\n                jp_tp = np.kron(sp, np.identity(2 ** (N - 1)))\n                jz_tp = np.kron(sz, np.identity(2 ** (N - 1)))\n            elif i == N - 1:\n                jp_tp = np.kron(np.identity(2 ** (N - 1)), sp)\n                jz_tp = np.kron(np.identity(2 ** (N - 1)), sz)\n            else:\n                jp_tp = np.kron(\n                    np.identity(2 ** i), \n                    np.kron(sp, np.identity(2 ** (N - 1 - i)))\n                )\n                jz_tp = np.kron(\n                    np.identity(2 ** i), \n                    np.kron(sz, np.identity(2 ** (N - 1 - i)))\n                )\n            jp.append(jp_tp)\n            jz.append(jz_tp)\n        Jp = sum(jp)\n        Jz = 0.5 * sum(jz)\n    elif basis == \"Dicke\":\n        N = len(rho) - 1\n        j = N / 2 \n        coef = 4.0 / float(N)       \n        offdiag = [\n            np.sqrt(float(j * (j + 1) - m * (m + 1))) \n            for m in np.arange(j, -j - 1, -1)\n        ][1:]\n        # Ensure we create a complex array\n        Jp = np.diag(offdiag, 1).astype(complex)\n        Jz = np.diag(np.arange(j, -j - 1, -1))\n    else:\n        valid_types = [\"Dicke\", \"Pauli\"]\n        raise ValueError(\n                f\"Invalid basis: '{basis}'. Supported types: {', '.join(valid_types)}\"\n            )    \n\n    Jx = 0.5 * (Jp + np.conj(Jp).T)\n    Jy = -0.5 * 1j * (Jp - np.conj(Jp).T)\n\n    Jx_mean = np.trace(rho @ Jx)\n    Jy_mean = np.trace(rho @ Jy)\n    Jz_mean = np.trace(rho @ Jz)\n\n    if Jx_mean == 0 and Jy_mean == 0:\n        if Jz_mean == 0:\n            raise ValueError(\"The density matrix does not have a valid spin squeezing.\")\n        else:\n            A = np.trace(rho @ (Jx @ Jx - Jy @ Jy))\n            B = np.trace(rho @ (Jx @ Jy + Jy @ Jx))\n            C = np.trace(rho @ (Jx @ Jx + Jy @ Jy))\n    else:\n        costheta = Jz_mean / np.sqrt(Jx_mean**2 + Jy_mean**2 + Jz_mean**2)\n        sintheta = np.sin(np.arccos(costheta))\n        cosphi = Jx_mean / np.sqrt(Jx_mean**2 + Jy_mean**2)\n        sinphi = (np.sin(np.arccos(cosphi)) if Jy_mean &gt; 0 \n                  else np.sin(2 * np.pi - np.arccos(cosphi)))\n\n        Jn1 = -Jx * sinphi + Jy * cosphi\n        Jn2 = (-Jx * costheta * cosphi \n                - Jy * costheta * sinphi \n                + Jz * sintheta)\n        A = np.trace(rho @ (Jn1 @ Jn1 - Jn2 @ Jn2))\n        B = np.trace(rho @ (Jn1 @ Jn2 + Jn2 @ Jn1))\n        C = np.trace(rho @ (Jn1 @ Jn1 + Jn2 @ Jn2))\n\n    V_minus = 0.5 * (C - np.sqrt(A**2 + B**2))\n    V_minus = np.real(V_minus)\n    xi = coef * V_minus\n\n    if output == \"KU\":\n        pass\n    elif output == \"WBIMH\":\n        xi = (N / 2)**2 * xi / (Jx_mean**2 + Jy_mean**2 + Jz_mean**2)\n    else:\n        valid_types = [\"KU\", \"WBIMH\"]\n        raise ValueError(\n                f\"Invalid basis: '{basis}'. Supported types: {', '.join(valid_types)}\"\n            )  \n\n    return xi\n</code></pre>"},{"location":"API/python/functions/#target-time","title":"Target time","text":"<p>Calculation of the time to reach a given precision limit. </p> <p>This function finds the earliest time \\(t\\) in <code>tspan</code> where the objective  function <code>func</code> reaches or crosses the target value \\(f\\). The first argument  of func must be the time variable.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>float</code> <p>The target value of the objective function.</p> required <code>tspan</code> <code>array</code> <p>Time points for the evolution.</p> required <code>func</code> <code>callable</code> <p>The objective function to evaluate. Must return a float.</p> required <code>*args</code> <code>tuple</code> <p>Positional arguments to pass to <code>func</code>.</p> <code>()</code> <code>**kwargs</code> <code>dict</code> <p>Keyword arguments to pass to <code>func</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>float</code> <p>Time to reach the given target precision.</p> Source code in <code>quanestimation/Resource/Resource.py</code> <pre><code>def TargetTime(f, tspan, func, *args, **kwargs):\n    r\"\"\"\n    Calculation of the time to reach a given precision limit. \n\n    This function finds the earliest time $t$ in `tspan` where the objective \n    function `func` reaches or crosses the target value $f$. The first argument \n    of func must be the time variable.\n\n    Args:\n        f (float): \n            The target value of the objective function.\n        tspan (array): \n            Time points for the evolution.\n        func (callable): \n            The objective function to evaluate. Must return a float.\n        *args (tuple): \n            Positional arguments to pass to `func`.\n        **kwargs (dict): \n            Keyword arguments to pass to `func`.\n\n    Returns:\n        (float): \n            Time to reach the given target precision.\n    \"\"\"\n    # Check if we're already at the target at the first point\n    f0 = func(tspan[0], *args, **kwargs)\n    if np.isclose(f0, f, atol=1e-8):\n        return tspan[0]\n\n    # Iterate through time points\n    for i in range(1, len(tspan)):\n        f1 = func(tspan[i], *args, **kwargs)\n\n        # Check if we've crossed the target\n        if (f0 - f) * (f1 - f) &lt;= 0:\n            return tspan[i]\n        elif np.isclose(f1, f, atol=1e-8):\n            return tspan[i]\n\n        f0 = f1\n\n    # No crossing found\n    print(\"No time is found in the given time span to reach the target.\")\n\n    return None\n</code></pre>"},{"location":"API/python/functions/#quantum-cramer-rao-bounds","title":"Quantum Cram\u00e9r-Rao bounds","text":""},{"location":"API/python/functions/#classical-fisher-information-matrix-cfim","title":"Classical Fisher information matrix (CFIM)","text":"<p>Calculation of the classical Fisher information matrix for the chosen measurements.</p> <p>This function computes the classical Fisher information (CFI) and classical Fisher  information matrix (CFIM) for a density matrix. The entry of CFIM \\(\\mathcal{I}\\) is defined as</p> \\[ \\mathcal{I}_{ab}=\\sum_y\\frac{1}{p(y|\\textbf{x})}[\\partial_a p(y|\\textbf{x})][\\partial_b p(y|\\textbf{x})], \\] Symbols <ul> <li>\\(p(y|\\textbf{x})=\\mathrm{Tr}(\\rho\\Pi_y)\\).</li> <li>\\(\\rho\\): the parameterized density matrix.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>rho</code> <code>array</code> <p>Density matrix.</p> required <code>drho</code> <code>list</code> <p>List of derivative matrices of the density matrix on the unknown  parameters to be estimated. For example, drho[0] is the derivative  matrix on the first parameter.</p> required <code>M</code> <code>list</code> <p>List of positive operator-valued measure (POVM). The default  measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM).</p> <code>[]</code> <code>eps</code> <code>float</code> <p>Machine epsilon for numerical stability.</p> <code>1e-08</code> <p>Returns:</p> Type Description <code>float / array</code> <p>For single parameter estimation (the length of drho is equal to one), the output is CFI  and for multiparameter estimation (the length of drho is more than one), it returns CFIM.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If drho is not a list.</p> <code>TypeError</code> <p>If M is not a list.   </p> Example <p>rho = np.array([[0.5, 0], [0, 0.5]]);</p> <p>drho = [np.array([[1, 0], [0, -1]])];</p> <p>cfim = CFIM(rho, drho);     </p> Notes <p>SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state  which can be downloaded from here.</p> Source code in <code>quanestimation/AsymptoticBound/CramerRao.py</code> <pre><code>def CFIM(rho, drho, M=[], eps=1e-8):\n    r\"\"\"\n    Calculation of the classical Fisher information matrix for the chosen measurements.\n\n    This function computes the classical Fisher information (CFI) and classical Fisher \n    information matrix (CFIM) for a density matrix. The entry of CFIM $\\mathcal{I}$\n    is defined as\n\n    $$\n    \\mathcal{I}_{ab}=\\sum_y\\frac{1}{p(y|\\textbf{x})}[\\partial_a p(y|\\textbf{x})][\\partial_b p(y|\\textbf{x})],\n    $$\n\n    Symbols: \n        - $p(y|\\textbf{x})=\\mathrm{Tr}(\\rho\\Pi_y)$.\n        - $\\rho$: the parameterized density matrix.\n\n    Args: \n        rho (np.array): \n            Density matrix.\n        drho (list): \n            List of derivative matrices of the density matrix on the unknown \n            parameters to be estimated. For example, drho[0] is the derivative \n            matrix on the first parameter.\n        M (list, optional): \n            List of positive operator-valued measure (POVM). The default \n            measurement is a set of rank-one symmetric informationally complete POVM (SIC-POVM).\n        eps (float, optional): \n            Machine epsilon for numerical stability.\n\n    Returns:\n        (float/np.array): \n            For single parameter estimation (the length of drho is equal to one), the output is CFI \n            and for multiparameter estimation (the length of drho is more than one), it returns CFIM.\n\n    Raises:\n        TypeError: If drho is not a list.\n        TypeError: If M is not a list.   \n\n    Example:\n        rho = np.array([[0.5, 0], [0, 0.5]]);\n\n        drho = [np.array([[1, 0], [0, -1]])];\n\n        cfim = CFIM(rho, drho);     \n\n    Notes: \n        SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state \n        which can be downloaded from [here](https://www.physics.umb.edu/Research/QBism/solutions.html).\n    \"\"\"\n\n    if not isinstance(drho, list):\n        raise TypeError(\"Please make sure drho is a list!\")\n\n    if not M:\n        M = SIC(len(rho[0]))\n    else:\n        if not isinstance(M, list):\n            raise TypeError(\"Please make sure M is a list!\")\n\n    num_measurements = len(M)\n    num_params = len(drho)\n    cfim_res = np.zeros([num_params, num_params])\n\n    for i in range(num_measurements):\n        povm_element = M[i]\n        p = np.real(np.trace(rho @ povm_element))\n        c_add = np.zeros([num_params, num_params])\n\n        if p &gt; eps:\n            for param_i in range(num_params):\n                drho_i = drho[param_i]\n                dp_i = np.real(np.trace(drho_i @ povm_element))\n\n                for param_j in range(param_i, num_params):\n                    drho_j = drho[param_j]\n                    dp_j = np.real(np.trace(drho_j @ povm_element))\n                    c_add[param_i][param_j] = np.real(dp_i * dp_j / p)\n                    c_add[param_j][param_i] = np.real(dp_i * dp_j / p)\n\n        cfim_res += c_add\n\n    if num_params == 1:\n        return cfim_res[0][0]\n    else:\n        return cfim_res\n</code></pre>"},{"location":"API/python/functions/#fisher-information-matrix-fim","title":"Fisher information matrix (FIM)","text":"<p>Calculation of the classical Fisher information matrix (CFIM) for a given probability distributions.</p> <p>This function computes the classical Fisher information matrix (CFIM) for a given probability  distributions. The entry of FIM \\(I\\) is defined as</p> \\[ I_{ab}=\\sum_{y}\\frac{1}{p_y}[\\partial_a p_y][\\partial_b p_y], \\] Symbols <ul> <li>\\(\\{p_y\\}\\): a set of the discrete probability distribution.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>array</code> <p>The probability distribution.</p> required <code>dp</code> <code>list</code> <p>Derivatives of the probability distribution on the unknown parameters to  be estimated. For example, dp[0] is the derivative vector on the first parameter.</p> required <code>eps</code> <code>float</code> <p>Machine epsilon.</p> <code>1e-08</code> <p>Returns:</p> Type Description <code>float / array</code> <p>For single parameter estimation (the length of drho is equal to one), the output is CFI  and for multiparameter estimation (the length of drho is more than one), it returns CFIM.</p> Source code in <code>quanestimation/AsymptoticBound/CramerRao.py</code> <pre><code>def FIM(p, dp, eps=1e-8):\n    r\"\"\"\n    Calculation of the classical Fisher information matrix (CFIM) for a given probability distributions.\n\n    This function computes the classical Fisher information matrix (CFIM) for a given probability \n    distributions. The entry of FIM $I$ is defined as\n\n    $$\n    I_{ab}=\\sum_{y}\\frac{1}{p_y}[\\partial_a p_y][\\partial_b p_y],\n    $$\n\n    Symbols: \n        - $\\{p_y\\}$: a set of the discrete probability distribution.\n\n    Args: \n        p (np.array): \n            The probability distribution.\n        dp (list): \n            Derivatives of the probability distribution on the unknown parameters to \n            be estimated. For example, dp[0] is the derivative vector on the first parameter.\n        eps (float, optional): \n            Machine epsilon.\n\n    Returns:\n        (float/np.array): \n            For single parameter estimation (the length of drho is equal to one), the output is CFI \n            and for multiparameter estimation (the length of drho is more than one), it returns CFIM.\n    \"\"\"\n\n    num_params = len(dp)\n    num_measurements = len(p)\n    fim_matrix = np.zeros([num_params, num_params])\n\n    for outcome_idx in range(num_measurements):\n        p_value = p[outcome_idx]\n        fim_add = np.zeros([num_params, num_params])\n\n        if p_value &gt; eps:\n            for param_i in range(num_params):\n                dp_i = dp[param_i][outcome_idx]\n\n                for param_j in range(param_i, num_params):\n                    dp_j = dp[param_j][outcome_idx]\n                    term = np.real(dp_i * dp_j / p_value)\n                    fim_add[param_i][param_j] = term\n                    fim_add[param_j][param_i] = term\n\n        fim_matrix += fim_add\n\n    if num_params == 1:\n        return fim_matrix[0][0]\n    else:\n        return fim_matrix\n</code></pre>"},{"location":"API/python/functions/#fisher-information-fi_expt","title":"Fisher information (FI_Expt)","text":"<p>Calculate the classical Fisher information (CFI) based on experimental data.</p> <p>Parameters:</p> Name Type Description Default <code>data_true</code> <code>array</code> <p>Experimental data obtained at the true parameter value.</p> required <code>data_shifted</code> <code>array</code> <p>Experimental data obtained at parameter value shifted by delta_x.</p> required <code>delta_x</code> <code>float</code> <p>Small known parameter shift.</p> required <code>ftype</code> <code>str</code> <p>Probability distribution of the data. Options:     - \"norm\": normal distribution (default).     - \"gamma\": gamma distribution.     - \"rayleigh\": Rayleigh distribution.     - \"poisson\": Poisson distribution.  </p> <code>'norm'</code> <p>Returns:</p> Type Description <code>float</code> <p>Classical Fisher information</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>ftype</code> is not one of the supported types (\"norm\", \"poisson\", \"gamma\", \"rayleigh\").    </p> Notes <p>The current implementation may be unstable and is subject to future modification.</p> Source code in <code>quanestimation/AsymptoticBound/CramerRao.py</code> <pre><code>def FI_Expt(data_true, data_shifted, delta_x, ftype=\"norm\"):\n    \"\"\"\n    Calculate the classical Fisher information (CFI) based on experimental data.\n\n    Args:\n        data_true (np.array): \n            Experimental data obtained at the true parameter value.\n        data_shifted (np.array): \n            Experimental data obtained at parameter value shifted by delta_x.\n        delta_x (float): \n            Small known parameter shift.\n        ftype (str, optional): \n            Probability distribution of the data. Options:  \n                - \"norm\": normal distribution (default).  \n                - \"gamma\": gamma distribution.  \n                - \"rayleigh\": Rayleigh distribution.  \n                - \"poisson\": Poisson distribution.  \n\n    Returns: \n        (float): \n            Classical Fisher information\n\n    Raises:\n        ValueError: \n            If `ftype` is not one of the supported types (\"norm\", \"poisson\", \"gamma\", \"rayleigh\").    \n\n    Notes:\n        The current implementation may be unstable and is subject to future modification.\n    \"\"\"\n    fidelity = 0.0\n    if ftype == \"norm\":\n        mu_true, std_true = norm.fit(data_true)\n        mu_shifted, std_shifted = norm.fit(data_shifted)\n        f_function = lambda x: np.sqrt(\n            norm.pdf(x, mu_true, std_true) * norm.pdf(x, mu_shifted, std_shifted)\n        )\n        fidelity, _ = quad(f_function, -np.inf, np.inf)\n\n    elif ftype == \"gamma\":\n        a_true, alpha_true, beta_true = gamma.fit(data_true)\n        a_shifted, alpha_shifted, beta_shifted = gamma.fit(data_shifted)\n        f_function = lambda x: np.sqrt(\n            gamma.pdf(x, a_true, alpha_true, beta_true) *\n            gamma.pdf(x, a_shifted, alpha_shifted, beta_shifted)\n        )\n        fidelity, _ = quad(f_function, 0., np.inf)\n\n    elif ftype == \"rayleigh\":\n        mean_true, var_true = rayleigh.fit(data_true)\n        mean_shifted, var_shifted = rayleigh.fit(data_shifted)\n        f_function = lambda x: np.sqrt(\n            rayleigh.pdf(x, mean_true, var_true) *\n            rayleigh.pdf(x, mean_shifted, var_shifted)\n        )\n        fidelity, _ = quad(f_function, -np.inf, np.inf)\n\n    elif ftype == \"poisson\":\n        k_max = max(max(data_true) + 1, max(data_shifted) + 1)\n        k_values = np.arange(k_max)\n        p_true = poisson.pmf(k_values, np.mean(data_true))\n        p_shifted = poisson.pmf(k_values, np.mean(data_shifted))\n        p_true /= np.sum(p_true)\n        p_shifted /= np.sum(p_shifted)\n        fidelity = np.sum(np.sqrt(p_true * p_shifted))\n\n    else:\n        valid_types = [\"norm\", \"poisson\", \"gamma\", \"rayleigh\"]\n        raise ValueError(\n            f\"Invalid distribution type: '{ftype}'. \"\n            f\"Supported types are: {', '.join(valid_types)}\"\n        )\n\n    fisher_information = 8 * (1 - fidelity) / delta_x**2\n    return fisher_information\n</code></pre>"},{"location":"API/python/functions/#symmetric-logarithmic-derivative-sld","title":"Symmetric logarithmic derivative (SLD)","text":"<p>Calculation of the symmetric logarithmic derivative (SLD) for a density matrix.</p> <p>This function computes the SLD operator \\(L_a\\), which is determined by</p> \\[ \\partial_{a}\\rho=\\frac{1}{2}(\\rho L_{a}+L_{a}\\rho) \\] <p>with \\(\\rho\\) the parameterized density matrix. The entries of SLD can be calculated as </p> \\[ \\langle\\lambda_i|L_{a}|\\lambda_j\\rangle=\\frac{2\\langle\\lambda_i| \\partial_{a}\\rho |\\lambda_j\\rangle}{\\lambda_i+\\lambda_j \\] <p>for \\(\\lambda_i~(\\lambda_j) \\neq 0\\). If \\(\\lambda_i=\\lambda_j=0\\), the entry of SLD is set to be zero.</p> <p>Parameters:</p> Name Type Description Default <code>rho</code> <code>array</code> <p>Density matrix.</p> required <code>drho</code> <code>list</code> <p>Derivatives of the density matrix on the unknown parameters to be  estimated. For example, drho[0] is the derivative vector on the first parameter.</p> required <code>rep</code> <code>str</code> <p>The basis for the SLDs. Options:     - \"original\" (default): basis same as input density matrix     - \"eigen\": basis same as eigenspace of density matrix</p> <code>'original'</code> <code>eps</code> <code>float</code> <p>Machine epsilon.</p> <code>1e-08</code> <p>Returns:</p> Type Description <code>array / list</code> <p>For single parameter estimation (i.e., length of <code>drho</code> equals 1), returns a matrix. For multiparameter estimation (i.e., length of <code>drho</code> is larger than 1), returns a list of matrices.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>drho</code> is not a list.  </p> <code>ValueError</code> <p>If <code>rep</code> has invalid value.</p> Source code in <code>quanestimation/AsymptoticBound/CramerRao.py</code> <pre><code>def SLD(rho, drho, rep=\"original\", eps=1e-8):\n    r\"\"\"\n    Calculation of the symmetric logarithmic derivative (SLD) for a density matrix.\n\n    This function computes the SLD operator $L_a$, which is determined by\n\n    $$\n    \\partial_{a}\\rho=\\frac{1}{2}(\\rho L_{a}+L_{a}\\rho)\n    $$\n\n    with $\\rho$ the parameterized density matrix. The entries of SLD can be calculated as \n\n    $$\n    \\langle\\lambda_i|L_{a}|\\lambda_j\\rangle=\\frac{2\\langle\\lambda_i| \\partial_{a}\\rho |\\lambda_j\\rangle}{\\lambda_i+\\lambda_j\n    $$\n\n    for $\\lambda_i~(\\lambda_j) \\neq 0$. If $\\lambda_i=\\lambda_j=0$, the entry of SLD is set to be zero.\n\n    Args:\n        rho (np.array): \n            Density matrix.\n        drho (list): \n            Derivatives of the density matrix on the unknown parameters to be \n            estimated. For example, drho[0] is the derivative vector on the first parameter.\n        rep (str, optional): \n            The basis for the SLDs. Options:  \n                - \"original\" (default): basis same as input density matrix  \n                - \"eigen\": basis same as eigenspace of density matrix\n        eps (float, optional): \n            Machine epsilon.\n\n    Returns:\n        (np.array/list): \n            For single parameter estimation (i.e., length of `drho` equals 1), returns a matrix.  \n            For multiparameter estimation (i.e., length of `drho` is larger than 1), returns a list of matrices.\n\n    Raises:\n        TypeError: If `drho` is not a list.  \n        ValueError: If `rep` has invalid value. \n    \"\"\"\n\n    if not isinstance(drho, list):\n        raise TypeError(\"drho must be a list of derivative matrices\")\n\n    num_params = len(drho)\n    dim = len(rho)\n    slds = [None] * num_params\n\n    purity = np.trace(rho @ rho)\n\n    # Handle pure state case\n    if np.abs(1 - purity) &lt; eps:\n        sld_original = [2 * d for d in drho]\n\n        for i in range(num_params):\n            if rep == \"original\":\n                slds[i] = sld_original[i]\n            elif rep == \"eigen\":\n                eigenvalues, eigenvectors = np.linalg.eig(rho)\n                eigenvalues = np.real(eigenvalues)\n                slds[i] = eigenvectors.conj().T @ sld_original[i] @ eigenvectors\n            else:\n                valid_reps = [\"original\", \"eigen\"]\n                raise ValueError(f\"Invalid rep value: '{rep}'. Valid options: {valid_reps}\")\n\n        return slds[0] if num_params == 1 else slds\n\n    # Handle mixed state case\n    eigenvalues, eigenvectors = np.linalg.eig(rho)\n    eigenvalues = np.real(eigenvalues)\n\n    for param_idx in range(num_params):\n        sld_eigenbasis = np.zeros((dim, dim), dtype=np.complex128)\n\n        for i in range(dim):\n            for j in range(dim):\n                if eigenvalues[i] + eigenvalues[j] &gt; eps:\n                    # Calculate matrix element in eigenbasis\n                    numerator = 2 * (eigenvectors[:, i].conj().T @ drho[param_idx] @ eigenvectors[:, j])\n                    sld_eigenbasis[i, j] = numerator / (eigenvalues[i] + eigenvalues[j])\n\n        # Handle any potential infinities\n        sld_eigenbasis[np.isinf(sld_eigenbasis)] = 0.0\n\n        # Transform to requested basis\n        if rep == \"original\":\n            slds[param_idx] = eigenvectors @ sld_eigenbasis @ eigenvectors.conj().T\n        elif rep == \"eigen\":\n            slds[param_idx] = sld_eigenbasis\n        else:\n            valid_reps = [\"original\", \"eigen\"]\n            raise ValueError(f\"Invalid rep value: '{rep}'. Valid options: {valid_reps}\")\n\n    return slds[0] if num_params == 1 else slds\n</code></pre>"},{"location":"API/python/functions/#right-logarithmic-derivative-rld","title":"Right logarithmic derivative (RLD)","text":"<p>Calculation of the right logarithmic derivative (RLD) for a density matrix. The RLD operator \\(\\mathcal{R}_a\\) is defined by</p> \\[ \\partial_{a}\\rho=\\rho \\mathcal{R}_a \\] <p>with \\(\\rho\\) the parameterized density matrix. The entries of RLD can be calculated as </p> \\[ \\langle\\lambda_i| \\mathcal{R}_{a} |\\lambda_j\\rangle=\\frac{1}{\\lambda_i}\\langle\\lambda_i|  \\partial_a\\rho |\\lambda_j\\rangle  \\] <p>for \\(\\lambda_i\\neq 0\\).</p> <p>Parameters:</p> Name Type Description Default <code>rho</code> <code>array</code> <p>Density matrix.  </p> required <code>drho</code> <code>list</code> <p>Derivatives of the density matrix on the unknown parameters to be  estimated. For example, drho[0] is the derivative vector on the first parameter.</p> required <code>rep</code> <code>str</code> <p>The basis for the RLD(s). Options:     - \"original\" (default): basis same as input density matrix.     - \"eigen\": basis same as eigenspace of density matrix.</p> <code>'original'</code> <code>eps</code> <code>float</code> <p>Machine epsilon.</p> <code>1e-08</code> <p>Returns:</p> Type Description <code>array / list</code> <p>For single parameter estimation (i.e., length of <code>drho</code> equals 1), returns a matrix. For multiparameter estimation (i.e., length of <code>drho</code> is larger than 1), returns a list of matrices.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>drho</code> is not a list.</p> <code>ValueError</code> <p>If <code>rep</code> has invalid value or RLD doesn't exist.</p> Source code in <code>quanestimation/AsymptoticBound/CramerRao.py</code> <pre><code>def RLD(rho, drho, rep=\"original\", eps=1e-8):\n    r\"\"\"\n    Calculation of the right logarithmic derivative (RLD) for a density matrix.\n    The RLD operator $\\mathcal{R}_a$ is defined by\n\n    $$\n    \\partial_{a}\\rho=\\rho \\mathcal{R}_a\n    $$\n\n    with $\\rho$ the parameterized density matrix. The entries of RLD can be calculated as \n\n    $$\n    \\langle\\lambda_i| \\mathcal{R}_{a} |\\lambda_j\\rangle=\\frac{1}{\\lambda_i}\\langle\\lambda_i| \n    \\partial_a\\rho |\\lambda_j\\rangle \n    $$\n\n    for $\\lambda_i\\neq 0$.\n\n    Args:\n        rho (np.array): \n            Density matrix.  \n        drho (list):  \n            Derivatives of the density matrix on the unknown parameters to be \n            estimated. For example, drho[0] is the derivative vector on the first parameter.\n        rep (str, optional): \n            The basis for the RLD(s). Options:  \n                - \"original\" (default): basis same as input density matrix.  \n                - \"eigen\": basis same as eigenspace of density matrix.\n        eps (float, optional): \n            Machine epsilon.\n\n    Returns:\n        (np.array/list): \n            For single parameter estimation (i.e., length of `drho` equals 1), returns a matrix.  \n            For multiparameter estimation (i.e., length of `drho` is larger than 1), returns a list of matrices.\n\n    Raises:\n        TypeError: If `drho` is not a list.\n        ValueError: If `rep` has invalid value or RLD doesn't exist.\n    \"\"\"\n\n    if not isinstance(drho, list):\n        raise TypeError(\"drho must be a list of derivative matrices\")\n\n    num_params = len(drho)\n    dim = len(rho)\n    rld_list = [None] * num_params\n\n    eigenvalues, eigenvectors = np.linalg.eig(rho)\n    eigenvalues = np.real(eigenvalues)\n\n    for param_idx in range(num_params):\n        rld_eigenbasis = np.zeros((dim, dim), dtype=np.complex128)\n\n        for i in range(dim):\n            for j in range(dim):\n                # Calculate matrix element in eigenbasis\n                element = (\n                    eigenvectors[:, i].conj().T \n                    @ drho[param_idx] \n                    @ eigenvectors[:, j]\n                )\n\n                if np.abs(eigenvalues[i]) &gt; eps:\n                    rld_eigenbasis[i, j] = element / eigenvalues[i]\n                else:\n                    if np.abs(element) &gt; eps:\n                        raise ValueError(\n                            \"RLD does not exist. It only exists when the support of \"\n                            \"drho is contained in the support of rho.\"\n                        )\n\n        # Handle any potential infinities\n        rld_eigenbasis[np.isinf(rld_eigenbasis)] = 0.0\n\n        # Transform to requested basis\n        if rep == \"original\":\n            rld_list[param_idx] = (\n                eigenvectors \n                @ rld_eigenbasis \n                @ eigenvectors.conj().T\n            )\n        elif rep == \"eigen\":\n            rld_list[param_idx] = rld_eigenbasis\n        else:\n            valid_reps = [\"original\", \"eigen\"]\n            raise ValueError(\n                f\"Invalid rep value: '{rep}'. Valid options: {', '.join(valid_reps)}\"\n            )\n\n    return rld_list[0] if num_params == 1 else rld_list\n</code></pre>"},{"location":"API/python/functions/#left-logarithmic-derivative-lld","title":"Left logarithmic derivative (LLD)","text":"<p>Calculation of the left logarithmic derivative (LLD) for a density matrix \\(\\rho\\).</p> <p>The LLD operator \\(\\mathcal{R}_a^{\\dagger}\\) is defined by</p> \\[ \\partial_{a}\\rho=\\mathcal{R}_a^{\\dagger}\\rho. \\] <p>The entries of LLD can be calculated as </p> \\[ \\langle\\lambda_i| \\mathcal{R}_{a}^{\\dagger} |\\lambda_j\\rangle=\\frac{1}{\\lambda_j}\\langle\\lambda_i|  \\partial_a\\rho |\\lambda_j\\rangle  \\] <p>for \\(\\lambda_j\\neq 0\\).</p> <p>Parameters:</p> Name Type Description Default <code>rho</code> <code>array</code> <p>Density matrix.</p> required <code>drho</code> <code>list</code> <p>Derivatives of the density matrix on the unknown parameters to be estimated.  For example, drho[0] is the derivative vector on the first parameter.</p> required <code>rep</code> <code>str</code> <p>The basis for the LLD(s). Options:     - \"original\" (default): basis same as input density matrix.     - \"eigen\": basis same as eigenspace of density matrix.</p> <code>'original'</code> <code>eps</code> <code>float</code> <p>Machine epsilon.</p> <code>1e-08</code> <p>Returns:</p> Type Description <code>array / list</code> <p>For single parameter estimation (i.e., length of <code>drho</code> equals 1), returns a matrix. For multiparameter estimation (i.e., length of <code>drho</code> is larger than 1), returns a list of matrices.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>drho</code> is not a list.  </p> <code>ValueError</code> <p>If <code>rep</code> has invalid value or LLD doesn't exist.</p> Source code in <code>quanestimation/AsymptoticBound/CramerRao.py</code> <pre><code>def LLD(rho, drho, rep=\"original\", eps=1e-8):\n    r\"\"\"\n    Calculation of the left logarithmic derivative (LLD) for a density matrix $\\rho$.\n\n    The LLD operator $\\mathcal{R}_a^{\\dagger}$ is defined by\n\n    $$\n    \\partial_{a}\\rho=\\mathcal{R}_a^{\\dagger}\\rho.\n    $$\n\n    The entries of LLD can be calculated as \n\n    $$\n    \\langle\\lambda_i| \\mathcal{R}_{a}^{\\dagger} |\\lambda_j\\rangle=\\frac{1}{\\lambda_j}\\langle\\lambda_i| \n    \\partial_a\\rho |\\lambda_j\\rangle \n    $$\n\n    for $\\lambda_j\\neq 0$.\n\n    Args: \n        rho (np.array): \n            Density matrix.\n        drho (list): \n            Derivatives of the density matrix on the unknown parameters to be estimated. \n            For example, drho[0] is the derivative vector on the first parameter.\n        rep (str, optional): \n            The basis for the LLD(s). Options:  \n                - \"original\" (default): basis same as input density matrix.  \n                - \"eigen\": basis same as eigenspace of density matrix.\n        eps (float, optional): \n            Machine epsilon.\n\n    Returns:\n        (np.array/list): \n            For single parameter estimation (i.e., length of `drho` equals 1), returns a matrix.  \n            For multiparameter estimation (i.e., length of `drho` is larger than 1), returns a list of matrices.\n\n    Raises:\n        TypeError: If `drho` is not a list.  \n        ValueError: If `rep` has invalid value or LLD doesn't exist.  \n    \"\"\"\n\n    if not isinstance(drho, list):\n        raise TypeError(\"drho must be a list of derivative matrices\")\n\n    param_num = len(drho)\n    dim = len(rho)\n    lld_list = [None] * param_num\n\n    eigenvalues, eigenvectors = np.linalg.eig(rho)\n    eigenvalues = np.real(eigenvalues)\n\n    for param_idx in range(param_num):\n        lld_eigenbasis = np.zeros((dim, dim), dtype=np.complex128)\n\n        for i in range(dim):\n            for j in range(dim):\n                # Calculate matrix element in eigenbasis\n                element = (\n                    eigenvectors[:, i].conj().T \n                    @ drho[param_idx] \n                    @ eigenvectors[:, j]\n                )\n\n                if np.abs(eigenvalues[j]) &gt; eps:\n                    lld_eigenbasis[i, j] = element / eigenvalues[j]\n                else:\n                    if np.abs(element) &gt; eps:\n                        raise ValueError(\n                            \"LLD does not exist. It only exists when the support of \"\n                            \"drho is contained in the support of rho.\"\n                        )\n\n        # Handle any potential infinities\n        lld_eigenbasis[np.isinf(lld_eigenbasis)] = 0.0\n\n        # Transform to requested basis\n        if rep == \"original\":\n            lld_list[param_idx] = (\n                eigenvectors \n                @ lld_eigenbasis \n                @ eigenvectors.conj().T\n            )\n        elif rep == \"eigen\":\n            lld_list[param_idx] = lld_eigenbasis\n        else:\n            valid_reps = [\"original\", \"eigen\"]\n            raise ValueError(\n                f\"Invalid rep value: '{rep}'. Valid options: {', '.join(valid_reps)}\"\n            )\n\n    return lld_list[0] if param_num == 1 else lld_list\n</code></pre>"},{"location":"API/python/functions/#quantum-fisher-information-matrix-qfim","title":"Quantum Fisher information matrix (QFIM)","text":"<p>Calculate the quantum Fisher information (QFI) and quantum Fisher  information matrix (QFIM) for all types.</p> <p>The entry of QFIM \\(\\mathcal{F}\\) is defined as:</p> \\[ \\mathcal{F}_{ab}=\\frac{1}{2}\\mathrm{Tr}(\\rho\\{L_a, L_b\\}) \\] <p>with \\(L_a, L_b\\) being SLD operators.</p> <p>Alternatively:</p> \\[ \\mathcal{F}_{ab}=\\mathrm{Tr}(\\rho \\mathcal{R}_a \\mathcal{R}^{\\dagger}_b) \\] <p>with \\(\\mathcal{R}_a\\) being the RLD or LLD operator.</p> <p>Parameters:</p> Name Type Description Default <code>rho</code> <code>array</code> <p>Density matrix.</p> required <code>drho</code> <code>list</code> <p>Derivatives of the density matrix with respect to the unknown parameters.  Each element in the list is a matrix of the same dimension as <code>rho</code> and  represents the partial derivative of the density matrix with respect to  one parameter. For example, <code>drho[0]</code> is the derivative with respect to  the first parameter.</p> required <code>LDtype</code> <code>str</code> <p>Specifies the type of logarithmic derivative to use for QFI/QFIM calculation:     - \"SLD\": Symmetric Logarithmic Derivative (default).     - \"RLD\": Right Logarithmic Derivative.     - \"LLD\": Left Logarithmic Derivative.  </p> <code>'SLD'</code> <code>exportLD</code> <code>bool</code> <p>Whether to export the values of logarithmic derivatives.  </p> <code>False</code> <code>eps</code> <code>float</code> <p>Machine epsilon.  </p> <code>1e-08</code> <p>Returns:</p> Type Description <code>float / array</code> <p>For single parameter estimation (i.e., length of <code>drho</code> equals 1), returns QFI. For multiparameter estimation (i.e., length of <code>drho</code> is larger than 1), returns QFIM.  </p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>drho</code> is not a list.</p> <code>ValueError</code> <p>If <code>LDtype</code> is not one of the supported types (\"SLD\", \"RLD\", \"LLD\").</p> Source code in <code>quanestimation/AsymptoticBound/CramerRao.py</code> <pre><code>def QFIM(rho, drho, LDtype=\"SLD\", exportLD=False, eps=1e-8):\n    r\"\"\"\n    Calculate the quantum Fisher information (QFI) and quantum Fisher \n    information matrix (QFIM) for all types.\n\n    The entry of QFIM $\\mathcal{F}$ is defined as:\n\n    $$\n    \\mathcal{F}_{ab}=\\frac{1}{2}\\mathrm{Tr}(\\rho\\{L_a, L_b\\})\n    $$\n\n    with $L_a, L_b$ being SLD operators.\n\n    Alternatively:\n\n    $$\n    \\mathcal{F}_{ab}=\\mathrm{Tr}(\\rho \\mathcal{R}_a \\mathcal{R}^{\\dagger}_b)\n    $$\n\n    with $\\mathcal{R}_a$ being the RLD or LLD operator.\n\n    Args:\n        rho (np.array): \n            Density matrix.\n        drho (list): \n            Derivatives of the density matrix with respect to the unknown parameters. \n            Each element in the list is a matrix of the same dimension as `rho` and \n            represents the partial derivative of the density matrix with respect to \n            one parameter. For example, `drho[0]` is the derivative with respect to \n            the first parameter.\n        LDtype (str, optional): \n            Specifies the type of logarithmic derivative to use for QFI/QFIM calculation:  \n                - \"SLD\": Symmetric Logarithmic Derivative (default).  \n                - \"RLD\": Right Logarithmic Derivative.  \n                - \"LLD\": Left Logarithmic Derivative.  \n        exportLD (bool, optional): \n            Whether to export the values of logarithmic derivatives.  \n        eps (float, optional): \n            Machine epsilon.  \n\n    Returns:\n        (float/np.array): \n            For single parameter estimation (i.e., length of `drho` equals 1), returns QFI.  \n            For multiparameter estimation (i.e., length of `drho` is larger than 1), returns QFIM.  \n\n    Raises:\n        TypeError: If `drho` is not a list.\n        ValueError: If `LDtype` is not one of the supported types (\"SLD\", \"RLD\", \"LLD\").        \n    \"\"\"\n\n    if not isinstance(drho, list):\n        raise TypeError(\"drho must be a list of derivative matrices\")\n\n    num_params = len(drho)\n    qfim_result = None\n    log_derivatives = None\n\n    # Single parameter estimation\n    if num_params == 1:\n        if LDtype == \"SLD\":\n            sld = SLD(rho, drho, eps=eps)\n            anticommutator = sld @ sld + sld @ sld\n            qfim_result = np.real(0.5 * np.trace(rho @ anticommutator))\n        elif LDtype == \"RLD\":\n            rld = RLD(rho, drho, eps=eps)\n            qfim_result = np.real(np.trace(rho @ rld @ rld.conj().T))\n        elif LDtype == \"LLD\":\n            lld = LLD(rho, drho, eps=eps)\n            qfim_result = np.real(np.trace(rho @ lld @ lld.conj().T))\n        else:\n            valid_types = [\"SLD\", \"RLD\", \"LLD\"]\n            raise ValueError(\n                f\"Invalid LDtype: '{LDtype}'. Supported types: {', '.join(valid_types)}\"\n            )\n        log_derivatives = sld if LDtype == \"SLD\" else rld if LDtype == \"RLD\" else lld\n\n    # Multiparameter estimation\n    else:\n        if LDtype == \"SLD\":\n            qfim_result = np.zeros((num_params, num_params))\n            sld_list = SLD(rho, drho, eps=eps)\n            for i in range(num_params):\n                for j in range(i, num_params):\n                    anticommutator = sld_list[i] @ sld_list[j] + sld_list[j] @ sld_list[i]\n                    qfim_result[i, j] = np.real(0.5 * np.trace(rho @ anticommutator))\n                    qfim_result[j, i] = qfim_result[i, j]\n            log_derivatives = sld_list\n\n        elif LDtype == \"RLD\":\n            qfim_result = np.zeros((num_params, num_params), dtype=np.complex128)\n            rld_list = RLD(rho, drho, eps=eps)\n            for i in range(num_params):\n                for j in range(i, num_params):\n                    term = np.trace(rho @ rld_list[i] @ rld_list[j].conj().T)\n                    qfim_result[i, j] = term\n                    qfim_result[j, i] = term.conj()\n            log_derivatives = rld_list\n\n        elif LDtype == \"LLD\":\n            qfim_result = np.zeros((num_params, num_params), dtype=np.complex128)\n            lld_list = LLD(rho, drho, eps=eps)\n            for i in range(num_params):\n                for j in range(i, num_params):\n                    term = np.trace(rho @ lld_list[i] @ lld_list[j].conj().T)\n                    qfim_result[i, j] = term\n                    qfim_result[j, i] = term.conj()\n            log_derivatives = lld_list\n\n        else:\n            valid_types = [\"SLD\", \"RLD\", \"LLD\"]\n            raise ValueError(\n                f\"Invalid LDtype: '{LDtype}'. Supported types: {', '.join(valid_types)}\"\n            )\n\n    if exportLD:\n        return qfim_result, log_derivatives\n    return qfim_result\n</code></pre>"},{"location":"API/python/functions/#quantum-fisher-information-matrix-with-kraus-operators","title":"Quantum Fisher information matrix with Kraus operators","text":"<p>Calculation of the quantum Fisher information (QFI) and quantum Fisher  information matrix (QFIM) for a quantum channel described by Kraus operators.</p> <p>The quantum channel is given by</p> \\[ \\rho=\\sum_{i} K_i \\rho_0 K_i^{\\dagger}, \\] <p>where \\(\\rho_0\\) is the initial state and \\(\\{K_i\\}\\) are the Kraus operators.</p> <p>The derivatives of the density matrix \\(\\partial_a\\rho\\) are calculated from the  derivatives of the Kraus operators \\(\\{\\partial_a K_i\\}\\) as</p> \\[ \\partial_a\\rho=\\sum_{i}\\left[(\\partial_a K_i)\\rho_0 K_i^{\\dagger}+K_i\\rho_0(\\partial_a K_i)^{\\dagger}\\right]. \\] <p>Then the QFI (QFIM) is calculated via the function <code>QFIM</code> with the evolved state  \\(\\rho\\) and its derivatives \\(\\{\\partial_a\\rho\\}\\).</p> <p>Parameters:</p> Name Type Description Default <code>rho0</code> <code>array</code> <p>Initial density matrix.</p> required <code>K</code> <code>list</code> <p>Kraus operators.</p> required <code>dK</code> <code>list</code> <p>Derivatives of the Kraus operators. It is a nested list where the first index  corresponds to the parameter and the second index corresponds to the Kraus operator index.  For example, <code>dK[0][1]</code> is the derivative of the second Kraus operator with respect  to the first parameter.</p> required <code>LDtype</code> <code>str</code> <p>Types of QFI (QFIM) can be set as the objective function. Options:     - \"SLD\" (default): QFI (QFIM) based on symmetric logarithmic derivative.     - \"RLD\": QFI (QFIM) based on right logarithmic derivative.     - \"LLD\": QFI (QFIM) based on left logarithmic derivative.  </p> <code>'SLD'</code> <code>exportLD</code> <code>bool</code> <p>Whether to export the values of logarithmic derivatives.  </p> <code>False</code> <code>eps</code> <code>float</code> <p>Machine epsilon.  </p> <code>1e-08</code> <p>Returns:</p> Type Description <code>float / array</code> <p>For single parameter estimation (the length of dK is equal to one), the output is QFI  and for multiparameter estimation (the length of dK is more than one), it returns QFIM.</p> Source code in <code>quanestimation/AsymptoticBound/CramerRao.py</code> <pre><code>def QFIM_Kraus(rho0, K, dK, LDtype=\"SLD\", exportLD=False, eps=1e-8):\n    r\"\"\"\n    Calculation of the quantum Fisher information (QFI) and quantum Fisher \n    information matrix (QFIM) for a quantum channel described by Kraus operators.\n\n    The quantum channel is given by\n\n    $$\n    \\rho=\\sum_{i} K_i \\rho_0 K_i^{\\dagger},\n    $$\n\n    where $\\rho_0$ is the initial state and $\\{K_i\\}$ are the Kraus operators.\n\n    The derivatives of the density matrix $\\partial_a\\rho$ are calculated from the \n    derivatives of the Kraus operators $\\{\\partial_a K_i\\}$ as\n\n    $$\n    \\partial_a\\rho=\\sum_{i}\\left[(\\partial_a K_i)\\rho_0 K_i^{\\dagger}+K_i\\rho_0(\\partial_a K_i)^{\\dagger}\\right].\n    $$\n\n    Then the QFI (QFIM) is calculated via the function `QFIM` with the evolved state \n    $\\rho$ and its derivatives $\\{\\partial_a\\rho\\}$.\n\n    Args:\n        rho0 (np.array): \n            Initial density matrix.\n        K (list): \n            Kraus operators.\n        dK (list): \n            Derivatives of the Kraus operators. It is a nested list where the first index \n            corresponds to the parameter and the second index corresponds to the Kraus operator index. \n            For example, `dK[0][1]` is the derivative of the second Kraus operator with respect \n            to the first parameter.\n        LDtype (str, optional): \n            Types of QFI (QFIM) can be set as the objective function. Options:  \n                - \"SLD\" (default): QFI (QFIM) based on symmetric logarithmic derivative.  \n                - \"RLD\": QFI (QFIM) based on right logarithmic derivative.  \n                - \"LLD\": QFI (QFIM) based on left logarithmic derivative.  \n        exportLD (bool, optional): \n            Whether to export the values of logarithmic derivatives.  \n        eps (float, optional): \n            Machine epsilon.  \n\n    Returns:\n        (float/np.array): \n            For single parameter estimation (the length of dK is equal to one), the output is QFI \n            and for multiparameter estimation (the length of dK is more than one), it returns QFIM.\n    \"\"\"\n\n    # Transpose dK: from [parameters][operators] to [operators][parameters]\n    dK_transposed = [\n        [dK[i][j] for i in range(len(K))] \n        for j in range(len(dK[0]))\n    ]\n\n    # Compute the evolved density matrix\n    rho = sum(Ki @ rho0 @ Ki.conj().T for Ki in K)\n\n    # Compute the derivatives of the density matrix\n    drho = [\n        sum(\n            dKi @ rho0 @ Ki.conj().T + Ki @ rho0 @ dKi.conj().T\n            for Ki, dKi in zip(K, dKj)\n        )\n        for dKj in dK_transposed\n    ]\n\n    return QFIM(rho, drho, LDtype=LDtype, exportLD=exportLD, eps=eps)\n</code></pre>"},{"location":"API/python/functions/#quantum-fisher-information-matrix-in-bloch-representation","title":"Quantum Fisher information matrix in Bloch representation","text":"<p>Calculation of the quantum Fisher information (QFI) and quantum Fisher  information matrix (QFIM) in Bloch representation.</p> <p>The Bloch vector representation of a quantum state is defined as</p> \\[ \\rho = \\frac{1}{d}\\left(\\mathbb{I} + \\sum_{i=1}^{d^2-1} r_i \\lambda_i\\right), \\] <p>where \\(\\lambda_i\\) are the generators of SU(d) group.</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>array</code> <p>Parameterized Bloch vector.</p> required <code>dr</code> <code>list</code> <p>Derivatives of the Bloch vector with respect to the unknown parameters.  Each element in the list is a vector of the same length as <code>r</code> and  represents the partial derivative of the Bloch vector with respect to  one parameter. For example, <code>dr[0]</code> is the derivative with respect to  the first parameter.</p> required <code>eps</code> <code>float</code> <p>Machine epsilon.  </p> <code>1e-08</code> <p>Returns:</p> Type Description <code>float / array</code> <p>For single parameter estimation (the length of <code>dr</code> is equal to one),  the output is QFI and for multiparameter estimation (the length of <code>dr</code>  is more than one), it returns QFIM.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>dr</code> is not a list.  </p> <code>ValueError</code> <p>If the dimension of the Bloch vector is invalid.</p> Source code in <code>quanestimation/AsymptoticBound/CramerRao.py</code> <pre><code>def QFIM_Bloch(r, dr, eps=1e-8):\n    r\"\"\"\n    Calculation of the quantum Fisher information (QFI) and quantum Fisher \n    information matrix (QFIM) in Bloch representation.\n\n    The Bloch vector representation of a quantum state is defined as\n\n    $$\n    \\rho = \\frac{1}{d}\\left(\\mathbb{I} + \\sum_{i=1}^{d^2-1} r_i \\lambda_i\\right),\n    $$\n\n    where $\\lambda_i$ are the generators of SU(d) group.\n\n    Args:\n        r (np.array): \n            Parameterized Bloch vector.\n        dr (list): \n            Derivatives of the Bloch vector with respect to the unknown parameters. \n            Each element in the list is a vector of the same length as `r` and \n            represents the partial derivative of the Bloch vector with respect to \n            one parameter. For example, `dr[0]` is the derivative with respect to \n            the first parameter.\n        eps (float, optional): \n            Machine epsilon.  \n\n    Returns:\n        (float/np.array): \n            For single parameter estimation (the length of `dr` is equal to one), \n            the output is QFI and for multiparameter estimation (the length of `dr` \n            is more than one), it returns QFIM.\n\n    Raises:\n        TypeError: If `dr` is not a list.  \n        ValueError: If the dimension of the Bloch vector is invalid.  \n    \"\"\"\n\n    if not isinstance(dr, list):\n        raise TypeError(\"dr must be a list of derivative vectors\")\n\n    num_params = len(dr)\n    qfim_result = np.zeros((num_params, num_params))\n\n    # Calculate dimension from Bloch vector length\n    dim_float = np.sqrt(len(r) + 1)\n    if dim_float.is_integer():\n        dim = int(dim_float)\n    else:\n        raise ValueError(\"Invalid Bloch vector dimension\")\n\n    # Get SU(N) generators\n    lambda_generators = suN_generator(dim)\n\n    # Handle single-qubit system\n    if dim == 2:\n        r_norm = np.linalg.norm(r) ** 2\n\n        # Pure state case\n        if np.abs(r_norm - 1.0) &lt; eps:\n            for i in range(num_params):\n                for j in range(i, num_params):\n                    qfim_result[i, j] = np.real(np.inner(dr[i], dr[j]))\n                    qfim_result[j, i] = qfim_result[i, j]\n        # Mixed state case\n        else:\n            for i in range(num_params):\n                for j in range(i, num_params):\n                    term1 = np.inner(dr[i], dr[j])\n                    term2 = (np.inner(r, dr[i]) * np.inner(r, dr[j])) / (1 - r_norm)\n                    qfim_result[i, j] = np.real(term1 + term2)\n                    qfim_result[j, i] = qfim_result[i, j]\n    # Handle higher-dimensional systems\n    else:\n        # Reconstruct density matrix from Bloch vector\n        rho = np.eye(dim, dtype=np.complex128) / dim\n        for idx in range(dim**2 - 1):\n            coeff = np.sqrt(dim * (dim - 1) / 2) * r[idx] / dim\n            rho += coeff * lambda_generators[idx]\n\n        # Calculate G matrix\n        G = np.zeros((dim**2 - 1, dim**2 - 1), dtype=np.complex128)\n        for i in range(dim**2 - 1):\n            for j in range(i, dim**2 - 1):\n                anticommutator = (\n                    lambda_generators[i] @ lambda_generators[j] + \n                    lambda_generators[j] @ lambda_generators[i]\n                )\n                G[i, j] = 0.5 * np.trace(rho @ anticommutator)\n                G[j, i] = G[i, j]\n\n        # Calculate matrix for inversion\n        r_vec = np.array(r).reshape(len(r), 1)\n        mat = G * dim / (2 * (dim - 1)) - r_vec @ r_vec.T\n        mat_inv = inv(mat)\n\n        # Calculate QFIM\n        for i in range(num_params):\n            for j in range(i, num_params):\n                dr_i = np.array(dr[i]).reshape(1, len(r))\n                dr_j = np.array(dr[j]).reshape(len(r), 1)\n                qfim_result[i, j] = np.real(dr_i @ mat_inv @ dr_j)[0, 0]\n                qfim_result[j, i] = qfim_result[i, j]\n\n    return qfim_result[0, 0] if num_params == 1 else qfim_result\n</code></pre>"},{"location":"API/python/functions/#quantum-fisher-information-matrix-with-gaussian-states","title":"Quantum Fisher information matrix with Gaussian states","text":"<p>Calculation of the quantum Fisher information (QFI) and quantum  Fisher information matrix (QFIM) for Gaussian states.</p> <p>The Gaussian state is characterized by its first-order moment (displacement vector)  and second-order moment (covariance matrix). The QFIM is calculated using the  method described in [1].</p> <p>Parameters:</p> Name Type Description Default <code>R</code> <code>array</code> <p>First-order moment (displacement vector).</p> required <code>dR</code> <code>list</code> <p>Derivatives of the first-order moment with respect to the unknown parameters.  Each element in the list is a vector of the same length as <code>R</code> and represents the partial  derivative of the displacement vector with respect to one parameter. For example, <code>dR[0]</code>  is the derivative with respect to the first parameter.</p> required <code>D</code> <code>array</code> <p>Second-order moment (covariance matrix).</p> required <code>dD</code> <code>list</code> <p>Derivatives of the second-order moment with respect to the unknown parameters.  Each element in the list is a matrix of the same dimension as <code>D</code> and  represents the partial derivative of the covariance matrix with respect to  one parameter. For example, <code>dD[0]</code> is the derivative with respect to  the first parameter.</p> required <p>Returns:</p> Type Description <code>float / array</code> <p>For single parameter estimation (the length of <code>dR</code> is equal to one),  the output is QFI and for multiparameter estimation (the length of <code>dR</code>  is more than one), it returns QFIM.</p> Notes <p>This function follows the approach from: [1] Monras, A., Phase space formalism for quantum estimation of Gaussian states, arXiv:1303.3682 (2013).</p> Source code in <code>quanestimation/AsymptoticBound/CramerRao.py</code> <pre><code>def QFIM_Gauss(R, dR, D, dD):\n    r\"\"\"\n    Calculation of the quantum Fisher information (QFI) and quantum \n    Fisher information matrix (QFIM) for Gaussian states.\n\n    The Gaussian state is characterized by its first-order moment (displacement vector) \n    and second-order moment (covariance matrix). The QFIM is calculated using the \n    method described in [1].\n\n    Args:\n        R (np.array): \n            First-order moment (displacement vector).\n        dR (list): \n            Derivatives of the first-order moment with respect to the unknown parameters. \n            Each element in the list is a vector of the same length as `R` and represents the partial \n            derivative of the displacement vector with respect to one parameter. For example, `dR[0]` \n            is the derivative with respect to the first parameter.\n        D (np.array): \n            Second-order moment (covariance matrix).\n        dD (list): \n            Derivatives of the second-order moment with respect to the unknown parameters. \n            Each element in the list is a matrix of the same dimension as `D` and \n            represents the partial derivative of the covariance matrix with respect to \n            one parameter. For example, `dD[0]` is the derivative with respect to \n            the first parameter.\n\n    Returns:\n        (float/np.array): \n            For single parameter estimation (the length of `dR` is equal to one), \n            the output is QFI and for multiparameter estimation (the length of `dR` \n            is more than one), it returns QFIM.\n\n    Notes:\n        This function follows the approach from:\n        [1] Monras, A., Phase space formalism for quantum estimation of Gaussian states, arXiv:1303.3682 (2013).\n    \"\"\"\n\n    num_params = len(dR)\n    m = len(R) // 2  # Number of modes\n    qfim = np.zeros((num_params, num_params))\n\n    # Compute the covariance matrix from the second-order moments and displacement\n    cov_matrix = np.array(\n        [\n            [D[i][j] - R[i] * R[j] for j in range(2 * m)]\n            for i in range(2 * m)\n        ]\n    )\n\n    # Compute the derivatives of the covariance matrix\n    dcov = []\n    for k in range(num_params):\n        dcov_k = np.zeros((2 * m, 2 * m))\n        for i in range(2 * m):\n            for j in range(2 * m):\n                dcov_k[i, j] = dD[k][i][j] - dR[k][i] * R[j] - R[i] * dR[k][j]\n        dcov.append(dcov_k)\n\n    # Compute the square root of the covariance matrix\n    cov_sqrt = sqrtm(cov_matrix)\n\n    # Define the symplectic matrix J for m modes\n    J_block = np.array([[0, 1], [-1, 0]])\n    J = np.kron(J_block, np.eye(m))\n\n    # Compute the matrix B = cov_sqrt @ J @ cov_sqrt\n    B = cov_sqrt @ J @ cov_sqrt\n\n    # Permutation matrix to rearrange the basis\n    P = np.eye(2 * m)\n    # Rearrange the basis: first all q's then all p's\n    P = np.vstack([P[::2], P[1::2]])\n\n    # Schur decomposition of B\n    _, Q = schur(B)\n    eigenvalues = eigvals(B)\n    # Extract the imaginary parts of every other eigenvalue\n    c = eigenvalues[::2].imag\n\n    # Diagonal matrix with entries 1/sqrt(c_i) for each mode\n    diag_inv_sqrt = np.diagflat(1.0 / np.sqrt(c))\n\n    # Construct the matrix S\n    temp1 = J @ cov_sqrt @ Q\n    temp2 = P @ np.kron(np.array([[0, 1], [-1, 0]]), -diag_inv_sqrt)\n    S = inv(temp1 @ temp2).T @ P.T\n\n    # Define the basis matrices for the Gaussian representation\n    sigma_x = np.array([[0.0, 1.0], [1.0, 0.0]])\n    sigma_y = np.array([[0.0, -1.0j], [1.0j, 0.0]])\n    sigma_z = np.array([[1.0, 0.0], [0.0, -1.0]])\n    identity = np.eye(2)\n    a_gauss = [1j * sigma_y, sigma_z, identity, sigma_x]\n\n    # Construct the basis matrices for the m-mode system\n    es = []\n    for i in range(m):\n        row = []\n        for j in range(m):\n            e_ij = np.eye(1, m * m, m * i + j).reshape(m, m)\n            row.append(e_ij)\n        es.append(row)\n\n    # As: a list of two-mode basis matrices for each of the four types\n    As = []\n    for a in a_gauss:\n        A_type = []\n        for i in range(m):\n            for j in range(m):\n                A_ij = np.kron(es[i][j], a) / np.sqrt(2)\n                A_type.append(A_ij)\n        As.append(A_type)\n\n    # Compute the coefficients g for each parameter and each basis matrix\n    g = []\n    for k in range(num_params):\n        g_k = []\n        for A_type in As:\n            g_type = []\n            for A_mat in A_type:\n                term = np.trace(inv(S) @ dcov[k] @ inv(S.T) @ A_mat.T)\n                g_type.append(term)\n            g_k.append(g_type)\n        g.append(g_k)\n\n    # Initialize the matrices G for each parameter\n    G_matrices = [np.zeros((2 * m, 2 * m), dtype=np.complex128) for _ in range(num_params)]\n\n    # Construct the matrices G for each parameter\n    for k in range(num_params):\n        for i in range(m):\n            for j in range(m):\n                for l in range(4):  # For each of the four types\n                    denom = 4 * c[i] * c[j] + (-1) ** (l + 1)\n                    A_l_ij = As[l][i * m + j]\n                    G_matrices[k] += np.real(\n                        g[k][l][i * m + j] / denom * inv(S.T) @ A_l_ij @ inv(S)\n                    )\n\n    # Compute the QFIM\n    for i in range(num_params):\n        for j in range(num_params):\n            term1 = np.trace(G_matrices[i] @ dcov[j])\n            term2 = dR[i] @ inv(cov_matrix) @ dR[j]\n            qfim[i, j] = np.real(term1 + term2)\n\n    if num_params == 1:\n        return qfim[0, 0]\n    else:\n        return qfim\n</code></pre>"},{"location":"API/python/functions/#holevo-cramer-rao-bound","title":"Holevo Cram\u00e9r-Rao bound","text":"<p>Calculate the Holevo Cramer-Rao bound (HCRB) via semidefinite programming (SDP).</p> <p>The HCRB is defined as:</p> \\[ \\min_{\\{X_i\\}} \\left\\{ \\mathrm{Tr}(\\mathrm{Re}Z) + \\mathrm{Tr}(| \\mathrm{Im} Z |) \\right\\},  \\] <p>where \\(Z_{ij} = \\mathrm{Tr}(\\rho X_i X_j)\\) and \\(V\\) is the covariance matrix.</p> <p>Parameters:</p> Name Type Description Default <code>rho</code> <code>array</code> <p>Density matrix.</p> required <code>drho</code> <code>list</code> <p>Derivatives of the density matrix with respect to unknown parameters. For example, <code>drho[0]</code> is the derivative with respect to the first parameter.</p> required <code>W</code> <code>array</code> <p>Weight matrix for the bound.</p> required <code>eps</code> <code>float</code> <p>Machine epsilon for numerical stability.</p> <code>1e-08</code> <p>Returns:</p> Type Description <code>float</code> <p>The value of the Holevo Cramer-Rao bound.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>drho</code> is not a list.</p> Notes <p>In the single-parameter scenario, the HCRB is equivalent to the QFI. For a rank-one weight matrix, the HCRB is equivalent to the inverse of the QFIM.</p> Source code in <code>quanestimation/AsymptoticBound/AnalogCramerRao.py</code> <pre><code>def HCRB(rho, drho, W, eps=1e-8):\n    r\"\"\"\n    Calculate the Holevo Cramer-Rao bound (HCRB) via semidefinite programming (SDP).\n\n    The HCRB is defined as:\n\n    $$\n    \\min_{\\{X_i\\}} \\left\\{ \\mathrm{Tr}(\\mathrm{Re}Z) + \\mathrm{Tr}(| \\mathrm{Im} Z |) \\right\\}, \n    $$\n\n    where $Z_{ij} = \\mathrm{Tr}(\\rho X_i X_j)$ and $V$ is the covariance matrix.\n\n    Args:\n        rho (np.array): \n            Density matrix.\n        drho (list): \n            Derivatives of the density matrix with respect to unknown parameters.  \n            For example, `drho[0]` is the derivative with respect to the first parameter.\n        W (np.array): \n            Weight matrix for the bound.\n        eps (float, optional): \n            Machine epsilon for numerical stability.\n\n    Returns: \n        (float): \n            The value of the Holevo Cramer-Rao bound.\n\n    Raises:\n        TypeError: If `drho` is not a list.\n\n    Notes:\n        In the single-parameter scenario, the HCRB is equivalent to the QFI.  \n        For a rank-one weight matrix, the HCRB is equivalent to the inverse of the QFIM.\n    \"\"\"\n\n    if not isinstance(drho, list):\n        raise TypeError(\"drho must be a list of derivative matrices\")\n\n    if len(drho) == 1:\n        print(\n            \"In single parameter scenario, HCRB is equivalent to QFI. \"\n            \"Returning QFI value.\"\n        )\n        return QFIM(rho, drho, eps=eps)\n\n    if matrix_rank(W) == 1:\n        print(\n            \"For rank-one weight matrix, HCRB is equivalent to QFIM. \"\n            \"Returning Tr(W @ inv(QFIM)).\"\n        )\n        qfim = QFIM(rho, drho, eps=eps)\n        return np.trace(W @ np.linalg.pinv(qfim))\n    dim = len(rho)\n    num = dim * dim\n    num_params = len(drho)\n\n    # Generate basis matrices\n    basis = [np.identity(dim)] + suN_generator(dim)\n    basis = [b / np.sqrt(2) for b in basis]\n\n    # Compute vectorized derivatives\n    vec_drho = []\n    for param_idx in range(num_params):\n        components = [\n            np.real(np.trace(drho[param_idx] @ basis_mat))\n            for basis_mat in basis\n        ]\n        vec_drho.append(np.array(components))\n\n    # Compute S matrix\n    S = np.zeros((num, num), dtype=np.complex128)\n    for i in range(num):\n        for j in range(num):\n            S[i, j] = np.trace(basis[i] @ basis[j] @ rho)\n\n    # Regularize and factor S\n    precision = len(str(int(1 / eps))) - 1\n    lu, d, _ = sp.linalg.ldl(S.round(precision))\n    R = (lu @ sp.linalg.sqrtm(d)).conj().T\n\n    # Define optimization variables\n    V = cp.Variable((num_params, num_params))\n    X = cp.Variable((num, num_params))\n\n    # Define constraints\n    constraints = [\n        cp.bmat([\n            [V, X.T @ R.conj().T],\n            [R @ X, np.identity(num)]\n        ]) &gt;&gt; 0\n    ]\n\n    # Add linear constraints\n    for i in range(num_params):\n        for j in range(num_params):\n            constraint_val = X[:, i].T @ vec_drho[j]\n            if i == j:\n                constraints.append(constraint_val == 1)\n            else:\n                constraints.append(constraint_val == 0)\n\n    # Solve the optimization problem\n    problem = cp.Problem(cp.Minimize(cp.trace(W @ V)), constraints)\n    problem.solve()\n\n    return problem.value\n</code></pre>"},{"location":"API/python/functions/#nagaoka-hayashi-bound","title":"Nagaoka-Hayashi bound","text":"<p>Calculation of the Nagaoka-Hayashi bound (NHB) via the semidefinite program (SDP).</p> <p>The NHB is defined as:</p> \\[ \\min_{X} \\left\\{ \\mathrm{Tr}[W \\mathrm{Re}(Z)] + \\|\\sqrt{W} \\mathrm{Im}(Z) \\sqrt{W}\\|_1 \\right\\},  \\] <p>where \\(Z_{ij} = \\mathrm{Tr}(\\rho X_i X_j)\\) and \\(V\\) is the covariance matrix.</p> <p>Parameters:</p> Name Type Description Default <code>rho</code> <code>array</code> <p>Density matrix.</p> required <code>drho</code> <code>list</code> <p>Derivatives of the density matrix with respect to unknown parameters. For example, <code>drho[0]</code> is the derivative with respect to the first parameter.</p> required <code>W</code> <code>array</code> <p>Weight matrix for the bound.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The value of the Nagaoka-Hayashi bound.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>drho</code> is not a list.</p> Source code in <code>quanestimation/AsymptoticBound/AnalogCramerRao.py</code> <pre><code>def NHB(rho, drho, W):\n    r\"\"\"\n    Calculation of the Nagaoka-Hayashi bound (NHB) via the semidefinite program (SDP).\n\n    The NHB is defined as:\n\n    $$\n    \\min_{X} \\left\\{ \\mathrm{Tr}[W \\mathrm{Re}(Z)] + \\|\\sqrt{W} \\mathrm{Im}(Z) \\sqrt{W}\\|_1 \\right\\}, \n    $$\n\n    where $Z_{ij} = \\mathrm{Tr}(\\rho X_i X_j)$ and $V$ is the covariance matrix.\n\n    Args:\n        rho (np.array): \n            Density matrix.\n        drho (list): \n            Derivatives of the density matrix with respect to unknown parameters.  \n            For example, `drho[0]` is the derivative with respect to the first parameter.\n        W (np.array): \n            Weight matrix for the bound.\n\n    Returns: \n        (float): \n            The value of the Nagaoka-Hayashi bound.\n\n    Raises:\n        TypeError: \n            If `drho` is not a list.\n    \"\"\"\n    if not isinstance(drho, list):\n        raise TypeError(\"drho must be a list of derivative matrices\")\n\n    dim = len(rho)\n    num_params = len(drho)\n\n    # Initialize a temporary matrix for L components\n    L_temp = [[None for _ in range(num_params)] for _ in range(num_params)]\n\n    # Create Hermitian variables for the upper triangle and mirror to lower triangle\n    for i in range(num_params):\n        for j in range(i, num_params):\n            L_temp[i][j] = cp.Variable((dim, dim), hermitian=True)\n            if i != j:\n                L_temp[j][i] = L_temp[i][j]\n\n    # Construct the block matrix L\n    L_blocks = [cp.hstack(L_temp[i]) for i in range(num_params)]\n    L = cp.vstack(L_blocks)\n\n    # Create Hermitian variables for X\n    X = [cp.Variable((dim, dim), hermitian=True) for _ in range(num_params)]\n\n    # Construct the block matrix constraint\n    block_matrix = cp.bmat([\n        [L, cp.vstack(X)],\n        [cp.hstack(X), np.identity(dim)]\n    ])\n    constraints = [block_matrix &gt;&gt; 0]\n\n    # Add trace constraints\n    for i in range(num_params):\n        constraints.append(cp.trace(X[i] @ rho) == 0)\n        for j in range(num_params):\n            if i == j:\n                constraints.append(cp.trace(X[i] @ drho[j]) == 1)\n            else:\n                constraints.append(cp.trace(X[i] @ drho[j]) == 0)\n\n    # Define and solve the optimization problem\n    objective = cp.Minimize(cp.real(cp.trace(cp.kron(W, rho) @ L)))\n    prob = cp.Problem(objective, constraints)\n    prob.solve()\n\n    return prob.value\n</code></pre>"},{"location":"API/python/functions/#bayesian-cramer-rao-bounds","title":"Bayesian Cram\u00e9r-Rao bounds","text":""},{"location":"API/python/functions/#bayesian-classical-fisher-information-matrix-bcfim","title":"Bayesian classical Fisher information matrix (BCFIM)","text":"<p>Calculation of the Bayesian classical Fisher information matrix (BCFIM).</p> <p>This function computes the Bayesian classical Fisher information (BCFI) or Bayesian classical  Fisher information matrix (BCFIM). The BCFIM is defined as:</p> \\[     \\mathcal{I}_{\\mathrm{Bayes}} = \\int p(\\textbf{x}) \\mathcal{I} \\, \\mathrm{d}\\textbf{x}. \\] <p>where \\(\\mathcal{I}\\) is the classical Fisher information matrix (CFIM) and \\(p(\\textbf{x})\\)  is the prior distribution.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>list</code> <p>Parameter regimes for integration. Each element is an array  representing the values of one parameter.</p> required <code>p</code> <code>array</code> <p>Prior distribution over the parameter space. Must have the same dimensions  as the product of the lengths of the arrays in <code>x</code>.</p> required <code>rho</code> <code>list</code> <p>Parameterized density matrices. Each element corresponds to  a point in the parameter space defined by <code>x</code>.</p> required <code>drho</code> <code>list</code> <p>Derivatives of the density matrices with respect to the parameters. For single parameter estimation (length of <code>x</code> is 1),  <code>drho</code> is a list of derivatives at each parameter point. For multiparameter estimation, <code>drho</code> is a  multidimensional list where <code>drho[i]</code> is a list of derivatives with respect to each parameter at the i-th parameter point,  and <code>drho[i][j]</code> is the derivative of the density matrix at the i-th parameter point with respect to the j-th parameter.</p> required <code>M</code> <code>list</code> <p>Positive operator-valued measure (POVM). Default is a set of rank-one symmetric informationally complete POVM (SIC-POVM).</p> <code>[]</code> <code>eps</code> <code>float</code> <p>Machine epsilon for numerical stability.</p> <code>1e-08</code> <p>Returns:</p> Type Description <code>float / array</code> <p>For single parameter estimation (length of <code>x</code> is 1), returns BCFI.            For multiparameter estimation (length of <code>x</code> &gt; 1), returns BCFIM.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>M</code> is provided but not a list.</p> Notes <p>SIC-POVM is calculated using Weyl-Heisenberg covariant SIC-POVM fiducial states  available at http://www.physics.umb.edu/Research/QBism/solutions.html.</p> Source code in <code>quanestimation/BayesianBound/BayesCramerRao.py</code> <pre><code>def BCFIM(x, p, rho, drho, M=[], eps=1e-8):\n    r\"\"\"\n    Calculation of the Bayesian classical Fisher information matrix (BCFIM).\n\n    This function computes the Bayesian classical Fisher information (BCFI) or Bayesian classical \n    Fisher information matrix (BCFIM). The BCFIM is defined as:\n\n    $$\n        \\mathcal{I}_{\\mathrm{Bayes}} = \\int p(\\textbf{x}) \\mathcal{I} \\, \\mathrm{d}\\textbf{x}.\n    $$\n\n    where $\\mathcal{I}$ is the classical Fisher information matrix (CFIM) and $p(\\textbf{x})$ \n    is the prior distribution.\n\n    Args:\n        x (list): \n            Parameter regimes for integration. Each element is an array \n            representing the values of one parameter.\n        p (np.array): \n            Prior distribution over the parameter space. Must have the same dimensions \n            as the product of the lengths of the arrays in `x`.\n        rho (list): \n            Parameterized density matrices. Each element corresponds to \n            a point in the parameter space defined by `x`.\n        drho (list): \n            Derivatives of the density matrices with respect to the parameters. For single parameter estimation (length of `x` is 1), \n            `drho` is a list of derivatives at each parameter point. For multiparameter estimation, `drho` is a \n            multidimensional list where `drho[i]` is a list of derivatives with respect to each parameter at the i-th parameter point, \n            and `drho[i][j]` is the derivative of the density matrix at the i-th parameter point with respect to the j-th parameter.\n        M (list, optional): \n            Positive operator-valued measure (POVM). Default is a set of rank-one symmetric informationally complete POVM (SIC-POVM).\n        eps (float, optional): \n            Machine epsilon for numerical stability.\n\n    Returns:\n        (float/np.array): \n            For single parameter estimation (length of `x` is 1), returns BCFI.             \n            For multiparameter estimation (length of `x` &gt; 1), returns BCFIM.\n\n    Raises:\n        TypeError: \n            If `M` is provided but not a list.\n\n    Notes:\n        SIC-POVM is calculated using Weyl-Heisenberg covariant SIC-POVM fiducial states \n        available at [http://www.physics.umb.edu/Research/QBism/solutions.html](http://www.physics.umb.edu/Research/QBism/solutions.html).\n    \"\"\"\n\n    para_num = len(x)\n    if para_num == 1:\n        #### single parameter scenario ####\n        if M == []:\n            M = SIC(len(rho[0]))\n        else:\n            if type(M) != list:\n                raise TypeError(\"Please make sure M is a list!\")\n\n        p_num = len(p)\n        if type(drho[0]) == list:\n            drho = [drho[i][0] for i in range(p_num)]\n        p_num = len(p)\n        F_tp = np.zeros(p_num)\n        for m in range(p_num):\n            F_tp[m] = CFIM(rho[m], [drho[m]], M=M, eps=eps)\n\n        arr = [p[i] * F_tp[i] for i in range(p_num)]\n        return simpson(arr, x[0])\n    else:\n        #### multiparameter scenario ####\n        p_shape = np.shape(p)\n        p_ext = extract_ele(p, para_num)\n        rho_ext = extract_ele(rho, para_num)\n        drho_ext = extract_ele(drho, para_num)\n\n        p_list, rho_list, drho_list = [], [], []\n        for p_ele, rho_ele, drho_ele in zip(p_ext, rho_ext, drho_ext):\n            p_list.append(p_ele)\n            rho_list.append(rho_ele)\n            drho_list.append(drho_ele)\n\n        dim = len(rho_list[0])\n        if M == []:\n            M = SIC(dim)\n        else:\n            if type(M) != list:\n                raise TypeError(\"Please make sure M is a list!\")\n\n        F_list = [\n            [[0.0 for i in range(len(p_list))] for j in range(para_num)]\n            for k in range(para_num)\n        ]\n    for i in range(len(p_list)):\n        # Convert drho_list[i] to a list of arrays to ensure proper type handling\n        drho_arrays = [np.array(d, dtype=np.complex128) for d in drho_list[i]]\n        F_tp = CFIM(rho_list[i], drho_arrays, M=M, eps=eps)\n        for pj in range(para_num):\n            for pk in range(para_num):\n                # Ensure we're assigning float values\n                F_list[pj][pk][i] = float(np.real(F_tp[pj][pk]))\n\n    BCFIM_res = np.zeros([para_num, para_num])\n    for para_i in range(0, para_num):\n        for para_j in range(para_i, para_num):\n            F_ij = np.array(F_list[para_i][para_j]).reshape(p_shape)\n            arr = p * F_ij\n            for si in reversed(range(para_num)):\n                arr = simpson(arr, x[si])\n            BCFIM_res[para_i][para_j] = float(arr)\n            BCFIM_res[para_j][para_i] = float(arr)\n    return BCFIM_res\n</code></pre>"},{"location":"API/python/functions/#bayesian-quantum-fisher-information-matrix-bqfim","title":"Bayesian quantum Fisher information matrix (BQFIM)","text":"<p>Calculation of the Bayesian quantum Fisher information matrix (BQFIM).</p> <p>This function computes the Bayesian quantum Fisher information (BQFI) or Bayesian quantum  Fisher information matrix (BQFIM). The BQFIM is defined as:</p> \\[     \\mathcal{F}_{\\mathrm{Bayes}} = \\int p(\\textbf{x}) \\mathcal{F} \\, \\mathrm{d}\\textbf{x}. \\] <p>where \\(\\mathcal{F}\\) is the quantum Fisher information matrix (QFIM) and \\(p(\\textbf{x})\\)  is the prior distribution.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>list</code> <p>Parameter regimes for integration. Each element is an array  representing the values of one parameter.</p> required <code>p</code> <code>array</code> <p>Prior distribution over the parameter space. Must have the same dimensions  as the product of the lengths of the arrays in <code>x</code>.</p> required <code>rho</code> <code>list</code> <p>Parameterized density matrices. Each element corresponds to  a point in the parameter space defined by <code>x</code>.</p> required <code>drho</code> <code>list</code> <p>Derivatives of the density matrices with respect to  the parameters. <code>drho[i][j]</code> is the derivative of the density matrix at the i-th  parameter point with respect to the j-th parameter.</p> required <code>LDtype</code> <code>str</code> <p>Type of logarithmic derivative (default: \"SLD\"). Options: - \"SLD\": Symmetric logarithmic derivative - \"RLD\": Right logarithmic derivative - \"LLD\": Left logarithmic derivative  </p> <code>'SLD'</code> <code>eps</code> <code>float</code> <p>Machine epsilon for numerical stability.</p> <code>1e-08</code> <p>Returns:</p> Type Description <code>float / array</code> <p>For single parameter estimation (length of <code>x</code> is 1), returns BQFI.  For multiparameter estimation (length of <code>x</code> &gt; 1), returns BQFIM.</p> Source code in <code>quanestimation/BayesianBound/BayesCramerRao.py</code> <pre><code>def BQFIM(x, p, rho, drho, LDtype=\"SLD\", eps=1e-8):\n    r\"\"\"\n    Calculation of the Bayesian quantum Fisher information matrix (BQFIM).\n\n    This function computes the Bayesian quantum Fisher information (BQFI) or Bayesian quantum \n    Fisher information matrix (BQFIM). The BQFIM is defined as:\n\n    $$\n        \\mathcal{F}_{\\mathrm{Bayes}} = \\int p(\\textbf{x}) \\mathcal{F} \\, \\mathrm{d}\\textbf{x}.\n    $$\n\n    where $\\mathcal{F}$ is the quantum Fisher information matrix (QFIM) and $p(\\textbf{x})$ \n    is the prior distribution.\n\n    Args:\n        x (list): Parameter regimes for integration. Each element is an array \n            representing the values of one parameter.\n        p (np.array): Prior distribution over the parameter space. Must have the same dimensions \n            as the product of the lengths of the arrays in `x`.\n        rho (list): Parameterized density matrices. Each element corresponds to \n            a point in the parameter space defined by `x`.\n        drho (list): Derivatives of the density matrices with respect to \n            the parameters. `drho[i][j]` is the derivative of the density matrix at the i-th \n            parameter point with respect to the j-th parameter.\n        LDtype (str, optional): Type of logarithmic derivative (default: \"SLD\"). Options:  \n            - \"SLD\": Symmetric logarithmic derivative  \n            - \"RLD\": Right logarithmic derivative  \n            - \"LLD\": Left logarithmic derivative  \n        eps (float, optional): Machine epsilon for numerical stability.\n\n    Returns:\n        (float/np.array): \n            For single parameter estimation (length of `x` is 1), returns BQFI. \n            For multiparameter estimation (length of `x` &gt; 1), returns BQFIM.\n    \"\"\"\n\n    para_num = len(x)\n    if para_num == 1:\n        #### single parameter scenario ####\n        p_num = len(p)\n        if type(drho[0]) == list:\n            drho = [drho[i][0] for i in range(p_num)]\n\n        F_tp = np.zeros(p_num)\n        for m in range(p_num):\n            F_tp[m] = QFIM(rho[m], [drho[m]], LDtype=LDtype, eps=eps)\n        arr = [p[i] * F_tp[i] for i in range(p_num)]\n        return simpson(arr, x[0])\n    else:\n        #### multiparameter scenario ####\n        p_shape = np.shape(p)\n        p_ext = extract_ele(p, para_num)\n        rho_ext = extract_ele(rho, para_num)\n        drho_ext = extract_ele(drho, para_num)\n\n        p_list, rho_list, drho_list = [], [], []\n        for p_ele, rho_ele, drho_ele in zip(p_ext, rho_ext, drho_ext):\n            p_list.append(p_ele)\n            rho_list.append(rho_ele)\n            drho_list.append(drho_ele)\n\n        F_list = [\n            [[0.0 for i in range(len(p_list))] for j in range(para_num)]\n            for k in range(para_num)\n        ]\n        for i in range(len(p_list)):\n            F_tp = QFIM(rho_list[i], drho_list[i], LDtype=LDtype, eps=eps)\n            for pj in range(para_num):\n                for pk in range(para_num):\n                    F_list[pj][pk][i] = F_tp[pj][pk]\n\n        BQFIM_res = np.zeros([para_num, para_num])\n        for para_i in range(0, para_num):\n            for para_j in range(para_i, para_num):\n                F_ij = np.array(F_list[para_i][para_j]).reshape(p_shape)\n                arr = p * F_ij\n                for si in reversed(range(para_num)):\n                    arr = simpson(arr, x[si])\n                BQFIM_res[para_i][para_j] = arr\n                BQFIM_res[para_j][para_i] = arr\n        return BQFIM_res\n</code></pre>"},{"location":"API/python/functions/#bayesian-cramer-rao-bound-bcrb","title":"Bayesian Cram\u00e9r-Rao bound (BCRB)","text":"<p>Calculation of the Bayesian Cramer-Rao bound (BCRB).</p> <p>This function computes the Bayesian Cramer-Rao bound (BCRB) for single or multiple parameters.</p> <p>The covariance matrix with prior distribution \\(p(\\textbf{x})\\) is:</p> \\[     \\mathrm{cov}(\\hat{\\textbf{x}},\\{\\Pi_y\\}) = \\int p(\\textbf{x}) \\sum_y \\mathrm{Tr}     (\\rho\\Pi_y) (\\hat{\\textbf{x}}-\\textbf{x})(\\hat{\\textbf{x}}-\\textbf{x})^{\\mathrm{T}}     \\mathrm{d}\\textbf{x}. \\] <p>This function calculates three types of BCRB:</p> <p>Type 1:</p> \\[     \\mathrm{cov} \\geq \\int p(\\textbf{x}) \\left( B \\mathcal{I}^{-1} B      + \\textbf{b} \\textbf{b}^{\\mathrm{T}} \\right) \\mathrm{d}\\textbf{x}. \\] <p>Type 2: $$     \\mathrm{cov} \\geq \\mathcal{B} \\mathcal{I}_{\\mathrm{Bayes}}^{-1} \\mathcal{B}      + \\int p(\\textbf{x}) \\textbf{b} \\textbf{b}^{\\mathrm{T}} \\mathrm{d}\\textbf{x}. $$</p> <p>Type 3: $$     \\mathrm{cov} \\geq \\int p(\\textbf{x}) \\mathcal{G} \\left( \\mathcal{I}_p      + \\mathcal{I} \\right)^{-1} \\mathcal{G}^{\\mathrm{T}} \\mathrm{d}\\textbf{x}. $$</p> Symbols <ul> <li>\\(\\textbf{b}\\): bias vector</li> <li>\\(\\textbf{b}'\\): its derivatives</li> <li>\\(B\\): diagonal matrix with \\(B_{ii} = 1 + [\\textbf{b}']_{i}\\)</li> <li>\\(\\mathcal{I}\\): classical Fisher information matrix (CFIM)</li> <li>\\(\\mathcal{B} = \\int p(\\textbf{x}) B \\mathrm{d}\\textbf{x}\\)</li> <li>\\(\\mathcal{I}_{\\mathrm{Bayes}} = \\int p(\\textbf{x}) \\mathcal{I} \\mathrm{d}\\textbf{x}\\)</li> <li>\\([\\mathcal{I}_{p}]_{ab} = [\\partial_a \\ln p(\\textbf{x})][\\partial_b \\ln p(\\textbf{x})]\\)</li> <li>\\(\\mathcal{G}_{ab} = [\\partial_b \\ln p(\\textbf{x})][\\textbf{b}]_a + B_{aa}\\delta_{ab}\\)</li> </ul> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>list</code> <p>Parameter regimes for integration.</p> required <code>p</code> <code>array</code> <p>Prior distribution over the parameter space. Must have the same dimensions  as the product of the lengths of the arrays in <code>x</code>.</p> required <code>dp</code> <code>list</code> <p>Derivatives of the prior distribution with respect to the parameters.</p> required <code>rho</code> <code>list</code> <p>Parameterized density matrices. Each element corresponds to  a point in the parameter space defined by <code>x</code>.</p> required <code>drho</code> <code>list</code> <p>Derivatives of the density matrices with respect to  the parameters. <code>drho[i][j]</code> is the derivative of the density matrix at the i-th  parameter point with respect to the j-th parameter.</p> required <code>M</code> <code>list</code> <p>Positive operator-valued measure (POVM). Default is  a set of rank-one symmetric informationally complete POVM (SIC-POVM).</p> <code>[]</code> <code>b</code> <code>list</code> <p>Bias vector. Default is zero bias.</p> <code>[]</code> <code>db</code> <code>list</code> <p>Derivatives of the bias vector. Default is zero.</p> <code>[]</code> <code>btype</code> <code>int</code> <p>Type of BCRB to calculate (1, 2, or 3).</p> <code>1</code> <code>eps</code> <code>float</code> <p>Machine epsilon for numerical stability.</p> <code>1e-08</code> <p>Returns:</p> Type Description <code>float / array</code> <p>For single parameter estimation (length of <code>x</code> is 1), returns BCRB.  For multiparameter estimation (length of <code>x</code> &gt; 1), returns BCRB matrix.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>M</code> is provided but not a list.</p> <code>NameError</code> <p>If <code>btype</code> is not in {1, 2, 3}.</p> Notes <p>SIC-POVM is calculated using Weyl-Heisenberg covariant SIC-POVM fiducial states  available at http://www.physics.umb.edu/Research/QBism/solutions.html.</p> Source code in <code>quanestimation/BayesianBound/BayesCramerRao.py</code> <pre><code>def BCRB(x, p, dp, rho, drho, M=[], b=[], db=[], btype=1, eps=1e-8):\n    r\"\"\"\n    Calculation of the Bayesian Cramer-Rao bound (BCRB).\n\n    This function computes the Bayesian Cramer-Rao bound (BCRB) for single or multiple parameters.\n\n    The covariance matrix with prior distribution $p(\\textbf{x})$ is:\n\n    $$\n        \\mathrm{cov}(\\hat{\\textbf{x}},\\{\\Pi_y\\}) = \\int p(\\textbf{x}) \\sum_y \\mathrm{Tr}\n        (\\rho\\Pi_y) (\\hat{\\textbf{x}}-\\textbf{x})(\\hat{\\textbf{x}}-\\textbf{x})^{\\mathrm{T}}\n        \\mathrm{d}\\textbf{x}.\n    $$\n\n    This function calculates three types of BCRB:\n\n    **Type 1:**\n\n    $$\n        \\mathrm{cov} \\geq \\int p(\\textbf{x}) \\left( B \\mathcal{I}^{-1} B \n        + \\textbf{b} \\textbf{b}^{\\mathrm{T}} \\right) \\mathrm{d}\\textbf{x}.\n    $$\n\n    **Type 2:**\n    $$\n        \\mathrm{cov} \\geq \\mathcal{B} \\mathcal{I}_{\\mathrm{Bayes}}^{-1} \\mathcal{B} \n        + \\int p(\\textbf{x}) \\textbf{b} \\textbf{b}^{\\mathrm{T}} \\mathrm{d}\\textbf{x}.\n    $$\n\n    **Type 3:**\n    $$\n        \\mathrm{cov} \\geq \\int p(\\textbf{x}) \\mathcal{G} \\left( \\mathcal{I}_p \n        + \\mathcal{I} \\right)^{-1} \\mathcal{G}^{\\mathrm{T}} \\mathrm{d}\\textbf{x}.\n    $$\n\n    Symbols:\n        - $\\textbf{b}$: bias vector\n        - $\\textbf{b}'$: its derivatives\n        - $B$: diagonal matrix with $B_{ii} = 1 + [\\textbf{b}']_{i}$\n        - $\\mathcal{I}$: classical Fisher information matrix (CFIM)\n        - $\\mathcal{B} = \\int p(\\textbf{x}) B \\mathrm{d}\\textbf{x}$\n        - $\\mathcal{I}_{\\mathrm{Bayes}} = \\int p(\\textbf{x}) \\mathcal{I} \\mathrm{d}\\textbf{x}$\n        - $[\\mathcal{I}_{p}]_{ab} = [\\partial_a \\ln p(\\textbf{x})][\\partial_b \\ln p(\\textbf{x})]$\n        - $\\mathcal{G}_{ab} = [\\partial_b \\ln p(\\textbf{x})][\\textbf{b}]_a + B_{aa}\\delta_{ab}$\n\n    Args:\n        x (list): \n            Parameter regimes for integration.\n        p (np.array): \n            Prior distribution over the parameter space. Must have the same dimensions \n            as the product of the lengths of the arrays in `x`.\n        dp (list): \n            Derivatives of the prior distribution with respect to the parameters.\n        rho (list): \n            Parameterized density matrices. Each element corresponds to \n            a point in the parameter space defined by `x`.\n        drho (list): \n            Derivatives of the density matrices with respect to \n            the parameters. `drho[i][j]` is the derivative of the density matrix at the i-th \n            parameter point with respect to the j-th parameter.\n        M (list, optional): \n            Positive operator-valued measure (POVM). Default is \n            a set of rank-one symmetric informationally complete POVM (SIC-POVM).\n        b (list, optional): \n            Bias vector. Default is zero bias.\n        db (list, optional): \n            Derivatives of the bias vector. Default is zero.\n        btype (int, optional): \n            Type of BCRB to calculate (1, 2, or 3).\n        eps (float, optional): \n            Machine epsilon for numerical stability.\n\n    Returns:\n        (float/np.array): \n            For single parameter estimation (length of `x` is 1), returns BCRB. \n            For multiparameter estimation (length of `x` &gt; 1), returns BCRB matrix.\n\n    Raises:\n        TypeError: If `M` is provided but not a list.\n        NameError: If `btype` is not in {1, 2, 3}.\n\n    Notes:\n        SIC-POVM is calculated using Weyl-Heisenberg covariant SIC-POVM fiducial states \n        available at [http://www.physics.umb.edu/Research/QBism/solutions.html](http://www.physics.umb.edu/Research/QBism/solutions.html).\n    \"\"\"\n\n    para_num = len(x)\n    if para_num == 1:\n        #### single parameter scenario ####\n        p_num = len(p)\n        if not b:\n            b = np.zeros(p_num)\n            db = np.zeros(p_num)\n        elif not db:\n            db = np.zeros(p_num)\n\n        if M == []:\n            M = SIC(len(rho[0]))\n        else:\n            if type(M) != list:\n                raise TypeError(\"Please make sure M is a list!\")\n\n        if type(drho[0]) == list:\n            drho = [drho[i][0] for i in range(p_num)]\n        if type(b[0]) == list or type(b[0]) == np.ndarray:\n            b = b[0]\n        if type(db[0]) == list or type(db[0]) == np.ndarray:\n            db = db[0]\n\n        F_tp = np.zeros(p_num)\n        for m in range(p_num):\n            F_tp[m] = CFIM(rho[m], [drho[m]], M=M, eps=eps)\n\n        if btype == 1:\n            arr = [\n                p[i] * ((1 + db[i]) ** 2 / F_tp[i] + b[i] ** 2) for i in range(p_num)\n            ]\n            F = simpson(arr, x[0])\n            return F\n        elif btype == 2:\n            arr = [p[i] * F_tp[i] for i in range(p_num)]\n            F1 = simpson(arr, x[0])\n            arr2 = [p[j] * (1 + db[j]) for j in range(p_num)]\n            B = simpson(arr2, x[0])\n            arr3 = [p[k] * b[k] ** 2 for k in range(p_num)]\n            bb = simpson(arr3, x[0])\n            F = B**2 / F1 + bb\n            return F\n        elif btype == 3:\n            I_tp = [np.real(dp[i] * dp[i] / p[i] ** 2) for i in range(p_num)]\n            arr = [p[j]*(dp[j]*b[j]/p[j]+(1 + db[j]))**2 / (I_tp[j] + F_tp[j]) for j in range(p_num)]\n            F = simpson(arr, x[0])\n            return F\n        else:\n            raise NameError(\"NameError: btype should be choosen in {1, 2, 3}.\")\n    else:\n        #### multiparameter scenario ####\n        if not b:\n            b, db = [], []\n            for i in range(para_num):\n                b.append(np.zeros(len(x[i])))\n                db.append(np.zeros(len(x[i])))\n        elif not db:\n            db = []\n            for i in range(para_num):\n                db.append(np.zeros(len(x[i])))\n\n        p_shape = np.shape(p)\n        p_ext = extract_ele(p, para_num)\n        dp_ext = extract_ele(dp, para_num)\n        rho_ext = extract_ele(rho, para_num)\n        drho_ext = extract_ele(drho, para_num)\n        b_pro = product(*b)\n        db_pro = product(*db)\n\n        p_list, rho_list, drho_list = [], [], []\n        for p_ele, rho_ele, drho_ele in zip(p_ext, rho_ext, drho_ext):\n            p_list.append(p_ele)\n            rho_list.append(rho_ele)\n            drho_list.append(drho_ele)\n        dp_list = [dpi for dpi in dp_ext]\n\n        b_list, db_list = [], []\n        for b_ele, db_ele in zip(b_pro, db_pro):\n            b_list.append([b_ele[i] for i in range(para_num)])\n            db_list.append([db_ele[j] for j in range(para_num)])\n\n        dim = len(rho_list[0])\n        if M == []:\n            M = SIC(dim)\n        else:\n            if type(M) != list:\n                raise TypeError(\"Please make sure M is a list!\")\n        if btype == 1:\n            F_list = [\n                [[0.0 for i in range(len(p_list))] for j in range(para_num)]\n                for k in range(para_num)\n            ]\n            for i in range(len(p_list)):\n                F_tp = CFIM(rho_list[i], drho_list[i], M=M, eps=eps)\n                F_inv = np.linalg.pinv(F_tp)\n                B = np.diag([(1.0 + db_list[i][j]) for j in range(para_num)])\n                term1 = B @ F_inv @ B\n                term2 = np.dot(\n                    np.array(b_list[i]).reshape(para_num, 1),\n                    np.array(b_list[i]).reshape(1, para_num),\n                )\n                for pj in range(para_num):\n                    for pk in range(para_num):\n                        F_list[pj][pk][i] = term1[pj][pk] + term2[pj][pk]\n\n            res = np.zeros([para_num, para_num])\n            for para_i in range(0, para_num):\n                for para_j in range(para_i, para_num):\n                    F_ij = np.array(F_list[para_i][para_j]).reshape(p_shape)\n                    arr = p * F_ij\n                    for si in reversed(range(para_num)):\n                        arr = simpson(arr, x[si])\n                    res[para_i][para_j] = arr\n                    res[para_j][para_i] = arr\n            return res\n        elif btype == 2:\n            F_list = [\n                [[0.0 for i in range(len(p_list))] for j in range(para_num)]\n                for k in range(para_num)\n            ]\n            B_list = [\n                [[0.0 for i in range(len(p_list))] for j in range(para_num)]\n                for k in range(para_num)\n            ]\n            bb_list = [\n                [[0.0 for i in range(len(p_list))] for j in range(para_num)]\n                for k in range(para_num)\n            ]\n            for i in range(len(p_list)):\n                F_tp = CFIM(rho_list[i], drho_list[i], M=M, eps=eps)\n                B_tp = np.diag([(1.0 + db_list[i][j]) for j in range(para_num)])\n                bb_tp = np.dot(\n                    np.array(b_list[i]).reshape(para_num, 1),\n                    np.array(b_list[i]).reshape(1, para_num),\n                )\n                for pj in range(para_num):\n                    for pk in range(para_num):\n                        F_list[pj][pk][i] = F_tp[pj][pk]\n                        B_list[pj][pk][i] = B_tp[pj][pk]\n                        bb_list[pj][pk][i] = bb_tp[pj][pk]\n\n            F_res = np.zeros([para_num, para_num])\n            for para_i in range(0, para_num):\n                for para_j in range(para_i, para_num):\n                    F_ij = np.array(F_list[para_i][para_j]).reshape(p_shape)\n                    arr = p * F_ij\n                    for si in reversed(range(para_num)):\n                        arr = simpson(arr, x[si])\n                    F_res[para_i][para_j] = arr\n                    F_res[para_j][para_i] = arr\n            B_res = np.zeros([para_num, para_num])\n            bb_res = np.zeros([para_num, para_num])\n            for para_m in range(para_num):\n                for para_n in range(para_num):\n                    B_mn = np.array(B_list[para_m][para_n]).reshape(p_shape)\n                    bb_mn = np.array(bb_list[para_m][para_n]).reshape(p_shape)\n                    arr2 = p * B_mn\n                    arr3 = p * bb_mn\n                    for sj in reversed(range(para_num)):\n                        arr2 = simpson(arr2, x[sj])\n                        arr3 = simpson(arr3, x[sj])\n                    B_res[para_m][para_n] = arr2\n                    bb_res[para_m][para_n] = arr3\n            res = B_res @ np.linalg.pinv(F_res) @ B_res + bb_res\n            return res\n        elif btype == 3:\n            F_list = [\n                [[0.0 for i in range(len(p_list))] for j in range(para_num)]\n                for k in range(para_num)\n            ]\n            for i in range(len(p_list)):\n                F_tp = CFIM(rho_list[i], drho_list[i], M=M, eps=eps)\n                I_tp = np.zeros((para_num, para_num))\n                G_tp = np.zeros((para_num, para_num))\n                for pm in range(para_num):\n                    for pn in range(para_num):\n                        if pm == pn:\n                            G_tp[pm][pn] = dp_list[i][pn]*b_list[i][pm]/p_list[i]+(1.0 + db_list[i][pm])\n                        else:\n                            G_tp[pm][pn] = dp_list[i][pn]*b_list[i][pm]/p_list[i]\n                        I_tp[pm][pn] = dp_list[i][pm] * dp_list[i][pn] / p_list[i] ** 2\n\n                F_tot = G_tp @ np.linalg.pinv(F_tp + I_tp) @ G_tp.T\n                for pj in range(para_num):\n                    for pk in range(para_num):\n                        F_list[pj][pk][i] = F_tot[pj][pk]\n\n            res = np.zeros([para_num, para_num])\n            for para_i in range(0, para_num):\n                for para_j in range(para_i, para_num):\n                    F_ij = np.array(F_list[para_i][para_j]).reshape(p_shape)\n                    arr = p * F_ij\n                    for si in reversed(range(para_num)):\n                        arr = simpson(arr, x[si])\n                    res[para_i][para_j] = arr\n                    res[para_j][para_i] = arr\n            return res\n        else:\n            raise NameError(\"NameError: btype should be choosen in {1, 2, 3}.\")\n</code></pre>"},{"location":"API/python/functions/#bayesian-quantum-cramer-rao-bound-bqcrb","title":"Bayesian quantum Cram\u00e9r-Rao bound (BQCRB)","text":"<p>Calculation of the Bayesian quantum Cramer-Rao bound (BQCRB). </p> <p>The covariance matrix with a prior distribution \\(p(\\textbf{x})\\) is defined as</p> \\[     \\mathrm{cov}(\\hat{\\textbf{x}},\\{\\Pi_y\\})=\\int p(\\textbf{x})\\sum_y\\mathrm{Tr}     (\\rho\\Pi_y)(\\hat{\\textbf{x}}-\\textbf{x})(\\hat{\\textbf{x}}-\\textbf{x})^{\\mathrm{T}}     \\mathrm{d}\\textbf{x}, \\] Symbols <ul> <li>\\(\\textbf{x}=(x_0,x_1,\\dots)^{\\mathrm{T}}\\): the unknown parameters to be estimated     and the integral \\(\\int\\mathrm{d}\\textbf{x}:=\\iiint\\mathrm{d}x_0\\mathrm{d}x_1\\cdots\\).</li> <li>\\(\\{\\Pi_y\\}\\): a set of positive operator-valued measure (POVM). </li> <li>\\(\\rho\\): the parameterized density matrix.</li> </ul> <p>This function calculates three types of the BQCRB. The first one is</p> \\[     \\mathrm{cov}(\\hat{\\textbf{x}},\\{\\Pi_y\\})\\geq\\int p(\\textbf{x})\\left(B\\mathcal{F}^{-1}B     +\\textbf{b}\\textbf{b}^{\\mathrm{T}}\\right)\\mathrm{d}\\textbf{x}, \\] Symbols <ul> <li>\\(\\textbf{b}\\) and \\(\\textbf{b}'\\): the vectors of biase and its derivatives on parameters.</li> <li>\\(B\\): a diagonal matrix with the \\(i\\)th entry \\(B_{ii}=1+[\\textbf{b}']_{i}\\)</li> <li>\\(\\mathcal{F}\\): the QFIM for all types.</li> </ul> <p>The second one is</p> \\[     \\mathrm{cov}(\\hat{\\textbf{x}},\\{\\Pi_y\\})\\geq \\mathcal{B}\\,\\mathcal{F}_{\\mathrm{Bayes}}^{-1}\\,     \\mathcal{B}+\\int p(\\textbf{x})\\textbf{b}\\textbf{b}^{\\mathrm{T}}\\mathrm{d}\\textbf{x}, \\] Symbols <ul> <li>\\(\\mathcal{B}=\\int p(\\textbf{x})B\\mathrm{d}\\textbf{x}\\): the average of \\(B\\) </li> <li>\\(\\mathcal{F}_{\\mathrm{Bayes}}=\\int p(\\textbf{x})\\mathcal{F}\\mathrm{d}\\textbf{x}\\): the average QFIM.</li> </ul> <p>The third one is</p> \\[     \\mathrm{cov}(\\hat{\\textbf{x}},\\{\\Pi_y\\})\\geq \\int p(\\textbf{x})     \\mathcal{G}\\left(\\mathcal{I}_p+\\mathcal{F}\\right)^{-1}\\mathcal{G}^{\\mathrm{T}}\\mathrm{d}\\textbf{x}. \\] Symbols <ul> <li>\\([\\mathcal{I}_{p}]_{ab}:=[\\partial_a \\ln p(\\textbf{x})][\\partial_b \\ln p(\\textbf{x})]\\).</li> <li>\\(\\mathcal{G}_{ab}:=[\\partial_b\\ln p(\\textbf{x})][\\textbf{b}]_a+B_{aa}\\delta_{ab}\\).</li> </ul> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>list</code> <p>The regimes of the parameters for the integral.</p> required <code>p</code> <code>(array, multidimensional)</code> <p>The prior distribution.</p> required <code>rho</code> <code>(list, multidimensional)</code> <p>Parameterized density matrix.</p> required <code>drho</code> <code>(list, multidimensional)</code> <p>Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated.</p> required <code>b</code> <code>list</code> <p>Vector of biases of the form \\(\\textbf{b}=(b(x_0),b(x_1),\\dots)^{\\mathrm{T}}\\).</p> <code>[]</code> <code>db</code> <code>list</code> <p>Derivatives of b with respect to the unknown parameters to be estimated, It should be  expressed as \\(\\textbf{b}'=(\\partial_0 b(x_0),\\partial_1 b(x_1),\\dots)^{\\mathrm{T}}\\).</p> <code>[]</code> <code>btype</code> <code>int</code> <p>Types of the BQCRB. Options are:     1 (default) -- It means to calculate the first type of the BQCRB.     2 -- It means to calculate the second type of the BQCRB.     3 -- It means to calculate the third type of the BCRB.</p> <code>1</code> <code>LDtype</code> <code>str</code> <p>Types of QFI (QFIM) can be set as the objective function. Options are:     - \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD).     - \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD).     - \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD).</p> <code>'SLD'</code> <code>eps</code> <code>(float, optional)</code> <p>Machine epsilon.</p> <code>1e-08</code> <p>Returns:</p> Type Description <code>float / array</code> <p>For single parameter estimation (the length of <code>x</code> equals to one), the  output is a float and for multiparameter estimation (the length of <code>x</code> is larger than one),  it returns a matrix.</p> Source code in <code>quanestimation/BayesianBound/BayesCramerRao.py</code> <pre><code>def BQCRB(x, p, dp, rho, drho, b=[], db=[], btype=1, LDtype=\"SLD\", eps=1e-8):\n    r\"\"\"\n    Calculation of the Bayesian quantum Cramer-Rao bound (BQCRB). \n\n    The covariance matrix with a prior distribution $p(\\textbf{x})$ is defined as\n\n    $$\n        \\mathrm{cov}(\\hat{\\textbf{x}},\\{\\Pi_y\\})=\\int p(\\textbf{x})\\sum_y\\mathrm{Tr}\n        (\\rho\\Pi_y)(\\hat{\\textbf{x}}-\\textbf{x})(\\hat{\\textbf{x}}-\\textbf{x})^{\\mathrm{T}}\n        \\mathrm{d}\\textbf{x},\n    $$\n\n    Symbols:\n        - $\\textbf{x}=(x_0,x_1,\\dots)^{\\mathrm{T}}$: the unknown parameters to be estimated\n            and the integral $\\int\\mathrm{d}\\textbf{x}:=\\iiint\\mathrm{d}x_0\\mathrm{d}x_1\\cdots$.\n        - $\\{\\Pi_y\\}$: a set of positive operator-valued measure (POVM). \n        - $\\rho$: the parameterized density matrix.\n\n    This function calculates three types of the BQCRB. The first one is\n\n    $$\n        \\mathrm{cov}(\\hat{\\textbf{x}},\\{\\Pi_y\\})\\geq\\int p(\\textbf{x})\\left(B\\mathcal{F}^{-1}B\n        +\\textbf{b}\\textbf{b}^{\\mathrm{T}}\\right)\\mathrm{d}\\textbf{x},\n    $$\n\n    Symbols: \n        - $\\textbf{b}$ and $\\textbf{b}'$: the vectors of biase and its derivatives on parameters.\n        - $B$: a diagonal matrix with the $i$th entry $B_{ii}=1+[\\textbf{b}']_{i}$\n        - $\\mathcal{F}$: the QFIM for all types.\n\n    The second one is\n\n    $$\n        \\mathrm{cov}(\\hat{\\textbf{x}},\\{\\Pi_y\\})\\geq \\mathcal{B}\\,\\mathcal{F}_{\\mathrm{Bayes}}^{-1}\\,\n        \\mathcal{B}+\\int p(\\textbf{x})\\textbf{b}\\textbf{b}^{\\mathrm{T}}\\mathrm{d}\\textbf{x},\n    $$\n\n    Symbols: \n        - $\\mathcal{B}=\\int p(\\textbf{x})B\\mathrm{d}\\textbf{x}$: the average of $B$ \n        - $\\mathcal{F}_{\\mathrm{Bayes}}=\\int p(\\textbf{x})\\mathcal{F}\\mathrm{d}\\textbf{x}$: the average QFIM.\n\n    The third one is\n\n    $$\n        \\mathrm{cov}(\\hat{\\textbf{x}},\\{\\Pi_y\\})\\geq \\int p(\\textbf{x})\n        \\mathcal{G}\\left(\\mathcal{I}_p+\\mathcal{F}\\right)^{-1}\\mathcal{G}^{\\mathrm{T}}\\mathrm{d}\\textbf{x}.\n    $$\n\n    Symbols: \n        - $[\\mathcal{I}_{p}]_{ab}:=[\\partial_a \\ln p(\\textbf{x})][\\partial_b \\ln p(\\textbf{x})]$.\n        - $\\mathcal{G}_{ab}:=[\\partial_b\\ln p(\\textbf{x})][\\textbf{b}]_a+B_{aa}\\delta_{ab}$.\n\n    Args:\n        x (list): \n            The regimes of the parameters for the integral.\n        p (np.array, multidimensional): \n            The prior distribution.\n        rho (list, multidimensional): \n            Parameterized density matrix.\n        drho (list, multidimensional): \n            Derivatives of the parameterized density matrix (rho) with respect to the unknown parameters to be estimated.\n        b (list): \n            Vector of biases of the form $\\textbf{b}=(b(x_0),b(x_1),\\dots)^{\\mathrm{T}}$.\n        db (list): \n            Derivatives of b with respect to the unknown parameters to be estimated, It should be \n            expressed as $\\textbf{b}'=(\\partial_0 b(x_0),\\partial_1 b(x_1),\\dots)^{\\mathrm{T}}$.\n        btype (int): \n            Types of the BQCRB. Options are:  \n                1 (default) -- It means to calculate the first type of the BQCRB.  \n                2 -- It means to calculate the second type of the BQCRB.\n                3 -- It means to calculate the third type of the BCRB.\n        LDtype (str): \n            Types of QFI (QFIM) can be set as the objective function. Options are:  \n                - \"SLD\" (default) -- QFI (QFIM) based on symmetric logarithmic derivative (SLD).  \n                - \"RLD\" -- QFI (QFIM) based on right logarithmic derivative (RLD).  \n                - \"LLD\" -- QFI (QFIM) based on left logarithmic derivative (LLD).\n        eps (float,optional): \n            Machine epsilon.\n\n    Returns:\n        (float/np.array): \n            For single parameter estimation (the length of `x` equals to one), the \n            output is a float and for multiparameter estimation (the length of `x` is larger than one), \n            it returns a matrix.\n    \"\"\"\n\n    para_num = len(x)\n\n    if para_num == 1:\n        #### single parameter scenario ####\n        p_num = len(p)\n\n        if not b:\n            b = np.zeros(p_num)\n            db = np.zeros(p_num)\n        elif not db:\n            db = np.zeros(p_num)\n\n        if type(drho[0]) == list:\n            drho = [drho[i][0] for i in range(p_num)]\n        if type(b[0]) == list or type(b[0]) == np.ndarray:\n            b = b[0]\n        if type(db[0]) == list or type(db[0]) == np.ndarray:\n            db = db[0]\n\n        F_tp = np.zeros(p_num)\n        for m in range(p_num):\n            F_tp[m] = QFIM(rho[m], [drho[m]], LDtype=LDtype, eps=eps)\n\n        if btype == 1:\n            arr = [\n                p[i] * ((1 + db[i]) ** 2 / F_tp[i] + b[i] ** 2) for i in range(p_num)\n            ]\n            F = simpson(arr, x[0])\n            return F\n        elif btype == 2:\n            arr2 = [p[i] * F_tp[i] for i in range(p_num)]\n            F2 = simpson(arr2, x[0])\n            arr2 = [p[j] * (1 + db[j]) for j in range(p_num)]\n            B = simpson(arr2, x[0])\n            arr3 = [p[k] * b[k] ** 2 for k in range(p_num)]\n            bb = simpson(arr3, x[0])\n            F = B**2 / F2 + bb\n            return F\n        elif btype == 3:\n            I_tp = [np.real(dp[i] * dp[i] / p[i] ** 2) for i in range(p_num)]\n            arr = [p[j]*(dp[j]*b[j]/p[j]+(1 + db[j]))**2 / (I_tp[j] + F_tp[j]) for j in range(p_num)]\n            F = simpson(arr, x[0])\n            return F\n        else:\n            raise NameError(\"NameError: btype should be choosen in {1, 2, 3}.\")\n    else:\n        #### multiparameter scenario ####\n        if not b:\n            b, db = [], []\n            for i in range(para_num):\n                b.append(np.zeros(len(x[i])))\n                db.append(np.zeros(len(x[i])))\n        elif not db:\n            db = []\n            for i in range(para_num):\n                db.append(np.zeros(len(x[i])))\n\n        p_shape = np.shape(p)\n        p_ext = extract_ele(p, para_num)\n        dp_ext = extract_ele(dp, para_num)\n        rho_ext = extract_ele(rho, para_num)\n        drho_ext = extract_ele(drho, para_num)\n        b_pro = product(*b)\n        db_pro = product(*db)\n\n        p_list, rho_list, drho_list = [], [], []\n        for p_ele, rho_ele, drho_ele in zip(p_ext, rho_ext, drho_ext):\n            p_list.append(p_ele)\n            rho_list.append(rho_ele)\n            drho_list.append(drho_ele)\n        dp_list = [dpi for dpi in dp_ext]\n\n        b_list, db_list = [], []\n        for b_ele, db_ele in zip(b_pro, db_pro):\n            b_list.append([b_ele[i] for i in range(para_num)])\n            db_list.append([db_ele[j] for j in range(para_num)])\n\n        if btype == 1:\n            F_list = [\n                [[0.0 for i in range(len(p_list))] for j in range(para_num)]\n                for k in range(para_num)\n            ]\n            for i in range(len(p_list)):\n                F_tp = QFIM(rho_list[i], drho_list[i], LDtype=LDtype, eps=eps)\n                F_inv = np.linalg.pinv(F_tp)\n                B = np.diag([(1.0 + db_list[i][j]) for j in range(para_num)])\n                term1 = B @ F_inv @ B\n                term2 = np.dot(\n                    np.array(b_list[i]).reshape(para_num, 1),\n                    np.array(b_list[i]).reshape(1, para_num),\n                )\n                for pj in range(para_num):\n                    for pk in range(para_num):\n                        F_list[pj][pk][i] = term1[pj][pk] + term2[pj][pk]\n\n            res = np.zeros([para_num, para_num])\n            for para_i in range(0, para_num):\n                for para_j in range(para_i, para_num):\n                    F_ij = np.array(F_list[para_i][para_j]).reshape(p_shape)\n                    arr = p * F_ij\n                    for si in reversed(range(para_num)):\n                        arr = simpson(arr, x[si])\n                    res[para_i][para_j] = arr\n                    res[para_j][para_i] = arr\n            return res\n        elif btype == 2:\n            F_list = [\n                [[0.0 for i in range(len(p_list))] for j in range(para_num)]\n                for k in range(para_num)\n            ]\n            B_list = [\n                [[0.0 for i in range(len(p_list))] for j in range(para_num)]\n                for k in range(para_num)\n            ]\n            bb_list = [\n                [[0.0 for i in range(len(p_list))] for j in range(para_num)]\n                for k in range(para_num)\n            ]\n            for i in range(len(p_list)):\n                F_tp = QFIM(rho_list[i], drho_list[i], LDtype=LDtype, eps=eps)\n                B_tp = np.diag([(1.0 + db_list[i][j]) for j in range(para_num)])\n                bb_tp = np.dot(\n                    np.array(b_list[i]).reshape(para_num, 1),\n                    np.array(b_list[i]).reshape(1, para_num),\n                )\n                for pj in range(para_num):\n                    for pk in range(para_num):\n                        F_list[pj][pk][i] = F_tp[pj][pk]\n                        B_list[pj][pk][i] = B_tp[pj][pk]\n                        bb_list[pj][pk][i] = bb_tp[pj][pk]\n\n            F_res = np.zeros([para_num, para_num])\n            for para_i in range(0, para_num):\n                for para_j in range(para_i, para_num):\n                    F_ij = np.array(F_list[para_i][para_j]).reshape(p_shape)\n                    arr = p * F_ij\n                    for si in reversed(range(para_num)):\n                        arr = simpson(arr, x[si])\n                    F_res[para_i][para_j] = arr\n                    F_res[para_j][para_i] = arr\n            B_res = np.zeros([para_num, para_num])\n            bb_res = np.zeros([para_num, para_num])\n            for para_m in range(para_num):\n                for para_n in range(para_num):\n                    B_mn = np.array(B_list[para_m][para_n]).reshape(p_shape)\n                    bb_mn = np.array(bb_list[para_m][para_n]).reshape(p_shape)\n                    arr2 = p * B_mn\n                    arr3 = p * bb_mn\n                    for sj in reversed(range(para_num)):\n                        arr2 = simpson(arr2, x[sj])\n                        arr3 = simpson(arr3, x[sj])\n                    B_res[para_m][para_n] = arr2\n                    bb_res[para_m][para_n] = arr3\n            res = B_res @ np.linalg.pinv(F_res) @ B_res + bb_res\n            return res\n        elif btype == 3:\n            F_list = [\n                [[0.0 for i in range(len(p_list))] for j in range(para_num)]\n                for k in range(para_num)\n            ]\n            for i in range(len(p_list)):\n                F_tp = QFIM(rho_list[i], drho_list[i], LDtype=LDtype, eps=eps)\n                I_tp = np.zeros((para_num, para_num))\n                G_tp = np.zeros((para_num, para_num))\n                for pm in range(para_num):\n                    for pn in range(para_num):\n                        if pm == pn:\n                            G_tp[pm][pn] = dp_list[i][pn]*b_list[i][pm]/p_list[i]+(1.0 + db_list[i][pm])\n                        else:\n                            G_tp[pm][pn] = dp_list[i][pn]*b_list[i][pm]/p_list[i]\n                        I_tp[pm][pn] = dp_list[i][pm] * dp_list[i][pn] / p_list[i] ** 2\n\n                F_tot = G_tp @ np.linalg.pinv(F_tp + I_tp) @ G_tp.T\n                for pj in range(para_num):\n                    for pk in range(para_num):\n                        F_list[pj][pk][i] = F_tot[pj][pk]\n\n            res = np.zeros([para_num, para_num])\n            for para_i in range(0, para_num):\n                for para_j in range(para_i, para_num):\n                    F_ij = np.array(F_list[para_i][para_j]).reshape(p_shape)\n                    arr = p * F_ij\n                    for si in reversed(range(para_num)):\n                        arr = simpson(arr, x[si])\n                    res[para_i][para_j] = arr\n                    res[para_j][para_i] = arr\n            return res\n        else:\n            raise NameError(\"NameError: btype should be choosen in {1, 2, 3}.\")\n</code></pre>"},{"location":"API/python/functions/#optimal-biased-bound-obb","title":"Optimal biased bound (OBB)","text":"<p>Calculate the optimal biased bound (OBB) for single parameter estimation.</p> <p>The OBB is defined as:</p> \\[ \\mathrm{var}(\\hat{x},\\{\\Pi_y\\}) \\geq \\int p(x) \\left( \\frac{(1+b')^2}{F} + b^2 \\right) \\mathrm{d}x \\] Symbols <ul> <li>\\(b\\): bias, \\(b'\\): its derivative.</li> <li>\\(F\\): quantum Fisher information (QFI).</li> </ul> <p>This bound is solved using a boundary value problem approach.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>array</code> <p>Parameter regime for integration.</p> required <code>p</code> <code>array</code> <p>Prior distribution.</p> required <code>dp</code> <code>array</code> <p>Derivative of the prior distribution with respect to the parameter.</p> required <code>rho</code> <code>list</code> <p>Parameterized density matrices.</p> required <code>drho</code> <code>list</code> <p>First derivatives of the density matrices with respect to the parameter.</p> required <code>d2rho</code> <code>list</code> <p>Second-order derivatives of the density matrices with respect to the parameter.</p> required <code>LDtype</code> <code>str</code> <p>Type of logarithmic derivative (default: \"SLD\"). Options:     - \"SLD\": Symmetric logarithmic derivative.     - \"RLD\": Right logarithmic derivative.     - \"LLD\": Left logarithmic derivative.  </p> <code>'SLD'</code> <code>eps</code> <code>float</code> <p>Machine epsilon.</p> <code>1e-08</code> <p>Returns:</p> Type Description <code>float</code> <p>The optimal biased bound value for single parameter estimation.</p> Notes <p>This function uses a boundary value problem solver to compute the optimal bias function.</p> Source code in <code>quanestimation/BayesianBound/BayesCramerRao.py</code> <pre><code>def OBB(x, p, dp, rho, drho, d2rho, LDtype=\"SLD\", eps=1e-8):\n    r\"\"\"\n    Calculate the optimal biased bound (OBB) for single parameter estimation.\n\n    The OBB is defined as:\n\n    $$\n    \\mathrm{var}(\\hat{x},\\{\\Pi_y\\}) \\geq \\int p(x) \\left( \\frac{(1+b')^2}{F} + b^2 \\right) \\mathrm{d}x\n    $$\n\n    Symbols:\n        - $b$: bias, $b'$: its derivative.\n        - $F$: quantum Fisher information (QFI).\n\n    This bound is solved using a boundary value problem approach.\n\n    Args:\n        x (np.array): \n            Parameter regime for integration.\n        p (np.array): \n            Prior distribution.\n        dp (np.array): \n            Derivative of the prior distribution with respect to the parameter.\n        rho (list): \n            Parameterized density matrices.\n        drho (list): \n            First derivatives of the density matrices with respect to the parameter.\n        d2rho (list): \n            Second-order derivatives of the density matrices with respect to the parameter.\n        LDtype (str, optional): \n            Type of logarithmic derivative (default: \"SLD\"). Options:  \n                - \"SLD\": Symmetric logarithmic derivative.  \n                - \"RLD\": Right logarithmic derivative.  \n                - \"LLD\": Left logarithmic derivative.  \n        eps (float, optional): \n            Machine epsilon.\n\n    Returns: \n        (float): \n            The optimal biased bound value for single parameter estimation.\n\n    Notes: \n        This function uses a boundary value problem solver to compute the optimal bias function.\n    \"\"\"\n\n    #### single parameter scenario ####\n    p_num = len(p)\n\n    if type(drho[0]) == list:\n        drho = [drho[i][0] for i in range(p_num)]\n    if type(d2rho[0]) == list:\n        d2rho = [d2rho[i][0] for i in range(p_num)]\n    if type(dp[0]) == list or type(dp[0]) == np.ndarray:\n        dp = [dp[i][0] for i in range(p_num)]\n    if type(x[0]) != float or type(x[0]) != int:\n        x = x[0]\n\n    F, J = np.zeros(p_num), np.zeros(p_num)\n    bias, dbias = np.zeros(p_num), np.zeros(p_num)\n    for m in range(p_num):\n        f, LD = QFIM(rho[m], [drho[m]], LDtype=LDtype, exportLD=True, eps=eps)\n        F[m] = f\n        term1 = d2rho[m] @ LD\n        term2 = d2rho[m] @ LD.conj().T\n        term3 = LD @ LD @ drho[m]\n        dF = np.real(np.trace(term1 + term2 - term3))\n        J[m] = dp[m] / p[m] - dF / f\n\n    y_guess = np.zeros((2, x.size))\n    fun = lambda m, n: OBB_func(m, n, x, J, F)\n    result = solve_bvp(fun, boundary_condition, x, y_guess)\n    res = result.sol(x)\n    bias, dbias = res[0], res[1]\n\n    value = [p[i] * ((1 + dbias[i]) ** 2 / F[i] + bias[i] ** 2) for i in range(p_num)]\n    return simpson(value, x)\n</code></pre>"},{"location":"API/python/functions/#van-trees-bound-vtb","title":"Van Trees bound (VTB)","text":"<p>Calculate the Van Trees bound (VTB), a Bayesian version of the Cramer-Rao bound.</p> <p>The covariance matrix with prior distribution \\(p(\\textbf{x})\\) is:</p> \\[     \\mathrm{cov}(\\hat{\\textbf{x}},\\{\\Pi_y\\}) = \\int p(\\textbf{x}) \\sum_y \\mathrm{Tr}     (\\rho\\Pi_y) (\\hat{\\textbf{x}}-\\textbf{x})(\\hat{\\textbf{x}}-\\textbf{x})^{\\mathrm{T}}     \\mathrm{d}\\textbf{x}. \\] <p>The VTB is given by:</p> \\[ \\mathrm{cov} \\geq \\left(\\mathcal{I}_{\\mathrm{prior}} + \\mathcal{I}_{\\mathrm{Bayes}}\\right)^{-1}. \\] Symbols <ul> <li>\\(\\mathcal{I}_{\\mathrm{prior}} = \\int p(\\textbf{x}) \\mathcal{I}_{p} \\, \\mathrm{d}\\textbf{x}\\)      is the classical Fisher information matrix (CFIM) for the prior distribution \\(p(\\textbf{x})\\).    </li> <li>\\(\\mathcal{I}_{\\mathrm{Bayes}} = \\int p(\\textbf{x}) \\mathcal{I} \\, \\mathrm{d}\\textbf{x}\\)      is the average CFIM over the prior.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>list</code> <p>Parameter regimes for integration.</p> required <code>p</code> <code>array</code> <p>Prior distribution.</p> required <code>dp</code> <code>list</code> <p>Derivatives of the prior distribution with respect to the parameters.</p> required <code>rho</code> <code>list</code> <p>Parameterized density matrices.</p> required <code>drho</code> <code>list</code> <p>Derivatives of the density matrices with respect to the parameters.</p> required <code>M</code> <code>list</code> <p>Positive operator-valued measure (POVM). Default is SIC-POVM.</p> <code>[]</code> <code>eps</code> <code>float</code> <p>Machine epsilon.</p> <code>1e-08</code> <p>Returns:</p> Type Description <code>float / array</code> <p>For single parameter: float. For multiple parameters: matrix.</p> Notes <p>SIC-POVM uses Weyl-Heisenberg covariant fiducial states from  http://www.physics.umb.edu/Research/QBism/solutions.html.</p> Source code in <code>quanestimation/BayesianBound/BayesCramerRao.py</code> <pre><code>def VTB(x, p, dp, rho, drho, M=[], eps=1e-8):\n    r\"\"\"\n    Calculate the Van Trees bound (VTB), a Bayesian version of the Cramer-Rao bound.\n\n    The covariance matrix with prior distribution $p(\\textbf{x})$ is:\n\n    $$\n        \\mathrm{cov}(\\hat{\\textbf{x}},\\{\\Pi_y\\}) = \\int p(\\textbf{x}) \\sum_y \\mathrm{Tr}\n        (\\rho\\Pi_y) (\\hat{\\textbf{x}}-\\textbf{x})(\\hat{\\textbf{x}}-\\textbf{x})^{\\mathrm{T}}\n        \\mathrm{d}\\textbf{x}.\n    $$\n\n    The VTB is given by:\n\n    $$\n    \\mathrm{cov} \\geq \\left(\\mathcal{I}_{\\mathrm{prior}} + \\mathcal{I}_{\\mathrm{Bayes}}\\right)^{-1}.\n    $$\n\n    Symbols:  \n        - $\\mathcal{I}_{\\mathrm{prior}} = \\int p(\\textbf{x}) \\mathcal{I}_{p} \\, \\mathrm{d}\\textbf{x}$ \n            is the classical Fisher information matrix (CFIM) for the prior distribution $p(\\textbf{x})$.    \n        - $\\mathcal{I}_{\\mathrm{Bayes}} = \\int p(\\textbf{x}) \\mathcal{I} \\, \\mathrm{d}\\textbf{x}$ \n            is the average CFIM over the prior.\n\n    Args:\n        x (list): \n            Parameter regimes for integration.\n        p (np.array): \n            Prior distribution.\n        dp (list): \n            Derivatives of the prior distribution with respect to the parameters.\n        rho (list): \n            Parameterized density matrices.\n        drho (list): \n            Derivatives of the density matrices with respect to the parameters.\n        M (list, optional): \n            Positive operator-valued measure (POVM). Default is SIC-POVM.\n        eps (float, optional): \n            Machine epsilon.\n\n    Returns:\n        (float/np.array): \n            For single parameter: float. For multiple parameters: matrix.\n\n    Notes: \n        SIC-POVM uses Weyl-Heisenberg covariant fiducial states from \n        [http://www.physics.umb.edu/Research/QBism/solutions.html](http://www.physics.umb.edu/Research/QBism/solutions.html).\n    \"\"\"\n\n    para_num = len(x)\n    p_num = len(p)\n\n    if para_num == 1:\n        #### single parameter scenario ####\n        if M == []:\n            M = SIC(len(rho[0]))\n        else:\n            if type(M) != list:\n                raise TypeError(\"Please make sure M is a list!\")\n\n        if type(drho[0]) == list:\n            drho = [drho[i][0] for i in range(p_num)]\n        if type(dp[0]) == list or type(dp[0]) == np.ndarray:\n            dp = [dp[i][0] for i in range(p_num)]\n\n        F_tp = np.zeros(p_num)\n        for m in range(p_num):\n            F_tp[m] = CFIM(rho[m], [drho[m]], M=M, eps=eps)\n\n        arr1 = [np.real(dp[i] * dp[i] / p[i]) for i in range(p_num)]\n        I = simpson(arr1, x[0])\n        arr2 = [np.real(F_tp[j] * p[j]) for j in range(p_num)]\n        F = simpson(arr2, x[0])\n        return 1.0 / (I + F)\n    else:\n        #### multiparameter scenario ####\n        p_shape = np.shape(p)\n        p_ext = extract_ele(p, para_num)\n        dp_ext = extract_ele(dp, para_num)\n        rho_ext = extract_ele(rho, para_num)\n        drho_ext = extract_ele(drho, para_num)\n\n        p_list, rho_list, drho_list = [], [], []\n        for p_ele, rho_ele, drho_ele in zip(p_ext, rho_ext, drho_ext):\n            p_list.append(p_ele)\n            rho_list.append(rho_ele)\n            drho_list.append(drho_ele)\n        dp_list = [dpi for dpi in dp_ext]\n\n        dim = len(rho_list[0])\n        if M == []:\n            M = SIC(dim)\n        else:\n            if type(M) != list:\n                raise TypeError(\"Please make sure M is a list!\")\n\n        F_list = [\n                [[0.0 for i in range(len(p_list))] for j in range(para_num)]\n                for k in range(para_num)\n            ]\n        I_list = [\n                [[0.0 for i in range(len(p_list))] for j in range(para_num)]\n                for k in range(para_num)\n            ]\n        for i in range(len(p_list)):\n            F_tp = CFIM(rho_list[i], drho_list[i], M=M, eps=eps)\n            for pj in range(para_num):\n                for pk in range(para_num):\n                    F_list[pj][pk][i] = F_tp[pj][pk]\n                    I_list[pj][pk][i] = (\n                            dp_list[i][pj] * dp_list[i][pk] / p_list[i] ** 2\n                        )\n\n        F_res = np.zeros([para_num, para_num])\n        I_res = np.zeros([para_num, para_num])\n        for para_i in range(0, para_num):\n            for para_j in range(para_i, para_num):\n                F_ij = np.array(F_list[para_i][para_j]).reshape(p_shape)\n                I_ij = np.array(I_list[para_i][para_j]).reshape(p_shape)\n                arr1 = p * F_ij\n                arr2 = p * I_ij\n                for si in reversed(range(para_num)):\n                    arr1 = simpson(arr1, x[si])\n                    arr2 = simpson(arr2, x[si])\n                F_res[para_i][para_j] = arr1\n                F_res[para_j][para_i] = arr1\n                I_res[para_i][para_j] = arr2\n                I_res[para_j][para_i] = arr2\n        return np.linalg.pinv(F_res + I_res)\n</code></pre>"},{"location":"API/python/functions/#quantum-van-trees-bound-qvtb","title":"Quantum Van Trees bound (QVTB)","text":"<p>Calculate the quantum Van Trees bound (QVTB), a Bayesian version of the quantum Cramer-Rao bound.</p> <p>The covariance matrix with prior distribution \\(p(\\textbf{x})\\) is:</p> \\[ \\mathrm{cov}(\\hat{\\textbf{x}},\\{\\Pi_y\\}) = \\int p(\\textbf{x}) \\sum_y \\mathrm{Tr} (\\rho\\Pi_y) (\\hat{\\textbf{x}}-\\textbf{x})(\\hat{\\textbf{x}}-\\textbf{x})^{\\mathrm{T}} \\mathrm{d}\\textbf{x}. \\] <p>The QVTB is given by:</p> <p>$$ \\mathrm{cov} \\geq \\left(\\mathcal{I}{\\mathrm{prior}} + \\mathcal{F}. $$}}\\right)^{-1</p> Symbols <ul> <li>\\(\\mathcal{I}_{\\mathrm{prior}} = \\int p(\\textbf{x}) \\mathcal{I}_{p} \\, \\mathrm{d}\\textbf{x}\\):     the classical Fisher information matrix (CFIM) for the prior distribution \\(p(\\textbf{x})\\).</li> <li>\\(\\mathcal{F}_{\\mathrm{Bayes}} = \\int p(\\textbf{x}) \\mathcal{F} \\, \\mathrm{d}\\textbf{x}\\):     the average quantum Fisher information matrix (QFIM) over the prior.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>list</code> <p>Parameter regimes for integration.</p> required <code>p</code> <code>array</code> <p>Prior distribution.</p> required <code>dp</code> <code>list</code> <p>Derivatives of the prior distribution with respect to the parameters.</p> required <code>rho</code> <code>list</code> <p>Parameterized density matrices.</p> required <code>drho</code> <code>list</code> <p>Derivatives of the density matrices with respect to the parameters.</p> required <code>LDtype</code> <code>string</code> <p>Type of logarithmic derivative (default: \"SLD\"). Options:     - \"SLD\": Symmetric logarithmic derivative.     - \"RLD\": Right logarithmic derivative.     - \"LLD\": Left logarithmic derivative.  </p> <code>'SLD'</code> <code>eps</code> <code>float</code> <p>Machine epsilon.</p> <code>1e-08</code> <p>Returns:</p> Type Description <code>float / array</code> <p>For single parameter: float. For multiple parameters: matrix.</p> Source code in <code>quanestimation/BayesianBound/BayesCramerRao.py</code> <pre><code>def QVTB(x, p, dp, rho, drho, LDtype=\"SLD\", eps=1e-8):\n    r\"\"\"\n    Calculate the quantum Van Trees bound (QVTB), a Bayesian version of the quantum Cramer-Rao bound.\n\n    The covariance matrix with prior distribution $p(\\textbf{x})$ is:\n\n    $$\n    \\mathrm{cov}(\\hat{\\textbf{x}},\\{\\Pi_y\\}) = \\int p(\\textbf{x}) \\sum_y \\mathrm{Tr}\n    (\\rho\\Pi_y) (\\hat{\\textbf{x}}-\\textbf{x})(\\hat{\\textbf{x}}-\\textbf{x})^{\\mathrm{T}}\n    \\mathrm{d}\\textbf{x}.\n    $$\n\n    The QVTB is given by:\n\n    \\$$\n    \\mathrm{cov} \\geq \\left(\\mathcal{I}_{\\mathrm{prior}} + \\mathcal{F}_{\\mathrm{Bayes}}\\right)^{-1}.\n    $$\n\n    Symbols:\n        - $\\mathcal{I}_{\\mathrm{prior}} = \\int p(\\textbf{x}) \\mathcal{I}_{p} \\, \\mathrm{d}\\textbf{x}$:  \n            the classical Fisher information matrix (CFIM) for the prior distribution $p(\\textbf{x})$.\n        - $\\mathcal{F}_{\\mathrm{Bayes}} = \\int p(\\textbf{x}) \\mathcal{F} \\, \\mathrm{d}\\textbf{x}$:  \n            the average quantum Fisher information matrix (QFIM) over the prior.\n\n    Args:\n        x (list): \n            Parameter regimes for integration.\n        p (np.array): \n            Prior distribution.\n        dp (list): \n            Derivatives of the prior distribution with respect to the parameters.\n        rho (list): \n            Parameterized density matrices.\n        drho (list): \n            Derivatives of the density matrices with respect to the parameters.\n        LDtype (string, optional): \n            Type of logarithmic derivative (default: \"SLD\"). Options:  \n                - \"SLD\": Symmetric logarithmic derivative.  \n                - \"RLD\": Right logarithmic derivative.  \n                - \"LLD\": Left logarithmic derivative.  \n        eps (float, optional): \n            Machine epsilon.\n\n    Returns: \n        (float/np.array): \n            For single parameter: float. For multiple parameters: matrix.\n    \"\"\"\n    para_num = len(x)\n    p_num = len(p)\n\n    if para_num == 1:\n        if type(drho[0]) == list:\n            drho = [drho[i][0] for i in range(p_num)]\n        if type(dp[0]) == list or type(dp[0]) == np.ndarray:\n            dp = [dp[i][0] for i in range(p_num)]\n\n        F_tp = np.zeros(p_num)\n        for m in range(p_num):\n            F_tp[m] = QFIM(rho[m], [drho[m]], LDtype=LDtype, eps=eps)\n\n        arr1 = [np.real(dp[i] * dp[i] / p[i]) for i in range(p_num)]\n        I = simpson(arr1, x[0])\n        arr2 = [np.real(F_tp[j] * p[j]) for j in range(p_num)]\n        F = simpson(arr2, x[0])\n        return 1.0 / (I + F)\n    else:\n        #### multiparameter scenario ####\n        p_shape = np.shape(p)\n        p_ext = extract_ele(p, para_num)\n        dp_ext = extract_ele(dp, para_num)\n        rho_ext = extract_ele(rho, para_num)\n        drho_ext = extract_ele(drho, para_num)\n\n        p_list, rho_list, drho_list = [], [], []\n        for p_ele, rho_ele, drho_ele in zip(p_ext, rho_ext, drho_ext):\n            p_list.append(p_ele)\n            rho_list.append(rho_ele)\n            drho_list.append(drho_ele)\n        dp_list = [dpi for dpi in dp_ext]\n\n        F_list = [\n                [[0.0 for i in range(len(p_list))] for j in range(para_num)]\n                for k in range(para_num)\n            ]\n        I_list = [\n                [[0.0 for i in range(len(p_list))] for j in range(para_num)]\n                for k in range(para_num)\n            ]\n        for i in range(len(p_list)):\n            F_tp = QFIM(rho_list[i], drho_list[i], LDtype=LDtype, eps=eps)\n            for pj in range(para_num):\n                for pk in range(para_num):\n                    F_list[pj][pk][i] = F_tp[pj][pk]\n                    I_list[pj][pk][i] = (\n                            dp_list[i][pj] * dp_list[i][pk] / p_list[i] ** 2\n                        )\n\n        F_res = np.zeros([para_num, para_num])\n        I_res = np.zeros([para_num, para_num])\n        for para_i in range(0, para_num):\n            for para_j in range(para_i, para_num):\n                F_ij = np.array(F_list[para_i][para_j]).reshape(p_shape)\n                I_ij = np.array(I_list[para_i][para_j]).reshape(p_shape)\n                arr1 = p * F_ij\n                arr2 = p * I_ij\n                for si in reversed(range(para_num)):\n                    arr1 = simpson(arr1, x[si])\n                    arr2 = simpson(arr2, x[si])\n                F_res[para_i][para_j] = arr1\n                F_res[para_j][para_i] = arr1\n                I_res[para_i][para_j] = arr2\n                I_res[para_j][para_i] = arr2\n        return np.linalg.pinv(F_res + I_res)\n</code></pre>"},{"location":"API/python/functions/#quantum-ziv-zakai-bound","title":"Quantum Ziv-Zakai bound","text":"<p>Calculation of the quantum Ziv-Zakai bound (QZZB). The expression of QZZB with a  prior distribution p(x) in a finite regime \\([\\alpha,\\beta]\\) is</p> \\[\\begin{aligned}     \\mathrm{var}(\\hat{x},\\{\\Pi_y\\}) \\geq &amp;  \\frac{1}{2}\\int_0^\\infty \\mathrm{d}\\tau\\tau     \\mathcal{V}\\int_{-\\infty}^{\\infty} \\mathrm{d}x\\min\\!\\left\\{p(x), p(x+\\tau)\\right\\} \\nonumber \\\\     &amp; \\times\\left(1-\\frac{1}{2}||\\rho(x)-\\rho(x+\\tau)||\\right). \\end{aligned}\\] Symbols <ul> <li>\\(||\\cdot||\\): the trace norm</li> <li>\\(\\mathcal{V}\\): the \"valley-filling\" operator satisfying \\(\\mathcal{V}f(\\tau)=\\max_{h\\geq 0}f(\\tau+h)\\). </li> <li>\\(\\rho(x)\\): the parameterized density matrix.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>list</code> <p>The regimes of the parameters for the integral.</p> required <code>p</code> <code>ndarray</code> <p>The prior distribution as a multidimensional array.</p> required <code>rho</code> <code>list</code> <p>Parameterized density matrix as a multidimensional list.</p> required <code>eps</code> <code>float</code> <p>Machine epsilon. Defaults to 1e-8.</p> <code>1e-08</code> <p>Returns:</p> Type Description <code>float</code> <p>Quantum Ziv-Zakai bound (QZZB).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the length of x and p do not match.</p> Source code in <code>quanestimation/BayesianBound/ZivZakai.py</code> <pre><code>def QZZB(x, p, rho, eps=1e-8):\n    r\"\"\"\n    Calculation of the quantum Ziv-Zakai bound (QZZB). The expression of QZZB with a \n    prior distribution p(x) in a finite regime $[\\alpha,\\beta]$ is\n\n    \\begin{aligned}\n        \\mathrm{var}(\\hat{x},\\{\\Pi_y\\}) \\geq &amp;  \\frac{1}{2}\\int_0^\\infty \\mathrm{d}\\tau\\tau\n        \\mathcal{V}\\int_{-\\infty}^{\\infty} \\mathrm{d}x\\min\\!\\left\\{p(x), p(x+\\tau)\\right\\} \\nonumber \\\\\n        &amp; \\times\\left(1-\\frac{1}{2}||\\rho(x)-\\rho(x+\\tau)||\\right).\n    \\end{aligned}\n\n    Symbols:\n        - $||\\cdot||$: the trace norm\n        - $\\mathcal{V}$: the \"valley-filling\" operator satisfying $\\mathcal{V}f(\\tau)=\\max_{h\\geq 0}f(\\tau+h)$. \n        - $\\rho(x)$: the parameterized density matrix.\n\n    Args:\n        x (list): \n            The regimes of the parameters for the integral.\n        p (np.ndarray): \n            The prior distribution as a multidimensional array.\n        rho (list): \n            Parameterized density matrix as a multidimensional list.\n        eps (float, optional): \n            Machine epsilon. Defaults to 1e-8.\n\n    Returns:\n        (float): \n            Quantum Ziv-Zakai bound (QZZB).\n\n    Raises:\n        ValueError: \n            If the length of x and p do not match.\n    \"\"\"\n\n    if type(x[0]) == list or type(x[0]) == np.ndarray:\n        x = x[0]\n    p_num = len(p)\n    tau = [xi - x[0] for xi in x]\n    f_tau = np.zeros(p_num)\n    for i in range(p_num):\n        arr = [\n            np.real(2 * min(p[j], p[j + i]) * helstrom_dm(rho[j], rho[j + i], eps))\n            for j in range(p_num - i)\n        ]\n        f_tp = simpson(arr, x[0 : p_num - i])\n        f_tau[i] = f_tp\n    arr2 = [tau[m] * max(f_tau[m:]) for m in range(p_num)]\n    I = simpson(arr2, tau)\n    return 0.5 * I\n</code></pre>"},{"location":"API/python/functions/#bayesian-estimation","title":"Bayesian estimation","text":""},{"location":"API/python/functions/#maximum-a-posteriori-probability-map","title":"Maximum a posteriori probability (MAP)","text":"<p>Bayesian estimation. The prior distribution is updated via the posterior  distribution obtained by Bayes' rule. The estimated value of parameters are  updated via either the expectation value of the distribution or maximum a  posteriori probability (MAP).</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>list</code> <p>The regimes of the parameters for the integral.</p> required <code>p</code> <code>ndarray</code> <p>The prior distribution as a multidimensional array.</p> required <code>rho</code> <code>list</code> <p>Parameterized density matrix as a multidimensional list.</p> required <code>y</code> <code>ndarray</code> <p>The experimental results obtained in practice.</p> required <code>M</code> <code>list</code> <p>A set of positive operator-valued measure (POVM).  Defaults to a set of rank-one symmetric informationally complete  POVM (SIC-POVM).</p> <code>None</code> <code>estimator</code> <code>str</code> <p>Estimators for the bayesian estimation.  Options are:     \"mean\" (default) - The expectation value of the distribution.     \"MAP\" - Maximum a posteriori probability.</p> <code>'mean'</code> <code>savefile</code> <code>bool</code> <p>Whether to save all posterior distributions.  If True, generates \"pout.npy\" and \"xout.npy\" containing all  posterior distributions and estimated values across iterations.  If False, only saves the final posterior distribution and all  estimated values. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple</code> <p>pout (np.ndarray):      The posterior distribution in the final iteration.</p> <p>xout (float/list):      The estimated values in the final iteration.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>M</code> is not a list.</p> <code>ValueError</code> <p>If estimator is not \"mean\" or \"MAP\".</p> Note <p>SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state  which can be downloaded from here.</p> Source code in <code>quanestimation/BayesianBound/BayesEstimation.py</code> <pre><code>def Bayes(x, p, rho, y, M=None, estimator=\"mean\", savefile=False):\n    \"\"\"\n    Bayesian estimation. The prior distribution is updated via the posterior \n    distribution obtained by Bayes' rule. The estimated value of parameters are \n    updated via either the expectation value of the distribution or maximum a \n    posteriori probability (MAP).\n\n    Args:\n        x (list): The regimes of the parameters for the integral.\n        p (np.ndarray): The prior distribution as a multidimensional array.\n        rho (list): Parameterized density matrix as a multidimensional list.\n        y (np.ndarray): The experimental results obtained in practice.\n        M (list, optional): A set of positive operator-valued measure (POVM). \n            Defaults to a set of rank-one symmetric informationally complete \n            POVM (SIC-POVM).\n        estimator (str, optional): Estimators for the bayesian estimation. \n            Options are:\n                \"mean\" (default) - The expectation value of the distribution.\n                \"MAP\" - Maximum a posteriori probability.\n        savefile (bool, optional): Whether to save all posterior distributions. \n            If True, generates \"pout.npy\" and \"xout.npy\" containing all \n            posterior distributions and estimated values across iterations. \n            If False, only saves the final posterior distribution and all \n            estimated values. Defaults to False.\n\n    Returns:\n        (tuple): \n            pout (np.ndarray): \n                The posterior distribution in the final iteration.\n\n            xout (float/list): \n                The estimated values in the final iteration.\n\n    Raises:\n        TypeError: \n            If `M` is not a list.\n        ValueError: \n            If estimator is not \"mean\" or \"MAP\".\n\n    Note: \n        SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state \n        which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/solutions.html).\n    \"\"\"\n    if M is None:\n        M = []\n\n    para_num = len(x)\n    max_episode = len(y)\n\n    # Single parameter scenario\n    if para_num == 1:\n        if not M:\n            M = SIC(len(rho[0]))\n        elif not isinstance(M, list):\n            raise TypeError(\"M must be a list\")\n\n        x_out = []\n        p_out = []\n\n        for mi in range(max_episode):\n            res_exp = int(y[mi])\n            pyx = np.zeros(len(x[0]))\n\n            # Calculate conditional probabilities\n            for xi in range(len(x[0])):\n                p_tp = np.real(np.trace(rho[xi] @ M[res_exp]))\n                pyx[xi] = p_tp\n\n            # Update posterior distribution\n            arr = [pyx[m] * p[m] for m in range(len(x[0]))]\n            py = simpson(arr, x[0])\n            p_update = pyx * p / py\n            p = p_update / np.linalg.norm(p_update)\n\n            # Handle estimator type\n            if estimator == \"mean\":\n                mean = simpson([p[m] * x[0][m] for m in range(len(x[0]))], x[0])\n                x_out.append(mean)\n            elif estimator == \"MAP\":\n                indx = np.argmax(p)\n                x_out.append(x[0][indx])\n            else:\n                raise ValueError(\n                    \"Invalid estimator: {}. Supported values are 'mean' and 'MAP'\"\n                    .format(estimator)\n                )\n\n            # Save intermediate results if requested\n            if savefile:\n                p_out.append(p)\n\n        # Save final results\n        if savefile:\n            np.save(\"pout\", p_out)\n            np.save(\"xout\", x_out)\n            return p, x_out[-1]\n        else:\n            np.save(\"pout\", p)\n            np.save(\"xout\", x_out)\n            return p, x_out[-1]\n\n    # Multiparameter scenario\n    else:\n        p_shape = np.shape(p)\n        p_ext = extract_ele(p, para_num)\n        rho_ext = extract_ele(rho, para_num)\n\n        p_list, rho_list = [], []\n        for p_ele, rho_ele in zip(p_ext, rho_ext):\n            p_list.append(p_ele)\n            rho_list.append(rho_ele)\n\n        dim = len(rho_list[0])\n        if not M:\n            M = SIC(dim)\n        elif not isinstance(M, list):\n            raise TypeError(\"M must be a list\")\n\n        x_out = []\n        p_out = []  # Always initialize as list\n\n        for mi in range(max_episode):\n            res_exp = int(y[mi])\n            pyx_list = np.zeros(len(p_list))\n\n            # Calculate conditional probabilities\n            for xi in range(len(p_list)):\n                p_tp = np.real(np.trace(rho_list[xi] @ M[res_exp]))\n                pyx_list[xi] = p_tp\n\n            # Reshape and update posterior distribution\n            pyx = pyx_list.reshape(p_shape)\n            arr = p * pyx\n            for si in reversed(range(para_num)):\n                arr = simpson(arr, x[si])\n            py = arr\n            p_update = p * pyx / py\n            p = p_update / np.linalg.norm(p_update)\n\n            # Handle estimator type\n            if estimator == \"mean\":\n                mean = integ(x, p)\n                x_out.append(mean)\n            elif estimator == \"MAP\":\n                # Use unravel_index for better performance and type safety\n                max_idx = np.argmax(p)\n                indices = np.unravel_index(max_idx, p_shape)\n                x_out.append([x[i][indices[i]] for i in range(para_num)])\n            else:\n                raise ValueError(\n                    f\"Invalid estimator: {estimator}. Supported values are 'mean' and 'MAP'\"\n                )\n\n            # Save intermediate results if requested\n            if savefile:\n                p_out.append(p)\n\n        # Save final results\n        if savefile:\n            np.save(\"pout\", p_out)\n            np.save(\"xout\", x_out)\n            return p, x_out[-1]\n        else:\n            np.save(\"pout\", p)\n            np.save(\"xout\", x_out)\n            return p, x_out[-1]\n</code></pre>"},{"location":"API/python/functions/#maximum-likelihood-estimation-mle","title":"Maximum likelihood estimation (MLE)","text":"<p>Maximum likelihood estimation (MLE) for parameter estimation.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>list</code> <p>The regimes of the parameters for the integral.</p> required <code>rho</code> <code>list</code> <p>Parameterized density matrix as a multidimensional list.</p> required <code>y</code> <code>ndarray</code> <p>The experimental results obtained in practice.</p> required <code>M</code> <code>list</code> <p>A set of positive operator-valued measure (POVM). Defaults to a set of rank-one  symmetric informationally complete POVM (SIC-POVM).</p> <code>[]</code> <code>savefile</code> <code>bool</code> <p>Whether to save all likelihood functions. If True, generates \"Lout.npy\" and  \"xout.npy\" containing all likelihood functions and estimated values across  iterations. If False, only saves the final likelihood function and all  estimated values. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple</code> <p>Lout (np.ndarray):      The likelihood function in the final iteration.</p> <p>xout (float/list):      The estimated values in the final iteration.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>M</code> is not a list.</p> Note <p>SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state  which can be downloaded from here.</p> Source code in <code>quanestimation/BayesianBound/BayesEstimation.py</code> <pre><code>def MLE(x, rho, y, M=[], savefile=False):\n    \"\"\"\n    Maximum likelihood estimation (MLE) for parameter estimation.\n\n    Args:\n        x (list): \n            The regimes of the parameters for the integral.\n        rho (list): \n            Parameterized density matrix as a multidimensional list.\n        y (np.ndarray): \n            The experimental results obtained in practice.\n        M (list, optional): \n            A set of positive operator-valued measure (POVM). Defaults to a set of rank-one \n            symmetric informationally complete POVM (SIC-POVM).\n        savefile (bool, optional): \n            Whether to save all likelihood functions. If True, generates \"Lout.npy\" and \n            \"xout.npy\" containing all likelihood functions and estimated values across \n            iterations. If False, only saves the final likelihood function and all \n            estimated values. Defaults to False.\n\n    Returns:\n        (tuple): \n            Lout (np.ndarray): \n                The likelihood function in the final iteration.\n\n            xout (float/list): \n                The estimated values in the final iteration.\n\n    Raises:\n        TypeError: If `M` is not a list.\n\n    Note: \n        SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state \n        which can be downloaded from [here](http://www.physics.umb.edu/Research/QBism/solutions.html).\n    \"\"\"\n    if M is None:\n        M = []\n\n    para_num = len(x)\n    max_episode = len(y)\n    if para_num == 1:\n        #### single parameter scenario ####\n        if M == []:\n            M = SIC(len(rho[0]))\n        else:\n            if type(M) != list:\n                raise TypeError(\"Please make sure M is a list!\")\n\n        if savefile == False:\n            x_out = []\n            L_out = np.ones(len(x[0]))\n            for mi in range(max_episode):\n                res_exp = int(y[mi])\n                for xi in range(len(x[0])):\n                    p_tp = np.real(np.trace(rho[xi] @ M[res_exp]))\n                    L_out[xi] = L_out[xi] * p_tp\n                indx = np.where(L_out == max(L_out))[0][0]\n                x_out.append(x[0][indx])\n            np.save(\"Lout\", L_out)\n            np.save(\"xout\", x_out)\n\n            return L_out, x_out[-1]\n        else:\n            L_out, x_out = [], []\n            L_tp = np.ones(len(x[0]))\n            for mi in range(max_episode):\n                res_exp = int(y[mi])\n                for xi in range(len(x[0])):\n                    p_tp = np.real(np.trace(rho[xi] @ M[res_exp]))\n                    L_tp[xi] = L_tp[xi] * p_tp\n                indx = np.where(L_tp == max(L_tp))[0][0]\n                L_out.append(L_tp)\n                x_out.append(x[0][indx])\n\n            np.save(\"Lout\", L_out)\n            np.save(\"xout\", x_out)\n            return L_tp, x_out[-1]\n    else:\n        #### multiparameter scenario ####\n        p_shape = []\n        for i in range(para_num):\n            p_shape.append(len(x[i]))\n        rho_ext = extract_ele(rho, para_num)\n\n        rho_list = []\n        for rho_ele in rho_ext:\n            rho_list.append(rho_ele)\n\n        dim = len(rho_list[0])\n        if M == []:\n            M = SIC(dim)\n        else:\n            if type(M) != list:\n                raise TypeError(\"Please make sure M is a list!\")\n\n        if savefile == False:\n            x_out = []\n            L_list = np.ones(len(rho_list))\n            for mi in range(max_episode):\n                res_exp = int(y[mi])\n                for xi in range(len(rho_list)):\n                    p_tp = np.real(np.trace(rho_list[xi] @ M[res_exp]))\n                    L_list[xi] = L_list[xi] * p_tp\n                L_out = L_list.reshape(p_shape)\n                indx = np.where(L_out == np.max(L_out))\n                x_out.append([x[i][indx[i][0]] for i in range(para_num)])\n            np.save(\"Lout\", L_out)\n            np.save(\"xout\", x_out)\n\n            return L_out, x_out[-1]\n        else:\n            L_out, x_out = [], []\n            L_list = np.ones(len(rho_list))\n            for mi in range(max_episode):\n                res_exp = int(y[mi])\n                for xi in range(len(rho_list)):\n                    p_tp = np.real(np.trace(rho_list[xi] @ M[res_exp]))\n                    L_list[xi] = L_list[xi] * p_tp\n                L_tp = L_list.reshape(p_shape)\n                indx = np.where(L_tp == np.max(L_tp))\n                L_out.append(L_tp)\n                x_out.append([x[i][indx[i][0]] for i in range(para_num)])\n\n            np.save(\"Lout\", L_out)\n            np.save(\"xout\", x_out)\n            return L_tp, x_out[-1]\n</code></pre>"},{"location":"API/python/functions/#average-bayesian-cost-bayescost","title":"Average Bayesian cost (BayesCost)","text":"<p>Calculation of the average Bayesian cost with a quadratic cost function.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>list</code> <p>The regimes of the parameters for the integral.</p> required <code>p</code> <code>array</code> <p>The prior distribution as a multidimensional array.</p> required <code>xest</code> <code>float or list</code> <p>The estimators. xest is a float for single-parameter estimation and a list for multi-parameter estimation.</p> required <code>rho</code> <code>list</code> <p>Parameterized density matrix as a multidimensional list.</p> required <code>M</code> <code>list</code> <p>A set of positive operator-valued measure (POVM).</p> required <code>W</code> <code>array</code> <p>Weight matrix. Defaults to an identity matrix.</p> <code>[]</code> <code>eps</code> <code>float</code> <p>Machine epsilon.</p> <code>1e-08</code> <p>Returns:</p> Type Description <code>float</code> <p>The average Bayesian cost.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>M</code> is not a list.</p> Source code in <code>quanestimation/BayesianBound/BayesEstimation.py</code> <pre><code>def BayesCost(x, p, xest, rho, M, W=[], eps=1e-8):\n    \"\"\"\n    Calculation of the average Bayesian cost with a quadratic cost function.\n\n    Args:\n        x (list): \n            The regimes of the parameters for the integral.\n        p (array): \n            The prior distribution as a multidimensional array.\n        xest (float or list): \n            The estimators. xest is a float for single-parameter estimation\n            and a list for multi-parameter estimation.\n        rho (list): \n            Parameterized density matrix as a multidimensional list.\n        M (list): \n            A set of positive operator-valued measure (POVM).\n        W (array, optional): \n            Weight matrix. Defaults to an identity matrix.\n        eps (float, optional): \n            Machine epsilon.\n\n    Returns:\n        (float): \n            The average Bayesian cost.\n\n    Raises:\n        TypeError: \n            If `M` is not a list.\n    \"\"\"\n    if M is None:\n        M = []\n\n    if W is None:\n        W = []\n\n    para_num = len(x)\n    if para_num == 1:\n        # single-parameter scenario\n        if M == []:\n            M = SIC(len(rho[0]))\n        else:\n            if type(M) != list:\n                raise TypeError(\"Please make sure M is a list!\")\n\n        # if isinstance(x, np.ndarray):\n        #     x = [x]    \n\n        p_num = len(x[0])\n\n        value = [p[i]*sum([np.trace(rho[i] @ M[mi])*(x[0][i]-xest)**2 for mi in range(len(M))]) for i in range(p_num)]\n        C = simpson(value, x[0])\n        return np.real(C)\n    else:\n        # multi-parameter scenario\n        p_shape = np.shape(p)\n        p_ext = extract_ele(p, para_num)\n        rho_ext = extract_ele(rho, para_num)\n\n        p_list, rho_list = [], []\n        for p_ele, rho_ele in zip(p_ext, rho_ext):\n            p_list.append(p_ele)\n            rho_list.append(rho_ele)\n\n        x_pro = product(*x)\n        x_list = []\n        for x_ele in x_pro:\n            x_list.append([x_ele[i] for i in range(para_num)])\n\n        dim = len(rho_list[0])\n        p_num = len(p_list)\n\n        if W == []:\n            W = np.identity(para_num)\n\n        if M == []:\n            M = SIC(dim)\n        else:\n            if type(M) != list:\n                raise TypeError(\"Please make sure M is a list!\")\n\n        value = [0.0 for i in range(p_num)]\n        for i in range(p_num):\n            x_tp = np.array(x_list[i])\n            xCx = 0.0\n            for mi in range(len(M)):\n                xCx += np.trace(rho_list[i] @ M[mi])*np.dot((x_tp-xest[mi]).reshape(1, -1), W @ (x_tp-xest[mi]).reshape(-1, 1))[0][0]\n            value[i] = p_list[i]*xCx\n        C = np.array(value).reshape(p_shape)\n        for si in reversed(range(para_num)):\n            C = simpson(C, x[si])\n        return np.real(C)\n</code></pre>"},{"location":"API/python/functions/#bayesian-cost-bound-bcb","title":"Bayesian cost bound (BCB)","text":"<p>Calculation of the Bayesian cost bound with a quadratic cost function.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>list</code> <p>The regimes of the parameters for the integral.</p> required <code>p</code> <code>array</code> <p>The prior distribution as a multidimensional array.</p> required <code>rho</code> <code>list</code> <p>Parameterized density matrix as a multidimensional list.</p> required <code>W</code> <code>array</code> <p>Weight matrix. Defaults to an identity matrix.</p> <code>[]</code> <code>eps</code> <code>float</code> <p>Machine epsilon. Defaults to 1e-8.</p> <code>1e-08</code> <p>Returns:</p> Type Description <code>float</code> <p>The value of the minimum Bayesian cost.</p> Note <p>This function calculates the Bayesian cost bound for parameter estimation.</p> Source code in <code>quanestimation/BayesianBound/BayesEstimation.py</code> <pre><code>def BCB(x, p, rho, W=[], eps=1e-8):\n    \"\"\"\n    Calculation of the Bayesian cost bound with a quadratic cost function.\n\n    Args:\n        x (list): \n            The regimes of the parameters for the integral.\n        p (array): \n            The prior distribution as a multidimensional array.\n        rho (list): \n            Parameterized density matrix as a multidimensional list.\n        W (array, optional): \n            Weight matrix. Defaults to an identity matrix.\n        eps (float, optional): \n            Machine epsilon. Defaults to 1e-8.\n\n    Returns:\n        (float): \n            The value of the minimum Bayesian cost.\n\n    Note:\n        This function calculates the Bayesian cost bound for parameter estimation.\n    \"\"\"\n    para_num = len(x)\n    if para_num == 1:\n        # single-parameter scenario\n        dim = len(rho[0])\n        p_num = len(x[0])\n        value = [p[i]*x[0][i]**2 for i in range(p_num)]\n        delta2_x = simpson(value, x[0])\n        rho_avg = np.zeros((dim, dim), dtype=np.complex128)\n        rho_pri = np.zeros((dim, dim), dtype=np.complex128)\n        for di in range(dim):\n            for dj in range(dim):\n                rho_avg_arr = [p[m]*rho[m][di][dj] for m in range(p_num)]\n                rho_pri_arr = [p[n]*x[0][n]*rho[n][di][dj] for n in range(p_num)]\n                rho_avg[di][dj] = simpson(rho_avg_arr, x[0])\n                rho_pri[di][dj] = simpson(rho_pri_arr, x[0])\n        Lambda = Lambda_avg(rho_avg, [rho_pri], eps=eps)\n        minBC = delta2_x - np.real(np.trace(rho_avg @ Lambda[0] @ Lambda[0]))\n        return minBC\n    else:\n        # multi-parameter scenario\n        p_shape = np.shape(p)\n        p_ext = extract_ele(p, para_num)\n        rho_ext = extract_ele(rho, para_num)\n\n        p_list, rho_list = [], []\n        for p_ele, rho_ele in zip(p_ext, rho_ext):\n            p_list.append(p_ele)\n            rho_list.append(rho_ele)\n\n        dim = len(rho_list[0])\n        p_num = len(p_list)\n\n        x_pro = product(*x)\n        x_list = []\n        for x_ele in x_pro:\n            x_list.append([x_ele[i] for i in range(para_num)])\n\n        if W == []:\n            W = np.identity(para_num)\n\n        value = [0.0 for i in range(p_num)]\n        for i in range(p_num):\n            x_tp = np.array(x_list[i])\n            xCx = np.dot(x_tp.reshape(1, -1), np.dot(W, x_tp.reshape(-1, 1)))[0][0]\n            value[i] = p_list[i]*xCx\n        delta2_x = np.array(value).reshape(p_shape)\n        for si in reversed(range(para_num)):\n            delta2_x = simpson(delta2_x, x[si])\n        rho_avg = np.zeros((dim, dim), dtype=np.complex128)\n        rho_pri = [np.zeros((dim, dim), dtype=np.complex128) for i in range(para_num)]\n        for di in range(dim):\n            for dj in range(dim):\n                rho_avg_arr = [p_list[m]*rho_list[m][di][dj] for m in range(p_num)]\n                rho_avg_tp = np.array(rho_avg_arr).reshape(p_shape)\n                for si in reversed(range(para_num)):\n                    rho_avg_tp = simpson(rho_avg_tp, x[si])\n                rho_avg[di][dj] = rho_avg_tp\n\n                for para_i in range(para_num):\n                    rho_pri_arr = [p_list[n]*x_list[n][para_i]*rho_list[n][di][dj] for n in range(p_num)]\n                    rho_pri_tp = np.array(rho_pri_arr).reshape(p_shape)\n                    for si in reversed(range(para_num)):\n                        rho_pri_tp = simpson(rho_pri_tp, x[si])\n\n                    rho_pri[para_i][di][dj] = rho_pri_tp\n        Lambda = Lambda_avg(rho_avg, rho_pri, eps=eps)\n        Mat = np.zeros((para_num, para_num), dtype=np.complex128)\n        for para_m in range(para_num):\n            for para_n in range(para_num):\n                Mat += W[para_m][para_n] * np.dot(Lambda[para_m], Lambda[para_n])\n\n        minBC = delta2_x-np.real(np.trace(rho_avg @ Mat))\n        return minBC\n</code></pre>"},{"location":"API/python/functions/#common-utilities","title":"Common utilities","text":""},{"location":"API/python/functions/#bayes-input","title":"Bayes input","text":"<p>Generate input variables for Bayesian estimation.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>array</code> <p>Parameter regimes</p> required <code>func</code> <code>callable</code> <p>Function returning H or K</p> required <code>dfunc</code> <code>callable</code> <p>Function returning dH or dK</p> required <code>channel</code> <code>str</code> <p>\"dynamics\" or \"Kraus\" (default: \"dynamics\")</p> <code>'dynamics'</code> <p>Returns:</p> Type Description <code>tuple</code> <p>Tuple of (H_list, dH_list) or (K_list, dK_list)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>For invalid channel.</p> Source code in <code>quanestimation/Common/Common.py</code> <pre><code>def BayesInput(x, func, dfunc, channel=\"dynamics\"):\n    \"\"\"\n    Generate input variables for Bayesian estimation.\n\n    Args:\n        x (np.array): \n            Parameter regimes\n        func (callable): \n            Function returning H or K\n        dfunc (callable): \n            Function returning dH or dK\n        channel (str, optional): \n            \"dynamics\" or \"Kraus\" (default: \"dynamics\")\n\n    Returns:\n        (tuple): \n            Tuple of (H_list, dH_list) or (K_list, dK_list)\n\n    Raises:\n        ValueError: \n            For invalid channel.\n    \"\"\"\n    x_all = product(*x)\n    if channel == \"dynamics\":\n        H_list, dH_list = [], []\n        for xi in x_all:\n            H_list.append(func(*xi))\n            dH_list.append(dfunc(*xi))\n        return H_list, dH_list\n    elif channel == \"Kraus\":\n        K_list, dK_list = [], []\n        for xi in x_all:\n            K_list.append(func(*xi))\n            dK_list.append(dfunc(*xi))\n        return K_list, dK_list\n    else:\n        raise ValueError(\n            \"{!r} is not a valid channel. Supported values: \"\n            \"'dynamics' or 'Kraus'.\".format(channel)\n        )\n</code></pre>"},{"location":"API/python/functions/#sic-povm","title":"SIC-POVM","text":"<p>Generate SIC-POVM for given dimension.</p> <p>Parameters:</p> Name Type Description Default <code>dim</code> <code>float</code> <p>Dimension of the system.</p> required <p>Returns:</p> Type Description <code>list</code> <p>List of SIC-POVM elements.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dimension &gt; 151.</p> Source code in <code>quanestimation/Common/Common.py</code> <pre><code>def SIC(dim):\n    \"\"\"\n    Generate SIC-POVM for given dimension.\n\n    Args:\n        dim (float): \n            Dimension of the system.\n\n    Returns:\n        (list): \n            List of SIC-POVM elements.\n\n    Raises:\n        ValueError: \n            If dimension &gt; 151.\n    \"\"\"\n    if dim &lt;= 151:\n        file_path = os.path.join(\n            os.path.dirname(os.path.dirname(__file__)),\n            \"sic_fiducial_vectors/d%d.txt\" % (dim),\n        )\n        data = np.loadtxt(file_path)\n        fiducial = data[:, 0] + data[:, 1] * 1.0j\n        fiducial = np.array(fiducial).reshape(len(fiducial), 1)\n        M = sic_povm(fiducial)\n        return M\n    else:\n        raise ValueError(\n            \"The dimension of the space should be less or equal to 151.\"\n        )\n</code></pre>"},{"location":"API/python/functions/#sun-generators","title":"SU(\\(N\\)) generators","text":"<p>Generate sorted SU(N) generators.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>float</code> <p>Dimension of the system. </p> required <p>Returns:</p> Type Description <code>list</code> <p>List of SU(N) generators.</p> Source code in <code>quanestimation/Common/Common.py</code> <pre><code>def suN_generator(n):\n    \"\"\"\n    Generate sorted SU(N) generators.\n\n    Args:\n        n (float): \n            Dimension of the system. \n\n    Returns:\n        (list): \n            List of SU(N) generators.\n    \"\"\"\n    symm, anti_symm, diag = suN_unsorted(n)\n    if n == 2:\n        return [symm[0], anti_symm[0], diag[0]]\n    else:\n        Lambda = [0.0] * len(symm + anti_symm + diag)\n\n        Lambda[0], Lambda[1], Lambda[2] = symm[0], anti_symm[0], diag[0]\n\n        repeat_times = 2\n        m1, n1, k1 = 0, 3, 1\n        while True:\n            m1 += n1\n            j, l = 0, 0\n            for i in range(repeat_times):\n                Lambda[m1 + j] = symm[k1]\n                Lambda[m1 + j + 1] = anti_symm[k1]\n                j += 2\n                k1 += 1\n\n            repeat_times += 1\n            n1 = n1 + 2\n            if k1 == len(symm):\n                break\n\n        m2, n2, k2 = 2, 5, 1\n        while True:\n            m2 += n2\n            Lambda[m2] = diag[k2]\n            n2 = n2 + 2\n            k2 = k2 + 1\n            if k2 == len(diag):\n                break\n        return Lambda\n</code></pre>"},{"location":"guide/guide_Compopt/","title":"Comprehensive optimization","text":"<p>In order to obtain the optimal parameter estimation schemes, it is necessary to simultaneously optimize the probe state, control, and measurement. The comprehensive  optimization for the probe state and measurement (SM), the probe state and control (SC), the  control and measurement (CM) and the probe state, control and measurement (SCM) are proposed in QuanEstiamtion. In the package, the comprehensive optimization algorithms are particle  swarm optimization (PSO) [1], differential evolution (DE) [2],  and automatic differentiation (AD) [3].</p> PythonJulia <pre><code>com = ComprehensiveOpt(savefile=False, method=\"DE\", **kwargs)\ncom.dynamics(tspan, H0, dH, Hc=[], ctrl=[], decay=[], ctrl_bound=[], \n             dyn_method=\"expm\")\n</code></pre> SMSCCMSCM <pre><code>com.SM(W=[])\n</code></pre> <pre><code>com.SC(W=[], M=[], target=\"QFIM\", LDtype=\"SLD\")\n</code></pre> <pre><code>com.CM(rho0, W=[])\n</code></pre> <pre><code>com.SCM(W=[])  \n</code></pre> <p>Here <code>savefile</code> means whether to save all the optimized variables (probe states, control  coefficients and measurements). If set <code>True</code> then the optimized variables and the values  of the objective function obtained in all episodes will be saved during the training,  otherwise, the optimized variables in the final episode and the values of the objective  function in all episodes will be saved. <code>method</code> represents the optimization algorithm used,  options are: \"PSO\", \"DE\", and \"AD\". <code>**kwargs</code> is the keyword and the default value corresponding to the optimization algorithm which will be introduced in detail below.</p> <p>If the dynamics of the system can be described by the master equation, then the dynamics data  <code>tspan</code>, <code>H0</code>, and <code>dH</code> shoule be input. <code>tspan</code> is the time length for the evolution, <code>H0</code> and <code>dH</code> are the free Hamiltonian and its derivatives on the unknown parameters to be  estimated. <code>H0</code> is a matrix when the free Hamiltonian is time-independent and a list of matrices with the  length equal to <code>tspan</code> when it is time-dependent. <code>dH</code> should be input as \\([\\partial_a{H_0}, \\partial_b{H_0}, \\cdots]\\). <code>Hc</code> and <code>ctrl</code> are two lists represent the control Hamiltonians and the corresponding control coefficients.<code>decay</code> contains decay  operators \\((\\Gamma_1, \\Gamma_2, \\cdots)\\) and the corresponding decay rates \\((\\gamma_1,  \\gamma_2, \\cdots)\\) with the input rule decay=[[\\(\\Gamma_1\\), \\(\\gamma_1\\)], [\\(\\Gamma_2\\),  \\(\\gamma_2\\)],...]. The default values for <code>decay</code>, <code>Hc</code> and <code>ctrl</code> are empty which means the  dynamics is unitary and only governed by the free Hamiltonian. <code>ctrl_bound</code>is an array with two  elements representing the lower and upper bound of the control coefficients, respectively. The  default value of <code>ctrl_bound=[]</code> which means the control coefficients are in the regime  \\([-\\infty,\\infty]\\). <code>dyn_method=\"expm\"</code> represents the method for solving the dynamics is  matrix exponential, it can also be set as <code>dyn_method=\"ode\"</code> which means the dynamics  (differential equation) is directly solved with the ODE solvers.</p> <p>QuanEstimation contains four comprehensive optimizations which are <code>com.SM()</code>, <code>com.SC()</code>, <code>com.CM()</code> and <code>com.SCM()</code>. The <code>target</code> in <code>com.SC()</code> can be set as <code>target=\"QFIM\"</code> (default),  <code>target=\"CFIM</code> and <code>target=\"HCRB</code> for the corresponding objective functions are QFI  (\\(\\mathrm{Tr}(W\\mathcal{F}^{-1})\\)), CFI (\\(\\mathrm{Tr}(W\\mathcal{I}^{-1})\\)), and HCRB,  respectively. Here \\(\\mathcal{F}\\) and \\(\\mathcal{I}\\) are the QFIM and CFIM, \\(W\\) corresponds to  <code>W</code> is the weight matrix which defaults to the identity matrix. If the users set <code>target=\"HCRB</code>  for single parameter scenario, the program will exit and print <code>\"Program terminated. In the  single-parameter scenario, the HCRB is equivalent to the QFI. Please choose 'QFIM' as the  objective function\"</code>. <code>LDtype</code> represents the types of the QFIM, it can be set as  <code>LDtype=\"SLD\"</code> (default), <code>LDtype=\"RLD\"</code>, and <code>LDtype=\"LLD\"</code>. For the other three scenarios,  the objective function is CFI (\\(\\mathrm{Tr}(W\\mathcal{I}^{-1})\\)).</p> SMSCCMSCM <pre><code>opt = SMopt(psi=psi, M=M, seed=1234)\nalg = DE(kwargs...)\ndynamics = Lindblad(opt, tspan, H0, dH; Hc=missing, ctrl=missing, \n                    decay=missing, dyn_method=:Expm)  \nobj = CFIM_obj(W=missing)\nrun(opt, alg, obj, dynamics; savefile=false)\n</code></pre> <pre><code>opt = SCopt(psi=psi, ctrl=ctrl, ctrl_bound=ctrl_bound, seed=1234)\nalg = DE(kwargs...)\ndynamics = Lindblad(opt, tspan, H0, dH, Hc; decay=missing, \n                    dyn_method=:Expm)\n</code></pre> QFIMCFIMHCRB <pre><code>obj = QFIM_obj(W=missing, LDtype=:SLD)\n</code></pre> <pre><code>obj = CFIM_obj(W=missing)\n</code></pre> <pre><code>obj = HCRB_obj(W=missing)\n</code></pre> <pre><code>run(opt, alg, obj, dynamics; savefile=false)\n</code></pre> <pre><code>opt = CMopt(ctrl=ctrl, M=M, ctrl_bound=ctrl_bound, seed=1234)\nalg = DE(kwargs...)\ndynamics = Lindblad(opt, tspan, H0, dH, Hc; decay=missing,\n                    dyn_method=:Expm)\nobj = CFIM_obj(W=missing)\nrun(opt, alg, obj, dynamics; savefile=false)\n</code></pre> <pre><code>opt = SCMopt(psi=psi, ctrl=ctrl, M=M, ctrl_bound=ctrl_bound, seed=1234)\nalg = DE(kwargs...)\ndynamics = Lindblad(opt, tspan, H0, dH, Hc; decay=missing, \n                    dyn_method=:Expm)\nobj = CFIM_obj(W=missing)\nrun(opt, alg, obj, dynamics; savefile=false)\n</code></pre> <p>QuanEstimation contains four comprehensive optimizations which are <code>SMopt()</code>, <code>SCopt()</code>, <code>CMopt()</code>, and <code>SCMopt()</code>. The optimization variables including initial state, control, and measurement can be input via <code>ctrl=ctrl</code>, <code>psi=psi</code>, and <code>M=M</code>  for constructing a  comprehensive optimization problem. Here, <code>ctrl</code> is a list of arrays with the length  equal to control Hamiltonians, <code>psi</code> is an array representing the state and <code>M</code> is a list of arrays with the length equal to the dimension of the system which representing  the projective measurement basis. Besides, the boundary value of each control  coefficients can be input via <code>ctrl_bound=ctrl_bound</code> when the optimized variable  contains control. <code>ctrl_bound</code> is an array with two elements representing the lower and  upper bound of the control coefficients, respectively. The default value of <code>ctrl_bound= missing</code> which means the control coefficients are in the regime \\([-\\infty,\\infty]\\). <code>seed</code> is the random seed which can ensure the reproducibility of results.</p> <p>The objective function of <code>SCopt()</code> can be chosen as <code>QFIM_obj()</code> (default), <code>CFIM_obj()</code>,  and <code>HCRB_obj()</code> for the corresponding objective functions are QFI (\\(\\mathrm{Tr}(W\\mathcal{F}^ {-1})\\)), CFI (\\(\\mathrm{Tr}(W\\mathcal{I}^{-1})\\)), and HCRB, respectively. Here \\(\\mathcal{F}\\)  and \\(\\mathcal{I}\\) are the QFIM and CFIM, \\(W\\) corresponds to <code>W</code> is the weight matrix which  defaults to the identity matrix. If the users set <code>HCRB_obj()</code> for single parameter scenario,  the program will exit and print <code>\"Program terminated. In the single-parameter scenario, the  HCRB is equivalent to the QFI. Please choose 'QFIM_obj()' as the objective function\"</code>. <code>LDtype</code>  represents the types of the QFIM, it can be set as <code>LDtype=:SLD</code> (default), <code>LDtype=:RLD</code>,  and <code>LDtype=:LLD</code>. For the other three scenarios, the objective function is <code>CFIM_obj()</code>.</p> <p>If the dynamics of the system can be described by the master equation, then the dynamics data  <code>tspan</code>, <code>H0</code>, and <code>dH</code> shoule be input. <code>tspan</code> is the time length for the evolution, <code>H0</code> and <code>dH</code> are the free Hamiltonian and its derivatives on the unknown parameters to be  estimated. <code>H0</code> is a matrix when the free Hamiltonian is time-independent and a list of matrices with the  length equal to <code>tspan</code> when it is time-dependent. <code>dH</code> should be input as \\([\\partial_a{H_0}, \\partial_b{H_0}, \\cdots]\\). <code>Hc</code> and <code>ctrl</code> are two lists represent the control Hamiltonians and the corresponding control coefficients.<code>decay</code> contains decay  operators \\((\\Gamma_1, \\Gamma_2, \\cdots)\\) and the corresponding decay rates \\((\\gamma_1,  \\gamma_2, \\cdots)\\) with the input rule decay=[[\\(\\Gamma_1\\), \\(\\gamma_1\\)], [\\(\\Gamma_2\\),  \\(\\gamma_2\\)],...]. <code>dyn_method=:Expm</code> represents the method for solving the dynamics is  matrix exponential, it can also be set as <code>dyn_method=:Ode</code> which means the dynamics  (differential equation) is directly solved with the ODE solvers.</p> <p>The variable <code>savefile</code> means whether to save all the optimized variables (probe states,  control coefficients, and measurements). If set <code>true</code> then the optimized variables and the  values of the objective function obtained in all episodes will be saved during the training,  otherwise, the optimized variables in the final episode and the values of the objective  function in all episodes will be saved. The algorithm used in QuanEstimation for  comprehensive optimizaiton are PSO, DE, and AD. <code>kwargs...</code> is the keywords and the default  values corresponding to the optimization algorithm which will be introduced in detail below.</p>"},{"location":"guide/guide_Compopt/#pso","title":"PSO","text":"<p>The code for comprehensive optimization with PSO is as follows</p> PythonJulia <p><pre><code>com = ComprehensiveOpt(method=\"PSO\", **kwargs)\n</code></pre> where <code>kwargs</code> is of the form <pre><code>kwargs = {\"p_num\":10, \"psi0\":[], \"ctrl0\":[], \"measurement0\":[], \n          \"max_episode\":[1000,100], \"c0\":1.0, \"c1\":2.0, \"c2\":2.0, \n          \"seed\":1234}\n</code></pre> The keywords and the default values of PSO can be seen in the following  table</p> \\(~~~~~~~~~~\\)**kwargs\\(~~~~~~~~~~\\) \\(~~~~\\)default values\\(~~~~\\) \"p_num\" 10 \"psi0\" [ ] \"ctrl0\" [ ] \"measurement0\" [ ] \"max_episode\" [1000,100] \"c0\" 1.0 \"c1\" 2.0 \"c2\" 2.0 \"seed\" 1234 <p><code>psi0</code>, <code>ctrl0</code>, and <code>measurement0</code> in the algorithms represent the initial  guesses of states, control coefficients and measurements, respectively, <code>seed</code>  is the random seed. Here <code>p_num</code> is the number of particles, <code>c0</code>,  <code>c1</code>, and <code>c2</code> are the PSO parameters representing the inertia weight, cognitive  learning factor, and social learning factor, respectively. <code>max_episode</code> accepts  both integers and arrays with two elements. If it is an integer, for example  max_episode=1000, it means the program will continuously run 1000 episodes.  However, if it is an array, for example max_episode=[1000,100], the program will  run 1000 episodes in total but replace control coefficients of all the particles  with global best every 100 episodes. </p> <p><pre><code>alg = PSO(p_num=10, ini_particle=missing, max_episode=[1000,100], \n          c0=1.0, c1=2.0, c2=2.0)\n</code></pre> The keywords and the default values of PSO can be seen in the following  table</p> \\(~~~~~~~~~~\\)keywords\\(~~~~~~~~~~\\) \\(~~~~\\)default values\\(~~~~\\) \"p_num\" 10 \"ini_particle\" missing \"max_episode\" [1000,100] \"c0\" 1.0 \"c1\" 2.0 \"c2\" 2.0 <p><code>ini_particle</code>is a tuple contains <code>psi0</code>, <code>ctrl0</code>, and <code>measurement0</code>, which  representing the initial guesses of states, control coefficients, and measurements, respectively. The input rule of <code>ini_particle</code> shoule be <code>ini_particle=(psi0,  measurement0)</code>(SM), <code>ini_particle=(psi0, ctrl0)</code>(SC), <code>ini_particle=(ctrl0,  measurement0)</code>(CM) and  <code>ini_particle=(psi0, ctrl0, measurement0)</code>(SCM). Here <code>p_num</code> is the number of particles, <code>c0</code>, <code>c1</code>, and <code>c2</code> are the PSO parameters  representing the inertia weight, cognitive learning factor, and social learning  factor, respectively. <code>max_episode</code> accepts both integers and arrays with two  elements. If it is an integer, for example max_episode=1000, it means the program  will continuously run 1000 episodes. However, if it is an array, for example  max_episode=[1000,100], the program will run 1000 episodes in total but replace  control coefficients of all the particles with global best every 100 episodes. </p>"},{"location":"guide/guide_Compopt/#de","title":"DE","text":"<p>The code for comprehensive optimization with DE is as follows</p> PythonJulia <p><pre><code>com = ComprehensiveOpt(method=\"DE\", **kwargs)\n</code></pre> where <code>kwargs</code> is of the form <pre><code>kwargs = {\"p_num\":10, \"psi0\":[], \"ctrl0\":[], \"measurement0\":[], \n          \"max_episode\":1000, \"c\":1.0, \"cr\":0.5, \"seed\":1234}\n</code></pre> The keywords and the default values of DE can be seen in the following  table</p> \\(~~~~~~~~~~\\)**kwargs\\(~~~~~~~~~~\\) \\(~~~~\\)default values\\(~~~~\\) \"p_num\" 10 \"psi0\" [ ] \"ctrl0\" [ ] \"measurement0\" [ ] \"max_episode\" 1000 \"c\" 1.0 \"cr\" 0.5 \"seed\" 1234 <p><code>p_num</code> is the number of populations. Here <code>max_episode</code> is  an integer representing the number of episodes. <code>c</code> and <code>cr</code> are constants for  mutation and crossover.  </p> <p><pre><code>alg = DE(p_num=10, ini_population=missing, max_episode=1000, \n         c=1.0, cr=0.5)\n</code></pre> The keywords and the default values of DE can be seen in the following  table</p> \\(~~~~~~~~~~\\)keywords\\(~~~~~~~~~~\\) \\(~~~~\\)default values\\(~~~~\\) \"p_num\" 10 \"ini_population\" missing \"max_episode\" 1000 \"c\" 1.0 \"cr\" 0.5 <p>Here <code>max_episode</code> is an integer representing the number of episodes. <code>p_num</code>  represents the number of populations. <code>c</code> and <code>cr</code> are constants for mutation  and crossover. <code>ini_particle</code>is a tuple contains <code>psi0</code>, <code>ctrl0</code>, and <code>measurement0</code>, which representing the initial guesses of states, control coefficients, and  measurements, respectively. The input rule of <code>ini_particle</code> shoule be  <code>ini_particle=(psi0, measurement0)</code>(SM), <code>ini_particle=(psi0, ctrl0)</code>(SC),  <code>ini_particle=(ctrl0, measurement0)</code>(CM), and <code>ini_particle=(psi0, ctrl0, measurement0)</code>(SCM).</p>"},{"location":"guide/guide_Compopt/#ad","title":"AD","text":"<p>The code for comprehensive optimization with AD is as follows</p> PythonJulia <p><pre><code>com = ComprehensiveOpt(method=\"AD\", **kwargs)\n</code></pre> where <code>kwargs</code> is of the form <pre><code>kwargs = {\"Adam\":True, \"psi0\":[], \"ctrl0\":[], \"measurement0\":[],\n          \"max_episode\":300, \"epsilon\":0.01, \"beta1\":0.90, \"beta2\":0.99}\n</code></pre> The keywords and the default values of AD can be seen in the  following table</p> \\(~~~~~~~~~~\\)**kwargs\\(~~~~~~~~~~\\) \\(~~~~\\)default values\\(~~~~\\) \"Adam\" False \"psi0\" [ ] \"ctrl0\" [ ] \"measurement0\" [ ] \"max_episode\" 300 \"epsilon\" 0.01 \"beta1\" 0.90 \"beta2\" 0.99 <p>The optimized variables will update according to the learning rate <code>\"epsilon\"</code>  when <code>Adam=False</code>. However, If <code>Adam=True</code>, Adam algorithm will be used and the  Adam parameters include learning rate, the exponential decay rate for the first  moment estimates and the second moment estimates can be set by the user via  <code>epsilon</code>, <code>beta1</code> and <code>beta2</code>.</p> <p><pre><code>alg = AD(Adam=false, max_episode=300, epsilon=0.01, beta1=0.90, \n        beta2=0.99)\n</code></pre> The keywords and the default values of AD can be seen in the  following table</p> \\(~~~~~~~~~~\\)keywords\\(~~~~~~~~~~\\) \\(~~~~\\)default values\\(~~~~\\) \"Adam\" false \"max_episode\" 300 \"epsilon\" 0.01 \"beta1\" 0.90 \"beta2\" 0.99 <p>The optimized variables will update according to the learning rate <code>\"epsilon\"</code>  when <code>Adam=false</code>. However, If <code>Adam=true</code>, Adam algorithm will be used and the  Adam parameters include learning rate, the exponential decay rate for the first  moment estimates, and the second moment estimates can be set by the user via  <code>epsilon</code>, <code>beta1</code>, and <code>beta2</code>.</p> <p>Example 8.1  A single qubit system whose free evolution Hamiltonian is \\(H_0 = \\frac{1}{2}\\omega \\sigma_3\\) with  \\(\\omega\\) the frequency and \\(\\sigma_3\\) a Pauli matrix. The dynamics of the system is governed by</p> \\[\\begin{align} \\partial_t\\rho=-i[H_0, \\rho]+ \\gamma_{+}\\left(\\sigma_{+}\\rho\\sigma_{-}-\\frac{1}{2}\\{\\sigma_{-}\\sigma_{+},\\rho\\}\\right)+ \\gamma_{-}\\left(\\sigma_{-}\\rho\\sigma_{+}-\\frac{1}{2}\\{\\sigma_{+}\\sigma_{-},\\rho\\}\\right), \\end{align}\\] <p>where \\(\\gamma_{+}\\), \\(\\gamma_{-}\\) are decay rates and \\(\\sigma_{\\pm}=(\\sigma_1 \\pm \\sigma_2)/2\\). The control Hamiltonian \\begin{align} H_\\mathrm{c}=u_1(t)\\sigma_1+u_2(t)\\sigma_2+u_3(t)\\sigma_3 \\end{align}</p> <p>with \\(u_i(t)\\) \\((i=1,2,3)\\) the control field. Here \\(\\sigma_{1}\\), \\(\\sigma_{2}\\) are also Pauli matrices.</p> <p>In this case, we consider two types of comprehensive optimization, the first one is optimization of probe state and control (SC), and the other is optimization of probe state, control and measurement (SCM). QFI is taken as the target function for SC and CFI for SCM.</p> PythonJulia <pre><code>from quanestimation import *\nimport numpy as np\n\n# initial state\nrho0 = 0.5*np.array([[1., 1.], [1., 1.]])\n# free Hamiltonian\nomega = 1.0\nsx = np.array([[0., 1.], [1., 0.]])\nsy = np.array([[0., -1.j], [1.j, 0.]]) \nsz = np.array([[1., 0.], [0., -1.]])\nH0 = 0.5*omega*sz\n# derivative of the free Hamiltonian on omega\ndH = [0.5*sz]\n# control Hamiltonians \nHc = [sx,sy,sz]\n# dissipation\nsp = np.array([[0., 1.], [0., 0.]])  \nsm = np.array([[0., 0.], [1., 0.]]) \ndecay = [[sp, 0.], [sm, 0.1]]\n# measurement\nM1 = 0.5*np.array([[1., 1.], [1., 1.]])\nM2 = 0.5*np.array([[1., -1.], [-1., 1.]])\nM = [M1, M2]\nM_num = 2\n# time length for the evolution\ntspan = np.linspace(0., 10., 2500)\n</code></pre> SMSCCMSCM DEPSO <pre><code># comprehensive optimization algorithm: DE\nDE_paras = {\"p_num\":10, \"psi0\":[], \"ctrl0\":[], \"measurement0\":[], \\\n            \"max_episode\":1000, \"c\":1.0, \"cr\":0.5, \"seed\":1234}\ncom = ComprehensiveOpt(savefile=False, method=\"DE\", **DE_paras)\ncom.dynamics(tspan, H0, dH, decay=decay, dyn_method=\"expm\")\ncom.SM()\n# convert the \".csv\" file to the \".npy\" file\nM_ = np.loadtxt(\"measurements.csv\", dtype=np.complex128)\ncsv2npy_measurements(M_, M_num)\n# load the measurements\nM = np.load(\"measurements.npy\")[-1]\n</code></pre> <pre><code># comprehensive optimization algorithm: PSO\nPSO_paras = {\"p_num\":10, \"psi0\":[], \"ctrl0\":[], \\\n             \"measurement0\":[], \"max_episode\":[1000,100], \"c0\":1.0, \\\n             \"c1\":2.0, \"c2\":2.0, \"seed\":1234}\ncom = ComprehensiveOpt(savefile=False, method=\"PSO\", **PSO_paras)\ncom.dynamics(tspan, H0, dH, decay=decay, dyn_method=\"expm\")\ncom.SM()\n# convert the \".csv\" file to the \".npy\" file\nM_ = np.loadtxt(\"measurements.csv\", dtype=np.complex128)\ncsv2npy_measurements(M_, M_num)\n# load the measurements\nM = np.load(\"measurements.npy\")[-1]\n</code></pre> DEPSOAD <pre><code># comprehensive optimization algorithm: DE\nDE_paras = {\"p_num\":10, \"psi0\":[], \"ctrl0\":[], \"measurement0\":[], \\\n            \"max_episode\":1000, \"c\":1.0, \"cr\":0.5, \"seed\":1234}\ncom = ComprehensiveOpt(savefile=False, method=\"DE\", **DE_paras)\ncom.dynamics(tspan, H0, dH, Hc=Hc, decay=decay, ctrl_bound=[-2.0,2.0], \\\n             dyn_method=\"expm\")\n</code></pre> QFIMCFIM <pre><code>com.SC(W=[], target=\"QFIM\", LDtype=\"SLD\")\n</code></pre> <pre><code>com.SC(W=[], M=M, target=\"CFIM\")\n</code></pre> <pre><code># comprehensive optimization algorithm: PSO\nPSO_paras = {\"p_num\":10, \"psi0\":[], \"ctrl0\":[], \\\n             \"measurement0\":[], \"max_episode\":[1000,100], \"c0\":1.0, \\\n             \"c1\":2.0, \"c2\":2.0, \"seed\":1234}\ncom = ComprehensiveOpt(savefile=False, method=\"PSO\", **PSO_paras)\ncom.dynamics(tspan, H0, dH, Hc=Hc, decay=decay, ctrl_bound=[-2.0,2.0], \\\n             dyn_method=\"expm\")\n</code></pre> QFIMCFIM <pre><code>com.SC(W=[], target=\"QFIM\", LDtype=\"SLD\")\n</code></pre> <pre><code>com.SC(W=[], M=M, target=\"CFIM\")\n</code></pre> <pre><code># comprehensive optimization algorithm: AD\nAD_paras = {\"Adam\":False, \"psi0\":[], \"ctrl0\":[], \"measurement0\":[], \\\n            \"max_episode\":300, \"epsilon\":0.01, \"beta1\":0.90, \"beta2\":0.99}\ncom = ComprehensiveOpt(savefile=False, method=\"AD\", **AD_paras)\ncom.dynamics(tspan, H0, dH, Hc=Hc, decay=decay, ctrl_bound=[-2.0,2.0], \\\n             dyn_method=\"expm\")\n</code></pre> QFIMCFIM <pre><code>com.SC(W=[], target=\"QFIM\", LDtype=\"SLD\")\n</code></pre> <pre><code>com.SC(W=[], M=M, target=\"CFIM\")\n</code></pre> DEPSO <pre><code># comprehensive optimization algorithm: DE\nDE_paras = {\"p_num\":10, \"psi0\":[], \"ctrl0\":[], \"measurement0\":[], \\\n            \"max_episode\":1000, \"c\":1.0, \"cr\":0.5, \"seed\":1234}\ncom = ComprehensiveOpt(savefile=False, method=\"DE\", **DE_paras)\ncom.dynamics(tspan, H0, dH, Hc=Hc, decay=decay, ctrl_bound=[-2.0,2.0], \\\n             dyn_method=\"expm\")\ncom.CM(rho0)\n# convert the \".csv\" file to the \".npy\" file\nM_ = np.loadtxt(\"measurements.csv\", dtype=np.complex128)\ncsv2npy_measurements(M_, M_num)\n# load the measurements\nM = np.load(\"measurements.npy\")[-1]\n</code></pre> <pre><code># comprehensive optimization algorithm: PSO\nPSO_paras = {\"p_num\":10, \"psi0\":[], \"ctrl0\":[], \\\n             \"measurement0\":[], \"max_episode\":[1000,100], \"c0\":1.0, \\\n             \"c1\":2.0, \"c2\":2.0, \"seed\":1234}\ncom = ComprehensiveOpt(savefile=False, method=\"PSO\", **PSO_paras)\ncom.dynamics(tspan, H0, dH, Hc=Hc, decay=decay, ctrl_bound=[-2.0,2.0], \\\n             dyn_method=\"expm\")\ncom.CM(rho0)\n# convert the \".csv\" file to the \".npy\" file\nM_ = np.loadtxt(\"measurements.csv\", dtype=np.complex128)\ncsv2npy_measurements(M_, M_num)\n# load the measurements\nM = np.load(\"measurements.npy\")[-1]\n</code></pre> DEPSO <pre><code># comprehensive optimization algorithm: DE\nDE_paras = {\"p_num\":10, \"psi0\":[], \"ctrl0\":[], \"measurement0\":[], \\\n            \"max_episode\":1000, \"c\":1.0, \"cr\":0.5, \"seed\":1234}\ncom = ComprehensiveOpt(savefile=False, method=\"DE\", **DE_paras)\ncom.dynamics(tspan, H0, dH, Hc=Hc, decay=decay, ctrl_bound=[-2.0,2.0], \\\n             dyn_method=\"expm\")\ncom.SCM()\n# convert the \".csv\" file to the \".npy\" file\nM_ = np.loadtxt(\"measurements.csv\", dtype=np.complex128)\ncsv2npy_measurements(M_, M_num)\n# load the measurements\nM = np.load(\"measurements.npy\")[-1]\n</code></pre> <pre><code># comprehensive optimization algorithm: PSO\nPSO_paras = {\"p_num\":10, \"psi0\":[], \"ctrl0\":[], \\\n             \"measurement0\":[], \"max_episode\":[1000,100], \"c0\":1.0, \\\n             \"c1\":2.0, \"c2\":2.0, \"seed\":1234}\ncom = ComprehensiveOpt(savefile=False, method=\"PSO\", **PSO_paras)\ncom.dynamics(tspan, H0, dH, Hc=Hc, decay=decay, ctrl_bound=[-2.0,2.0], \\\n             dyn_method=\"expm\")\ncom.SCM()\n# convert the \".csv\" file to the \".npy\" file\nM_ = np.loadtxt(\"measurements.csv\", dtype=np.complex128)\ncsv2npy_measurements(M_, M_num)\n# load the measurements\nM = np.load(\"measurements.npy\")[-1]\n</code></pre> <pre><code>using QuanEstimation\nusing DelimitedFiles\n\n# initial state\nrho0 = 0.5*ones(2, 2)\n# free Hamiltonian\nomega = 1.0\nsx = [0. 1.; 1. 0.0im]\nsy = [0. -im; im 0.]\nsz = [1. 0.0im; 0. -1.]\nH0 = 0.5*omega*sz\n# derivative of the free Hamiltonian on omega\ndH = [0.5*sz]\n# control Hamiltonians \nHc = [sx, sy, sz]\n# dissipation\nsp = [0. 1.; 0. 0.0im]\nsm = [0. 0.; 1. 0.0im]\ndecay = [[sp, 0.0], [sm, 0.1]]\n# measurement\nM1 = 0.5*[1.0+0.0im  1.; 1.  1.]\nM2 = 0.5*[1.0+0.0im -1.; -1.  1.]\nM = [M1, M2]\nM_num = 2\n# time length for the evolution\ntspan = range(0., 10., length=2500)\n</code></pre> SMSCCMSCM <pre><code>opt = QuanEstimation.SMopt(seed=1234)\n</code></pre> DEPSO <pre><code># comprehensive optimization algorithm: DE\nalg = QuanEstimation.DE(p_num=10, max_episode=1000, c=1.0, cr=0.5) \n# objective function: CFI\nobj = QuanEstimation.CFIM_obj(M=M)\n# input the dynamics data\ndynamics = QuanEstimation.Lindblad(opt, tspan, H0, dH, decay=decay, \n                                   dyn_method=:Expm)\n# run the comprehensive optimization problem\nQuanEstimation.run(opt, alg, obj, dynamics; savefile=false)\n# convert the flattened data into a list of matrix\nM_ = readdlm(\"measurements.csv\",'\\t', Complex{Float64})\nM = [[reshape(M_[i,:], dim, dim) for i in 1:M_num] \n    for j in 1:Int(length(M_[:,1])/M_num)][end]\n</code></pre> <pre><code># comprehensive optimization algorithm: PSO\nalg = QuanEstimation.PSO(p_num=10, max_episode=[1000,100], c0=1.0, \n                         c1=2.0, c2=2.0)\n# objective function: CFI\nobj = QuanEstimation.CFIM_obj(M=M) \n# input the dynamics data\ndynamics = QuanEstimation.Lindblad(opt, tspan, H0, dH, decay=decay, \n                                   dyn_method=:Expm)   \n# run the comprehensive optimization problem\nQuanEstimation.run(opt, alg, obj, dynamics; savefile=false)\n# convert the flattened data into a list of matrix\nM_ = readdlm(\"measurements.csv\",'\\t', Complex{Float64})\nM = [[reshape(M_[i,:], dim, dim) for i in 1:M_num] \n    for j in 1:Int(length(M_[:,1])/M_num)][end]\n</code></pre> <pre><code>opt = QuanEstimation.SCopt(ctrl_bound=[-2.0,2.0], seed=1234)\n</code></pre> DEPSOAD <pre><code># comprehensive optimization algorithm: DE\nalg = QuanEstimation.DE(p_num=10, max_episode=1000, c=1.0, cr=0.5)\n</code></pre> QFIMCFIM <pre><code># objective function: QFI\nobj = QuanEstimation.QFIM_obj()\n# input the dynamics data\ndynamics = QuanEstimation.Lindblad(opt, tspan, H0, dH, Hc, decay=decay, \n                                   dyn_method=:Expm) \n# run the comprehensive optimization problem\nQuanEstimation.run(opt, alg, obj, dynamics; savefile=false)\n</code></pre> <pre><code># objective function: CFI\nobj = QuanEstimation.CFIM_obj(M=M) \n# input the dynamics data\ndynamics = QuanEstimation.Lindblad(opt, tspan, H0, dH, Hc, decay=decay, \n                                   dyn_method=:Expm) \n# run the comprehensive optimization problem\nQuanEstimation.run(opt, alg, obj, dynamics; savefile=false)\n</code></pre> <pre><code># comprehensive optimization algorithm: PSO\nalg = QuanEstimation.PSO(p_num=10, max_episode=[1000,100], c0=1.0, \n                         c1=2.0, c2=2.0)\n</code></pre> QFIMCFIM <pre><code># objective function: QFI\nobj = QuanEstimation.QFIM_obj() \n# input the dynamics data\ndynamics = QuanEstimation.Lindblad(opt, tspan, H0, dH, Hc, decay=decay, \n                                   dyn_method=:Expm) \n# run the comprehensive optimization problem\nQuanEstimation.run(opt, alg, obj, dynamics; savefile=false)\n</code></pre> <pre><code># objective function: CFI\nobj = QuanEstimation.CFIM_obj(M=M) \n# input the dynamics data\ndynamics = QuanEstimation.Lindblad(opt, tspan, H0, dH, Hc, decay=decay, \n                                   dyn_method=:Expm) \n# run the comprehensive optimization problem\nQuanEstimation.run(opt, alg, obj, dynamics; savefile=false)\n</code></pre> <pre><code># comprehensive optimization algorithm: AD\nalg = QuanEstimation.AD(Adam=true, max_episode=300, epsilon=0.01, \n                        beta1=0.90, beta2=0.99)\n</code></pre> QFIMCFIM <pre><code># objective function: QFI\nobj = QuanEstimation.QFIM_obj() \n# input the dynamics data\ndynamics = QuanEstimation.Lindblad(opt, tspan, H0, dH, Hc, decay=decay, \n                                   dyn_method=:Expm) \n# run the comprehensive optimization problem\nQuanEstimation.run(opt, alg, obj, dynamics; savefile=false)\n</code></pre> <pre><code># objective function: CFI\nobj = QuanEstimation.CFIM_obj(M=M) \n# input the dynamics data\ndynamics = QuanEstimation.Lindblad(opt, tspan, H0, dH, Hc, decay=decay, \n                                   dyn_method=:Expm) \n# run the comprehensive optimization problem\nQuanEstimation.run(opt, alg, obj, dynamics; savefile=false)\n</code></pre> <pre><code>opt = QuanEstimation.CMopt(ctrl_bound=[-2.0,2.0], seed=1234)\n</code></pre> DEPSO <pre><code># comprehensive optimization algorithm: DE\nalg = QuanEstimation.DE(p_num=10, max_episode=1000, c=1.0, cr=0.5)  \n# objective function: CFI\nobj = QuanEstimation.CFIM_obj(M=M) \n# input the dynamics data\ndynamics = QuanEstimation.Lindblad(opt, tspan, rho0, H0, dH, Hc,   \n                                   decay=decay, dyn_method=:Expm) \n# run the comprehensive optimization problem\nQuanEstimation.run(opt, alg, obj, dynamics; savefile=false)\n# convert the flattened data into a list of matrix\nM_ = readdlm(\"measurements.csv\",'\\t', Complex{Float64})\nM = [[reshape(M_[i,:], dim, dim) for i in 1:M_num] \n    for j in 1:Int(length(M_[:,1])/M_num)][end]\n</code></pre> <pre><code># comprehensive optimization algorithm: PSO\nalg = QuanEstimation.PSO(p_num=10, max_episode=[1000,100], c0=1.0, \n                         c1=2.0, c2=2.0)\n# objective function: CFI\nobj = QuanEstimation.CFIM_obj(M=M) \n# input the dynamics data\ndynamics = QuanEstimation.Lindblad(opt, tspan, rho0, H0, dH, Hc,  \n                                   decay=decay, dyn_method=:Expm)  \n# run the comprehensive optimization problem\nQuanEstimation.run(opt, alg, obj, dynamics; savefile=false)\n# convert the flattened data into a list of matrix\nM_ = readdlm(\"measurements.csv\",'\\t', Complex{Float64})\nM = [[reshape(M_[i,:], dim, dim) for i in 1:M_num] \n    for j in 1:Int(length(M_[:,1])/M_num)][end]\n</code></pre> <pre><code>opt = QuanEstimation.SCMopt(ctrl_bound=[-2.0,2.0], seed=1234)\n</code></pre> DEPSO <pre><code># comprehensive optimization algorithm: DE\nalg = QuanEstimation.DE(p_num=10, max_episode=1000, c=1.0, cr=0.5) \n# objective function: CFI\nobj = QuanEstimation.CFIM_obj(M=M) \n# input the dynamics data\ndynamics = QuanEstimation.Lindblad(opt, tspan, H0, dH, Hc, decay=decay, \n                                   dyn_method=:Expm)  \n# run the comprehensive optimization problem\nQuanEstimation.run(opt, alg, obj, dynamics; savefile=false)\n# convert the flattened data into a list of matrix\nM_ = readdlm(\"measurements.csv\",'\\t', Complex{Float64})\nM = [[reshape(M_[i,:], dim, dim) for i in 1:M_num] \n    for j in 1:Int(length(M_[:,1])/M_num)][end]\n</code></pre> <pre><code># comprehensive optimization algorithm: PSO\nalg = QuanEstimation.PSO(p_num=10, max_episode=[1000,100], c0=1.0, \n                         c1=2.0, c2=2.0) \n# objective function: CFI\nobj = QuanEstimation.CFIM_obj(M=M)\n# input the dynamics data\ndynamics = QuanEstimation.Lindblad(opt, tspan, H0, dH, Hc, decay=decay, \n                                   dyn_method=:Expm)  \n# run the comprehensive optimization problem\nQuanEstimation.run(opt, alg, obj, dynamics; savefile=false)\n# convert the flattened data into a list of matrix\nM_ = readdlm(\"measurements.csv\",'\\t', Complex{Float64})\nM = [[reshape(M_[i,:], dim, dim) for i in 1:M_num] \n    for j in 1:Int(length(M_[:,1])/M_num)][end]\n</code></pre> <p>Example 8.2  The Hamiltonian of a controlled system can be written as \\begin{align} H = H_0(\\textbf{x})+\\sum_{k=1}^K u_k(t) H_k, \\end{align}</p> <p>where \\(H_0(\\textbf{x})\\) is the free evolution Hamiltonian with unknown parameters \\(\\textbf{x}\\) and \\(H_k\\)  represents the \\(k\\)th control Hamiltonian with \\(u_k\\) the correspong control coefficient.</p> <p>In the multiparameter scenario, the dynamics of electron and nuclear coupling in NV\\(^{-}\\) can be expressed as \\begin{align} \\partial_t\\rho=-i[H_0+H_{\\mathrm{c}},\\rho]+\\frac{\\gamma}{2}(S_3\\rho S_3-S^2_3\\rho-\\rho S^2_3) \\end{align}</p> <p>with \\(\\gamma\\) the dephasing rate. And \\begin{align} H_0/\\hbar=DS^2_3+g_{\\mathrm{S}}\\vec{B}\\cdot\\vec{S}+g_{\\mathrm{I}}\\vec{B}\\cdot\\vec{I}+\\vec{S}^{\\,\\mathrm{T}}\\mathcal{A}\\vec{I} \\end{align}</p> <p>is the free evolution Hamiltonian, where \\(\\vec{S}=(S_1,S_2,S_3)^{\\mathrm{T}}\\) and \\(\\vec{I}=(I_1,I_2,I_3)^{\\mathrm{T}}\\) with  \\(S_i=s_i\\otimes I\\) and \\(I_i=I\\otimes \\sigma_i\\) (\\(i=1,2,3\\)) the electron and nuclear operators. \\(\\mathcal{A}=\\mathrm{diag} (A_1,A_1,A_2)\\) is the hyperfine tensor with \\(A_1\\) and \\(A_2\\) the axial and transverse magnetic hyperfine coupling coefficients. The coefficients \\(g_{\\mathrm{S}}=g_\\mathrm{e}\\mu_\\mathrm{B}/\\hbar\\) and \\(g_{\\mathrm{I}}=g_\\mathrm{n}\\mu_\\mathrm{n}/\\hbar\\),  where \\(g_\\mathrm{e}\\) (\\(g_\\mathrm{n}\\)) is the \\(g\\) factor of the electron (nuclear), \\(\\mu_\\mathrm{B}\\) (\\(\\mu_\\mathrm{n}\\)) is the Bohr (nuclear) magneton, and \\(\\hbar\\) is the Plank's constant. \\(\\vec{B}\\) is the magnetic field which be estimated. The control Hamiltonian is \\begin{align} H_{\\mathrm{c}}/\\hbar=\\sum^3_{i=1}\\Omega_i(t)S_i \\end{align}</p> <p>with \\(\\Omega_i(t)\\) the time-dependent Rabi frequency.</p> <p>In this case, the initial state is taken as \\(\\frac{1}{\\sqrt{2}}(|1\\rangle+|\\!-\\!1\\rangle)\\otimes|\\!\\!\\uparrow\\rangle\\),  where \\(\\frac{1}{\\sqrt{2}}(|1\\rangle+|\\!-\\!1\\rangle)\\) is an electron state with \\(|1\\rangle\\) \\((|\\!-\\!1\\rangle)\\) the  eigenstate of \\(s_3\\) with respect to the eigenvalue \\(1\\) (\\(-1\\)). \\(|\\!\\!\\uparrow\\rangle\\) is a nuclear state and  the eigenstate of \\(\\sigma_3\\) with respect to the eigenvalue 1. \\(W\\) is set to be identity.</p> PythonJulia <pre><code>from quanestimation import *\nimport numpy as np\n\n# initial state\nrho0 = np.zeros((6, 6), dtype=np.complex128)\nrho0[0][0], rho0[0][4], rho0[4][0], rho0[4][4] = 0.5, 0.5, 0.5, 0.5\n# free Hamiltonian\nsx = np.array([[0., 1.],[1., 0.]])\nsy = np.array([[0., -1.j],[1.j, 0.]]) \nsz = np.array([[1., 0.],[0., -1.]])\nide2 = np.array([[1., 0.],[0., 1.]])\ns1 = np.array([[0., 1., 0.],[1., 0., 1.],[0., 1., 0.]])/np.sqrt(2)\ns2 = np.array([[0., -1.j, 0.],[1.j, 0., -1.j],[0., 1.j, 0.]])/np.sqrt(2)\ns3 = np.array([[1., 0., 0.],[0., 0., 0.],[0., 0., -1.]])\nide3 = np.array([[1., 0., 0.],[0., 1., 0.],[0., 0., 1.]])\nI1, I2, I3 = np.kron(ide3, sx), np.kron(ide3, sy), np.kron(ide3, sz)\nS1, S2, S3 = np.kron(s1, ide2), np.kron(s2, ide2), np.kron(s3, ide2)\nB1, B2, B3 = 5.0e-4, 5.0e-4, 5.0e-4\n# All numbers are divided by 100 in this example \n# for better calculation accurancy\ncons = 100\nD = (2*np.pi*2.87*1000)/cons\ngS = (2*np.pi*28.03*1000)/cons\ngI = (2*np.pi*4.32)/cons\nA1 = (2*np.pi*3.65)/cons\nA2 = (2*np.pi*3.03)/cons\nH0 = D*np.kron(np.dot(s3, s3), ide2) + gS*(B1*S1+B2*S2+B3*S3) \\\n     + gI*(B1*I1+B2*I2+B3*I3) + A1*(np.kron(s1, sx) + np.kron(s2, sy)) \\\n     + A2*np.kron(s3, sz)\n# derivatives of the free Hamiltonian on B1, B2, and B3\ndH = [gS*S1+gI*I1, gS*S2+gI*I2, gS*S3+gI*I3]\n# control Hamiltonians \nHc = [S1, S2, S3]\n# dissipation\ndecay = [[S3,2*np.pi/cons]]  \n# measurement\ndim = len(rho0)\nM_num = dim\nM = [np.dot(basis(dim, i), basis(dim, i).conj().T) for i in range(dim)]\n# time length for the evolution\ntspan = np.linspace(0., 2., 4000)\n# guessed control coefficients\ncnum = 10\nctrl0 = -0.2*np.ones((len(Hc), cnum))\n</code></pre> SMSCCMSCM DEPSO <pre><code># comprehensive optimization algorithm: DE\nDE_paras = {\"p_num\":10, \"psi0\":[], \"ctrl0\":[], \"measurement0\":[], \\\n            \"max_episode\":1000, \"c\":1.0, \"cr\":0.5, \"seed\":1234}\ncom = ComprehensiveOpt(savefile=False, method=\"DE\", **DE_paras)\ncom.dynamics(tspan, H0, dH, decay=decay, dyn_method=\"expm\")\ncom.SM()\n# convert the \".csv\" file to the \".npy\" file\nM_ = np.loadtxt(\"measurements.csv\", dtype=np.complex128)\ncsv2npy_measurements(M_, M_num)\n# load the measurements\nM = np.load(\"measurements.npy\")[-1]\n</code></pre> <pre><code># comprehensive optimization algorithm: PSO\nPSO_paras = {\"p_num\":10, \"psi0\":[], \"ctrl0\":[], \\\n             \"measurement0\":[], \"max_episode\":[1000,100], \"c0\":1.0, \\\n             \"c1\":2.0, \"c2\":2.0, \"seed\":1234}\ncom = ComprehensiveOpt(savefile=False, method=\"PSO\", **PSO_paras)\ncom.dynamics(tspan, H0, dH, decay=decay, dyn_method=\"expm\")\ncom.SM()\n# convert the \".csv\" file to the \".npy\" file\nM_ = np.loadtxt(\"measurements.csv\", dtype=np.complex128)\ncsv2npy_measurements(M_, M_num)\n# load the measurements\nM = np.load(\"measurements.npy\")[-1]\n</code></pre> DEPSOAD <pre><code># comprehensive optimization algorithm: DE\nDE_paras = {\"p_num\":10, \"psi0\":[], \"ctrl0\":[], \"measurement0\":[], \\\n            \"max_episode\":1000, \"c\":1.0, \"cr\":0.5, \"seed\":1234}\ncom = ComprehensiveOpt(savefile=False, method=\"DE\", **DE_paras)\ncom.dynamics(tspan, H0, dH, Hc=Hc, decay=decay, ctrl=[ctrl0], \\\n             ctrl_bound=[-0.2,0.2], dyn_method=\"expm\")\n</code></pre> QFIMCFIMHCRB <pre><code># objective function: tr(WF^{-1})\ncom.SC(W=[], target=\"QFIM\", LDtype=\"SLD\")\n</code></pre> <pre><code># objective function: tr(WI^{-1})\ncom.SC(W=[], M=M, target=\"CFIM\")\n</code></pre> <pre><code># objective function: HCRB\ncom.SC(W=[], target=\"HCRB\")\n</code></pre> <pre><code># comprehensive optimization algorithm: PSO\nPSO_paras = {\"p_num\":10, \"psi0\":[], \"ctrl0\":[], \\\n             \"measurement0\":[], \"max_episode\":[1000,100], \"c0\":1.0, \\\n             \"c1\":2.0, \"c2\":2.0, \"seed\":1234}\ncom = ComprehensiveOpt(savefile=False, method=\"PSO\", **PSO_paras)\ncom.dynamics(tspan, H0, dH, Hc=Hc, decay=decay, ctrl=[ctrl0], \\\n             ctrl_bound=[-0.2,0.2], dyn_method=\"expm\")\n</code></pre> QFIMCFIMHCRB <pre><code># objective function: tr(WF^{-1})\ncom.SC(W=[], target=\"QFIM\", LDtype=\"SLD\")\n</code></pre> <pre><code># objective function: tr(WI^{-1})\ncom.SC(W=[], M=M, target=\"CFIM\")\n</code></pre> <pre><code># objective function: HCRB\ncom.SC(W=[], target=\"HCRB\")\n</code></pre> <pre><code># comprehensive optimization algorithm: AD\nAD_paras = {\"Adam\":False, \"psi0\":[], \"ctrl0\":[], \"measurement0\":[], \\\n            \"max_episode\":300, \"epsilon\":0.01, \"beta1\":0.90, \"beta2\":0.99}\ncom = ComprehensiveOpt(savefile=False, method=\"AD\", **AD_paras)\ncom.dynamics(tspan, H0, dH, Hc=Hc, decay=decay, ctrl=[ctrl0], \\\n             ctrl_bound=[-0.2,0.2], dyn_method=\"expm\")\n</code></pre> QFIMCFIM <pre><code># objective function: tr(WF^{-1})\ncom.SC(W=[], target=\"QFIM\", LDtype=\"SLD\")\n</code></pre> <pre><code># objective function: tr(WI^{-1})\ncom.SC(W=[], M=M, target=\"CFIM\")\n</code></pre> DEPSO <pre><code># comprehensive optimization algorithm: DE\nDE_paras = {\"p_num\":10, \"psi0\":[], \"ctrl0\":[], \"measurement0\":[], \\\n            \"max_episode\":1000, \"c\":1.0, \"cr\":0.5, \"seed\":1234}\ncom = ComprehensiveOpt(savefile=False, method=\"DE\", **DE_paras)\ncom.dynamics(tspan, H0, dH, Hc=Hc, decay=decay, ctrl_bound=[-0.2,0.2], \\\n             dyn_method=\"expm\")\ncom.CM(rho0)\n# convert the \".csv\" file to the \".npy\" file\nM_ = np.loadtxt(\"measurements.csv\", dtype=np.complex128)\ncsv2npy_measurements(M_, M_num)\n# load the measurements\nM = np.load(\"measurements.npy\")[-1]\n</code></pre> <pre><code># comprehensive optimization algorithm: PSO\nPSO_paras = {\"p_num\":10, \"psi0\":[], \"ctrl0\":[], \\\n             \"measurement0\":[], \"max_episode\":[1000,100], \"c0\":1.0, \\\n             \"c1\":2.0, \"c2\":2.0, \"seed\":1234}\ncom = ComprehensiveOpt(savefile=False, method=\"PSO\", **PSO_paras)\ncom.dynamics(tspan, H0, dH, Hc=Hc, decay=decay, ctrl_bound=[-0.2,0.2], \\  \n             dyn_method=\"expm\")\ncom.CM(rho0)\n# convert the \".csv\" file to the \".npy\" file\nM_ = np.loadtxt(\"measurements.csv\", dtype=np.complex128)\ncsv2npy_measurements(M_, M_num)\n# load the measurements\nM = np.load(\"measurements.npy\")[-1]\n</code></pre> DEPSO <pre><code># comprehensive optimization algorithm: DE\nDE_paras = {\"p_num\":10, \"psi0\":[], \"ctrl0\":[], \"measurement0\":[], \\\n            \"max_episode\":1000, \"c\":1.0, \"cr\":0.5, \"seed\":1234}\ncom = ComprehensiveOpt(savefile=False, method=\"DE\", **DE_paras)\ncom.dynamics(tspan, H0, dH, Hc=Hc, decay=decay, ctrl_bound=[-0.2,0.2], \\\n             dyn_method=\"expm\")\ncom.SCM()\n# convert the \".csv\" file to the \".npy\" file\nM_ = np.loadtxt(\"measurements.csv\", dtype=np.complex128)\ncsv2npy_measurements(M_, M_num)\n# load the measurements\nM = np.load(\"measurements.npy\")[-1]\n</code></pre> <pre><code># comprehensive optimization algorithm: PSO\nPSO_paras = {\"p_num\":10, \"psi0\":[], \"ctrl0\":[], \\\n             \"measurement0\":[], \"max_episode\":[1000,100], \"c0\":1.0, \\\n             \"c1\":2.0, \"c2\":2.0, \"seed\":1234}\ncom = ComprehensiveOpt(savefile=False, method=\"PSO\", **PSO_paras)\ncom.dynamics(tspan, H0, dH, Hc=Hc, decay=decay, ctrl_bound=[-0.2,0.2], \\\n             dyn_method=\"expm\")\ncom.SCM()\n# convert the \".csv\" file to the \".npy\" file\nM_ = np.loadtxt(\"measurements.csv\", dtype=np.complex128)\ncsv2npy_measurements(M_, M_num)\n# load the measurements\nM = np.load(\"measurements.npy\")[-1]\n</code></pre> <pre><code>using QuanEstimation\nusing LinearAlgebra\nusing DelimitedFiles\n\n# initial state\nrho0 = zeros(ComplexF64, 6, 6)\nrho0[1:4:5, 1:4:5] .= 0.5\n# free Hamiltonian\nsx = [0. 1.; 1. 0.]\nsy = [0. -im; im 0.]\nsz = [1. 0.; 0. -1.]\ns1 = [0. 1. 0.; 1. 0. 1.; 0. 1. 0.]/sqrt(2)\ns2 = [0. -im 0.; im 0. -im; 0. im 0.]/sqrt(2)\ns3 = [1. 0. 0.; 0. 0. 0.; 0. 0. -1.]\nIs = I1, I2, I3 = [kron(I(3), sx), kron(I(3), sy), kron(I(3), sz)]\nS = S1, S2, S3 = [kron(s1, I(2)), kron(s2, I(2)), kron(s3, I(2))]\nB = B1, B2, B3 = [5.0e-4, 5.0e-4, 5.0e-4]\n# All numbers are divided by 100 in this example \n# for better calculation accurancy\ncons = 100\nD = (2pi*2.87*1000)/cons\ngS = (2pi*28.03*1000)/cons\ngI = (2pi*4.32)/cons\nA1 = (2pi*3.65)/cons\nA2 = (2pi*3.03)/cons\nH0 = sum([D*kron(s3^2, I(2)), sum(gS*B.*S), sum(gI*B.*Is),\n          A1*(kron(s1, sx) + kron(s2, sy)), A2*kron(s3, sz)])\n# derivatives of the free Hamiltonian on B1, B2 and B3\ndH = gS*S+gI*Is\n# control Hamiltonians \nHc = [S1, S2, S3]\n# dissipation\ndecay = [[S3, 2pi/cons]]\n# measurement\ndim = size(rho0, 1)\nM_num = dim\nM = [QuanEstimation.basis(dim, i)*QuanEstimation.basis(dim, i)' \n     for i in 1:dim]\n# time length for the evolution\ntspan = range(0., 2., length=4000)\n# guessed control coefficients\ncnum = 10\nctrl = -0.2*ones((length(Hc), cnum))\n# guessed measurements\nC = [QuanEstimation.basis(dim, i) for i in 1:dim]\n</code></pre> SMSCCMSCM <pre><code>opt = QuanEstimation.SMopt(seed=1234)\n</code></pre> DEPSO <pre><code># comprehensive optimization algorithm: DE\nalg = QuanEstimation.DE(p_num=10, max_episode=1000, c=1.0, cr=0.5)\n# objective function: CFI\nobj = QuanEstimation.CFIM_obj(M=M) \n# input the dynamics data\ndynamics = QuanEstimation.Lindblad(opt, tspan, H0, dH, decay=decay, \n                                   dyn_method=:Expm)   \n# run the comprehensive optimization problem\nQuanEstimation.run(opt, alg, obj, dynamics; savefile=false)\n# convert the flattened data into a list of matrix\nM_ = readdlm(\"measurements.csv\",'\\t', Complex{Float64})\nM = [[reshape(M_[i,:], dim, dim) for i in 1:M_num] \n    for j in 1:Int(length(M_[:,1])/M_num)][end]\n</code></pre> <pre><code># comprehensive optimization algorithm: PSO\nalg = QuanEstimation.PSO(p_num=10, max_episode=[1000,100], c0=1.0, \n                         c1=2.0, c2=2.0) \n# objective function: CFI\nobj = QuanEstimation.CFIM_obj(M=M) \n# input the dynamics data\ndynamics = QuanEstimation.Lindblad(opt, tspan, H0, dH, decay=decay, \n                                   dyn_method=:Expm) \n# run the comprehensive optimization problem\nQuanEstimation.run(opt, alg, obj, dynamics; savefile=false)\n# convert the flattened data into a list of matrix\nM_ = readdlm(\"measurements.csv\",'\\t', Complex{Float64})\nM = [[reshape(M_[i,:], dim, dim) for i in 1:M_num] \n    for j in 1:Int(length(M_[:,1])/M_num)][end]\n</code></pre> <pre><code>opt = QuanEstimation.SCopt(ctrl_bound=[-0.2,0.2], seed=1234)\n</code></pre> DEPSOAD <pre><code># comprehensive optimization algorithm: DE\nalg = QuanEstimation.DE(p_num=10, max_episode=1000, c=1.0, cr=0.5)\n</code></pre> QFIMCFIMHCRB <pre><code># objective function: tr(WF^{-1})\nobj = QuanEstimation.QFIM_obj() \n# input the dynamics data\ndynamics = QuanEstimation.Lindblad(opt, tspan, H0, dH, Hc, decay=decay, \n                                   dyn_method=:Expm) \n# run the comprehensive optimization problem\nQuanEstimation.run(opt, alg, obj, dynamics; savefile=false)\n</code></pre> <pre><code># objective function: tr(WI^{-1})\nobj = QuanEstimation.CFIM_obj(M=M) \n# input the dynamics data\ndynamics = QuanEstimation.Lindblad(opt, tspan, H0, dH, Hc, decay=decay, \n                                   dyn_method=:Expm) \n# run the comprehensive optimization problem\nQuanEstimation.run(opt, alg, obj, dynamics; savefile=false)\n</code></pre> <pre><code># objective function: HCRB\nobj = QuanEstimation.HCRB_obj() \n# input the dynamics data\ndynamics = QuanEstimation.Lindblad(opt, tspan, H0, dH, Hc, decay=decay, \n                                   dyn_method=:Expm) \n# run the comprehensive optimization problem\nQuanEstimation.run(opt, alg, obj, dynamics; savefile=false)\n</code></pre> <pre><code># comprehensive optimization algorithm: PSO\nalg = QuanEstimation.PSO(p_num=10, max_episode=[1000,100], c0=1.0, \n                         c1=2.0, c2=2.0) \n</code></pre> QFIMCFIMHCRB <pre><code># objective function: tr(WF^{-1})\nobj = QuanEstimation.QFIM_obj() \n# input the dynamics data\ndynamics = QuanEstimation.Lindblad(opt, tspan, H0, dH, Hc, decay=decay, \n                                   dyn_method=:Expm)\n# run the comprehensive optimization problem\nQuanEstimation.run(opt, alg, obj, dynamics; savefile=false)\n</code></pre> <pre><code># objective function: tr(WI^{-1})\nobj = QuanEstimation.CFIM_obj(M=M) \n# input the dynamics data\ndynamics = QuanEstimation.Lindblad(opt, tspan, H0, dH, Hc, decay=decay, \n                                   dyn_method=:Expm)\n# run the comprehensive optimization problem\nQuanEstimation.run(opt, alg, obj, dynamics; savefile=false)\n</code></pre> <pre><code># objective function: HCRB\nobj = QuanEstimation.HCRB_obj() \n# input the dynamics data\ndynamics = QuanEstimation.Lindblad(opt, tspan, H0, dH, Hc, decay=decay, \n                                   dyn_method=:Expm)\n# run the comprehensive optimization problem\nQuanEstimation.run(opt, alg, obj, dynamics; savefile=false)\n</code></pre> <pre><code># comprehensive optimization algorithm: AD\nalg = QuanEstimation.AD(Adam=true, max_episode=300, epsilon=0.01, \n                        beta1=0.90, beta2=0.99)\n</code></pre> QFIMCFIM <pre><code># objective function: tr(WF^{-1})\nobj = QuanEstimation.QFIM_obj()\n# input the dynamics data\ndynamics = QuanEstimation.Lindblad(opt, tspan, H0, dH, Hc, decay=decay, \n                                   dyn_method=:Expm) \n# run the comprehensive optimization problem\nQuanEstimation.run(opt, alg, obj, dynamics; savefile=false) \n</code></pre> <pre><code># objective function: tr(WI^{-1})\nobj = QuanEstimation.CFIM_obj(M=M) \n# input the dynamics data\ndynamics = QuanEstimation.Lindblad(opt, tspan, H0, dH, Hc, decay=decay, \n                                   dyn_method=:Expm) \n# run the comprehensive optimization problem\nQuanEstimation.run(opt, alg, obj, dynamics; savefile=false)\n</code></pre> <pre><code>opt = QuanEstimation.CMopt(seed=1234)\n</code></pre> DEPSO <pre><code># comprehensive optimization algorithm: DE\nalg = QuanEstimation.DE(p_num=10, max_episode=1000, c=1.0, cr=0.5)\n# objective function: CFI\nobj = QuanEstimation.CFIM_obj()\n# input the dynamics data\ndynamics = QuanEstimation.Lindblad(opt, tspan, rho0, H0, dH, Hc,  \n                                   decay=decay, dyn_method=:Expm)    \n# run the comprehensive optimization problem\nQuanEstimation.run(opt, alg, obj, dynamics; savefile=false)\n# convert the flattened data into a list of matrix\nM_ = readdlm(\"measurements.csv\",'\\t', Complex{Float64})\nM = [[reshape(M_[i,:], dim, dim) for i in 1:M_num] \n    for j in 1:Int(length(M_[:,1])/M_num)][end]\n</code></pre> <pre><code># comprehensive optimization algorithm: PSO\nalg = QuanEstimation.PSO(p_num=10, max_episode=[1000,100], c0=1.0, \n                         c1=2.0, c2=2.0)\n# objective function: CFI\nobj = QuanEstimation.CFIM_obj() \n# input the dynamics data\ndynamics = QuanEstimation.Lindblad(opt, tspan, rho0, H0, dH, Hc, \n                                   decay=decay, dyn_method=:Expm)  \n# run the comprehensive optimization problem\nQuanEstimation.run(opt, alg, obj, dynamics; savefile=false)\n# convert the flattened data into a list of matrix\nM_ = readdlm(\"measurements.csv\",'\\t', Complex{Float64})\nM = [[reshape(M_[i,:], dim, dim) for i in 1:M_num] \n    for j in 1:Int(length(M_[:,1])/M_num)][end]\n</code></pre> <pre><code>opt = QuanEstimation.SCMopt(seed=1234)\n</code></pre> DEPSO <pre><code># comprehensive optimization algorithm: DE\nalg = QuanEstimation.DE(p_num=10, max_episode=1000, c=1.0, cr=0.5)\n# objective function: CFI\nobj = QuanEstimation.CFIM_obj() \n# input the dynamics data\ndynamics = QuanEstimation.Lindblad(opt, tspan, H0, dH, Hc, decay=decay, \n                                   dyn_method=:Expm)   \n# run the comprehensive optimization problem\nQuanEstimation.run(opt, alg, obj, dynamics; savefile=false)\n# convert the flattened data into a list of matrix\nM_ = readdlm(\"measurements.csv\",'\\t', Complex{Float64})\nM = [[reshape(M_[i,:], dim, dim) for i in 1:M_num] \n    for j in 1:Int(length(M_[:,1])/M_num)][end]\n</code></pre> <pre><code># comprehensive optimization algorithm: PSO\nalg = QuanEstimation.PSO(p_num=10, max_episode=[1000,100], c0=1.0, \n                         c1=2.0, c2=2.0)\n# objective function: CFI\nobj = QuanEstimation.CFIM_obj() \n# input the dynamics data\ndynamics = QuanEstimation.Lindblad(opt, tspan, H0, dH, Hc, decay=decay, \n                                   dyn_method=:Expm)   \n# run the comprehensive optimization problem\nQuanEstimation.run(opt, alg, obj, dynamics; savefile=false)\n# convert the flattened data into a list of matrix\nM_ = readdlm(\"measurements.csv\",'\\t', Complex{Float64})\nM = [[reshape(M_[i,:], dim, dim) for i in 1:M_num] \n    for j in 1:Int(length(M_[:,1])/M_num)][end]\n</code></pre> <p>For optimization of probe state and measurement, the parameterization can also be implemented  with the Kraus operators which can be realized by</p> PythonJulia <pre><code>com = ComprehensiveOpt(savefile=False, method=\"DE\", **kwargs)\ncom.Kraus(K, dK)\ncom.SM(W=[])\n</code></pre> <pre><code>opt = SMopt(psi=psi, M=M, seed=1234)\nalg = DE(kwargs...)\ndynamics = Kraus(opt, K, dK) \nobj = CFIM_obj(W=missing)\nrun(opt, alg, obj, dynamics; savefile=false)\n</code></pre> <p>where <code>K</code> and <code>dK</code> are the Kraus operators and its derivatives with respect to the  unknown parameters.</p> <p>Example 8.3 The Kraus operators for the amplitude damping channel are</p> \\[\\begin{eqnarray} K_1 = \\left(\\begin{array}{cc} 1 &amp; 0  \\\\ 0 &amp; \\sqrt{1-\\gamma} \\end{array}\\right), K_2 = \\left(\\begin{array}{cc} 0 &amp; \\sqrt{\\gamma} \\\\ 0 &amp; 0 \\end{array}\\right), \\nonumber \\end{eqnarray}\\] <p>where \\(\\gamma\\) is the unknown parameter to be estimated which represents the decay  probability. In this example, the probe state is taken as \\(|+\\rangle\\langle+|\\) with  \\(|+\\rangle=\\frac{1}{\\sqrt{2}}(|0\\rangle+|1\\rangle)\\). Here \\(|0\\rangle\\) \\((|1\\rangle)\\) is  the eigenstate of \\(\\sigma_3\\) (Pauli matrix) with respect to the eigenvalue \\(1\\) \\((-1)\\).</p> PythonJulia <pre><code>from quanestimation import *\nimport numpy as np\n\n# initial state\nrho0 = 0.5*np.array([[1., 1.], [1., 1.]])\n# Kraus operators for the amplitude damping channel\ngamma = 0.1\nK1 = np.array([[1., 0.], [0., np.sqrt(1-gamma)]])\nK2 = np.array([[0., np.sqrt(gamma)], [0., 0.]])\nK = [K1, K2]\n# derivatives of Kraus operators on gamma\ndK1 = np.array([[1., 0.], [0., -0.5/np.sqrt(1-gamma)]])\ndK2 = np.array([[0., 0.5/np.sqrt(gamma)], [0., 0.]])\ndK = [[dK1], [dK2]]\n</code></pre> DEPSO <pre><code># comprehensive optimization algorithm: DE\nDE_paras = {\"p_num\":10, \"psi0\":[], \"ctrl0\":[], \"measurement0\":[], \\\n            \"max_episode\":1000, \"c\":1.0, \"cr\":0.5, \"seed\":1234}\ncom = ComprehensiveOpt(savefile=False, method=\"DE\", **DE_paras)\ncom.Kraus(K, dK)\ncom.SM()\n# convert the \".csv\" file to the \".npy\" file\nM_ = np.loadtxt(\"measurements.csv\", dtype=np.complex128)\ncsv2npy_measurements(M_, 2)\n# load the measurements\nM = np.load(\"measurements.npy\")[-1]\n</code></pre> <pre><code># comprehensive optimization algorithm: PSO\nPSO_paras = {\"p_num\":10, \"psi0\":[], \"ctrl0\":[], \\\n             \"measurement0\":[], \"max_episode\":[1000,100], \"c0\":1.0, \\\n             \"c1\":2.0, \"c2\":2.0, \"seed\":1234}\ncom = ComprehensiveOpt(savefile=False, method=\"PSO\", **PSO_paras)\ncom.Kraus(K, dK)\ncom.SM()\n# convert the \".csv\" file to the \".npy\" file\nM_ = np.loadtxt(\"measurements.csv\", dtype=np.complex128)\ncsv2npy_measurements(M_, 2)\n# load the measurements\nM = np.load(\"measurements.npy\")[-1]\n</code></pre> <pre><code>using QuanEstimation\nusing DelimitedFiles\n\n# initial state\nrho0 = 0.5*ones(2, 2)\n# Kraus operators for the amplitude damping channel\ngamma = 0.1\nK1 = [1. 0.; 0. sqrt(1-gamma)]\nK2 = [0. sqrt(gamma); 0. 0.]\nK = [K1, K2]\n# derivatives of Kraus operators on gamma\ndK1 = [1. 0.; 0. -0.5/sqrt(1-gamma)]\ndK2 = [0. 0.5/sqrt(gamma); 0. 0.]\ndK = [[dK1], [dK2]]\n# comprehensive optimization \nM_num = 2\nopt = QuanEstimation.SMopt(seed=1234)\n</code></pre> DEPSO <pre><code># comprehensive optimization algorithm: DE\nalg = QuanEstimation.DE(p_num=10, max_episode=1000, c=1.0, cr=0.5)\n# objective function: CFI\nobj = QuanEstimation.CFIM_obj() \n# input the dynamics data\ndynamics = QuanEstimation.Kraus(opt, K, dK)  \n# run the comprehensive optimization problem\nQuanEstimation.run(opt, alg, obj, dynamics; savefile=false)\n# convert the flattened data into a list of matrix\nM_ = readdlm(\"measurements.csv\",'\\t', Complex{Float64})\nM = [[reshape(M_[i,:], dim, dim) for i in 1:M_num] \n    for j in 1:Int(length(M_[:,1])/M_num)][end]\n</code></pre> <pre><code># comprehensive optimization algorithm: PSO\nalg = QuanEstimation.PSO(p_num=10, max_episode=[1000,100], c0=1.0, \n                             c1=2.0, c2=2.0)\n# objective function: CFI\nobj = QuanEstimation.CFIM_obj() \n# input the dynamics data\ndynamics = QuanEstimation.Kraus(opt, K, dK)   \n# run the comprehensive optimization problem\nQuanEstimation.run(opt, alg, obj, dynamics; savefile=false)\n# convert the flattened data into a list of matrix\nM_ = readdlm(\"measurements.csv\",'\\t', Complex{Float64})\nM = [[reshape(M_[i,:], dim, dim) for i in 1:M_num] \n    for j in 1:Int(length(M_[:,1])/M_num)][end]\n</code></pre>"},{"location":"guide/guide_Compopt/#bibliography","title":"Bibliography","text":"<p>[1] J. Kennedy and R. Eberhar, Particle swarm optimization, Proc. 1995 IEEE International Conference on Neural Networks 4, 1942-1948 (1995). </p> <p>[2] R. Storn and K. Price, Differential Evolution-A Simple and Efficient Heuristic for global Optimization over Continuous Spaces, J. Global Optim. 11, 341 (1997).</p> <p>[3] A. G. Baydin, B. A. Pearlmutter, A. A. Radul, and J. M. Siskind, Automatic differentiation in machine learning: a survey, J. Mach. Learn. Res. 18, 1-43 (2018).</p>"},{"location":"guide/guide_Copt/","title":"Control optimization","text":"<p>The Hamiltonian of a controlled system can be written as \\begin{align} H = H_0(\\textbf{x})+\\sum_{k=1}^K u_k(t) H_k, \\end{align}</p> <p>where \\(H_0(\\textbf{x})\\) is the free evolution Hamiltonian with unknown parameters \\(\\textbf{x}\\)  and \\(H_k\\) represents the \\(k\\)th control Hamiltonian with \\(u_k\\) the corresponding control  coefficients. In QuanEstimation, different algorithms are invoked to update the control  coefficients. The control optimization algorithms are the gradient ascent pulse engineering  (GRAPE) [1,2,3], GRAPE algorithm based on the automatic differentiation  (auto-GRAPE) [4], particle swarm optimization (PSO) [5],  and differential evolution (DE) [6]. The codes for control optimization are</p> PythonJulia <pre><code>control = ControlOpt(savefile=False, method=\"auto-GRAPE\", **kwargs)\ncontrol.dynamics(tspan, rho0, H0, dH, Hc, decay=[], ctrl_bound=[], \n                 dyn_method=\"expm\")\n</code></pre> QFIMCFIMHCRB <pre><code>control.QFIM(W=[], LDtype=\"SLD\")\n</code></pre> <pre><code>control.CFIM(M=[], W=[])\n</code></pre> <pre><code>control.HCRB(W=[])\n</code></pre> <p>In QuanEstimation, the optimization codes are executed in Julia and the data will be saved in the <code>.csv</code> file. The variable <code>savefile</code> indicates whether to save all the control  coefficients and its default value is <code>False</code> which means the control coefficients for the  final episode and the values of the objective function in all episodes will be saved in  \"controls.csv\" and \"f.csv\", respectively. If set <code>True</code> then the control coefficients and the  values of the objective function in all episodes will be saved during the training. The package contains five control optimization algorithms which can be set via <code>method</code>, <code>**kwargs</code> is  the corresponding keyword and default value.</p> <p>After calling <code>control = ControlOpt()</code>, the dynamics parameters shoule be input. Here <code>tspan</code>  is the time length for the evolution and <code>rho0</code> represents the density matrix of the initial  state. <code>H0</code> and <code>dH</code> are the free Hamiltonian and its derivatives with respect to the unknown  parameters to be estimated. <code>H0</code> is a matrix when the free Hamiltonian is time-independent and  a list of matrices with the length equal to <code>tspan</code> when it is time-dependent. <code>dH</code> should be input as  \\([\\partial_a{H_0}, \\partial_b{H_0}, \\cdots]\\). <code>Hc</code> is a list representing the control  Hamiltonians. <code>decay</code> contains decay operators \\((\\Gamma_1, \\Gamma_2, \\cdots)\\) and the  corresponding decay rates \\((\\gamma_1, \\gamma_2, \\cdots)\\), its input rule is decay=[[\\(\\Gamma_1\\), \\(\\gamma_1\\)], [\\(\\Gamma_2\\), \\(\\gamma_2\\)],...]. The default value for  <code>decay</code> is empty which means the dynamics is unitary. The package can be used to optimize  bounded control problems by setting lower and upper bounds of the control coefficients via  <code>ctrl_bound</code>, which is an array with two elements representing the lower and upper bound of  each control coefficient, respectively. The default value of <code>ctrl_bound=[]</code> which means the  control coefficients are in the regime \\([-\\infty,\\infty]\\). <code>dyn_method=\"expm\"</code> represents  the method for solving the dynamics is matrix exponential, it can also be set as <code>dyn_method=\"ode\"</code> which means the dynamics (differential equation) is directly solved with the ODE solvers.</p> <p>The objective functions for control optimization can be set as QFI \\(\\left[\\mathrm{Tr}(W \\mathcal{F}^{-1})\\right]\\), CFI \\(\\left[\\mathrm{Tr}(W\\mathcal{I}^{-1})\\right]\\), and HCRB, the  corresponding codes for them are <code>control.QFIM()</code> (default), <code>control.CFIM()</code>, and <code>control.HCRB()</code>.  Here \\(\\mathcal{F}\\) and \\(\\mathcal{I}\\) are the QFIM and CFIM, \\(W\\) corresponds to <code>W</code> is the weight  matrix which defaults to the identity matrix. If the users call <code>control.HCRB()</code> for single  parameter scenario, the program will exit and print <code>\"Program terminated. In the single-parameter  scenario, the HCRB is equivalent to the QFI. Please choose 'QFIM' as the objective function\"</code>.  <code>LDtype</code> in <code>control.QFIM()</code> represents the types of the QFIM, it can be set as <code>LDtype=\"SLD\"</code>  (default), <code>LDtype=\"RLD\"</code>, and <code>LDtype=\"LLD\"</code>. <code>M</code> in <code>control.CFIM()</code> represents a set of  positive operator-valued measure (POVM) with default value <code>[]</code> which means a set of rank-one  symmetric informationally complete POVM (SIC-POVM) is used in the calculation.</p> <pre><code>opt = ControlOpt(ctrl=ctrl, ctrl_bound=ctrl_bound, seed=1234)\nalg = autoGRAPE(kwargs...)\ndynamics = Lindblad(opt, tspan, rho0, H0, dH, Hc, decay=mising, \n                    dyn_method=:Expm) \n</code></pre> QFIMCFIMHCRB <pre><code>obj = QFIM_obj(W=missing, LDtype=:SLD)\n</code></pre> <pre><code>obj = CFIM_obj(M=missing, W=missing)\n</code></pre> <pre><code>obj = HCRB_obj(W=missing)\n</code></pre> <p><pre><code>run(opt, alg, obj, dynamics; savefile=false)\n</code></pre> In control optimization, a set of control coefficients (optimization variable) and its boundary  value can be input via <code>ctrl=ctrl</code> and <code>ctrl_bound=ctrl_bound</code> in <code>ControlOpt()</code>. <code>ctrl</code> is a list of arrays with the length equal to control Hamiltonians,  <code>ctrl_bound</code> is an array with two elements representing the lower and upper bound of the  control coefficients, respectively. The default value of <code>ctrl_bound=missing</code> which means  the control coefficients are in the regime \\([-\\infty,\\infty]\\). <code>seed</code> is the random seed  which can ensure the reproducibility of results.</p> <p>The package can deal with the parameterization process in the form of master equation, the  dynamics parameters shoule be input via <code>Lindblad()</code>. Here <code>tspan</code> is the time length for  the evolution and <code>rho0</code> represents the density matrix of the initial state. <code>H0</code> and <code>dH</code>  are the free Hamiltonian and its derivatives with respect to the unknown parameters to be  estimated. <code>H0</code> is a matrix when the free Hamiltonian is time-independent and a list of matrices with the length equal to <code>tspan</code> when it is time-dependent. <code>dH</code> should be input as \\([\\partial_a{H_0},  \\partial_b{H_0}, \\cdots]\\). <code>Hc</code> is a list representing the control Hamiltonians. <code>decay</code>  contains decay operators \\((\\Gamma_1, \\Gamma_2, \\cdots)\\) and the corresponding decay rates  \\((\\gamma_1, \\gamma_2, \\cdots)\\) with the input rule decay=[[\\(\\Gamma_1\\), \\(\\gamma_1\\)],  [\\(\\Gamma_2\\), \\(\\gamma_2\\)],...]. The default value <code>decay</code> is <code>missing</code> which means the  dynamics is unitary. <code>dyn_method=:Expm</code> represents the method for solving the dynamics is  matrix exponential, it can also be set as <code>dyn_method=:Ode</code> which means the dynamics  (differential equation) is directly solved with the ODE solvers.</p> <p>The objective functions for control optimization can be set as QFI \\(\\left[\\mathrm{Tr}(W \\mathcal{F}^{-1})\\right]\\), CFI \\(\\left[\\mathrm{Tr}(W\\mathcal{I}^{-1})\\right]\\), and HCRB, the  corresponding codes for them are <code>QFIM_obj()</code> (default), <code>CFIM_obj()</code>, and <code>HCRB_obj()</code>. Here  \\(\\mathcal{F}\\) and \\(\\mathcal{I}\\) are the QFIM and CFIM, \\(W\\) corresponds to <code>W</code> is the weight  matrix which defaults to the identity matrix. If the users call <code>HCRB_obj()</code> for single parameter  scenario, the program will exit and print <code>\"Program terminated. In the single-parameter scenario,  the HCRB is equivalent to the QFI. Please choose 'QFIM_obj' as the objective function\"</code>.  <code>LDtype</code> in <code>QFIM_obj()</code> represents the types of the QFIM, it can be set as <code>LDtype=:SLD</code>  (default), <code>LDtype=:RLD</code>, and <code>LDtype=:LLD</code>. <code>M</code> in <code>CFIM_obj()</code> represents a set of positive  operator-valued measure (POVM) with default value <code>missing</code> which means a set of rank-one  symmetric informationally complete POVM (SIC-POVM) is used in the calculation.</p> <p>The variable <code>savefile</code> indicates whether to save all the control coefficients and its default  value is <code>false</code> which means the control coefficients for the final episode and the values of  the objective function in all episodes will be saved in \"controls.csv\" and \"f.csv\", respectively. If set <code>true</code> then the control coefficients and the values of the objective function in all  episodes will be saved during the training. The algorithm used for optimizing the control coefficients in QuanEstimation are GRAPE, auto-GRAPE, PSO, DE, and DDPG. <code>kwargs...</code> contains  the keywords and defaults value corresponding to the optimization algorithm which will be  introduced in detail below.</p>"},{"location":"guide/guide_Copt/#grape-and-auto-grape","title":"GRAPE and auto-GRAPE","text":"<p>The codes for control optimization with GRAPE and auto-GRAPE are as follows</p> PythonJulia <p><pre><code>control = ControlOpt(method=\"GRAPE\", **kwargs)\n</code></pre> <pre><code>control = ControlOpt(method=\"auto-GRAPE\", **kwargs)\n</code></pre> where <code>kwargs</code> is of the form <pre><code>kwargs = {\"Adam\":True, \"ctrl0\":[], \"max_episode\":300, \"epsilon\":0.01, \\\n          \"beta1\":0.90, \"beta2\":0.99}\n</code></pre> The keywords and the default values of GRAPE and auto-GRAPE can be seen in the following table</p> \\(~~~~~~~~~~\\)**kwargs\\(~~~~~~~~~~\\) \\(~~~~\\)default values\\(~~~~\\) \"Adam\" True \"ctrl0\" [ ] \"max_episode\" 300 \"epsilon\" 0.01 \"beta1\" 0.90 \"beta2\" 0.99 <p>Adam algorithm can be introduced to update the control coefficients when using GRAPE and  auto-GRAPE for control optimization, which can be realized by setting <code>Adam=True</code>. In this  case, the Adam parameters include learning rate, the exponential decay rate for the first  moment estimates and the second moment estimates can be set by the users via <code>epsilon</code>, <code>beta1</code>, and <code>beta2</code>, respectively. If <code>Adam=False</code>, the control coefficients will update according to  the learning rate <code>\"epsilon\"</code>. <code>ctrl0</code> is a list representing the initial guesses of control  coefficients and <code>max_episode</code> is the number of episodes.</p> <p><pre><code>alg = GRAPE(Adam=true, max_episode=300, epsilon=0.01, beta1=0.90, \n            beta2=0.99)\n</code></pre> <pre><code>alg = autoGRAPE(Adam=true, max_episode=300, epsilon=0.01, beta1=0.90, \n                beta2=0.99)\n</code></pre> The keywords and the default values of GRAPE and auto-GRAPE can be seen in the following table</p> \\(~~~~~~~~~~\\)keywords\\(~~~~~~~~~~\\) \\(~~~~\\)default values\\(~~~~\\) \"Adam\" true \"max_episode\" 300 \"epsilon\" 0.01 \"beta1\" 0.90 \"beta2\" 0.99 <p>Adam algorithm can be introduced to update the control coefficients when using GRAPE and  auto-GRAPE for control optimization, which can be realized by setting <code>Adam=true</code>. In this  case, the Adam parameters include learning rate, the exponential decay rate for the first  moment estimates and the second moment estimates can be set by the users via <code>epsilon</code>, <code>beta1</code>, and <code>beta2</code>, respectively. If <code>Adam=false</code>, the control coefficients will update according to  the learning rate <code>\"epsilon\"</code>.</p>"},{"location":"guide/guide_Copt/#pso","title":"PSO","text":"<p>The code for control optimization with PSO is as follows</p> PythonJulia <p><pre><code>control = ControlOpt(method=\"PSO\", **kwargs)\n</code></pre> where <code>kwargs</code> is of the form <pre><code>kwargs = {\"p_num\":10, \"ctrl0\":[], \"max_episode\":[1000,100], \\\n          \"c0\":1.0, \"c1\":2.0, \"c2\":2.0, \"seed\":1234}\n</code></pre> The keywords and the default values of PSO can be seen in the following table</p> \\(~~~~~~~~~~\\)**kwargs\\(~~~~~~~~~~\\) \\(~~~~\\)default values\\(~~~~\\) \"p_num\" 10 \"ctrl0\" [ ] \"max_episode\" [1000,100] \"c0\" 1.0 \"c1\" 2.0 \"c2\" 2.0 \"seed\" 1234 <p>Here <code>p_num</code> is the number of particles. <code>c0</code>, <code>c1</code>, and <code>c2</code> are the PSO parameters  representing the inertia weight, cognitive learning factor, and social learning factor,  respectively. <code>max_episode</code> accepts both integer and array with two elements. If it is an  integer, for example <code>max_episode=1000</code>, it means the program will continuously run 1000  episodes. However, if it is an array, for example <code>max_episode=[1000,100]</code>, the program will  run 1000 episodes in total but replace control coefficients of all the particles with global  best every 100 episodes. <code>seed</code> is the random seed which can ensure the reproducibility of  the results.</p> <pre><code>alg = PSO(p_num=10, ini_particle=missing, max_episode=[1000,100], \n          c0=1.0, c1=2.0, c2=2.0)\n</code></pre> <p>The keywords and the default values of PSO can be seen in the following table</p> \\(~~~~~~~~~~\\)keywords\\(~~~~~~~~~~\\) \\(~~~~\\)default values\\(~~~~\\) \"p_num\" 10 \"ini_particle\" missing \"max_episode\" [1000,100] \"c0\" 1.0 \"c1\" 2.0 \"c2\" 2.0 <p>Here <code>p_num</code> is the number of particles. <code>c0</code>, <code>c1</code>, and <code>c2</code> are the PSO parameters  representing the inertia weight, cognitive learning factor, and social learning factor,  respectively. <code>max_episode</code> accepts both integer and array with two elements. If it is an  integer, for example <code>max_episode=1000</code>, it means the program will continuously run 1000  episodes. However, if it is an array, for example <code>max_episode=[1000,100]</code>, the program will  run 1000 episodes in total but replace control coefficients of all the particles with global  best every 100 episodes. <code>ini_particle</code> is a tuple representing the initial guesses of control  coefficients.</p>"},{"location":"guide/guide_Copt/#de","title":"DE","text":"<p>The code for control optimization with DE is as follows</p> PythonJulia <p><pre><code>control = ControlOpt(method=\"DE\", **kwargs)\n</code></pre> where <code>kwargs</code> is of the form <pre><code>kwargs = {\"p_num\":10, \"ctrl0\":[], \"max_episode\":1000, \"c\":1.0, \\\n          \"cr\":0.5, \"seed\":1234}\n</code></pre> The keywords and the default values of DE can be seen in the following table</p> \\(~~~~~~~~~~\\)**kwargs\\(~~~~~~~~~~\\) \\(~~~~\\)default values\\(~~~~\\) \"p_num\" 10 \"ctrl0\" [ ] \"max_episode\" 1000 \"c\" 1.0 \"cr\" 0.5 \"seed\" 1234 <p><code>p_num</code> and <code>max_episode</code> represent the number of populations and episodes. <code>c</code> and <code>cr</code>  are the mutation constant and the crossover constant.</p> <p><pre><code>alg = DE(p_num=10, ini_population=missing, max_episode=1000, \n         c=1.0, cr=0.5)\n</code></pre> The keywords and the default values of DE can be seen in the following table</p> \\(~~~~~~~~~~\\)keywords\\(~~~~~~~~~~\\) \\(~~~~\\)default values\\(~~~~\\) \"p_num\" 10 \"ini_population\" missing \"max_episode\" 1000 \"c\" 1.0 \"cr\" 0.5 <p><code>ini_population</code> is a tuple representing the initial guesses of control and <code>max_episode</code>  represents the number of populations and episodes. <code>c</code> and <code>cr</code> are the mutation constant  and the crossover constant.</p> <p>Example 5.1  In this example, the free evolution Hamiltonian of a single qubit system is \\(H_0=\\frac{1}{2}\\omega  \\sigma_3\\) with \\(\\omega\\) the frequency and \\(\\sigma_3\\) a Pauli matrix. The dynamics of the system  is governed by</p> \\[\\begin{align} \\partial_t\\rho=-i[H_0, \\rho]+ \\gamma_{+}\\left(\\sigma_{+}\\rho\\sigma_{-}-\\frac{1}{2}\\{\\sigma_{-} \\sigma_{+},\\rho\\}\\right)+ \\gamma_{-}\\left(\\sigma_{-}\\rho\\sigma_{+}-\\frac{1}{2}\\{\\sigma_{+}\\sigma_{-}, \\rho\\}\\right), \\end{align}\\] <p>where \\(\\gamma_{+}\\), \\(\\gamma_{-}\\) are decay rates and \\(\\sigma_{\\pm}=(\\sigma_1 \\pm \\sigma_2)/2\\).  The control Hamiltonian  \\begin{align} H_\\mathrm{c}=u_1(t)\\sigma_1+u_2(t)\\sigma_2+u_3(t)\\sigma_3. \\end{align}</p> <p>Here \\(\\sigma_{1}\\), \\(\\sigma_{2}\\) are also Pauli matrices. The probe state is taken as \\(|+\\rangle\\) and  the measurement for CFI is \\(\\{|+\\rangle\\langle+|, |-\\rangle\\langle-|\\}\\) with \\(|\\pm\\rangle:=\\frac{1}{\\sqrt{2}}(|0\\rangle\\pm|1\\rangle)\\). \\(|0\\rangle\\) \\((|1\\rangle)\\) is the eigenstate  of \\(\\sigma_3\\) with respect to the eigenvalue \\(1\\) \\((-1)\\).</p> PythonJulia <pre><code>from quanestimation import *\nimport numpy as np\n\n# initial state\nrho0 = 0.5*np.array([[1., 1.], [1., 1.]])\n# free Hamiltonian\nomega = 1.0\nsx = np.array([[0., 1.], [1., 0.]])\nsy = np.array([[0., -1.j], [1.j, 0.]]) \nsz = np.array([[1., 0.], [0., -1.]])\nH0 = 0.5*omega*sz\n# derivative of the free Hamiltonian on omega\ndH = [0.5*sz]\n# control Hamiltonians \nHc = [sx, sy, sz]\n# dissipation\nsp = np.array([[0., 1.], [0., 0.]])  \nsm = np.array([[0., 0.], [1., 0.]]) \ndecay = [[sp, 0.], [sm, 0.1]]\n# measurement\nM1 = 0.5*np.array([[1., 1.], [1., 1.]])\nM2 = 0.5*np.array([[1., -1.], [-1., 1.]])\nM = [M1, M2]\n# time length for the evolution\ntspan = np.linspace(0., 10., 2500)\n# guessed control coefficients\ncnum = len(tspan)-1\nctrl0 = [np.array([np.zeros(cnum), np.zeros(cnum), np.zeros(cnum)])]\n</code></pre> auto-GRAPEGRAPEPSODE <pre><code># control algorithm: auto-GRAPE\nGRAPE_paras = {\"Adam\":True, \"ctrl0\":ctrl0, \"max_episode\":300, \\\n               \"epsilon\":0.01, \"beta1\":0.90, \"beta2\":0.99}\ncontrol = ControlOpt(savefile=False, method=\"auto-GRAPE\", **GRAPE_paras)\n</code></pre> <pre><code># control algorithm: GRAPE\nGRAPE_paras = {\"Adam\":True, \"ctrl0\":ctrl0, \"max_episode\":300, \\\n               \"epsilon\":0.01, \"beta1\":0.90, \"beta2\":0.99}\ncontrol = ControlOpt(savefile=False, method=\"GRAPE\", **GRAPE_paras)\n</code></pre> <pre><code># control algorithm: PSO\nPSO_paras = {\"p_num\":10, \"ctrl0\":ctrl0, \"max_episode\":[1000,100], \\\n             \"c0\":1.0, \"c1\":2.0, \"c2\":2.0, \"seed\":1234}\ncontrol = ControlOpt(savefile=False, method=\"PSO\", **PSO_paras)\n</code></pre> <pre><code># control algorithm: DE\nDE_paras = {\"p_num\":10, \"ctrl0\":ctrl0, \"max_episode\":1000, \"c\":1.0, \\\n            \"cr\":0.5, \"seed\":1234}\ncontrol = ControlOpt(savefile=False, method=\"DE\", **DE_paras)\n</code></pre> <p> ``` py</p> <pre><code>using QuanEstimation\nusing Random\n\n# initial state\nrho0 = 0.5*ones(2, 2)\n# free Hamiltonian\nomega = 1.0\nsx = [0. 1.; 1. 0.0im]\nsy = [0. -im; im 0.]\nsz = [1. 0.0im; 0. -1.]\nH0 = 0.5*omega*sz\n# derivative of the free Hamiltonian on omega\ndH = [0.5*sz]\n# control Hamiltonians \nHc = [sx, sy, sz]\n# dissipation\nsp = [0. 1.; 0. 0.0im]\nsm = [0. 0.; 1. 0.0im]\ndecay = [[sp, 0.], [sm, 0.1]]\n# measurement\nM1 = 0.5*[1.0+0.0im  1.; 1.  1.]\nM2 = 0.5*[1.0+0.0im -1.; -1.  1.]\nM = [M1, M2]\n# time length for the evolution\ntspan = range(0., 10., length=2500)\n# guessed control coefficients\ncnum = length(tspan)-1\nctrl = [zeros(cnum) for _ in 1:length(Hc)]\nctrl_bound = [-2., 2.]\n# set the optimization type\nopt = QuanEstimation.ControlOpt(ctrl=ctrl, ctrl_bound=ctrl_bound, seed=1234)\n</code></pre> auto-GRAPEGRAPEPSODE <pre><code># control algorithm: auto-GRAPE\nalg = QuanEstimation.autoGRAPE(Adam=true, max_episode=300, epsilon=0.01, \n                               beta1=0.90, beta2=0.99)\n</code></pre> QFIMCFIM <pre><code># objective function: QFI\nobj = QuanEstimation.QFIM_obj()\n</code></pre> <pre><code># objective function: CFI\nobj = QuanEstimation.CFIM_obj(M=M)\n</code></pre> <pre><code># control algorithm: GRAPE\nalg = QuanEstimation.GRAPE(Adam=true, max_episode=300, epsilon=0.01, \n                           beta1=0.90, beta2=0.99)\n</code></pre> QFIMCFIM <pre><code># objective function: QFI\nobj = QuanEstimation.QFIM_obj()\n</code></pre> <pre><code># objective function: CFI\nobj = QuanEstimation.CFIM_obj(M=M)\n</code></pre> <pre><code># control algorithm: PSO\nalg = QuanEstimation.PSO(p_num=10, ini_particle=([ctrl],), \n                         max_episode=[1000,100], c0=1.0, \n                         c1=2.0, c2=2.0)\n</code></pre> QFIMCFIM <pre><code># objective function: QFI\nobj = QuanEstimation.QFIM_obj()\n</code></pre> <pre><code># objective function: CFI\nobj = QuanEstimation.CFIM_obj(M=M)\n</code></pre> <pre><code># control algorithm: DE\nalg = QuanEstimation.DE(p_num=10, ini_population=([ctrl],), \n                        max_episode=1000, c=1.0, cr=0.5)\n</code></pre> QFIMCFIM <pre><code># objective function: QFI\nobj = QuanEstimation.QFIM_obj()\n</code></pre> <pre><code># objective function: CFI\nobj = QuanEstimation.CFIM_obj(M=M)\n</code></pre> <p>&lt;!-- === \"DDPG\"     <pre><code># control algorithm: DDPG\nalg = QuanEstimation.DDPG(max_episode=500, layer_num=4, layer_dim=220)\n</code></pre>     === \"QFIM\"         <pre><code># objective function: QFI\nobj = QuanEstimation.QFIM_obj()\n</code></pre>     === \"CFIM\"         <pre><code># objective function: CFI\nobj = QuanEstimation.CFIM_obj(M=M) --&gt;\n</code></pre> <pre><code># input the dynamics data\ndynamics = QuanEstimation.Lindblad(opt, tspan, rho0, H0, dH, Hc, decay, \n                                   dyn_method=:Expm)  \n# run the control optimization problem\nQuanEstimation.run(opt, alg, obj, dynamics; savefile=false)\n</code></pre></p> <p>Example 5.2  In the multiparameter scenario, the dynamics of electron and nuclear coupling in NV\\(^{-}\\) can  be expressed as \\begin{align} \\partial_t\\rho=-i[H_0,\\rho]+\\frac{\\gamma}{2}(S_3\\rho S_3-S^2_3\\rho-\\rho S^2_3) \\end{align}</p> <p>with \\(\\gamma\\) the dephasing rate. And \\begin{align} H_0/\\hbar=DS^2_3+g_{\\mathrm{S}}\\vec{B}\\cdot\\vec{S}+g_{\\mathrm{I}}\\vec{B}\\cdot\\vec{I}+\\vec{S}^ {\\,\\mathrm{T}}\\mathcal{A}\\vec{I} \\end{align}</p> <p>is the free evolution Hamiltonian, where \\(\\vec{S}=(S_1,S_2,S_3)^{\\mathrm{T}}\\) and  \\(\\vec{I}=(I_1,I_2,I_3)^{\\mathrm{T}}\\) with \\(S_i=s_i\\otimes I\\) and \\(I_i=I\\otimes \\sigma_i\\) \\((i=1,2,3)\\) the electron and nuclear operators. \\(s_1, s_2, and s_3\\) are spin-1 operators with </p> \\[\\begin{eqnarray} s_1 = \\frac{1}{\\sqrt{2}}\\left(\\begin{array}{ccc} 0 &amp; 1 &amp; 0 \\\\ 1 &amp; 0 &amp; 1 \\\\ 0 &amp; 1 &amp; 0 \\end{array}\\right), s_2 = \\frac{1}{\\sqrt{2}}\\left(\\begin{array}{ccc} 0 &amp; -i &amp; 0\\\\ i &amp; 0 &amp; -i\\\\ 0 &amp; i &amp; 0 \\end{array}\\right), \\nonumber \\end{eqnarray}\\] <p>and \\(s_3=\\mathrm{diag}(1,0,-1)\\) and \\(\\sigma_i (i=1,2,3)\\) is Pauli matrix. \\(\\mathcal{A}=\\mathrm{diag} (A_1,A_1,A_2)\\) is the hyperfine tensor with \\(A_1\\) and \\(A_2\\) the axial and transverse magnetic  hyperfine coupling coefficients. The coefficients \\(g_{\\mathrm{S}}=g_\\mathrm{e}\\mu_\\mathrm{B}/\\hbar\\)  and \\(g_{\\mathrm{I}}=g_\\mathrm{n}\\mu_\\mathrm{n}/\\hbar\\), where \\(g_\\mathrm{e}\\) (\\(g_\\mathrm{n}\\)) is  the \\(g\\) factor of the electron (nuclear), \\(\\mu_\\mathrm{B}\\) (\\(\\mu_\\mathrm{n}\\)) is the Bohr (nuclear)  magneton, and \\(\\hbar\\) is the Plank's constant. \\(\\vec{B}\\) is the magnetic field which be estimated.</p> <p>In this case, the initial state is taken as \\(\\frac{1}{\\sqrt{2}}(|1\\rangle+|\\!-\\!1\\rangle)\\otimes |\\!\\!\\uparrow\\rangle\\), where \\(\\frac{1}{\\sqrt{2}}(|1\\rangle+|\\!-\\!1\\rangle)\\) is an electron state  with \\(|1\\rangle\\) \\(\\left(|-\\!1\\rangle\\right)\\) the eigenstate of \\(s_3\\) with respect to the eigenvalue \\(1\\)  (\\(-1\\)). \\(|\\uparrow\\rangle\\) is a nuclear state and the eigenstate of \\(\\sigma_3\\) with respect  to the eigenvalue 1. \\(W\\) is set to be identity.</p> <p>Here three types of measurement optimization are considerd, projective measurement, linear combination of a given set of positive operator-valued measure (POVM) and optimal rotated measurement of an input measurement.</p> PythonJulia <pre><code>from quanestimation import *\nimport numpy as np\nfrom numpy.random import random\n\n# initial state\nrho0 = np.zeros((6, 6), dtype=np.complex128)\nrho0[0][0], rho0[0][4], rho0[4][0], rho0[4][4] = 0.5, 0.5, 0.5, 0.5\n# free Hamiltonian\nsx = np.array([[0., 1.],[1., 0.]])\nsy = np.array([[0., -1.j],[1.j, 0.]]) \nsz = np.array([[1., 0.],[0., -1.]])\nide2 = np.array([[1., 0.],[0., 1.]])\ns1 = np.array([[0., 1., 0.],[1., 0., 1.],[0., 1., 0.]])/np.sqrt(2)\ns2 = np.array([[0., -1.j, 0.],[1.j, 0., -1.j],[0., 1.j, 0.]])/np.sqrt(2)\ns3 = np.array([[1., 0., 0.],[0., 0., 0.],[0., 0., -1.]])\nide3 = np.array([[1., 0., 0.],[0., 1., 0.],[0., 0., 1.]])\nI1, I2, I3 = np.kron(ide3, sx), np.kron(ide3, sy), np.kron(ide3, sz)\nS1, S2, S3 = np.kron(s1, ide2), np.kron(s2, ide2), np.kron(s3, ide2)\nB1, B2, B3 = 5.0e-4, 5.0e-4, 5.0e-4\n# All numbers are divided by 100 in this example \n# for better calculation accurancy\ncons = 100\nD = (2*np.pi*2.87*1000)/cons\ngS = (2*np.pi*28.03*1000)/cons\ngI = (2*np.pi*4.32)/cons\nA1 = (2*np.pi*3.65)/cons\nA2 = (2*np.pi*3.03)/cons\nH0 = D*np.kron(np.dot(s3, s3), ide2) + gS*(B1*S1+B2*S2+B3*S3) \\\n     + gI*(B1*I1+B2*I2+B3*I3) + A1*(np.kron(s1, sx) + np.kron(s2, sy)) \\\n     + A2*np.kron(s3, sz)\n# derivatives of the free Hamiltonian on B1, B2 and B3\ndH = [gS*S1+gI*I1, gS*S2+gI*I2, gS*S3+gI*I3]\n# control Hamiltonians \nHc = [S1, S2, S3]\n# dissipation\ndecay = [[S3, 2*np.pi/cons]]\n# measurement\ndim = len(rho0)\nM = [np.dot(basis(dim, i), basis(dim, i).conj().T) for i in range(dim)]\n# time length for the evolution\ntspan = np.linspace(0., 2., 4000)\n# guessed control coefficients\ncnum = 10\nnp.random.seed(1234)\nini_1 = np.zeros((len(Hc),cnum))\nini_2 = 0.2*np.ones((len(Hc),cnum))\nini_3 = -0.2*np.ones((len(Hc),cnum))\nini_4 = np.array([np.linspace(-0.2,0.2,cnum) for i in range(len(Hc))])\nini_5 = np.array([np.linspace(-0.2,0.0,cnum) for i in range(len(Hc))])\nini_6 = np.array([np.linspace(0,0.2,cnum) for i in range(len(Hc))])\nini_7 = -0.2*np.ones((len(Hc),cnum))+0.01*random((len(Hc),cnum))\nini_8 = -0.2*np.ones((len(Hc),cnum))+0.01*random((len(Hc),cnum))\nini_9 = -0.2*np.ones((len(Hc),cnum))+0.05*random((len(Hc),cnum))\nini_10 = -0.2*np.ones((len(Hc),cnum))+0.05*random((len(Hc),cnum))\nctrl0 = [ini_1, ini_2, ini_3, ini_4, ini_5, \\\n         ini_6, ini_7, ini_8, ini_9, ini_10]\n</code></pre> auto-GRAPEPSODE <p><pre><code># control algorithm: auto-GRAPE\nGRAPE_paras = {\"Adam\":True, \"ctrl0\":ctrl0, \"max_episode\":300, \\\n               \"epsilon\":0.01, \"beta1\":0.90, \"beta2\":0.99}\ncontrol = ControlOpt(savefile=False, method=\"auto-GRAPE\", **GRAPE_paras)\n</code></pre> <pre><code># input the dynamics data\ncontrol.dynamics(tspan, rho0, H0, dH, Hc, decay=decay, \\\n                 ctrl_bound=[-0.2, 0.2], dyn_method=\"expm\")\n</code></pre></p> QFIMCFIM <pre><code># objective function: tr(WF^{-1})\ncontrol.QFIM()\n</code></pre> <pre><code># objective function: tr(WI^{-1})\ncontrol.CFIM(M=M)\n</code></pre> <p><pre><code># control algorithm: PSO\nPSO_paras = {\"p_num\":10, \"ctrl0\":ctrl0, \"max_episode\":[1000,100], \\\n             \"c0\":1.0, \"c1\":2.0, \"c2\":2.0, \"seed\":1234}\ncontrol = ControlOpt(savefile=False, method=\"PSO\", **PSO_paras)\n</code></pre> <pre><code># input the dynamics data\ncontrol.dynamics(tspan, rho0, H0, dH, Hc, decay=decay, \\\n                 ctrl_bound=[-0.2, 0.2], dyn_method=\"expm\")\n</code></pre></p> QFIMCFIMHCRB <pre><code># objective function: tr(WF^{-1})\ncontrol.QFIM()\n</code></pre> <pre><code># objective function: tr(WI^{-1})\ncontrol.CFIM(M=M)\n</code></pre> <pre><code># objective function: HCRB\ncontrol.HCRB()\n</code></pre> <p><pre><code># control algorithm: DE\nDE_paras = {\"p_num\":10, \"ctrl0\":ctrl0, \"max_episode\":1000, \"c\":1.0, \\\n            \"cr\":0.5, \"seed\":1234}\ncontrol = ControlOpt(savefile=False, method=\"DE\", **DE_paras)\n</code></pre> <pre><code># input the dynamics data\ncontrol.dynamics(tspan, rho0, H0, dH, Hc, decay=decay, \\\n                 ctrl_bound=[-0.2, 0.2], dyn_method=\"expm\")\n</code></pre></p> QFIMCFIMHCRB <pre><code># objective function: tr(WF^{-1})\ncontrol.QFIM()\n</code></pre> <pre><code># objective function: tr(WI^{-1})\ncontrol.CFIM(M=M)\n</code></pre> <pre><code># objective function: HCRB\ncontrol.HCRB()\n</code></pre> <pre><code>using QuanEstimation\nusing Random\nusing LinearAlgebra\n\n# initial state\nrho0 = zeros(ComplexF64, 6, 6)\nrho0[1:4:5, 1:4:5] .= 0.5\ndim = size(rho0, 1)\n# Hamiltonian\nsx = [0. 1.; 1. 0.]\nsy = [0. -im; im 0.]\nsz = [1. 0.; 0. -1.]\ns1 = [0. 1. 0.; 1. 0. 1.; 0. 1. 0.]/sqrt(2)\ns2 = [0. -im 0.; im 0. -im; 0. im 0.]/sqrt(2)\ns3 = [1. 0. 0.; 0. 0. 0.; 0. 0. -1.]\nIs = I1, I2, I3 = [kron(I(3), sx), kron(I(3), sy), kron(I(3), sz)]\nS = S1, S2, S3 = [kron(s1, I(2)), kron(s2, I(2)), kron(s3, I(2))]\nB = B1, B2, B3 = [5.0e-4, 5.0e-4, 5.0e-4]\n# All numbers are divided by 100 in this example \n# for better calculation accurancy\ncons = 100\nD = (2pi*2.87*1000)/cons\ngS = (2pi*28.03*1000)/cons\ngI = (2pi*4.32)/cons\nA1 = (2pi*3.65)/cons\nA2 = (2pi*3.03)/cons\nH0 = sum([D*kron(s3^2, I(2)), sum(gS*B.*S), sum(gI*B.*Is),\n          A1*(kron(s1, sx) + kron(s2, sy)), A2*kron(s3, sz)])\n# derivatives of the free Hamiltonian on B1, B2 and B3\ndH = gS*S+gI*Is\n# control Hamiltonians \nHc = [S1, S2, S3]\n# dissipation\ndecay = [[S3, 2*pi/cons]]\n# measurement\nM = [QuanEstimation.basis(dim, i)*QuanEstimation.basis(dim, i)' \n     for i in 1:dim]\n# time length for the evolution \ntspan = range(0., 2., length=4000)\n# guessed control coefficients\ncnum = 10\nrng = MersenneTwister(1234)\nini_1 = [zeros(cnum) for _ in 1:length(Hc)]\nini_2 = 0.2.*[ones(cnum) for _ in 1:length(Hc)]\nini_3 = -0.2.*[ones(cnum) for _ in 1:length(Hc)]\nini_4 = [[range(-0.2, 0.2, length=cnum)...] for _ in 1:length(Hc)]\nini_5 = [[range(-0.2, 0., length=cnum)...] for _ in 1:length(Hc)]\nini_6 = [[range(0., 0.2, length=cnum)...] for _ in 1:length(Hc)]\nini_7 = [-0.2*ones(cnum)+0.01*rand(rng,cnum) for _ in 1:length(Hc)]\nini_8 = [-0.2*ones(cnum)+0.01*rand(rng,cnum) for _ in 1:length(Hc)]\nini_9 = [-0.2*ones(cnum)+0.05*rand(rng,cnum) for _ in 1:length(Hc)]\nini_10 = [-0.2*ones(cnum)+0.05*rand(rng,cnum) for _ in 1:length(Hc)]\nctrl0 = [Symbol(\"ini_\", i)|&gt;eval for i in 1:10]\n# set the optimization type\nopt = QuanEstimation.ControlOpt(ctrl=ini_1, ctrl_bound=[-0.2, 0.2], seed=1234)\n</code></pre> auto-GRAPEPSODE <pre><code># control algorithm: auto-GRAPE\nalg = QuanEstimation.autoGRAPE(Adam=true, max_episode=300, epsilon=0.01, \n                               beta1=0.90, beta2=0.99)\n</code></pre> QFIMCFIM <pre><code># objective function: tr(WF^{-1})\nobj = QuanEstimation.QFIM_obj()\n</code></pre> <pre><code># objective function: tr(WI^{-1})\nobj = QuanEstimation.CFIM_obj(M=M)\n</code></pre> <pre><code># control algorithm: PSO\nalg = QuanEstimation.PSO(p_num=10, ini_particle=(ctrl0,), \n                         max_episode=[1000,100], c0=1.0, \n                         c1=2.0, c2=2.0)\n</code></pre> QFIMCFIMHCRB <pre><code># objective function: tr(WF^{-1})\nobj = QuanEstimation.QFIM_obj()\n</code></pre> <pre><code># objective function: tr(WI^{-1})\nobj = QuanEstimation.CFIM_obj(M=M)\n</code></pre> <pre><code># objective function: HCRB\nobj = QuanEstimation.HCRB_obj()\n</code></pre> <pre><code># control algorithm: DE\nalg = QuanEstimation.DE(p_num=10, ini_population=(ctrl0,), \n                        max_episode=1000, c=1.0, cr=0.5)\n</code></pre> QFIMCFIMHCRB <pre><code># objective function: tr(WF^{-1})\nobj = QuanEstimation.QFIM_obj()\n</code></pre> <pre><code># objective function: tr(WI^{-1})\nobj = QuanEstimation.CFIM_obj(M=M)\n</code></pre> <pre><code># objective function: HCRB\nobj = QuanEstimation.HCRB_obj()\n</code></pre> <p> ``` jl</p>"},{"location":"guide/guide_Copt/#input-the-dynamics-data","title":"input the dynamics data","text":"<p>control.dynamics(tspan, rho0, H0, dH, Hc, decay=decay, \\                  ctrl_bound=[-2.0, 2.0], dyn_method=\"expm\") ```</p> QFIMCFIM <p>``` py</p> <p>``` py</p>"},{"location":"guide/guide_Copt/#objective-function-qfi","title":"objective function: QFI","text":"<p>control.QFIM() ```</p>"},{"location":"guide/guide_Copt/#objective-function-cfi","title":"objective function: CFI","text":"<p>control.CFIM(M=M) ```</p>"},{"location":"guide/guide_Copt/#input-the-dynamics-data_1","title":"input the dynamics data","text":"<p>dynamics = QuanEstimation.Lindblad(opt, tspan, rho0, H0, dH, Hc, decay,                                     dyn_method=:Expm)  </p>"},{"location":"guide/guide_Copt/#run-the-control-optimization-problem","title":"run the control optimization problem","text":"<p>QuanEstimation.run(opt, alg, obj, dynamics; savefile=false) ```</p>"},{"location":"guide/guide_Copt/#minimum-parameterization-time-optimization","title":"Minimum parameterization time optimization","text":"<p>Search of the minimum time to reach a given value of the objective function.</p> PythonJulia <pre><code>control.mintime(f, W=[], M=[], method=\"binary\", target=\"QFIM\", \n                LDtype=\"SLD\")\n</code></pre> <pre><code>mintime(f, opt, alg, obj, dynamics; method=\"binary\", savefile=false)\n</code></pre> <p><code>f</code> is the given value of the objective function. In the package, two methods for searching  the minimum time are provided which are logarithmic search and forward search from the  beginning of time. It can be realized by setting <code>method=binary</code> (default) and  <code>method=forward</code>. <code>target</code> represents the objective function for searching the minimum time,  the users can choose QFI \\(\\left[\\mathrm{Tr}(WF^{-1})\\right]\\), CFI \\(\\left[\\mathrm{Tr}(WI^{-1})\\right]\\),  and HCRB for the objective functions. If <code>target=\"QFIM\"</code>, the types for the logarithmic derivatives  can be set via <code>LDtype</code>.</p>"},{"location":"guide/guide_Copt/#bibliography","title":"Bibliography","text":"<p>[1] N. Khaneja, T. Reiss, C. Hehlet, T. Schulte-Herbruggen, and S. J. Glaser, Optimal control of coupled spin dynamics: Design of NMR pulse sequences by gradient  ascent algorithms, J. Magn. Reson. 172, 296 (2005).</p> <p>[2] J. Liu and H. Yuan, Quantum parameter estimation with optimal control, Phys. Rev. A 96, 012117 (2017).</p> <p>[3] J. Liu and H. Yuan, Control-enhanced multiparameter quantum estimation, Phys. Rev. A 96, 042114 (2017).</p> <p>[4] A. G. Baydin, B. A. Pearlmutter, A. A. Radul, and J. M. Siskind, Automatic differentiation in machine learning: a survey, J. Mach. Learn. Res. 18, 1-43 (2018).</p> <p>[5] J. Kennedy and R. Eberhar, Particle swarm optimization, Proc. 1995 IEEE International Conference on Neural Networks 4, 1942-1948 (1995). </p> <p>[6] R. Storn and K. Price, Differential Evolution-A Simple and Efficient Heuristic for global Optimization over Continuous Spaces, J. Global Optim. 11, 341 (1997).</p>"},{"location":"guide/guide_Mopt/","title":"Measurement optimization","text":"<p>In QuanEstimation, three measurement optimization scenarios are considered. The first one is to optimize a set of rank-one projective measurement, it can be written in a specific basis \\(\\{|\\phi_i\\rangle\\}\\) with \\(|\\phi_i\\rangle=\\sum_j C_{ij}|j\\rangle\\) in the Hilbert space  as \\(\\{|\\phi_i\\rangle\\langle\\phi_i|\\}\\). In this case, the goal is to search a set of optimal  coefficients \\(C_{ij}\\). The second scenario is to find the optimal linear combination of  an input measurement \\(\\{\\Pi_j\\}\\). The third scenario is to find the optimal rotated  measurement of an input measurement. After rotation, the new measurement is \\(\\{U\\Pi_i U^{\\dagger}\\}\\), where \\(U=\\prod_k \\exp(i s_k\\lambda_k)\\) with \\(\\lambda_k\\) a SU(\\(N\\))  generator and \\(s_k\\) a real number in the regime \\([0,2\\pi]\\). In this scenario, the goal is  to search a set of optimal coefficients \\(s_k\\). Here different algorithms are invoked to  search the optimal measurement include particle swarm optimization (PSO) [1],  differential evolution (DE) [2], and automatic differentiation (AD)  [3]. The codes for execute measurement optimization are</p> PythonJulia <p><pre><code>m = MeasurementOpt(mtype=\"projection\", minput=[], savefile=False, \n                   method=\"DE\", **kwargs)\nm.dynamics(tspan, rho0, H0, dH, Hc=[], ctrl=[], decay=[], \\\n           dyn_method=\"expm\")\nm.CFIM(W=[])\n</code></pre> <code>mtype</code> represents the type of measurement optimization which defaults to <code>\"projection\"</code>.  In this setting, rank-one projective measurement optimization will be performed <code>minput</code>  will keep empty in this scenario. For the other two measurement optimization scenarios  <code>mtype=\"input\"</code>. If the users want to find the optimal linear combination of an input  measurement, the variable <code>minput</code> should be input as <code>minput=[\"LC\", [Pi1,Pi2,...], m]</code>  with <code>[Pi1,Pi2,...]</code> a set of POVM and <code>m</code> the number of operators of the output  measurement. For finding the optimal linear combination of an input measurement, the  variable <code>minput</code> becomes <code>minput=[\"rotation\", [Pi1,Pi2,...]]</code>. <code>savefile</code> means whether  to save all the measurements. If set <code>False</code> the measurements in the final episode and  the values of the objective function in all episodes will be saved, if <code>savefile=True</code>  the measurements and the values of the objective function obtained in all episodes will  be saved during the training. <code>method</code> represents the algorithm used to optimize the  measurements, options are: \"PSO\", \"DE\" and \"AD\". <code>**kwargs</code> is the keyword and default  value corresponding to the optimization algorithm which will be introduced in detail  below.</p> <p>If the dynamics of the system can be described by the master equation, then the dynamics data  <code>tspan</code>, <code>rho0</code>, <code>H0</code> and <code>dH</code> shoule be input. <code>tspan</code> is the time length for the evolution,  <code>rho0</code> represents the density matrix of the initial state, <code>H0</code> and <code>dH</code> are the free  Hamiltonian and its derivatives on the unknown parameters to be estimated. <code>H0</code> is a matrix  when the free Hamiltonian is time-independent and a list of matrices with the length equal to  <code>tspan</code> when it is time-dependent. <code>dH</code> should be input as \\([\\partial_a{H_0}, \\partial_b{H_0}, \\cdots]\\).  <code>Hc</code> and <code>ctrl</code> are two lists represent the control Hamiltonians and the corresponding control  coefficients. <code>decay</code> contains decay operators \\((\\Gamma_1,\\Gamma_2, \\cdots)\\) and the  corresponding decay rates \\((\\gamma_1, \\gamma_2, \\cdots)\\) with the input rule  decay=[[\\(\\Gamma_1\\), \\(\\gamma_1\\)], [\\(\\Gamma_2\\), \\(\\gamma_2\\)],...]. The default values for <code>decay</code>,  <code>Hc</code> and <code>ctrl</code> are empty which means the dynamics is unitary and only governed by the free  Hamiltonian. <code>dyn_method=\"expm\"</code> represents the method for solving the dynamics is  matrix exponential, it can also be set as <code>dyn_method=\"ode\"</code> which means the dynamics  (differential equation) is directly solved with the ODE solvers.</p> <p>The objective function for measurement optimization are CFI and \\(\\mathrm{Tr}(W\\mathcal{I}^ {-1})\\) with \\(\\mathcal{I}\\) the CFIM. \\(W\\) corresponds to <code>W</code> in the objective function is the  weight matrix which defaults to the identity matrix.</p> <p><pre><code>opt = MeasurementOpt(mtype=:Projection, seed=1234)\nalg = DE(kwargs...)\ndynamics = Lindblad(opt, tspan, rho0, H0, dH; Hc=missing, \n                    ctrl=missing, decay=missing, dyn_method=:Expm)\nobj = CFIM_obj(W=missing)\nrun(opt, alg, obj, dynamics; savefile=false)\n</code></pre> <code>mtype</code> represents the type of measurement optimization which defaults to <code>\"Projection\"</code>.  In this setting, rank-one projective measurement optimization will be performed. For the other  two measurement optimization scenarios this variable becomes <code>mtype=\"LC\"</code> and <code>mtype=\"Rotation\"</code>.  If the users want to find the optimal linear combination of an input measurement, the input  rule of <code>opt</code> is <code>MeasurementOpt(mtype=:LC,POVM_basis=[Pi1,Pi2,...],M_num=m)</code> with  <code>[Pi1,Pi2,...]</code> a set of POVM and <code>m</code> the number of operators of the output measurement.  For finding the optimal linear combination of an input measurement, the code <code>opt</code> is  <code>MeasurementOpt(mtype=:LC,POVM_basis=[Pi1,Pi2,...])</code>.  <code>seed</code> is the random seed which can  ensure the reproducibility of results.</p> <p>If the dynamics of the system can be described by the master equation, then the dynamics data  <code>tspan</code>, <code>rho0</code>, <code>H0</code> and <code>dH</code> shoule be input. <code>tspan</code> is the time length for the evolution,  <code>rho0</code> represents the density matrix of the initial state, <code>H0</code> and <code>dH</code> are the free  Hamiltonian and its derivatives on the unknown parameters to be estimated. <code>H0</code> is a matrix  when the free Hamiltonian is time-independent and a list of matrices with the length equal to  <code>tspan</code> when it is time-dependent. <code>dH</code> should be input as \\([\\partial_a{H_0}, \\partial_b{H_0}, \\cdots]\\).  <code>Hc</code> and <code>ctrl</code> are two lists represent the control Hamiltonians and the corresponding control  coefficients. <code>decay</code> contains decay operators \\((\\Gamma_1,\\Gamma_2, \\cdots)\\) and the  corresponding decay rates \\((\\gamma_1, \\gamma_2, \\cdots)\\) with the input rule  decay=[[\\(\\Gamma_1\\), \\(\\gamma_1\\)], [\\(\\Gamma_2\\), \\(\\gamma_2\\)],...]. The default values for <code>decay</code>,  <code>Hc</code> and <code>ctrl</code> are <code>missing</code> which means the dynamics is unitary and only governed by the free  Hamiltonian. <code>dyn_method=:Expm</code> represents the method for solving the dynamics is  matrix exponential, it can also be set as <code>dyn_method=:Ode</code> which means the dynamics  (differential equation) is directly solved with the ODE solvers.</p> <p>The objective function for measurement optimization are CFI and \\(\\mathrm{Tr}(W\\mathcal{I}^ {-1})\\) with \\(\\mathcal{I}\\) the CFIM. \\(W\\) corresponds to <code>W</code> in the objective function is the  weight matrix which defaults to the identity matrix. The variable <code>savefile</code> means whether to  save all the measurements. If set <code>false</code> the measurements in the final episode and the values  of the objective function in all episodes will be saved, if <code>savefile=true</code> the measurements  and the values of the objective function obtained in all episodes will be saved during the  training. The algorithm used for optimizing the measurements are PSO, DE and AD. <code>kwargs...</code>  is the keywords and default values corresponding to the optimization algorithm which will be  introduced in detail below.</p>"},{"location":"guide/guide_Mopt/#pso","title":"PSO","text":"<p>The code for measurement optimization with PSO is as follows</p> PythonJulia <p><pre><code>m = MeasurementOpt(method=\"PSO\", **kwargs)\n</code></pre> where <code>kwargs</code> is of the form <pre><code>kwargs = {\"p_num\":10, \"measurement0\":[], \"max_episode\":[1000,100], \\ \n          \"c0\":1.0, \"c1\":2.0, \"c2\":2.0, \"seed\":1234}\n</code></pre> The keywords and the default values of PSO can be seen in the following table</p> \\(~~~~~~~~~~\\)**kwargs\\(~~~~~~~~~~\\) \\(~~~~\\)default values\\(~~~~\\) \"p_num\" 10 \"measurement0\" [ ] \"max_episode\" [1000,100] \"c0\" 1.0 \"c1\" 2.0 \"c2\" 2.0 \"seed\" 1234 <p><code>p_num</code> is the number of particles, <code>c0</code>, <code>c1</code> and <code>c2</code> are the PSO parameters  representing the inertia weight, cognitive learning factor and social learning factor,  respectively. <code>max_episode</code> accepts both integers and arrays with two elements. If it is  an integer, for example <code>max_episode=1000</code>, it means the program will continuously run  1000 episodes. However, if it is an array, for example <code>max_episode=[1000,100]</code>, the  program will run 1000 episodes in total but replace control coefficients of all the  particles with global best every 100 episodes. <code>seed</code> is the random seed which can  ensure the reproducibility of the results. <code>measurement0</code> in the algorithm is a list  representing the initial guesses of measurements. In the case of projective measurement  optimization, the entry of <code>measurement0</code> is a list of arrays with the length equal to  the dimension of the system. In the cases of finding the optimal linear combination and  the optimal rotation of a given set of measurement, the entry of <code>measurement0</code> is a  2D-array and array, respectively. Here, an example of generating <code>measurement0</code> is given  as follows</p> <p>Example 7.1</p> projectionLCrotation <pre><code>from quanestimation import *\nimport numpy as np\n\n# the dimension of the system\ndim = 6\n# generation of the entry of `measurement0`\nC = [[] for i in range(dim)] \nfor i in range(dim):\n    r_ini = 2*np.random.random(dim)-np.ones(dim)\n    r = r_ini/np.linalg.norm(r_ini)\n    phi = 2*np.pi*np.random.random(dim)\n    C[i] = [r[j]*np.exp(1.0j*phi[j]) for j in range(dim)]\nC = np.array(gramschmidt(C))\nmeasurement0 = [C]\n</code></pre> <pre><code>from quanestimation import *\nimport numpy as np\n\n# the dimension of the system\ndim = 6\n# a given set of measurement\nPOVM_basis = SIC(dim)\n# the number of operators of the output measurement\nm = 4\n# generation of the entry of `measurement0`\nB = np.array([np.random.random(len(POVM_basis)) for i in range(m)])\nmeasurement0 = [B]\n</code></pre> <pre><code>from quanestimation import *\nimport numpy as np\n\n# the dimension of the system\ndim = 6\n# a given set of measurement\nPOVM_basis = SIC(dim)\n# generation of the entry of `measurement0`\ns = np.random.random(dim**2)\nmeasurement0 = [s]\n</code></pre> <p>In this algorithm, the length of <code>measurement0</code> should be less than or equal to <code>p_num</code>.</p> <p><pre><code>alg = PSO(p_num=10, ini_particle=missing, max_episode=[1000,100], \n          c0=1.0, c1=2.0, c2=2.0)\n</code></pre> The keywords and the default values of PSO can be seen in the following table</p> \\(~~~~~~~~~~\\)keywords\\(~~~~~~~~~~\\) \\(~~~~\\)default values\\(~~~~\\) \"p_num\" 10 \"ini_particle\" missing \"max_episode\" [1000,100] \"c0\" 1.0 \"c1\" 2.0 \"c2\" 2.0 <p><code>p_num</code> is the number of particles, <code>c0</code>, <code>c1</code>, and <code>c2</code> are the PSO parameters representing  the inertia weight, cognitive learning factor, and social learning factor, respectively.  <code>max_episode</code> accepts both integers and arrays with two elements. If it is an integer,  for example <code>max_episode=1000</code>, it means the program will continuously run 1000 episodes.  However, if it is an array, for example <code>max_episode=[1000,100]</code>, the program will run 1000  episodes in total but replace control coefficients of all the particles with global best  every 100 episodes. <code>ini_particle</code> in the algorithm is a list representing the initial guesses  of measurements, In the case of projective measurement optimization, the entry of <code>ini_particle</code>  is a list of arrays with the length equal to the dimension of the system. In the cases of  finding the optimal linear combination and the optimal rotation of a given set of measurement,  the entry of <code>ini_particle</code> is a 2D-array and array, respectively. Here, an example of  generating <code>ini_particle</code> is given as follows</p> <p>Example 7.1</p> ProjectionLCRotation <pre><code>using QuanEstimation\n\n# the dimension of the system\ndim = 6\n# generation of the entry of `measurement0`\nC = [ComplexF64[] for _ in 1:dim]\nfor i in 1:dim\n    r_ini = 2*rand(dim) - ones(dim)\n    r = r_ini/norm(r_ini)\n    \u03d5 = 2pi*rand(dim)\n    C[i] = [r*exp(im*\u03d5) for (r,\u03d5) in zip(r,\u03d5)] \nend\nC = QuanEstimation.gramschmidt(C)\nmeasurement0 = ([C],)\n</code></pre> <pre><code>using QuanEstimation\n\n# the dimension of the system\ndim = 6\n# a given set of measurement\nPOVM_basis = QuanEstimation.SIC(dim)\n# the number of operators of the output measurement\nm = 4\n# generation of the entry of `measurement0`\nB = [rand(length(POVM_basis)) for _ in 1:m]\nmeasurement0 = ([B],)\n</code></pre> <pre><code>using QuanEstimation\n\n# the dimension of the system\ndim = 6\n# a given set of measurement\nPOVM_basis = QuanEstimation.SIC(dim)\n# generation of the entry of `measurement0`\ns = rand(dim^2)\nmeasurement0 = ([s],)\n</code></pre> <p>In this algorithm, the length of <code>measurement0</code> should be less than or equal to <code>p_num</code>.</p>"},{"location":"guide/guide_Mopt/#de","title":"DE","text":"<p>The code for measurement optimization with DE is as follows</p> PythonJulia <p><pre><code>m = MeasurementOpt(method=\"DE\", **kwargs)\n</code></pre> where <code>kwargs</code> is of the form <pre><code>kwargs = {\"p_num\":10, \"measurement0\":[], \"max_episode\":1000, \\\n          \"c\":1.0, \"cr\":0.5, \"seed\":1234}\n</code></pre> The keywords and the default values of DE can be seen in the following table</p> \\(~~~~~~~~~~\\)**kwargs\\(~~~~~~~~~~\\) \\(~~~~\\)default values\\(~~~~\\) \"p_num\" 10 \"measurement0\" [ ] \"max_episode\" 1000 \"c\" 1.0 \"cr\" 0.5 \"seed\" 1234 <p><code>p_num</code> represents the number of populations, <code>c</code> and <code>cr</code> are the mutation constant and the  crossover constant. Here <code>max_episode</code> is an integer representing the number of episodes,  the variable <code>measurement0</code> is the same with <code>measurement0</code> in PSO.</p> <p><pre><code>alg = DE(p_num=10, ini_population=missing, max_episode=1000, \n         c=1.0, cr=0.5)\n</code></pre>     The keywords and the default values of DE can be seen in the following table</p> \\(~~~~~~~~~~\\)keywords\\(~~~~~~~~~~\\) \\(~~~~\\)default values\\(~~~~\\) \"p_num\" 10 \"ini_population\" [ ] \"max_episode\" 1000 \"c\" 1.0 \"cr\" 0.5 <p><code>p_num</code> represents the number of populations, <code>c</code> and <code>cr</code> are the mutation constant  and the crossover constant. Here <code>max_episode</code> is an integer representing the number of  episodes, the variable <code>ini_population</code> is the same with <code>ini_particle</code> in PSO.</p>"},{"location":"guide/guide_Mopt/#ad","title":"AD","text":"<p>The code for measurement optimization with AD is as follows</p> PythonJulia <p><pre><code>com = MeasurementOpt(method=\"AD\", **kwargs)\n</code></pre> where <code>kwargs</code> is of the form <pre><code>kwargs = {\"Adam\":False, \"measurement0\":[], \"max_episode\":300, \\ \n          \"epsilon\":0.01, \"beta1\":0.90, \"beta2\":0.99}\n</code></pre> The keywords and the default values of AD can be seen in the following  table</p> \\(~~~~~~~~~~\\)**kwargs\\(~~~~~~~~~~\\) \\(~~~~\\)default values\\(~~~~\\) \"Adam\" False \"measurement0\" [ ] \"max_episode\" 300 \"epsilon\" 0.01 \"beta1\" 0.90 \"beta2\" 0.99 <p>The measurements will update according to the learning rate <code>\"epsilon\"</code> for <code>Adam=False</code>,  However,  Adam algorithm can be introduced to update the measurements which can be realized by  setting <code>Adam=True</code>. In this case, the Adam parameters include learning rate, the exponential  decay rate for the first moment estimates, and the second moment estimates can be set by the  user via <code>epsilon</code>, <code>beta1</code>, and <code>beta2</code>. The input rule of <code>measurement0</code> is the same with  that in PSO, but the length of <code>measurement0</code> is equal to one.</p> <p><pre><code>alg = AD(Adam=false, max_episode=300, epsilon=0.01, beta1=0.90, \n         beta2=0.99)\n</code></pre> The keywords and the default values of AD can be seen in the following  table</p> \\(~~~~~~~~~~\\)keywords\\(~~~~~~~~~~\\) \\(~~~~\\)default values\\(~~~~\\) \"Adam\" false \"max_episode\" 300 \"epsilon\" 0.01 \"beta1\" 0.90 \"beta2\" 0.99 <p>The measurements will update according to the learning rate <code>\"epsilon\"</code> for <code>Adam=False</code>,  However,  Adam algorithm can be introduced to update the measurements which can be realized by  setting <code>Adam=true</code>. In this case, the Adam parameters include learning rate, the exponential  decay rate for the first moment estimates, and the second moment estimates can be set by the  user via <code>epsilon</code>, <code>beta1</code>, and <code>beta2</code>.</p> <p>Example 7.2  A single qubit system whose dynamics is governed by</p> \\[\\begin{align} \\partial_t\\rho=-i[H, \\rho]+ \\gamma_{+}\\left(\\sigma_{+}\\rho\\sigma_{-}-\\frac{1}{2}\\{\\sigma_{-} \\sigma_{+},\\rho\\}\\right)+ \\gamma_{-}\\left(\\sigma_{-}\\rho\\sigma_{+}-\\frac{1}{2}\\{\\sigma_{+} \\sigma_{-},\\rho\\}\\right), \\end{align}\\] <p>where \\(H = \\frac{1}{2}\\omega \\sigma_3\\) is the free Hamiltonian with \\(\\omega\\) the frequency,  \\(\\sigma_{\\pm}=(\\sigma_1 \\pm \\sigma_2)/2\\) and \\(\\gamma_{+}\\), \\(\\gamma_{-}\\) are decay rates. Here \\(\\sigma_{i}\\) for \\((i=1,2,3)\\) is the  Pauli matrix.</p> <p>In this case, the probe state is taken as \\(\\frac{1}{\\sqrt{2}}(|0\\rangle +|1\\rangle)\\),  \\(|0\\rangle\\) \\((|1\\rangle)\\) is the eigenstate of \\(\\sigma_3\\) with respect to the eigenvalue  \\(1\\) \\((-1)\\). </p> PythonJulia <pre><code>from quanestimation import *\nimport numpy as np\n\n# initial state\nrho0 = 0.5*np.array([[1., 1.], [1., 1.]])\n# free Hamiltonian\nomega = 1.0\nsx = np.array([[0., 1.], [1., 0.]])\nsy = np.array([[0., -1.j], [1.j, 0.]]) \nsz = np.array([[1., 0.], [0., -1.]])\nH0 = 0.5*omega*sz\n# derivative of the free Hamiltonian on omega\ndH = [0.5*sz]\n# dissipation\nsp = np.array([[0., 1.], [0., 0.]])  \nsm = np.array([[0., 0.], [1., 0.]]) \ndecay = [[sp, 0.], [sm, 0.1]]\n# generation of a set of POVM basis\ndim = np.shape(rho0)[0]\nPOVM_basis = SIC(dim)\n# time length for the evolution\ntspan = np.linspace(0., 10., 2500)\n</code></pre> projectionLCrotation DEPSO <pre><code>M_num = dim\n# measurement optimization algorithm: DE\nDE_paras = {\"p_num\":10, \"measurement0\":[], \"max_episode\":1000, \\\n            \"c\":1.0, \"cr\":0.5, \"seed\":1234}\nm = MeasurementOpt(mtype=\"projection\", minput=[], savefile=False, \\\n                   method=\"DE\", **DE_paras)\n</code></pre> <pre><code>M_num = dim\n# measurement optimization algorithm: PSO\nPSO_paras = {\"p_num\":10, \"measurement0\":[], \\\n             \"max_episode\":[1000,100], \"c0\":1.0, \\\n            \"c1\":2.0, \"c2\":2.0, \"seed\":1234}\nm = MeasurementOpt(mtype=\"projection\", minput=[], savefile=False, \\\n                   method=\"PSO\", **PSO_paras)\n</code></pre> DEPSOAD <pre><code>M_num = 2\n# measurement optimization algorithm: DE\nDE_paras = {\"p_num\":10, \"measurement0\":[], \"max_episode\":1000, \\\n            \"c\":1.0, \"cr\":0.5, \"seed\":1234}\nm = MeasurementOpt(mtype=\"input\", minput=[\"LC\", POVM_basis, M_num], \\\n                   savefile=False, method=\"DE\", **DE_paras)\n</code></pre> <pre><code>M_num = 2\n# measurement optimization algorithm: PSO\nPSO_paras = {\"p_num\":10, \"measurement0\":[], \"max_episode\":[1000,100], \\\n             \"c0\":1.0, \"c1\":2.0, \"c2\":2.0, \"seed\":1234}\nm = MeasurementOpt(mtype=\"input\", minput=[\"LC\", POVM_basis, M_num], \\\n                   savefile=False, method=\"PSO\", **PSO_paras)\n</code></pre> <pre><code>M_num = 2\n# measurement optimization algorithm: AD\nAD_paras = {\"Adam\":False, \"measurement0\":[], \"max_episode\":300, \\\n            \"epsilon\":0.01, \"beta1\":0.90, \"beta2\":0.99}\nm = MeasurementOpt(mtype=\"input\", minput=[\"LC\", POVM_basis, M_num], \\\n                   savefile=False, method=\"AD\", **AD_paras)\n</code></pre> DEPSOAD <pre><code>M_num = dim\n# measurement optimization algorithm: DE\nDE_paras = {\"p_num\":10, \"measurement0\":[], \"max_episode\":1000, \\\n            \"c\":1.0, \"cr\":0.5, \"seed\":1234}\nm = MeasurementOpt(mtype=\"input\", minput=[\"rotation\", POVM_basis], \\\n                   savefile=False, method=\"DE\", **DE_paras)\n</code></pre> <pre><code>M_num = dim\n# measurement optimization algorithm: PSO\nPSO_paras = {\"p_num\":10, \"measurement0\":[], \\\n             \"max_episode\":[1000,100], \"c0\":1.0, \\\n             \"c1\":2.0, \"c2\":2.0, \"seed\":1234}\nm = MeasurementOpt(mtype=\"input\", minput=[\"rotation\", POVM_basis], \\\n                   savefile=False, method=\"PSO\", **PSO_paras)\n</code></pre> <pre><code>M_num = dim\n# measurement optimization algorithm: AD\nAD_paras = {\"Adam\":False, \"measurement0\":[], \"max_episode\":300, \\\n            \"epsilon\":0.01, \"beta1\":0.90, \"beta2\":0.99}\nm = MeasurementOpt(mtype=\"input\", minput=[\"rotation\", POVM_basis], \\\n                   savefile=False, method=\"AD\", **AD_paras)\n</code></pre> <pre><code># input the dynamics data\nm.dynamics(tspan, rho0, H0, dH, decay=decay, dyn_method=\"expm\")\n# objective function: CFI\nm.CFIM()\n# convert the \".csv\" file to the \".npy\" file\nM_ = np.loadtxt(\"measurements.csv\", dtype=np.complex128)\ncsv2npy_measurements(M_, M_num)\n# load the measurements\nM = np.load(\"measurements.npy\")[-1]\n</code></pre> <pre><code>using QuanEstimation\nusing Random\nusing StableRNGs\nusing LinearAlgebra\nusing DelimitedFiles\n\n# initial state\nrho0 = 0.5*ones(2, 2)\n# free Hamiltonian\nomega = 1.0\nsx = [0. 1.; 1. 0.0im]\nsy = [0. -im; im 0.]\nsz = [1. 0.0im; 0. -1.]\nH0 = 0.5*omega*sz\n# derivative of the free Hamiltonian on omega\ndH = [0.5*sz]\n# dissipation\nsp = [0. 1.; 0. 0.0im]\nsm = [0. 0.; 1. 0.0im]\ndecay = [[sp, 0.], [sm, 0.1]]\n# generation of a set of POVM basis\ndim = size(rho0, 1)\nPOVM_basis = QuanEstimation.SIC(dim)\nM_num = dim\n# time length for the evolution\ntspan = range(0., 10., length=2500)\n</code></pre> ProjectionLCRotation <pre><code>opt = QuanEstimation.MeasurementOpt(mtype=:Projection, seed=1234)\n</code></pre> DEPSO <pre><code># measurement optimization algorithm: DE\nalg = QuanEstimation.DE(p_num=10, ini_population=missing, \n                        max_episode=1000, c=1.0, cr=0.5)\n</code></pre> <pre><code># measurement optimization algorithm: PSO\nalg = QuanEstimation.PSO(p_num=10, ini_particle=missing, \n                         max_episode=[1000,100], c0=1.0, c1=2.0, \n                         c2=2.0)\n</code></pre> <pre><code>opt = QuanEstimation.MeasurementOpt(mtype=:LC, \n                                    POVM_basis=POVM_basis, M_num=M_num, \n                                    seed=1234)\n</code></pre> DEPSOAD <pre><code># measurement optimization algorithm: DE\nalg = QuanEstimation.DE(p_num=10, ini_population=missing, \n                        max_episode=1000, c=1.0, cr=0.5)\n</code></pre> <pre><code># measurement optimization algorithm: PSO\nalg = QuanEstimation.PSO(p_num=10, ini_particle=missing, \n                         max_episode=[1000,100], c0=1.0, c1=2.0, \n                         c2=2.0)\n</code></pre> <pre><code># measurement optimization algorithm: AD\nalg = QuanEstimation.AD(Adam=true, max_episode=300, epsilon=0.01, \n                        beta1=0.90, beta2=0.99)\n</code></pre> <pre><code>opt = QuanEstimation.MeasurementOpt(mtype=:Rotation, \n                                    POVM_basis=POVM_basis, seed=1234)\n</code></pre> DEPSOAD <pre><code># measurement optimization algorithm: DE\nalg = QuanEstimation.DE(p_num=10, ini_population=missing, \n                        max_episode=1000, c=1.0, cr=0.5)\n</code></pre> <pre><code># measurement optimization algorithm: PSO\nalg = QuanEstimation.PSO(p_num=10, ini_particle=missing, \n                         max_episode=[1000,100], c0=1.0, c1=2.0, \n                         c2=2.0)\n</code></pre> <pre><code># measurement optimization algorithm: AD\nalg = QuanEstimation.AD(Adam=true, max_episode=300, epsilon=0.01, \n                        beta1=0.90, beta2=0.99)\n</code></pre> <pre><code># input the dynamics data\ndynamics = QuanEstimation.Lindblad(opt, tspan ,rho0, H0, dH, \n                                   decay=decay, dyn_method=:Expm)\n# objective function: CFI\nobj = QuanEstimation.CFIM_obj()\n# run the measurement optimization problem\nQuanEstimation.run(opt, alg, obj, dynamics; savefile=false)\n\n# convert the flattened data into a list of matrix\nM_ = readdlm(\"measurements.csv\",'\\t', Complex{Float64})\nM = [[reshape(M_[i,:], dim, dim) for i in 1:M_num] \n    for j in 1:Int(length(M_[:,1])/M_num)][end]\n</code></pre> <p>Example 7.3  In the multiparameter scenario, the dynamics of electron and nuclear coupling in NV\\(^{-}\\) can be expressed as \\begin{align} \\partial_t\\rho=-i[H_0,\\rho]+\\frac{\\gamma}{2}(S_3\\rho S_3-S^2_3\\rho-\\rho S^2_3) \\end{align}</p> <p>with \\(\\gamma\\) the dephasing rate. And \\begin{align} H_0/\\hbar=DS^2_3+g_{\\mathrm{S}}\\vec{B}\\cdot\\vec{S}+g_{\\mathrm{I}}\\vec{B}\\cdot\\vec{I}+\\vec{S}^{\\,\\mathrm{T}}\\mathcal{A}\\vec{I} \\end{align}</p> <p>is the free evolution Hamiltonian, where \\(\\vec{S}=(S_1,S_2,S_3)^{\\mathrm{T}}\\) and \\(\\vec{I}=(I_1,I_2,I_3)^{\\mathrm{T}}\\)  with \\(S_i=s_i\\otimes I\\) and \\(I_i=I\\otimes \\sigma_i\\) \\((i=1,2,3)\\) the electron and nuclear operators.  \\(s_1, s_2, s_3\\) are spin-1 operators with </p> \\[\\begin{eqnarray} s_1 = \\frac{1}{\\sqrt{2}}\\left(\\begin{array}{ccc} 0 &amp; 1 &amp; 0 \\\\ 1 &amp; 0 &amp; 1 \\\\ 0 &amp; 1 &amp; 0 \\end{array}\\right), s_2 = \\frac{1}{\\sqrt{2}}\\left(\\begin{array}{ccc} 0 &amp; -i &amp; 0\\\\ i &amp; 0 &amp; -i\\\\ 0 &amp; i &amp; 0 \\end{array}\\right), \\nonumber \\end{eqnarray}\\] <p>and \\(s_3=\\mathrm{diag}(1,0,-1)\\) and \\(\\sigma_i (i=1,2,3)\\) is Pauli matrix. \\(\\mathcal{A}=\\mathrm{diag} (A_1,A_1,A_2)\\) is the hyperfine tensor with \\(A_1\\) and \\(A_2\\) the axial and transverse magnetic hyperfine coupling coefficients. The coefficients \\(g_{\\mathrm{S}}=g_\\mathrm{e}\\mu_\\mathrm{B}/\\hbar\\) and \\(g_{\\mathrm{I}}=g_\\mathrm{n}\\mu_\\mathrm{n}/\\hbar\\),  where \\(g_\\mathrm{e}\\) (\\(g_\\mathrm{n}\\)) is the \\(g\\) factor of the electron (nuclear), \\(\\mu_\\mathrm{B}\\) (\\(\\mu_\\mathrm{n}\\)) is  the Bohr (nuclear) magneton and \\(\\hbar\\) is the Plank's constant. \\(\\vec{B}\\) is the magnetic field which be estimated.</p> <p>In this case,the initial state is taken as \\(\\frac{1}{\\sqrt{2}}(|1\\rangle+|\\!-\\!1\\rangle)\\otimes|\\!\\!\\uparrow\\rangle\\),  where \\(\\frac{1}{\\sqrt{2}}(|1\\rangle+|\\!-\\!1\\rangle)\\) is an electron state with \\(|1\\rangle\\) (\\(|\\!-\\!1\\rangle\\)) the  eigenstate of \\(s_3\\) with respect to the eigenvalue \\(1\\) (\\(-1\\)). \\(|\\!\\!\\uparrow\\rangle\\) is a nuclear state and  the eigenstate of \\(\\sigma_3\\) with respect to the eigenvalue 1. \\(W\\) is set to be \\(I\\).</p> <p>Here three types of measurement optimization are considerd, projective measurement, linear combination of a given set of positive operator-valued measure (POVM) and optimal rotated measurement of an input measurement.</p> PythonJulia <pre><code>from quanestimation import *\nimport numpy as np\n\n# initial state\nrho0 = np.zeros((6, 6), dtype=np.complex128)\nrho0[0][0], rho0[0][4], rho0[4][0], rho0[4][4] = 0.5, 0.5, 0.5, 0.5\n# free Hamiltonian\nsx = np.array([[0., 1.],[1., 0.]])\nsy = np.array([[0., -1.j],[1.j, 0.]]) \nsz = np.array([[1., 0.],[0., -1.]])\nide2 = np.array([[1., 0.],[0., 1.]])\ns1 = np.array([[0., 1., 0.],[1., 0., 1.],[0., 1., 0.]])/np.sqrt(2)\ns2 = np.array([[0., -1.j, 0.],[1.j, 0., -1.j],[0., 1.j, 0.]])/np.sqrt(2)\ns3 = np.array([[1., 0., 0.],[0., 0., 0.],[0., 0., -1.]])\nide3 = np.array([[1., 0., 0.],[0., 1., 0.],[0., 0., 1.]])\nI1, I2, I3 = np.kron(ide3, sx), np.kron(ide3, sy), np.kron(ide3, sz)\nS1, S2, S3 = np.kron(s1, ide2), np.kron(s2, ide2), np.kron(s3, ide2)\nB1, B2, B3 = 5.0e-4, 5.0e-4, 5.0e-4\n# All numbers are divided by 100 in this example \n# for better calculation accurancy\ncons = 100\nD = (2*np.pi*2.87*1000)/cons\ngS = (2*np.pi*28.03*1000)/cons\ngI = (2*np.pi*4.32)/cons\nA1 = (2*np.pi*3.65)/cons\nA2 = (2*np.pi*3.03)/cons\nH0 = D*np.kron(np.dot(s3, s3), ide2) + gS*(B1*S1+B2*S2+B3*S3) \\\n     + gI*(B1*I1+B2*I2+B3*I3) + A1*(np.kron(s1, sx) + np.kron(s2, sy)) \\\n     + A2*np.kron(s3, sz)\n# derivatives of the free Hamiltonian on B1, B2, and B3\ndH = [gS*S1+gI*I1, gS*S2+gI*I2, gS*S3+gI*I3]\n# control Hamiltonians \nHc = [S1, S2, S3]\n# dissipation\ndecay = [[S3,2*np.pi/cons]]\n# generation of a set of POVM basis\ndim = len(rho0)\nPOVM_basis = [np.dot(basis(dim, i), basis(dim, i).conj().T) \\\n              for i in range(dim)]\n# time length for the evolution\ntspan = np.linspace(0., 2., 4000)\n</code></pre> projectionLCrotation DEPSO <pre><code>M_num = dim\n# measurement optimization algorithm: DE\nDE_paras = {\"p_num\":10, \"measurement0\":[], \"max_episode\":1000, \\\n            \"c\":1.0, \"cr\":0.5, \"seed\":1234}\nm = MeasurementOpt(mtype=\"projection\", minput=[], savefile=False, \\\n                   method=\"DE\", **DE_paras)\n</code></pre> <pre><code>M_num = dim\n# measurement optimization algorithm: PSO\nPSO_paras = {\"p_num\":10, \"measurement0\":[], \\\n             \"max_episode\":[1000,100], \"c0\":1.0, \\\n            \"c1\":2.0, \"c2\":2.0, \"seed\":1234}\nm = MeasurementOpt(mtype=\"projection\", minput=[], savefile=False, \\\n                   method=\"PSO\", **PSO_paras)\n</code></pre> DEPSOAD <pre><code>M_num = 4\n# measurement optimization algorithm: DE\nDE_paras = {\"p_num\":10, \"measurement0\":[], \"max_episode\":1000, \\\n            \"c\":1.0, \"cr\":0.5, \"seed\":1234}\nm = MeasurementOpt(mtype=\"input\", minput=[\"LC\", POVM_basis, M_num], \\\n                   savefile=False, method=\"DE\", **DE_paras)\n</code></pre> <pre><code>M_num = 4\n# measurement optimization algorithm: PSO\nPSO_paras = {\"p_num\":10, \"measurement0\":[], \"max_episode\":[1000,100], \\\n             \"c0\":1.0, \"c1\":2.0, \"c2\":2.0, \"seed\":1234}\nm = MeasurementOpt(mtype=\"input\", minput=[\"LC\", POVM_basis, M_num], \\\n                   savefile=False, method=\"PSO\", **PSO_paras)\n</code></pre> <pre><code>M_num = 4\n# measurement optimization algorithm: AD\nAD_paras = {\"Adam\":False, \"measurement0\":[], \"max_episode\":300, \\\n            \"epsilon\":0.01, \"beta1\":0.90, \"beta2\":0.99}\nm = MeasurementOpt(mtype=\"input\", minput=[\"LC\", POVM_basis, M_num], \\\n                   savefile=False, method=\"AD\", **AD_paras)\n</code></pre> DEPSOAD <pre><code>M_num = dim\n# measurement optimization algorithm: DE\nDE_paras = {\"p_num\":10, \"measurement0\":[], \"max_episode\":1000, \\\n            \"c\":1.0, \"cr\":0.5, \"seed\":1234}\nm = MeasurementOpt(mtype=\"input\", minput=[\"rotation\", POVM_basis], \\\n                   savefile=False, method=\"DE\", **DE_paras)\n</code></pre> <pre><code>M_num = dim\n# measurement optimization algorithm: PSO\nPSO_paras = {\"p_num\":10, \"measurement0\":[], \\\n             \"max_episode\":[1000,100], \"c0\":1.0, \\\n             \"c1\":2.0, \"c2\":2.0, \"seed\":1234}\nm = MeasurementOpt(mtype=\"input\", minput=[\"rotation\", POVM_basis], \\\n                   savefile=False, method=\"PSO\", **PSO_paras)\n</code></pre> <pre><code>M_num = dim\n# measurement optimization algorithm: AD\nAD_paras = {\"Adam\":False, \"measurement0\":[], \"max_episode\":300, \\\n            \"epsilon\":0.01, \"beta1\":0.90, \"beta2\":0.99}\nm = MeasurementOpt(mtype=\"input\", minput=[\"rotation\", POVM_basis], \\\n                   savefile=False, method=\"AD\", **AD_paras)\n</code></pre> <pre><code># input the dynamics data\nm.dynamics(tspan, rho0, H0, dH, decay=decay, dyn_method=\"expm\")\n# objective function: tr(WI^{-1})\nm.CFIM()\n# convert the \".csv\" file to the \".npy\" file\nM_ = np.loadtxt(\"measurements.csv\", dtype=np.complex128)\ncsv2npy_measurements(M_, M_num)\n# load the measurements\nM = np.load(\"measurements.npy\")[-1]\n</code></pre> <pre><code>using QuanEstimation\nusing Random\nusing LinearAlgebra\nusing DelimitedFiles\n\n# initial state\nrho0 = zeros(ComplexF64, 6, 6)\nrho0[1:4:5, 1:4:5] .= 0.5\n# Hamiltonian\nsx = [0. 1.; 1. 0.]\nsy = [0. -im; im 0.]\nsz = [1. 0.; 0. -1.]\ns1 = [0. 1. 0.; 1. 0. 1.; 0. 1. 0.]/sqrt(2)\ns2 = [0. -im 0.; im 0. -im; 0. im 0.]/sqrt(2)\ns3 = [1. 0. 0.; 0. 0. 0.; 0. 0. -1.]\nIs = I1, I2, I3 = [kron(I(3), sx), kron(I(3), sy), kron(I(3), sz)]\nS = S1, S2, S3 = [kron(s1, I(2)), kron(s2, I(2)), kron(s3, I(2))]\nB = B1, B2, B3 = [5.0e-4, 5.0e-4, 5.0e-4]\n# All numbers are divided by 100 in this example \n# for better calculation accurancy\ncons = 100\nD = (2pi*2.87*1000)/cons\ngS = (2pi*28.03*1000)/cons\ngI = (2pi*4.32)/cons\nA1 = (2pi*3.65)/cons\nA2 = (2pi*3.03)/cons\nH0 = sum([D*kron(s3^2, I(2)), sum(gS*B.*S), sum(gI*B.*Is),\n          A1*(kron(s1, sx) + kron(s2, sy)), A2*kron(s3, sz)])\n# derivatives of the free Hamiltonian on B1, B2 and B3\ndH = gS*S+gI*Is\n# control Hamiltonians \nHc = [S1, S2, S3]\n# dissipation\ndecay = [[S3, 2pi/cons]]\n# generation of a set of POVM basis\ndim = size(rho0, 1)\nPOVM_basis = [QuanEstimation.basis(dim, i)*QuanEstimation.basis(dim, i)' \n              for i in 1:dim]\n# time length for the evolution\ntspan = range(0., 2., length=4000)\n</code></pre> ProjectionLCRotation <pre><code>M_num = dim\nopt = QuanEstimation.MeasurementOpt(mtype=:Projection, seed=1234)\n</code></pre> DEPSO <pre><code># measurement optimization algorithm: DE\nalg = QuanEstimation.DE(p_num=10, ini_population=missing, \n                        max_episode=1000, c=1.0, cr=0.5)\n</code></pre> <pre><code># measurement optimization algorithm: PSO\nalg = QuanEstimation.PSO(p_num=10, ini_particle=missing, \n                         max_episode=[1000,100], c0=1.0, c1=2.0, \n                         c2=2.0)\n</code></pre> <pre><code>M_num = 4\nopt = QuanEstimation.MeasurementOpt(mtype=:LC, \n                                    POVM_basis=POVM_basis, M_num=M_num, \n                                    seed=1234)\n</code></pre> DEPSOAD <pre><code># measurement optimization algorithm: DE\nalg = QuanEstimation.DE(p_num=10, ini_population=missing, \n                        max_episode=1000, c=1.0, cr=0.5)\n</code></pre> <pre><code># measurement optimization algorithm: PSO\nalg = QuanEstimation.PSO(p_num=10, ini_particle=missing, \n                         max_episode=[1000,100], c0=1.0, c1=2.0, \n                         c2=2.0)\n</code></pre> <pre><code># measurement optimization algorithm: AD\nalg = QuanEstimation.AD(Adam=true, max_episode=300, epsilon=0.01, \n                        beta1=0.90, beta2=0.99)\n</code></pre> <pre><code>M_num = dim\nopt = QuanEstimation.MeasurementOpt(mtype=:Rotation, \n                                    POVM_basis=POVM_basis, seed=1234)\n</code></pre> DEPSOAD <pre><code># measurement optimization algorithm: DE\nalg = QuanEstimation.DE(p_num=10, ini_population=missing, \n                        max_episode=1000, c=1.0, cr=0.5)\n</code></pre> <pre><code># measurement optimization algorithm: PSO\nalg = QuanEstimation.PSO(p_num=10, ini_particle=missing, \n                         max_episode=[1000,100], c0=1.0, c1=2.0, \n                         c2=2.0)\n</code></pre> <pre><code># measurement optimization algorithm: AD\nalg = QuanEstimation.AD(Adam=true, max_episode=300, epsilon=0.01, \n                        beta1=0.90, beta2=0.99)\n</code></pre> <pre><code># input the dynamics data\ndynamics = QuanEstimation.Lindblad(opt, tspan ,rho0, H0, dH, \n                                   decay=decay, dyn_method=:Expm)\n# objective function: CFI\nobj = QuanEstimation.CFIM_obj()\n# run the measurement optimization problem\nQuanEstimation.run(opt, alg, obj, dynamics; savefile=false)\nM_ = readdlm(\"measurements.csv\",'\\t', Complex{Float64})\nM = [[reshape(M_[i,:], dim, dim) for i in 1:M_num] \n    for j in 1:Int(length(M_[:,1])/M_num)][end]\n</code></pre> <p>If the parameterization process is implemented with the Kraus operators, then the corresponding  parameters should be input via</p> PythonJulia <pre><code>m = MeasurementOpt(mtype=\"projection\", minput=[], savefile=False, \n                   method=\"DE\", **kwargs)\nm.Kraus(K, dK)\nm.CFIM(W=[])\n</code></pre> <pre><code>opt = MeasurementOpt(mtype=:Projection, seed=1234)\nalg = DE(kwargs...)\ndynamics = Kraus(opt, K, dK)\nobj = CFIM_obj(W=missing)\nrun(opt, alg, obj, dynamics; savefile=false)\n</code></pre> <p>where <code>K</code> and <code>dK</code> are the Kraus operators and its derivatives with respect to the  unknown parameters.</p> <p>Example 7.4 The Kraus operators for the amplitude damping channel are</p> \\[\\begin{eqnarray} K_1 = \\left(\\begin{array}{cc} 1 &amp; 0  \\\\ 0 &amp; \\sqrt{1-\\gamma} \\end{array}\\right), K_2 = \\left(\\begin{array}{cc} 0 &amp; \\sqrt{\\gamma} \\\\ 0 &amp; 0 \\end{array}\\right), \\nonumber \\end{eqnarray}\\] <p>where \\(\\gamma\\) is the unknown parameter to be estimated which represents the decay  probability. In this example, the probe state is taken as \\(|+\\rangle\\langle+|\\) with  \\(|+\\rangle=\\frac{1}{\\sqrt{2}}(|0\\rangle+|1\\rangle)\\). Here \\(|0\\rangle\\) \\((|1\\rangle)\\) is  the eigenstate of \\(\\sigma_3\\) (Pauli matrix) with respect to the eigenvalue \\(1\\) \\((-1)\\).</p> PythonJulia <pre><code>from quanestimation import *\nimport numpy as np\n\n# initial state\nrho0 = 0.5*np.array([[1., 1.], [1., 1.]])\n# Kraus operators for the amplitude damping channel\ngamma = 0.1\nK1 = np.array([[1., 0.], [0., np.sqrt(1-gamma)]])\nK2 = np.array([[0., np.sqrt(gamma)], [0., 0.]])\nK = [K1, K2]\n# derivatives of Kraus operators on gamma\ndK1 = np.array([[1., 0.], [0.0, -0.5/np.sqrt(1-gamma)]])\ndK2 = np.array([[0., 0.5/np.sqrt(gamma)], [0., 0.]])\ndK = [[dK1], [dK2]]\n# measurement\nPOVM_basis = SIC(len(rho0))\nM_num = 2\n</code></pre> projectionLCrotation DEPSO <pre><code># measurement optimization algorithm: DE\nDE_paras = {\"p_num\":10, \"measurement0\":[], \"max_episode\":1000, \\\n            \"c\":1.0, \"cr\":0.5, \"seed\":1234}\nm = MeasurementOpt(mtype=\"projection\", minput=[], savefile=False, \\\n                   method=\"DE\", **DE_paras)\n</code></pre> <pre><code># measurement optimization algorithm: PSO\nPSO_paras = {\"p_num\":10, \"measurement0\":[], \\\n             \"max_episode\":[1000,100], \"c0\":1.0, \\\n            \"c1\":2.0, \"c2\":2.0, \"seed\":1234}\nm = MeasurementOpt(mtype=\"projection\", minput=[], savefile=False, \\\n                   method=\"PSO\", **PSO_paras)\n</code></pre> DEPSOAD <pre><code># measurement optimization algorithm: DE\nDE_paras = {\"p_num\":10, \"measurement0\":[], \"max_episode\":1000, \\\n            \"c\":1.0, \"cr\":0.5, \"seed\":1234}\nm = MeasurementOpt(mtype=\"input\", minput=[\"LC\", POVM_basis, 2], \\\n                   savefile=False, method=\"DE\", **DE_paras)\n</code></pre> <pre><code># measurement optimization algorithm: PSO\nPSO_paras = {\"p_num\":10, \"measurement0\":[], \"max_episode\":[1000,100], \\\n             \"c0\":1.0, \"c1\":2.0, \"c2\":2.0, \"seed\":1234}\nm = MeasurementOpt(mtype=\"input\", minput=[\"LC\", POVM_basis, 2], \\\n                   savefile=False, method=\"PSO\", **PSO_paras)\n</code></pre> <pre><code># measurement optimization algorithm: AD\nAD_paras = {\"Adam\":False, \"measurement0\":[], \"max_episode\":300, \\\n            \"epsilon\":0.01, \"beta1\":0.90, \"beta2\":0.99}\nm = MeasurementOpt(mtype=\"input\", minput=[\"LC\", POVM_basis, 2], \\\n                   savefile=False, method=\"AD\", **AD_paras)\n</code></pre> DEPSOAD <pre><code># measurement optimization algorithm: DE\nDE_paras = {\"p_num\":10, \"measurement0\":[], \"max_episode\":1000, \\\n            \"c\":1.0, \"cr\":0.5, \"seed\":1234}\nm = MeasurementOpt(mtype=\"input\", minput=[\"rotation\", POVM_basis], \\\n                   savefile=False, method=\"DE\", **DE_paras)\n</code></pre> <pre><code># measurement optimization algorithm: PSO\nPSO_paras = {\"p_num\":10, \"measurement0\":[], \\\n             \"max_episode\":[1000,100], \"c0\":1.0, \\\n             \"c1\":2.0, \"c2\":2.0, \"seed\":1234}\nm = MeasurementOpt(mtype=\"input\", minput=[\"rotation\", POVM_basis], \\\n                   savefile=False, method=\"PSO\", **PSO_paras)\n</code></pre> <pre><code># measurement optimization algorithm: AD\nAD_paras = {\"Adam\":False, \"measurement0\":[], \"max_episode\":300, \\\n            \"epsilon\":0.01, \"beta1\":0.90, \"beta2\":0.99}\nm = MeasurementOpt(mtype=\"input\", minput=[\"rotation\", POVM_basis], \\\n                   savefile=False, method=\"AD\", **AD_paras)\n</code></pre> <pre><code># input the dynamics data\nm.Kraus(rho0, K, dK)\n# objective function: CFI\nm.CFIM()\n# convert the \".csv\" file to the \".npy\" file\nM_ = np.loadtxt(\"measurements.csv\", dtype=np.complex128)\ncsv2npy_measurements(M_, M_num)\n# load the measurements\nM = np.load(\"measurements.npy\")[-1]\n</code></pre> <pre><code>using QuanEstimation\nusing DelimitedFiles\n\n# initial state\nrho0 = 0.5*ones(2, 2)\n# Kraus operators for the amplitude damping channel\ngamma = 0.1\nK1 = [1. 0.; 0. sqrt(1-gamma)]\nK2 = [0. sqrt(gamma); 0. 0.]\nK = [K1, K2]\n# derivatives of Kraus operators on gamma\ndK1 = [1. 0.; 0. -0.5/sqrt(1-gamma)]\ndK2 = [0. 0.5/sqrt(gamma); 0. 0.]\ndK = [[dK1], [dK2]]\n# measurement\ndim = size(rho0,1)\nPOVM_basis = QuanEstimation.SIC(dim)\nM_num = 2\n</code></pre> ProjectionLCRotation <pre><code>opt = QuanEstimation.MeasurementOpt(mtype=:Projection, seed=1234)\n</code></pre> DEPSO <pre><code># measurement optimization algorithm: DE\nalg = QuanEstimation.DE(p_num=10, ini_population=missing, \n                        max_episode=1000, c=1.0, cr=0.5)\n</code></pre> <pre><code># measurement optimization algorithm: PSO\nalg = QuanEstimation.PSO(p_num=10, ini_particle=missing, \n                         max_episode=[1000,100], c0=1.0, c1=2.0, \n                         c2=2.0)\n</code></pre> <pre><code>opt = QuanEstimation.MeasurementOpt(mtype=:LC, \n                                    POVM_basis=POVM_basis, M_num=2, \n                                    seed=1234)\n</code></pre> DEPSOAD <pre><code># measurement optimization algorithm: DE\nalg = QuanEstimation.DE(p_num=10, ini_population=missing, \n                        max_episode=1000, c=1.0, cr=0.5)\n</code></pre> <pre><code># measurement optimization algorithm: PSO\nalg = QuanEstimation.PSO(p_num=10, ini_particle=missing, \n                         max_episode=[1000,100], c0=1.0, c1=2.0, \n                         c2=2.0)\n</code></pre> <pre><code># measurement optimization algorithm: AD\nalg = QuanEstimation.AD(Adam=true, max_episode=300, epsilon=0.01, \n                        beta1=0.90, beta2=0.99)\n</code></pre> <pre><code>opt = QuanEstimation.MeasurementOpt(mtype=:Rotation, \n                                    POVM_basis=POVM_basis, seed=1234)\n</code></pre> DEPSOAD <pre><code># measurement optimization algorithm: DE\nalg = QuanEstimation.DE(p_num=10, ini_population=missing, \n                        max_episode=1000, c=1.0, cr=0.5)\n</code></pre> <pre><code># measurement optimization algorithm: PSO\nalg = QuanEstimation.PSO(p_num=10, ini_particle=missing, \n                         max_episode=[1000,100], c0=1.0, c1=2.0, \n                         c2=2.0)\n</code></pre> <pre><code># measurement optimization algorithm: AD\nalg = QuanEstimation.AD(Adam=true, max_episode=300, epsilon=0.01, \n                        beta1=0.90, beta2=0.99)\n</code></pre> <pre><code># input the dynamics data\ndynamics = QuanEstimation.Kraus(opt, rho0, K, dK)\n# objective function: CFI\nobj = QuanEstimation.CFIM_obj()\n# run the measurement optimization problem\nQuanEstimation.run(opt, alg, obj, dynamics; savefile=false)\n# convert the flattened data into a list of matrix\nM_ = readdlm(\"measurements.csv\",'\\t', Complex{Float64})\nM = [[reshape(M_[i,:], dim, dim) for i in 1:M_num] \n    for j in 1:Int(length(M_[:,1])/M_num)][end]\n</code></pre>"},{"location":"guide/guide_Mopt/#bibliography","title":"Bibliography","text":"<p>[1] J. Kennedy and R. Eberhar, Particle swarm optimization, Proc. 1995 IEEE International Conference on Neural Networks 4, 1942-1948 (1995). </p> <p>[2] R. Storn and K. Price, Differential Evolution-A Simple and Efficient Heuristic for global Optimization over Continuous Spaces, J. Global Optim. 11, 341 (1997).</p> <p>[3] A. G. Baydin, B. A. Pearlmutter, A. A. Radul, and J. M. Siskind, Automatic differentiation in machine learning: a survey, J. Mach. Learn. Res. 18, 1-43 (2018).</p>"},{"location":"guide/guide_Sopt/","title":"State optimization","text":"<p>For state optimization in QuanEstimation, the probe state is expanded as  \\(|\\psi\\rangle=\\sum_i c_i|i\\rangle\\) in a specific basis \\(\\{|i\\rangle\\}\\). Thus, search of the  optimal probe states is equal to search of the normalized complex coefficients \\(\\{c_i\\}\\). In  QuanEstimation, the state optimization algorithms are the automatic differentiation (AD)  [1], reverse iterative (RI)[2] algorithm, particle swarm optimization (PSO)  [3], differential evolution (DE) [4], and Nelder-Mead (NM)  [5].  Call the following codes to perform state optimizaiton</p> PythonJulia <pre><code>state = StateOpt(savefile=False, method=\"AD\", **kwargs)\nstate.dynamics(tspan, H0, dH, Hc=[], ctrl=[], decay=[], \n               dyn_method=\"expm\")\n</code></pre> QFIMCFIMHCRB <pre><code>state.QFIM(W=[], LDtype=\"SLD\")\n</code></pre> <pre><code>state.CFIM(M=[], W=[])\n</code></pre> <pre><code>state.HCRB(W=[])\n</code></pre> <p>The variable <code>savefile</code> means whether to save all the states. If set <code>False</code> (default) the  states in the final episode and the values of the objective function in all episodes will  be saved. If set <code>True</code> then the states and the values of the objective function obtained  in all episodes will be saved during the training. <code>method</code> represents the algorithm used  to optimize the states, options are: \"AD\", \"PSO\", \"DE\", and \"NM\". <code>**kwargs</code> contains  the keywords and default values corresponding to the optimization algorithm which will be  introduced in detail below.</p> <p><code>tspan</code> is the time length for the evolution, <code>H0</code> and <code>dH</code> are the free Hamiltonian and its derivatives with respect to the unknown parameters to be estimated. <code>H0</code> accepts both matrix  (time-independent evolution) and list of matrices (time-dependent evolution) with the length equal to  <code>tspan</code>. <code>dH</code> should be input as \\([\\partial_a{H_0}, \\partial_b{H_0}, \\cdots]\\). <code>Hc</code>  and <code>ctrl</code> are two lists represent the control Hamiltonians and the corresponding control  coefficients. <code>decay</code> contains decay operators \\((\\Gamma_1, \\Gamma_2, \\cdots)\\) and the  corresponding decay rates \\((\\gamma_1, \\gamma_2, \\cdots)\\) with the input rule  decay=[[\\(\\Gamma_1\\), \\(\\gamma_1\\)], [\\(\\Gamma_2\\), \\(\\gamma_2\\)],...]. The default values for  <code>decay</code>, <code>Hc</code> and <code>ctrl</code> are empty which means the dynamics is unitary and only governed by  the free Hamiltonian. <code>dyn_method=\"expm\"</code> represents the method for solving the dynamics is  matrix exponential, it can also be set as <code>dyn_method=\"ode\"</code> which means the dynamics  (differential equation) is directly solved with the ODE solvers.</p> <p>The objective functions for state optimization can be chosen as QFI \\(\\left[\\mathrm{Tr} (W\\mathcal{F}^{-1})\\right]\\), CFI \\(\\left[\\mathrm{Tr}(W\\mathcal{I}^{-1})\\right]\\), and HCRB,  the corresponding codes for them are <code>state.QFIM()</code> (default), <code>state.CFIM()</code>, and  <code>state.HCRB()</code>. Here \\(\\mathcal{F}\\) and \\(\\mathcal{I}\\) are the QFIM and CFIM, \\(W\\) corresponds  to <code>W</code> represents the weight matrix, the default value for <code>W</code> is the identity matrix. If  the users call <code>state.HCRB()</code> for single parameter scenario, the program will exit and print  <code>\"Program terminated. In the single-parameter scenario, the HCRB is equivalent to the QFI. Please  choose 'QFIM' as the objective function\"</code>. <code>LDtype</code> in <code>state.QFIM()</code> represents the types  of the QFIM, it can be set as <code>LDtype=\"SLD\"</code> (default), <code>LDtype=\"RLD\"</code>, and <code>LDtype=\"LLD\"</code>.  <code>M</code> represents a set of positive operator-valued measure (POVM) with default value <code>[]</code>.  In the package, a set of rank-one symmetric informationally complete POVM (SIC-POVM) is  used when <code>M=[]</code>.</p> <pre><code>opt = StateOpt(psi=psi, seed=1234)\nalg = AD(kwargs...)\ndynamics = Lindblad(opt, tspan, H0, dH; Hc=missing, \n                    ctrl=missing, decay=missing, dyn_method=:Expm)\n</code></pre> QFIMCFIMHCRB <pre><code>obj = QFIM_obj(W=missing, LDtype=:SLD)\n</code></pre> <pre><code>obj = CFIM_obj(M=missing, W=missing)\n</code></pre> <pre><code>obj = HCRB_obj(W=missing)\n</code></pre> <p><pre><code>run(opt, alg, obj, dynamics; savefile=false)\n</code></pre> The initial state (optimization variable) can be input via <code>psi=psi</code> in <code>StateOpt()</code> for  constructing a state optimization problem. <code>psi</code> is an array representing the state.  <code>Lindblad</code> accepts the dynamics parameters. <code>tspan</code> is the time length for the evolution,  <code>H0</code> and <code>dH</code> are the free Hamiltonian and its derivatives with respect to the unknown  parameters to be estimated. <code>H0</code> accepts both matrix (time-independent evolution) and list of matrices (time-dependent evolution) with the length equal to <code>tspan</code>. <code>dH</code> should be input as  \\([\\partial_a{H_0}, \\partial_b{H_0}, \\cdots]\\). <code>Hc</code> and <code>ctrl</code> are two lists represent the  control Hamiltonians and the corresponding control coefficients. <code>decay</code> contains decay  operators \\((\\Gamma_1, \\Gamma_2, \\cdots)\\) and the corresponding decay rates  \\((\\gamma_1, \\gamma_2, \\cdots)\\) with the input rule  decay=[[\\(\\Gamma_1\\), \\(\\gamma_1\\)], [\\(\\Gamma_2\\), \\(\\gamma_2\\)],...]. The default values for  <code>decay</code>, <code>Hc</code>, and <code>ctrl</code> are <code>missing</code> which means the dynamics is unitary and only governed  by the free Hamiltonian. <code>seed</code> is the random seed which can ensure the reproducibility of  results. <code>dyn_method=:Expm</code> represents the method for solving the dynamics is  matrix exponential, it can also be set as <code>dyn_method=:Ode</code> which means the dynamics  (differential equation) is directly solved with the ODE solvers.</p> <p>The objective functions for state optimization can be set as QFI (\\(\\mathrm{Tr}(W\\mathcal{F}^ {-1})\\)), CFI (\\(\\mathrm{Tr}(W\\mathcal{I}^{-1})\\)), and HCRB, the corresponding codes for them are <code>QFIM_obj()</code> (default), <code>CFIM_obj()</code>, and <code>HCRB_obj()</code>. Here \\(\\mathcal{F}\\) and  \\(\\mathcal{I}\\) are the QFIM and CFIM, \\(W\\) corresponds to <code>W</code> is the weight matrix which  defaults to the identity matrix. If the users call <code>HCRB_obj()</code> for single parameter  scenario, the program will exit and print <code>\"Program terminated. In the single-parameter scenario,  the HCRB is equivalent to the QFI. Please choose 'QFIM_obj()' as the objective function\"</code>. <code>LDtype</code> in <code>QFIM_obj()</code> represents the types of the QFIM, it can be set as <code>LDtype=:SLD</code>  (default), <code>LDtype=:RLD</code> and <code>LDtype=:LLD</code>. <code>M</code> represents a set of positive operator-valued  measure (POVM) with default value <code>missing</code>. In the package, a set of rank-one symmetric  informationally complete POVM (SIC-POVM) is used when <code>M=missing</code>.</p> <p><code>savefile</code> means whether to save all the states. If set <code>false</code> (default) the states in the  final episode and the values of the objective function in all episodes will be saved. If set  <code>true</code> then the states and the values of the objective function obtained in all episodes will  be saved during the training. The algorithm used to optimize the states in QuanEstimation  are AD, PSO, DE, DDPG, and NM. <code>kwargs...</code> contains the keywords and default values corresponding  to the optimization algorithm which will be introduced in detail below.</p>"},{"location":"guide/guide_Sopt/#ad","title":"AD","text":"<p>The code for state optimization with AD is as follows</p> PythonJulia <p><pre><code>state = StateOpt(method=\"GRAPE\", **kwargs)\n</code></pre> where <code>kwargs</code> is of the form <pre><code>kwargs = {\"Adam\":False, \"psi0\":[], \"max_episode\":300, \"epsilon\":0.01, \n          \"beta1\":0.90, \"beta2\":0.99}\n</code></pre> The keywords and the default values of AD can be seen in the following  table</p> \\(~~~~~~~~~~\\)**kwargs\\(~~~~~~~~~~\\) \\(~~~~\\)default values\\(~~~~\\) \"Adam\" False \"psi0\" [ ] \"max_episode\" 300 \"epsilon\" 0.01 \"beta1\" 0.90 \"beta2\" 0.99 <p>In state optimization, the state will update according to the learning rate <code>\"epsilon\"</code>. However, Adam algorithm can be introduced to update the states which can be realized by setting  <code>Adam=True</code>. In this case, the Adam parameters include learning rate, the exponential decay  rate for the first moment estimates and the second moment estimates can be set by the user via  <code>epsilon</code>, <code>beta1</code> and <code>beta2</code>. <code>psi0</code> is a list representing the initial guesses of states and  <code>max_episode</code> is the number of episodes.</p> <p><pre><code>alg = AD(Adam=false, max_episode=300, epsilon=0.01, beta1=0.90, \n         beta2=0.99)\n</code></pre> The keywords and the default values of AD can be seen in the following  table</p> \\(~~~~~~~~~~\\)keywords\\(~~~~~~~~~~\\) \\(~~~~\\)default values\\(~~~~\\) \"Adam\" false \"max_episode\" 300 \"epsilon\" 0.01 \"beta1\" 0.90 \"beta2\" 0.99 <p>In state optimization, the state will update according to the learning rate <code>\"epsilon\"</code>. However, Adam algorithm can be introduced to update the states which can be realized by setting  <code>Adam=true</code>. In this case, the Adam parameters include learning rate, the exponential decay  rate for the first moment estimates and the second moment estimates can be set by the user via  <code>epsilon</code>, <code>beta1</code>, and <code>beta2</code>.</p>"},{"location":"guide/guide_Sopt/#ri","title":"RI","text":"<p>The code for state optimization with RI is as follows</p> PythonJulia <p><pre><code>state = StateOpt(method=\"RI\", **kwargs)\n</code></pre> where <code>kwargs</code> is of the form <pre><code>kwargs = {\"psi0\":[], \"max_episode\":300, \"seed\":1234}\n</code></pre> The keywords and the default values of RI can be seen in the following table</p> \\(~~~~~~~~~~\\)**kwargs\\(~~~~~~~~~~\\) \\(~~~~\\)default values\\(~~~~\\) \"psi0\" [ ] \"max_episode\" 300 \"seed\" 1234 <p><code>psi0</code> is a list representing the initial guesses of states and <code>max_episode</code> is the number of episodes. <code>seed</code> is the random seed. </p> <p><pre><code>alg = RI(max_episode=300)\n</code></pre> The keywords and the default values of RI can be seen in the following  table</p> \\(~~~~~~~~~~\\)keywords\\(~~~~~~~~~~\\) \\(~~~~\\)default values\\(~~~~\\) \"max_episode\" 300 <p><code>max_episode</code> is the number of episodes.</p>"},{"location":"guide/guide_Sopt/#pso","title":"PSO","text":"<p>The code for state optimization with PSO is as follows</p> PythonJulia <p><pre><code>state = StateOpt(method=\"PSO\", **kwargs)\n</code></pre> where <code>kwargs</code> is of the form <pre><code>kwargs = {\"p_num\":10, \"psi0\":[], \"max_episode\":[1000,100], \n          \"c0\":1.0, \"c1\":2.0, \"c2\":2.0, \"seed\":1234}\n</code></pre> The keywords and the default values of PSO can be seen in the following  table</p> \\(~~~~~~~~~~\\)**kwargs\\(~~~~~~~~~~\\) \\(~~~~\\)default values\\(~~~~\\) \"p_num\" 10 \"psi0\" [ ] \"max_episode\" [1000,100] \"c0\" 1.0 \"c1\" 2.0 \"c2\" 2.0 \"seed\" 1234 <p><code>p_num</code> is the number of particles. Here <code>max_episode</code> accepts both integers and  arrays with two elements. If it is an integer, for example <code>max_episode=1000</code>, it means the  program will continuously run 1000 episodes. However, if it is an array, for example  <code>max_episode=[1000,100]</code>, the program will run 1000 episodes in total but replace states of  all the particles with global best every 100 episodes. <code>c0</code>, <code>c1</code>, and <code>c2</code> are the PSO  parameters representing the inertia weight, cognitive learning factor, and social learning  factor, respectively.  <code>seed</code> is the random seed.</p> <p><pre><code>alg = PSO(p_num=10, ini_particle=missing,  max_episode=[1000,100], \n          c0=1.0, c1=2.0, c2=2.0)\n</code></pre> The keywords and the default values of PSO can be seen in the following  table</p> \\(~~~~~~~~~~\\)keywords\\(~~~~~~~~~~\\) \\(~~~~\\)default values\\(~~~~\\) \"p_num\" 10 \"ini_particle\" missing \"max_episode\" [1000,100] \"c0\" 1.0 \"c1\" 2.0 \"c2\" 2.0 <p><code>p_num</code> is the number of particles. <code>ini_particle</code> is a tuple representing the initial  guesses of states and <code>max_episode</code> is the number of episodes. Here <code>max_episode</code> accepts  both integers and arrays with two elements. If it is an integer, for example <code>max_episode=1000</code>,  it means the program will continuously run 1000 episodes. However, if it is an array, for example  <code>max_episode=[1000,100]</code>, the program will run 1000 episodes in total but replace states of  all the particles with global best every 100 episodes. <code>c0</code>, <code>c1</code>, and <code>c2</code> are the PSO  parameters representing the inertia weight, cognitive learning factor, and social learning  factor, respectively. </p>"},{"location":"guide/guide_Sopt/#de","title":"DE","text":"<p>The code for state optimization with DE is as follows</p> PythonJulia <p><pre><code>state = StateOpt(method=\"DE\", **kwargs)\n</code></pre> where <code>kwargs</code> is of the form <pre><code>kwargs = {\"p_num\":10, \"psi0\":[], \"max_episode\":1000, \"c\":1.0, \n          \"cr\":0.5, \"seed\":1234}\n</code></pre> The keywords and the default values of DE can be seen in the following  table</p> \\(~~~~~~~~~~\\)**kwargs\\(~~~~~~~~~~\\) \\(~~~~\\)default values\\(~~~~\\) \"p_num\" 10 \"psi0\" [ ] \"max_episode\" 1000 \"c\" 1.0 \"cr\" 0.5 \"seed\" 1234 <p><code>p_num</code> represents the number of populations. <code>c</code> and <code>cr</code> are the mutation constant and  crossover constant.</p> <p><pre><code>alg = DE(p_num=10, ini_population=missing, max_episode=1000, \n         c=1.0, cr=0.5)\n</code></pre> The keywords and the default values of DE can be seen in the following  table</p> \\(~~~~~~~~~~\\)keywords\\(~~~~~~~~~~\\) \\(~~~~\\)default values\\(~~~~\\) \"p_num\" 10 \"ini_population\" missing \"max_episode\" 1000 \"c\" 1.0 \"cr\" 0.5 <p><code>ini_population</code> is a tuple representing the initial guesses of states , <code>c</code> and <code>cr</code>  are the mutation constant and crossover constant.</p>"},{"location":"guide/guide_Sopt/#nm","title":"NM","text":"<p>The code for state optimization with NM is as follows</p> PythonJulia <p><pre><code>state = StateOpt(method=\"NM\", **kwargs)\n</code></pre> where <code>kwargs</code> is of the form <pre><code>kwargs = {\"p_num\":10, \"psi0\":psi0, \"max_episode\":1000, \"ar\":1.0, \n          \"ae\":2.0, \"ac\":0.5, \"as0\":0.5, \"seed\":1234}\n</code></pre> The keywords and the default values of NM can be seen in the following  table</p> \\(~~~~~~~~~~\\)**kwargs\\(~~~~~~~~~~\\) \\(~~~~\\)default values\\(~~~~\\) \"p_num\" 10 \"psi0\" [ ] \"max_episode\" 1000 \"ar\" 1.0 \"ae\" 2.0 \"ac\" 0.5 \"as0\" 0.5 \"seed\" 1234 <p><code>p_num</code> represents the number of initial states. <code>ar</code>, <code>ae</code>, <code>ac</code>, and <code>as0</code> are  constants for reflection, expansion, constraction, and shrink, respectively.</p> <p><pre><code>alg = NM(p_num=10, ini_state=missing, max_episode=1000, ar=1.0, \n         ae=2.0, ac=0.5, as0=0.5)\n</code></pre> The keywords and the default values of NM can be seen in the following  table</p> \\(~~~~~~~~~~\\)keywords\\(~~~~~~~~~~\\) \\(~~~~\\)default values\\(~~~~\\) \"p_num\" 10 \"ini_state\" missing \"max_episode\" 1000 \"ar\" 1.0 \"ae\" 2.0 \"ac\" 0.5 \"as0\" 0.5 <p><code>ini_state</code> represents the number of initial states. <code>ar</code>, <code>ae</code>, <code>ac</code>, and <code>as0</code> are  constants for reflection, expansion, constraction, and shrink, respectively.</p> <p>Example 6.1  The Hamiltonian of the Lipkin\u2013Meshkov\u2013Glick (LMG) model is \\begin{align} H_{\\mathrm{LMG}}=-\\frac{\\lambda}{N}(J_1^2+gJ_2^2)-hJ_3, \\end{align}</p> <p>where \\(N\\) is the number of spins of the system, \\(\\lambda\\) is the spin\u2013spin interaction strength,  \\(h\\) is the strength of the external field and \\(g\\) is the anisotropic parameter.  \\(J_i=\\frac{1}{2}\\sum_{j=1}^N \\sigma_i^{(j)}\\) (\\(i=1,2,3\\)) is the collective spin operator with  \\(\\sigma_i^{(j)}\\) the \\(i\\)th Pauli matrix for the \\(j\\)th spin. In single-parameter scenario, we take  \\(g\\) as the unknown parameter to be estimated. The states are expanded as  \\(|\\psi\\rangle=\\sum^J_{m=-J}c_m|J,m\\rangle\\) with \\(|J,m\\rangle\\) the Dicke state and \\(c_m\\) a complex  coefficient. Here we fixed \\(J=N/2\\). In this example, the probe state is optimized for both noiseless scenario and collective dephasing noise. The dynamics under collective dephasing can be expressed as</p>  $\\partial_t\\rho = -i[H_{\\mathrm{LMG}},\\rho]+\\gamma \\left(J_3\\rho J_3-\\frac{1}{2}\\left\\{\\rho, J^2_3\\right\\}\\right)$  <p>with \\(\\gamma\\) the decay rate.</p> <p>In this case, all searches with different algorithms start from the coherent spin state defined by \\(|\\theta=\\frac{\\pi}{2},\\phi=\\frac{\\pi}{2}\\rangle=\\exp(-\\frac{\\theta}{2}e^{-i\\phi}J_{+}+\\frac{\\theta}{2}e^{i\\phi}J_{-})|J,J\\rangle\\) with \\(J_{\\pm}=J_1{\\pm}iJ_2\\). Here, QuTip [6,7] is applied for generation of the spin coherent state.</p> PythonJulia <pre><code>from quanestimation import *\nimport numpy as np\nfrom qutip import *\n\n# the dimension of the system\nN = 8\n# generation of the coherent spin state\npsi_css = spin_coherent(0.5*N, 0.5*np.pi, 0.5*np.pi, type=\"ket\").full()\npsi_css = psi_css.reshape(1, -1)[0]\n# guessed state\npsi0 = [psi_css]\n# free Hamiltonian\nLambda, g, h = 1.0, 0.5, 0.1\nJx, Jy, Jz = jmat(0.5*N)\nJx, Jy, Jz = Jx.full(), Jy.full(), Jz.full()\nH0 = -Lambda*(np.dot(Jx, Jx) + g*np.dot(Jy, Jy))/N - h*Jz\n# derivative of the free Hamiltonian on g\ndH = [-Lambda*np.dot(Jy, Jy)/N]\n# dissipation\ndecay = [[Jz, 0.1]]\n# time length for the evolution\ntspan = np.linspace(0., 10., 2500)\n</code></pre> ADPSODENM <pre><code># state optimization algorithm: AD\nAD_paras = {\"Adam\":False, \"psi0\":psi0, \"max_episode\":300, \\\n            \"epsilon\":0.01, \"beta1\":0.90, \"beta2\":0.99}\nstate = StateOpt(savefile=False, method=\"AD\", **AD_paras)\n</code></pre> <pre><code># state optimization algorithm: PSO\nPSO_paras = {\"p_num\":10, \"psi0\":psi0, \"max_episode\":[1000,100], \\\n             \"c0\":1.0, \"c1\":2.0, \"c2\":2.0, \"seed\":1234}\nstate = StateOpt(savefile=False, method=\"PSO\", **PSO_paras)\n</code></pre> <pre><code># state optimization algorithm: DE\nDE_paras = {\"p_num\":10, \"psi0\":psi0, \"max_episode\":1000, \"c\":1.0, \\\n            \"cr\":0.5, \"seed\":1234}\nstate = StateOpt(savefile=False, method=\"DE\", **DE_paras)\n</code></pre> <pre><code># state optimization algorithm: NM\nNM_paras = {\"p_num\":20, \"psi0\":psi0, \"max_episode\":1000, \\\n            \"ar\":1.0, \"ae\":2.0, \"ac\":0.5, \"as0\":0.5, \"seed\":1234}\nstate = StateOpt(savefile=False, method=\"NM\", **NM_paras)\n</code></pre> <pre><code># input the dynamics data\nstate.dynamics(tspan, H0, dH, decay=decay, dyn_method=\"expm\")\n</code></pre> QFIMCFIM <pre><code># objective function: QFI\nstate.QFIM()\n</code></pre> <pre><code># objective function: CFI\nstate.CFIM()\n</code></pre> <pre><code>using QuanEstimation\nusing Random\nusing StableRNGs\nusing LinearAlgebra\nusing SparseArrays\n\n# the dimension of the system\nN = 8\n# generation of the coherent spin state\nj, theta, phi = N\u00f72, 0.5pi, 0.5pi\nJp = Matrix(spdiagm(1=&gt;[sqrt(j*(j+1)-m*(m+1)) for m in j:-1:-j][2:end]))\nJm = Jp'\npsi0 = exp(0.5*theta*exp(im*phi)*Jm - 0.5*theta*exp(-im*phi)*Jp)*\n       QuanEstimation.basis(Int(2*j+1), 1)\ndim = length(psi0)\n# free Hamiltonian\nlambda, g, h = 1.0, 0.5, 0.1\nJx = 0.5*(Jp + Jm)\nJy = -0.5im*(Jp - Jm)\nJz = spdiagm(j:-1:-j)\nH0 = -lambda*(Jx*Jx + g*Jy*Jy) / N - h*Jz\n# derivative of the free Hamiltonian on g\ndH = [-lambda*Jy*Jy/N]\n# dissipation\ndecay = [[Jz, 0.1]]\n# time length for the evolution\ntspan = range(0., 10., length=2500)\n# set the optimization type\nopt = QuanEstimation.StateOpt(psi=psi0, seed=1234) \n</code></pre> ADPSODENM <pre><code># state optimization algorithm: AD\nalg = QuanEstimation.AD(Adam=false, max_episode=300, epsilon=0.01, \n                        beta1=0.90, beta2=0.99)\n</code></pre> QFIMCFIM <pre><code># objective function: QFI\nobj = QuanEstimation.QFIM_obj()\n</code></pre> <pre><code># objective function: CFI\nobj = QuanEstimation.CFIM_obj()\n</code></pre> <pre><code># state optimization algorithm: PSO\nalg = QuanEstimation.PSO(p_num=10, max_episode=[1000,100], c0=1.0, \n                         c1=2.0, c2=2.0)\n</code></pre> QFIMCFIM <pre><code># objective function: QFI\nobj = QuanEstimation.QFIM_obj()\n</code></pre> <pre><code># objective function: CFI\nobj = QuanEstimation.CFIM_obj()\n</code></pre> <pre><code># state optimization algorithm: DE\nalg = QuanEstimation.DE(p_num=10, max_episode=1000, c=1.0, cr=0.5)\n</code></pre> QFIMCFIM <pre><code># objective function: QFI\nobj = QuanEstimation.QFIM_obj()\n</code></pre> <pre><code># objective function: CFI\nobj = QuanEstimation.CFIM_obj()\n</code></pre> <pre><code># state optimization algorithm: NM\nalg = QuanEstimation.NM(p_num=10, max_episode=1000, ar=1.0, \n                        ae=2.0, ac=0.5, as0=0.5)\n</code></pre> QFIMCFIM <pre><code># objective function: QFI\nobj = QuanEstimation.QFIM_obj()\n</code></pre> <pre><code># objective function: CFI\nobj = QuanEstimation.CFIM_obj()\n</code></pre> <pre><code># input the dynamics data\ndynamics = QuanEstimation.Lindblad(opt, tspan, H0, dH, decay=decay, \n                                   dyn_method=:Expm) \n# run the state optimization problem\nQuanEstimation.run(opt, alg, obj, dynamics; savefile=false)\n</code></pre> <p>Example 6.2  In the multiparameter scenario, \\(g\\) and \\(h\\) are chooen to be the unknown parameters to be estimated.</p> PythonJulia <pre><code>from quanestimation import *\nimport numpy as np\nfrom qutip import *\n\n# the dimension of the system\nN = 8\n# generation of coherent spin state\npsi_css = spin_coherent(0.5*N, 0.5*np.pi, 0.5*np.pi, type=\"ket\").full()\npsi_css = psi_css.reshape(1, -1)[0]\n# guessed state\npsi0 = [psi_css]\n# free Hamiltonian\nLambda, g, h = 1.0, 0.5, 0.1\nJx, Jy, Jz = jmat(0.5*N)\nJx, Jy, Jz = Jx.full(), Jy.full(), Jz.full()\nH0 = -Lambda*(np.dot(Jx, Jx) + g*np.dot(Jy, Jy))/N - h*Jz\n# derivatives of the free Hamiltonian on the g and h\ndH = [-Lambda*np.dot(Jy, Jy)/N, -Jz]\n# dissipation\ndecay = [[Jz, 0.1]]\n# time length for the evolution\ntspan = np.linspace(0., 10., 2500)\n# weight matrix\nW = np.array([[1/3, 0.], [0., 2/3]])\n</code></pre> ADPSODENM <p><pre><code># state optimization algorithm: AD\nAD_paras = {\"Adam\":False, \"psi0\":psi0, \"max_episode\":300, \\\n            \"epsilon\":0.01, \"beta1\":0.90, \"beta2\":0.99}\nstate = StateOpt(savefile=False, method=\"AD\", **AD_paras)\n</code></pre> <pre><code># input the dynamics data\nstate.dynamics(tspan, H0, dH, decay=decay, dyn_method=\"expm\")\n</code></pre></p> QFIMCFIMHCRB <pre><code># objective function: tr(WF^{-1})\nstate.QFIM()\n</code></pre> <pre><code># objective function: tr(WI^{-1})\nstate.CFIM()\n</code></pre> <pre><code># objective function: HCRB\nstate.HCRB()\n</code></pre> <p><pre><code># state optimization algorithm: PSO\nPSO_paras = {\"p_num\":10, \"psi0\":psi0, \"max_episode\":[1000,100], \\\n             \"c0\":1.0, \"c1\":2.0, \"c2\":2.0, \"seed\":1234}\nstate = StateOpt(savefile=False, method=\"PSO\", **PSO_paras)\n</code></pre> <pre><code># input the dynamics data\nstate.dynamics(tspan, H0, dH, decay=decay, dyn_method=\"expm\")\n</code></pre></p> QFIMCFIMHCRB <pre><code># objective function: tr(WF^{-1})\nstate.QFIM()\n</code></pre> <pre><code># objective function: tr(WI^{-1})\nstate.CFIM()\n</code></pre> <pre><code># objective function: HCRB\nstate.HCRB()\n</code></pre> <p><pre><code># state optimization algorithm: DE\nDE_paras = {\"p_num\":10, \"psi0\":psi0, \"max_episode\":1000, \"c\":1.0, \\\n            \"cr\":0.5, \"seed\":1234}\nstate = StateOpt(savefile=False, method=\"DE\", **DE_paras)\n</code></pre> <pre><code># input the dynamics data\nstate.dynamics(tspan, H0, dH, decay=decay, dyn_method=\"expm\")\n</code></pre></p> QFIMCFIMHCRB <pre><code># objective function: tr(WF^{-1})\nstate.QFIM()\n</code></pre> <pre><code># objective function: tr(WI^{-1})\nstate.CFIM()\n</code></pre> <pre><code># objective function: HCRB\nstate.HCRB()\n</code></pre> <p><pre><code># state optimization algorithm: NM\nNM_paras = {\"p_num\":20, \"psi0\":psi0, \"max_episode\":1000, \\\n            \"ar\":1.0, \"ae\":2.0, \"ac\":0.5, \"as0\":0.5, \"seed\":1234}\nstate = StateOpt(savefile=False, method=\"NM\", **NM_paras)\n</code></pre> <pre><code># input the dynamics data\nstate.dynamics(tspan, H0, dH, decay=decay, dyn_method=\"expm\")\n</code></pre></p> QFIMCFIMHCRB <pre><code># objective function: tr(WF^{-1})\nstate.QFIM()\n</code></pre> <pre><code># objective function: tr(WI^{-1})\nstate.CFIM()\n</code></pre> <pre><code># objective function: HCRB\nstate.HCRB()\n</code></pre> <pre><code>using QuanEstimation\nusing Random\nusing StableRNGs\nusing LinearAlgebra\nusing SparseArrays\n\n# the dimension of the system\nN = 8\n# generation of the coherent spin state\nj, theta, phi = N\u00f72, 0.5pi, 0.5pi\nJp = Matrix(spdiagm(1=&gt;[sqrt(j*(j+1)-m*(m+1)) for m in j:-1:-j][2:end]))\nJm = Jp'\npsi0 = exp(0.5*theta*exp(im*phi)*Jm - 0.5*theta*exp(-im*phi)*Jp)*\n           QuanEstimation.basis(Int(2*j+1), 1)\ndim = length(psi0)\n# free Hamiltonian\nlambda, g, h = 1.0, 0.5, 0.1\nJx = 0.5*(Jp + Jm)\nJy = -0.5im*(Jp - Jm)\nJz = spdiagm(j:-1:-j)\nH0 = -lambda*(Jx*Jx + g*Jy*Jy) / N + g * Jy^2 / N - h*Jz\n# derivative of the free Hamiltonian on g\ndH = [-lambda*Jy*Jy/N, -Jz]\n# dissipation\ndecay = [[Jz, 0.1]]\n# time length for the evolution\ntspan = range(0., 10., length=2500)\n# weight matrix\nW = [1/3 0.; 0. 2/3]\n# set the optimization type\nopt = QuanEstimation.StateOpt(psi=psi0, seed=1234)\n</code></pre> ADPSODENM <pre><code># state optimization algorithm: AD\nalg = QuanEstimation.AD(Adam=false, max_episode=300, epsilon=0.01, \n                        beta1=0.90, beta2=0.99)\n</code></pre> QFIMCFIM <pre><code># objective function: tr(WF^{-1})\nobj = QuanEstimation.QFIM_obj()\n</code></pre> <pre><code># objective function: tr(WI^{-1})\nobj = QuanEstimation.CFIM_obj()\n</code></pre> <pre><code># state optimization algorithm: PSO\nalg = QuanEstimation.PSO(p_num=10, max_episode=[1000,100], c0=1.0, \n                         c1=2.0, c2=2.0)\n</code></pre> QFIMCFIMHCRB <pre><code># objective function: tr(WF^{-1})\nobj = QuanEstimation.QFIM_obj()\n</code></pre> <pre><code># objective function: tr(WI^{-1})\nobj = QuanEstimation.CFIM_obj()\n</code></pre> <pre><code># objective function: HCRB\nobj = QuanEstimation.HCRB_obj()\n</code></pre> <pre><code># state optimization algorithm: DE\nalg = QuanEstimation.DE(p_num=10, max_episode=1000, c=1.0, cr=0.5)\n</code></pre> QFIMCFIMHCRB <pre><code># objective function: tr(WF^{-1})\nobj = QuanEstimation.QFIM_obj()\n</code></pre> <pre><code># objective function: tr(WI^{-1})\nobj = QuanEstimation.CFIM_obj()\n</code></pre> <pre><code># objective function: HCRB\nobj = QuanEstimation.HCRB_obj()\n</code></pre> <pre><code># state optimization algorithm: NM\nalg = QuanEstimation.NM(p_num=10, max_episode=1000, ar=1.0, \n                        ae=2.0, ac=0.5, as0=0.5)\n</code></pre> QFIMCFIMHCRB <pre><code># objective function: tr(WF^{-1})\nobj = QuanEstimation.QFIM_obj()\n</code></pre> <pre><code># objective function: tr(WI^{-1})\nobj = QuanEstimation.CFIM_obj()\n</code></pre> <pre><code># objective function: HCRB\nobj = QuanEstimation.HCRB_obj()\n</code></pre> <p> ``` jl</p> <p>If the parameterization process is implemented with the Kraus operators, then the corresponding  codes are</p> PythonJulia <pre><code>state = StateOpt(savefile=False, method=\"AD\", **kwargs)\nstate.state.Kraus(K, dK)\n</code></pre> QFIMCFIMHCRB <pre><code>state.QFIM(W=[], LDtype=\"SLD\")\n</code></pre> <pre><code>state.CFIM(M=[], W=[])\n</code></pre> <pre><code>state.HCRB(W=[])\n</code></pre> <pre><code>opt = StateOpt(psi=psi, seed=1234)\nalg = AD(kwargs...)\ndynamics = Kraus(opt, K, dK)\n</code></pre> QFIMCFIMHCRB <pre><code>obj = QFIM_obj(W=missing, LDtype=:SLD)\n</code></pre> <pre><code>obj = CFIM_obj(M=missing, W=missing)\n</code></pre> <pre><code>obj = HCRB_obj(W=missing)\n</code></pre> <pre><code>run(opt, alg, obj, dynamics; savefile=false)\n</code></pre> <p>where <code>K</code> and <code>dK</code> are the Kraus operators and its derivatives with respect to the  unknown parameters.</p> <p>Example 6.3 The Kraus operators for the amplitude damping channel are</p> \\[\\begin{eqnarray} K_1 = \\left(\\begin{array}{cc} 1 &amp; 0  \\\\ 0 &amp; \\sqrt{1-\\gamma} \\end{array}\\right), K_2 = \\left(\\begin{array}{cc} 0 &amp; \\sqrt{\\gamma} \\\\ 0 &amp; 0 \\end{array}\\right), \\nonumber \\end{eqnarray}\\] <p>where \\(\\gamma\\) is the unknown parameter to be estimated which represents the decay probability.</p> PythonJulia <pre><code>from quanestimation import *\nimport numpy as np\n\n# initial state\nrho0 = 0.5*np.array([[1., 1.], [1., 1.]])\n# Kraus operators for the amplitude damping channel\ngamma = 0.1\nK1 = np.array([[1., 0.], [0., np.sqrt(1-gamma)]])\nK2 = np.array([[0., np.sqrt(gamma)], [0., 0.]])\nK = [K1, K2]\n# derivatives of Kraus operators on gamma\ndK1 = np.array([[1., 0.], [0., -0.5/np.sqrt(1-gamma)]])\ndK2 = np.array([[0., 0.5/np.sqrt(gamma)], [0., 0.]])\ndK = [[dK1], [dK2]]\n</code></pre> ADRIPSODENM <p><pre><code># state optimization algorithm: AD\nAD_paras = {\"Adam\":False, \"psi0\":[], \"max_episode\":300, \\\n            \"epsilon\":0.01, \"beta1\":0.90, \"beta2\":0.99}\nstate = StateOpt(savefile=False, method=\"AD\", **AD_paras)\n</code></pre> <pre><code># input the dynamics data\nstate.Kraus(K, dK)\n</code></pre></p> QFIMCFIM <pre><code># objective function: QFI\nstate.QFIM()\n</code></pre> <pre><code># objective function: CFI\nstate.CFIM()\n</code></pre> <p><pre><code># state optimization algorithm: RI\nRI_paras = {\"psi0\":[], \"max_episode\":300, \"seed\":1234}\nstate = StateOpt(savefile=False, method=\"RI\", **RI_paras)\n</code></pre> <pre><code># input the dynamics data\nstate.Kraus(K, dK)\n</code></pre></p> QFIM <pre><code># objective function: QFI\nstate.QFIM()\n</code></pre> <p><pre><code># state optimization algorithm: PSO\nPSO_paras = {\"p_num\":10, \"psi0\":[], \"max_episode\":[1000,100], \\\n             \"c0\":1.0, \"c1\":2.0, \"c2\":2.0, \"seed\":1234}\nstate = StateOpt(savefile=False, method=\"PSO\", **PSO_paras)\n</code></pre> <pre><code># input the dynamics data\nstate.Kraus(K, dK)\n</code></pre></p> QFIMCFIM <pre><code># objective function: QFI\nstate.QFIM()\n</code></pre> <pre><code># objective function: CFI\nstate.CFIM()\n</code></pre> <p><pre><code># state optimization algorithm: DE\nDE_paras = {\"p_num\":10, \"psi0\":[], \"max_episode\":1000, \"c\":1.0, \\\n            \"cr\":0.5, \"seed\":1234}\nstate = StateOpt(savefile=False, method=\"DE\", **DE_paras)\n</code></pre> <pre><code># input the dynamics data\nstate.Kraus(K, dK)\n</code></pre></p> QFIMCFIM <pre><code># objective function: QFI\nstate.QFIM()\n</code></pre> <pre><code># objective function: CFI\nstate.CFIM()\n</code></pre> <p><pre><code># state optimization algorithm: NM\nNM_paras = {\"p_num\":20, \"psi0\":[], \"max_episode\":1000, \\\n            \"ar\":1.0, \"ae\":2.0, \"ac\":0.5, \"as0\":0.5, \"seed\":1234}\nstate = StateOpt(savefile=False, method=\"NM\", **NM_paras)\n</code></pre> <pre><code># input the dynamics data\nstate.Kraus(K, dK)\n</code></pre></p> QFIMCFIM <pre><code># objective function: QFI\nstate.QFIM()\n</code></pre> <pre><code># objective function: CFI\nstate.CFIM()\n</code></pre> <pre><code>using QuanEstimation\n\n# initial state\nrho0 = 0.5*ones(2, 2)\n# Kraus operators for the amplitude damping channel\ngamma = 0.1\nK1 = [1. 0.; 0. sqrt(1-gamma)]\nK2 = [0. sqrt(gamma); 0. 0.]\nK = [K1, K2]\n# derivatives of Kraus operators on gamma\ndK1 = [1. 0.; 0. -0.5/sqrt(1-gamma)]\ndK2 = [0. 0.5/sqrt(gamma); 0. 0.]\ndK = [[dK1], [dK2]]\nopt = QuanEstimation.Sopt(seed=1234)\n</code></pre> ADRIPSODENM <pre><code># state optimization algorithm: AD\nalg = QuanEstimation.AD(Adam=false, max_episode=300, epsilon=0.01, \n                        beta1=0.90, beta2=0.99)\n</code></pre> QFIMCFIM <pre><code># objective function: QFI\nobj = QuanEstimation.QFIM_obj()\n</code></pre> <pre><code># objective function: CFI\nobj = QuanEstimation.CFIM_obj()\n</code></pre> <pre><code># state optimization algorithm: RI\nalg = QuanEstimation.RI(max_episode=300)\n</code></pre> QFIM <pre><code># objective function: QFI\nobj = QuanEstimation.QFIM_obj()\n</code></pre> <pre><code># state optimization algorithm: PSO\nalg = QuanEstimation.PSO(p_num=10, max_episode=[1000,100], c0=1.0, \n                         c1=2.0, c2=2.0)\n</code></pre> QFIMCFIM <pre><code># objective function: QFI\nobj = QuanEstimation.QFIM_obj()\n</code></pre> <pre><code># objective function: CFI\nobj = QuanEstimation.CFIM_obj()\n</code></pre> <p><pre><code># state optimization algorithm: DE\nalg = QuanEstimation.DE(p_num=10, max_episode=1000, c=1.0, cr=0.5)\n</code></pre>         === \"QFIM\"     <pre><code># objective function: QFI\nobj = QuanEstimation.QFIM_obj()\n</code></pre></p> CFIM <pre><code># objective function: CFI\nobj = QuanEstimation.CFIM_obj()\n</code></pre> <pre><code># state optimization algorithm: NM\nalg = QuanEstimation.NM(p_num=10, max_episode=1000, ar=1.0, \n                        ae=2.0, ac=0.5, as0=0.5)\n</code></pre> QFIMCFIM <pre><code># objective function: QFI\nobj = QuanEstimation.QFIM_obj()\n</code></pre> <pre><code># objective function: CFI\nobj = QuanEstimation.CFIM_obj()\n</code></pre> <p> ``` jl</p>"},{"location":"guide/guide_Sopt/#input-the-dynamics-data","title":"input the dynamics data","text":"<p>dynamics = QuanEstimation.Lindblad(opt, tspan, H0, dH, decay=decay,                                     dyn_method=:Expm) </p>"},{"location":"guide/guide_Sopt/#run-the-state-optimization-problem","title":"run the state optimization problem","text":"<p>QuanEstimation.run(opt, alg, obj, dynamics; savefile=false) ```</p>"},{"location":"guide/guide_Sopt/#input-the-dynamics-data_1","title":"input the dynamics data","text":"<p>dynamics = QuanEstimation.Kraus(opt, K, dK)</p>"},{"location":"guide/guide_Sopt/#run-the-state-optimization-problem_1","title":"run the state optimization problem","text":"<p>QuanEstimation.run(opt, alg, obj, dynamics; savefile=false) ```</p>"},{"location":"guide/guide_Sopt/#bibliography","title":"Bibliography","text":"<p>[1] A. G. Baydin, B. A. Pearlmutter, A. A. Radul, and J. M. Siskind, Automatic differentiation in machine learning: a survey, J. Mach. Learn. Res. 18, 1-43 (2018).</p> <p>[2] R. Demkowicz-Dobrza\u0144ski, Optimal phase estimation with arbitrary a priori knowledge, Phys. Rev. A 83, 061802(R) (2011). </p> <p>[3] J. Kennedy and R. Eberhar, Particle swarm optimization, Proc. 1995 IEEE International Conference on Neural Networks 4, 1942-1948 (1995). </p> <p>[4] R. Storn and K. Price, Differential Evolution-A Simple and Efficient Heuristic for global Optimization over Continuous Spaces, J. Global Optim. 11, 341 (1997).</p> <p>[5] J. A. Nelder and R. Mead, A Simplex Method for Function Minimization, Comput. J. 7, 308\u2013313 (1965).</p> <p>[6] J. R. Johansson, P. D. Nation, and F. Nori, QuTiP: An open-source Python framework for the dynamics of open quantum systems, Comp. Phys. Comm. 183, 1760 (2012).</p> <p>[7] J. R. Johansson, P. D. Nation, and F. Nori, QuTiP 2: A Python framework for the dynamics of open quantum systems, Comp. Phys. Comm. 184, 1234 (2013).</p>"},{"location":"guide/guide_adaptive/","title":"Adaptive measurement schemes","text":"<p>In QuanEstimation, the Hamiltonian of the adaptive system should be written as \\(H(\\textbf{x}+\\textbf{u})\\) with \\(\\textbf{x}\\) the unknown parameters and \\(\\textbf{u}\\)  the tunable parameters. The tunable parameters \\(\\textbf{u}\\) are used to let the  Hamiltonian work at the optimal point \\(\\textbf{x}_{\\mathrm{opt}}\\). In this scenario, the adaptive estimation can be excuted through</p> PythonJulia <p><pre><code>apt = Adapt(x, p, rho0, method=\"FOP\", savefile=False, \n            max_episode=1000, eps=1e-8)\napt.dynamics(tspan, H, dH, Hc=[], ctrl=[], decay=[], \n             dyn_method=\"expm\")               \napt.CFIM(M=[], W=[]) \n</code></pre> where <code>x</code> is a list of arrays representing the regime of the parameters for the integral,  <code>p</code> is an array representing the prior distribution, it is multidimensional for multiparameter estimation.<code>rho0</code> is the density matrix of the probe state. The number of iterations can be  set via <code>max_episode</code> with the default value 1000. <code>eps</code> represents the machine epsilon which  defaults to \\(10^{-8}\\). At the end of the program, three files \"pout.npy\", \"xout.npy\", and \"y.npy\" including the posterior distributions, the estimated values and the experimental results will be  generated. The package contains two mothods for updating the tunable parameters. The first one is  updating the tunable parameters with a fix optimal point (<code>mtheod=\"FOP\"</code>), which is the default  method in QuanEstimation. The other is <code>method=\"MI\"</code> which means updating the tunable parameters  by maximizing the mutual information which is defined as</p> \\[\\begin{equation} I(\\textbf{u})=\\int\\mathrm{p}(\\textbf{x}) \\sum_{y}\\mathrm{p}(y|\\textbf{x},\\textbf{u})\\mathrm{log}_2  \\left[\\frac{\\mathrm{p}(y|\\textbf{x},\\textbf{u})}{\\int\\mathrm{p}(\\textbf{x})\\mathrm{p}(y|\\textbf{x},\\textbf{u})\\mathrm{d}\\textbf{x}}\\right]\\mathrm{d}\\textbf{x}. \\end{equation}\\] <p>If <code>savefile=True</code>, these files will be generated during the  training and \"pout.npy\" will save all the posterior distributions, otherwise, the posterior  distribution in the final iteration will be saved. </p> <p><pre><code>Adapt(x, p, rho0, tspan, H, dH; dyn_method=:Expm, method=\"FOP\", \n      savefile=false, max_episode=1000, eps=1e-8, Hc=missing, \n      ctrl=missing, decay=missing, M=missing, W=missing)\n</code></pre> where <code>x</code> is a list of arrays representing the regime of the parameters for the integral,  <code>p</code> is an array representing the prior distribution, it is multidimensional for multiparameter estimation.<code>rho0</code> is the density matrix of the probe state. The number of iterations can be  set via <code>max_episode</code> with the default value 1000. <code>eps</code> represents the machine epsilon which  defaults to \\(10^{-8}\\). At the end of the program, three files \"pout.csv\", \"xout.csv\", and \"y.csv\" including the posterior distributions, the estimated values and the experimental results will be  generated. The package contains two mothods for updating the tunable parameters. The first one is  updating the tunable parameters with a fix optimal point (<code>mtheod=\"FOP\"</code>), which is the default  method in QuanEstimation. The other is <code>method=\"MI\"</code> which means updating the tunable parameters  by maximizing the mutual information which is defined as</p> \\[\\begin{equation} I(\\textbf{u})=\\int\\mathrm{p}(\\textbf{x}) \\sum_{y}\\mathrm{p}(y|\\textbf{x},\\textbf{u})\\mathrm{log}_2  \\left[\\frac{\\mathrm{p}(y|\\textbf{x},\\textbf{u})}{\\int\\mathrm{p}(\\textbf{x})\\mathrm{p}(y|\\textbf{x},\\textbf{u})\\mathrm{d}\\textbf{x}}\\right]\\mathrm{d}\\textbf{x}. \\end{equation}\\] <p>If <code>savefile=true</code>, these files will be generated during the training and \"pout.csv\"  will save all the posterior distributions, otherwise, the posterior distribution in the final  iteration will be saved. </p> <p>If the dynamics of the system can be described by the master equation, then the dynamics data  <code>tspan</code>, <code>H</code>, and <code>dH</code> shoule be input. <code>tspan</code> is the time length for the evolution, <code>H</code> and  <code>dH</code> are multidimensional lists representing the Hamiltonian and its derivatives with respect to the unknown parameters to be estimated, they can be generated via</p> PythonJulia <pre><code>H, dH = BayesInput(x, func, dfunc, channel=\"dynamics\")\n</code></pre> <pre><code>H, dH = BayesInput(x, func, dfunc; channel=\"dynamics\")\n</code></pre> <p>Here <code>func</code> and <code>dfunc</code> are the functions defined by the users which return <code>H</code> and <code>dH</code>,  respectively. Futhermore, for the systems with noise and controls, the variables <code>decay</code>,  <code>Hc</code> and <code>ctrl</code> should be input. Here <code>Hc</code> and <code>ctrl</code> are two lists representing the control  Hamiltonians and the corresponding control coefficients. <code>decay</code> contains decay operators  \\((\\Gamma_1, \\Gamma_2, \\cdots)\\) and the corresponding decay rates \\((\\gamma_1, \\gamma_2, \\cdots)\\) with the input rule decay=[[\\(\\Gamma_1\\), \\(\\gamma_1\\)], [\\(\\Gamma_2\\), \\(\\gamma_2\\)],...].  </p> <p>The objective function for adaptive measurement are CFI and \\(\\mathrm{Tr}(W\\mathcal{I}^ {-1})\\) with \\(\\mathcal{I}\\) the CFIM. <code>W</code> is the weight matrix which defaults to the identity matrix.</p> <p>If the parameterization is implemented with the Kraus operators, the codes become</p> PythonJulia <pre><code>apt = Adapt(x, p, rho0, method=\"FOP\", savefile=False,  \n            max_episode=1000, eps=1e-8)\napt.Kraus(K, dK)               \napt.CFIM(M=[], W=[]) \n</code></pre> <pre><code>Adapt(x, p, rho0, K, dK; method=\"FOP\", savefile=false, \n      max_episode=1000, eps=1e-8, Hc=missing, ctrl=missing, \n      decay=missing, M=missing, W=missing)\n</code></pre> <p>and </p> PythonJulia <pre><code>K, dK = BayesInput(x, func, dfunc, channel=\"Kraus\")\n</code></pre> <pre><code>K, dK = BayesInput(x, func, dfunc; channel=\"Kraus\")\n</code></pre> <p>where <code>K</code> and <code>dK</code> are the Kraus operators and its derivatives with respect to the unknown parameters.</p> <p>Example 9.1 The Hamiltonian of a qubit system is \\begin{align} H=\\frac{B\\omega_0}{2}(\\sigma_1\\cos{x}+\\sigma_3\\sin{x}), \\end{align}</p> <p>where \\(B\\) is the magnetic field in the XZ plane, \\(x\\) is the unknown parameter and \\(\\sigma_{1}\\), \\(\\sigma_{3}\\) are the Pauli matrices.</p> <p>The probe state is taken as \\(|\\pm\\rangle\\). The measurement is  \\(\\{|\\!+\\rangle\\langle+\\!|,|\\!-\\rangle\\langle-\\!|\\}\\). Here \\(|\\pm\\rangle:=\\frac{1}{\\sqrt{2}}(|0\\rangle\\pm|1\\rangle)\\) with \\(|0\\rangle\\) \\((|1\\rangle)\\) the eigenstate of \\(\\sigma_3\\) with respect to the eigenvalue \\(1\\) \\((-1)\\). In this example, the prior distribution \\(p(x)\\) is uniform.</p> PythonJulia <pre><code>from quanestimation import *\nimport numpy as np\nimport random\n\n# initial state\nrho0 = 0.5 * np.array([[1., 1.], [1., 1.]])\n# free Hamiltonian\nB, omega0 = 0.5 * np.pi, 1.0\nsx = np.array([[0., 1.], [1., 0.]])\nsy = np.array([[0., -1.j], [1.j, 0.]]) \nsz = np.array([[1., 0.], [0., -1.]])\nH0_func = lambda x: 0.5*B*omega0*(sx*np.cos(x[0])+sz*np.sin(x[0]))\n# derivative of free Hamiltonian in x\ndH_func = lambda x: [0.5*B*omega0*(-sx*np.sin(x[0])+sz*np.cos(x[0]))]\n# measurement\nM1 = 0.5*np.array([[1., 1.], [1., 1.]])\nM2 = 0.5*np.array([[1., -1.], [-1., 1.]])\nM = [M1, M2]\n# time length for the evolution\ntspan = np.linspace(0., 1., 1000)\n# prior distribution\nx = np.linspace(-0.25*np.pi+0.1, 3.0*np.pi/4.0-0.1, 1000)\np = (1.0/(x[-1]-x[0]))*np.ones(len(x))\n# dynamics\nrho = [np.zeros((len(rho0), len(rho0)), dtype=np.complex128) for \\\n       i in range(len(x))]\nfor xi in range(len(x)):\n    H_tp = H0_func([x[xi]])\n    dH_tp = dH_func([x[xi]])\n    dynamics = Lindblad(tspan, rho0, H_tp, dH_tp)\n    rho_tp, drho_tp = dynamics.expm()\n    rho[xi] = rho_tp[-1]\n# Bayesian estimation\nnp.random.seed(1234)\ny = [0 for i in range(500)]\nres_rand = random.sample(range(0, len(y)), 125)\nfor i in range(len(res_rand)):\n    y[res_rand[i]] = 1\npout, xout = Bayes([x], p, rho, y, M=M, estimator=\"MAP\", savefile=False)\n# generation of H and dH\nH, dH = BayesInput([x], H0_func, dH_func, channel=\"dynamics\")\n# adaptive measurement\napt = Adapt([x], pout, rho0, method=\"FOP\", savefile=False, \n            max_episode=100, eps=1e-8)\napt.dynamics(tspan, H, dH, dyn_method=\"expm\")\napt.CFIM(M=M, W=[])\n</code></pre> <pre><code>using QuanEstimation\nusing Random\nusing StatsBase\n\n# free Hamiltonian\nfunction H0_func(x)\n    return 0.5*B*omega0*(sx*cos(x[1])+sz*sin(x[1]))\nend\n# derivative of free Hamiltonian in x\nfunction dH_func(x)\n    return [0.5*B*omega0*(-sx*sin(x[1])+sz*cos(x[1]))]\nend\n\nB, omega0 = pi/2.0, 1.0\nsx = [0. 1.; 1. 0.0im]\nsy = [0. -im; im 0.]\nsz = [1. 0.0im; 0. -1.]\n# initial state\nrho0 = 0.5*ones(2, 2)\n# measurement \nM1 = 0.5*[1.0+0.0im  1.; 1.  1.]\nM2 = 0.5*[1.0+0.0im -1.; -1.  1.]\nM = [M1, M2]\n# time length for the evolution\ntspan = range(0., stop=1., length=1000) |&gt;Vector\n# prior distribution\nx = range(-0.25*pi+0.1, stop=3.0*pi/4.0-0.1, length=1000) |&gt;Vector\np = (1.0/(x[end]-x[1]))*ones(length(x))\n# dynamics\nrho = Vector{Matrix{ComplexF64}}(undef, length(x))\nfor i = 1:length(x) \n    H0_tp = H0_func(x[i])\n    dH_tp = dH_func(x[i])\n    rho_tp, drho_tp = QuanEstimation.expm(tspan, rho0, H0_tp, dH_tp)\n    rho[i] = rho_tp[end]\nend\n# Bayesian estimation\nRandom.seed!(1234)\ny = [0 for i in 1:500]\nres_rand = sample(1:length(y), 125, replace=false)\nfor i in 1:length(res_rand)\n    y[res_rand[i]] = 1\nend\npout, xout = QuanEstimation.Bayes([x], p, rho, y, M=M, estimator=\"MAP\", savefile=false)\n# generation of H and dH\nH, dH = QuanEstimation.BayesInput([x], H0_func, dH_func; \n                                  channel=\"dynamics\")\n# adaptive measurement\nQuanEstimation.Adapt([x], pout, rho0, tspan, H, dH; M=M, dyn_method=:Expm, \n                     method=\"FOP\", max_episode=100)\n</code></pre> <p>Berry et al. [1,2] introduced a famous adaptive scheme in phase estimation. The  phase for the \\((n+1)\\)th round is updated via \\(\\Phi_{n+1}=\\Phi_{n}-(-1)^{y^{(n)}}\\Delta \\Phi_{n+1}\\) with \\(y^{(n)}\\) the experimental result in the \\(n\\)th round and \\(\\Delta\\Phi_{n+1}\\)  the phase difference generated by the proper algorithms. This adaptive scheme can be performed in QuanEstimation via</p> PythonJulia <p><pre><code>apt = Adapt_MZI(x, p, rho0)\napt.general()\napt.online(target=\"sharpness\", output=\"phi\")\n</code></pre> Here <code>x</code>, <code>p</code>, and <code>rho0</code> are the same with <code>Adapt</code>. <code>target=\"sharpness\"</code> represents the target function for calculating the tunable phase is sharpness, and it can also be set as  <code>target=\"MI\"</code> which means the target function is mutual information. The output can be set  through <code>output=\"phi\"</code> (default) and <code>output=\"dphi\"</code> representing the phase and phase  difference, respectively. Online and offline strategies are both available in the package  and the code for calling offline stratege becomes <code>apt.offline(method=\"DE\", **kwargs)</code> or  <code>apt.offline(method=\"PSO\", **kwargs)</code>. </p> <p><pre><code>apt = Adapt_MZI(x, p, rho0)\nonline(apt, target=:sharpness, output=\"phi\")\n</code></pre> Here <code>x</code>, <code>p</code>, and <code>rho0</code> are the same with <code>Adapt</code>. <code>target=:sharpness</code> represents the target function for calculating the tunable phase is sharpness, and it can also be set as  <code>target=:MI</code> which means the target function is mutual information. The output can be set  through <code>output=\"phi\"</code> (default) and <code>output=\"dphi\"</code> representing the phase and phase  difference, respectively. Online and offline strategies are both available in the package  and the code for calling offline stratege becomes <code>alg = QuanEstimation.DE(kwargs...)</code>  (<code>alg = QuanEstimation.PSO(kwargs...)</code>) and <code>offline(apt, alg, seed=seed)</code>.  <code>seed</code> is the random seed which can ensure the reproducibility of results.</p> <p>If the optimization algorithm is PSO, the keywords and the default values are</p> PythonJulia <p><pre><code>kwargs = {\"p_num\":10, \"deltaphi0\":[], \"max_episode\":[1000,100], \n          \"c0\":1.0, \"c1\":2.0, \"c2\":2.0, \"seed\":1234}\n</code></pre> The keywords and the default values of PSO can be seen in the following table</p> \\(~~~~~~~~~~\\)**kwargs\\(~~~~~~~~~~\\) \\(~~~~\\)default values\\(~~~~\\) \"p_num\" 10 \"deltaphi0\" [ ] \"max_episode\" [1000,100] \"c0\" 1.0 \"c1\" 2.0 \"c2\" 2.0 \"seed\" 1234 <p>Here <code>p_num</code> is the number of particles, <code>deltaphi0</code> represents the initial  guesses of phase difference. <code>max_episode</code> accepts both integer and array with two  elements. If it is an integer, for example <code>max_episode=1000</code>, it means the  program will continuously run 1000 episodes. However, if it is an array, for example  <code>max_episode=[1000,100]</code>, the program will run 1000 episodes in total but replace the data  of all the particles with global best every 100 episodes. <code>c0</code>, <code>c1</code> and <code>c2</code> are the PSO  parameters representing the inertia weight, cognitive learning factor and social  learning factor, respectively. </p> <p><pre><code>alg = PSO(p_num=10, ini_particle=missing, max_episode=[1000,100], \n          c0=1.0, c1=2.0, c2=2.0)\n</code></pre> The keywords and the default values of PSO can be seen in the following table</p> \\(~~~~~~~~~~\\)keywords\\(~~~~~~~~~~\\) \\(~~~~\\)default values\\(~~~~\\) \"p_num\" 10 \"ini_particle\" missing \"max_episode\" [1000,100] \"c0\" 1.0 \"c1\" 2.0 \"c2\" 2.0 <p>Here <code>p_num</code> is the number of particles, <code>ini_particle</code> represents the initial guesses  of phase difference. <code>max_episode</code> accepts both integer and array with two elements.  If it is an integer, for example <code>max_episode=1000</code>, it means the program will  continuously run 1000 episodes. However, if it is an array, for example  <code>max_episode=[1000,100]</code>, the program will run 1000 episodes in total but replace the  data of all the particles with global best every 100 episodes. <code>c0</code>, <code>c1</code> and <code>c2</code> are  the PSO parameters representing the inertia weight, cognitive learning factor and  social learning factor, respectively. </p> <p>If the optimization algorithm is DE, the keywords and the default values are</p> PythonJulia <p><pre><code>kwargs = {\"p_num\":10, \"deltaphi0\":[], \"max_episode\":1000, \"c\":1.0, \n          \"cr\":0.5, \"seed\":1234}\n</code></pre> The keywords and the default values of DE can be seen in the following table</p> \\(~~~~~~~~~~\\)**kwargs\\(~~~~~~~~~~\\) \\(~~~~\\)default values\\(~~~~\\) \"p_num\" 10 \"deltaphi0\" [ ] \"max_episode\" 1000 \"c\" 1.0 \"cr\" 0.5 \"seed\" 1234 <p><code>p_num</code> and <code>max_episode</code> are the number of populations and training episodes.  <code>c</code> and <code>cr</code> are DE parameters representing the mutation and crossover constants,  <code>seed</code> is the random seed which can ensure the reproducibility of results.</p> <p><pre><code>alg = DE(p_num=10, ini_population=missing, max_episode=1000, \n         c=1.0, cr=0.5)\n</code></pre> The keywords and the default values of DE can be seen in the following table</p> \\(~~~~~~~~~~\\)keywords\\(~~~~~~~~~~\\) \\(~~~~\\)default values\\(~~~~\\) \"p_num\" 10 \"ini_population\" missing \"max_episode\" 1000 \"c\" 1.0 \"cr\" 0.5 <p><code>ini_population</code> represents the initial guesses of phase difference. <code>p_num</code> and  <code>max_episode</code> are the number of populations and training episodes. <code>c</code> and <code>cr</code> are  DE parameters representing the mutation and crossover constants.</p> <p>Example 9.2 In this example, the adaptive measurement shceme is design for the MZI [3,4].  The input state is  \\begin{align} \\sqrt{\\frac{2}{N+2}}\\sum^{N/2}_{m=-N/2}\\sin\\left(\\frac{(2m+N+2)\\pi}{2(N+2)}\\right)|m\\rangle, \\end{align}</p> <p>where \\(N\\) is the number of photon, \\(|m\\rangle\\) is the eigenstate of \\(J_y\\) with the eigenvalue  \\(m\\).</p> PythonJulia <pre><code>from quanestimation import *\nimport numpy as np\n\n# the number of photons\nN = 8\n# probe state\npsi = np.zeros((N+1)**2).reshape(-1, 1)\nfor k in range(N+1):\n    psi += np.sin((k+1)*np.pi/(N+2))* \\\n           np.kron(basis(N+1, k), basis(N+1, N-k))\npsi = np.sqrt(2/(2+N))*psi\nrho0 = np.dot(psi, psi.conj().T)\n# prior distribution\nx = np.linspace(-np.pi, np.pi, 100)\np = (1.0/(x[-1]-x[0]))*np.ones(len(x))\napt = Adapt_MZI(x, p, rho0)\napt.general()\n</code></pre> onlineoffline <pre><code>apt.online(target=\"sharpness\", output=\"phi\")\n</code></pre> DEPSO <pre><code>DE_para = {\"p_num\":10, \"deltaphi0\":[], \"max_episode\":1000, \"c\":1.0, \n           \"cr\":0.5, \"seed\":1234}\napt.offline(target=\"sharpness\", method=\"DE\", **DE_para)\n</code></pre> <pre><code>PSO_para = {\"p_num\":10, \"deltaphi0\":[], \"max_episode\":[1000,100], \n            \"c0\":1.0, \"c1\":2.0, \"c2\":2.0, \"seed\":1234}\napt.offline(target=\"sharpness\", method=\"PSO\", **PSO_para)\n</code></pre> <pre><code>using QuanEstimation\nusing SparseArrays\n\n# the number of photons\nN = 8\n# probe state\npsi = sum([sin(k*pi/(N+2))*kron(QuanEstimation.basis(N+1,k), \n      QuanEstimation.basis(N+1, N-k+2)) for k in 1:(N+1)]) |&gt; sparse\npsi = psi*sqrt(2/(2+N))\nrho0 = psi*psi'\n# prior distribution\nx = range(-pi, pi, length=100)\np = (1.0/(x[end]-x[1]))*ones(length(x))\napt = QuanEstimation.Adapt_MZI(x, p, rho0)\n</code></pre> onlineoffline <pre><code>QuanEstimation.online(apt, target=:sharpness, output=\"phi\")\n</code></pre> DEPSO <pre><code>alg = QuanEstimation.DE(p_num=10, ini_population=missing, \n                        max_episode=1000, c=1.0, cr=0.5)\nQuanEstimation.offline(apt, alg, target=:sharpness, seed=1234)\n</code></pre> <pre><code>alg = QuanEstimation.PSO(p_num=10, ini_particle=missing,  \n                         max_episode=[1000,100], c0=1.0, \n                         c1=2.0, c2=2.0)\nQuanEstimation.offline(apt, alg, target=:sharpness, seed=1234)\n</code></pre>"},{"location":"guide/guide_adaptive/#bibliography","title":"Bibliography","text":"<p>[1] D. W. Berry and H. M. Wiseman,  Optimal States and Almost Optimal Adaptive Measurements for Quantum Interferometry,  Phys. Rev. Lett. 85, 5098 (2000).</p> <p>[2] D. W. Berry, H. M. Wiseman, and J. K. Breslin,  Optimal input states and feedback for interferometric phase estimation,  Phys. Rev. A 63, 053804 (2001).</p> <p>[3] A. Hentschel and B. C. Sanders, Machine Learning for Precise Quantum Measurement, Phys. Rev. Lett. 104, 063603 (2010).</p> <p>[4] A. Hentschel and B. C. Sanders, Efficient Algorithm for Optimizing Adaptive Quantum Metrology Processes, Phys. Rev. Lett. 104, 063603 (2011).</p>"},{"location":"guide/guide_bounds/","title":"Quantum metrological tools","text":"<p>QuanEstimation can be used to calculate several well-used metrological tools including  Quantum Cram\u00e9r-Rao bounds, Holevo Cram\u00e9r-Rao bound, Bayesian Cram\u00e9r-Rao bounds, Quantum  Ziv-Zakai bound and perform Bayesian estimation.</p> <p>Notes: When calculating with Python and Julia (i.e., calcute the inverse and eigenvalues  of matrices), the results may vary due to the inconsistency of the retained effective digits.  This difference has no effect on optimization. If users want to get consistent results, the same number of significant digits for calculation should be input,  (i.e., keep 8 decimal places).</p>"},{"location":"guide/guide_bounds/#quantum-cramer-rao-bounds","title":"Quantum Cram\u00e9r-Rao bounds","text":"<p>In quantum metrology, quantum Cram\u00e9r-Rao bounds are well used metrological tools for  parameter estimation. It can be expressed as [1,2,3] \\begin{align} \\mathrm{cov}\\left(\\hat{\\textbf{x}}, {\\Pi_y}\\right) \\geq \\frac{1}{n}\\mathcal{I}^{-1} \\left({\\Pi_y}\\right) \\geq \\frac{1}{n} \\mathcal{F}^{-1}, \\end{align}</p> <p>where \\(\\mathrm{cov}(\\hat{\\textbf{x}},\\{\\Pi_y\\})=\\sum_y\\mathrm{Tr}(\\rho\\Pi_y)(\\hat{\\textbf{x}} -\\textbf{x})(\\hat{\\textbf{x}}-\\textbf{x})^{\\mathrm{T}}\\) is the covariance matrix for the  unknown parameters \\(\\hat{\\textbf{x}}=(\\hat{x}_0,\\hat{x}_1,\\dots)^{\\mathrm{T}}\\) to be estimated.  \\(\\{\\Pi_y\\}\\) is a set of positive operator-valued measure (POVM) and \\(\\rho\\) represents the  parameterized density matrix. \\(n\\) is the repetition of the experiment, \\(\\mathcal{I}\\) and  \\(\\mathcal{F}\\) are the classical Fisher information matrix (CFIM) and quantum Fisher information  matrix (QFIM), respectively. The \\(ab\\)th entry of CFIM is defined as \\begin{align} \\mathcal{I}_{ab}=\\sum_y\\frac{1}{p(y|\\textbf{x})}[\\partial_a p(y|\\textbf{x})][\\partial_b  p(y|\\textbf{x})] \\end{align}</p> <p>with \\(p(y|\\textbf{x})=\\mathrm{Tr}(\\rho\\Pi_y)\\). The most well-used type of the QFIM is  SLD-based QFIM of the form \\begin{align} \\mathcal{F}_{ab}=\\frac{1}{2}\\mathrm{Tr}[\\rho (L_aL_b+ L_bL_a)] \\end{align}</p> <p>with \\(\\mathcal{F}_{ab}\\) the \\(ab\\)th entry of \\(\\mathcal{F}\\) and \\(L_{a}(L_{b})\\) the symmetric  logarithmic derivative (SLD) operator for \\(x_{a}(x_b)\\). The SLD operator is determined by \\begin{align} \\partial_{a}\\rho=\\frac{1}{2}(\\rho L_{a}+L_{a}\\rho). \\end{align}</p> <p>The \\(ij\\)th entry of SLD can be calculated by \\begin{align} \\langle\\lambda_i|L_{a}|\\lambda_j\\rangle=\\frac{2\\langle\\lambda_i| \\partial_{a}\\rho  |\\lambda_j\\rangle} {\\lambda_i+\\lambda_j}, ~~\\lambda_i (\\lambda_j)\\neq 0 . \\end{align}</p> <p>For \\(\\lambda_i (\\lambda_j)=0\\), the above equation is set to be zero.</p> <p>Besides, there are right logarithmic derivative (RLD) and left logarithmic derivative (LLD)  defined by \\(\\partial_{a}\\rho=\\rho \\mathcal{R}_a\\) and \\(\\partial_{a}\\rho=\\mathcal{R}_a^{\\dagger} \\rho\\) with the  corresponding QFIM  \\(\\mathcal{F}_{ab}=\\mathrm{Tr}(\\rho \\mathcal{R}_a  \\mathcal{R}^{\\dagger}_b)\\). The RLD and LLD operators are calculated via</p> \\[\\begin{align} \\langle\\lambda_i| \\mathcal{R}_{a} |\\lambda_j\\rangle &amp;= \\frac{1}{\\lambda_i}\\langle\\lambda_i| \\partial_{a}\\rho |\\lambda_j\\rangle,~~\\lambda_i\\neq 0, \\\\ \\langle\\lambda_i| \\mathcal{R}_{a}^{\\dagger} |\\lambda_j\\rangle &amp;= \\frac{1}{\\lambda_j}\\langle\\lambda_i| \\partial_{a}\\rho |\\lambda_j\\rangle,~~\\lambda_j\\neq 0. \\end{align}\\] <p>In QuanEstimation, three types of the logarithmic derivatives can be solved by calling the  codes</p> PythonJulia <p><pre><code>SLD(rho, drho, rep=\"original\", eps=1e-8)\n</code></pre> <pre><code>RLD(rho, drho, rep=\"original\", eps=1e-8)\n</code></pre> <pre><code>LLD(rho, drho, rep=\"original\", eps=1e-8)\n</code></pre></p> <p><pre><code>SLD(rho, drho; rep=\"original\", eps=1e-8)\n</code></pre> <pre><code>RLD(rho, drho; rep=\"original\", eps=1e-8)\n</code></pre> <pre><code>LLD(rho, drho; rep=\"original\", eps=1e-8)\n</code></pre></p> <p>where <code>rho</code> and <code>drho</code> are the density matrix of the state and its derivatives with respect to the unknown parameters to be estimated. <code>drho</code> should be input as \\([\\partial_a{\\rho},  \\partial_b{\\rho}, \\cdots]\\). For single parameter estimation (the length of <code>drho</code> is equal to  one), the output is a matrix and for multiparameter estimation (the length of <code>drho</code> is more  than one), it returns a list. There are two output choices for the logarithmic derivatives  basis which can be setting through <code>rep</code>. The default basis (<code>rep=\"original\"</code>) of the logarithmic  derivatives is the same with <code>rho</code> and the users can also request the logarithmic derivatives  written in the eigenspace of <code>rho</code> by <code>rep=\"eigen\"</code>. <code>eps</code> represents the machine epsilon which  defaults to \\(10^{-8}\\).</p> <p>In QuanEstimation, the QFI and QFIM can be calculated via the following function</p> PythonJulia <p><pre><code>QFIM(rho, drho, LDtype=\"SLD\", exportLD=False, eps=1e-8)\n</code></pre> <code>LDtype</code> represents the types of QFI (QFIM) can be set. Options are <code>LDtype=SLD</code> (default),  <code>LDtype=RLD</code> and <code>LDtype=LLD</code>. This function will return QFI (QFIM) if <code>exportLD=False</code>, however, if the users set <code>exportLD=True</code>, it will return logarithmic derivatives apart  from QFI (QFIM).</p> <p><pre><code>QFIM(rho, drho; LDtype=:SLD, exportLD=false, eps=1e-8)\n</code></pre> <code>LDtype</code> represents the types of QFI (QFIM) can be set. Options are <code>LDtype=SLD</code> (default),  <code>LDtype=RLD</code> and <code>LDtype=LLD</code>. This function will return QFI (QFIM) if <code>exportLD=false</code>, however, if the users set <code>exportLD=true</code>, it will return logarithmic derivatives apart  from QFI (QFIM).</p> <p>Example 3.1  The Hamiltonian of a single qubit system is \\(H=\\frac{1}{2}\\omega \\sigma_3\\) with \\(\\omega\\)  the frequency and \\(\\sigma_3\\) a Pauli matrix. The dynamics of the system is governed by</p> \\[\\begin{align} \\partial_t\\rho=-i[H, \\rho]+ \\gamma_{+}\\left(\\sigma_{+}\\rho\\sigma_{-}-\\frac{1}{2}\\{\\sigma_{-} \\sigma_{+},\\rho\\}\\right)+ \\gamma_{-}\\left(\\sigma_{-}\\rho\\sigma_{+}-\\frac{1}{2}\\{\\sigma_{+} \\sigma_{-},\\rho\\}\\right), \\end{align}\\] <p>where \\(\\sigma_{\\pm}=\\frac{1}{2}(\\sigma_1 \\pm \\sigma_2)\\) with \\(\\sigma_{1}\\), \\(\\sigma_{2}\\) Pauli  matrices and \\(\\gamma_{+}\\), \\(\\gamma_{-}\\) are decay rates. The probe state is taken as \\(|+\\rangle\\)  with \\(|+\\rangle=\\frac{1}{\\sqrt{2}}(|0\\rangle+|1\\rangle)\\). Here \\(|0\\rangle\\) and \\(|1\\rangle\\) are  the eigenstates of \\(\\sigma_3\\) with respect to the eigenvalues \\(1\\) and \\(-1\\).</p> PythonJulia <pre><code>from quanestimation import *\nimport numpy as np\n\n# initial state\nrho0 = 0.5*np.array([[1., 1.], [1., 1.]])\n# free Hamiltonian\nomega = 1.0\nsz = np.array([[1., 0.], [0., -1.]])\nH0 = 0.5*omega*sz\n# derivative of the free Hamiltonian on omega\ndH = [0.5*sz]\n# dissipation\nsp = np.array([[0., 1.], [0., 0.]])  \nsm = np.array([[0., 0.], [1., 0.]]) \ndecay = [[sp, 0.0], [sm, 0.1]]\n# time length for the evolution\ntspan = np.linspace(0., 50., 2000)\n# dynamics\ndynamics = Lindblad(tspan, rho0, H0, dH, decay)\nrho, drho = dynamics.expm()\n# calculation of the QFI\nF = []\nfor ti in range(1,2000):\n    # QFI\n    F_tp = QFIM(rho[ti], drho[ti])\n    F.append(F_tp)\n</code></pre> <pre><code>using QuanEstimation\n\n# initial state\nrho0 = 0.5*ones(2, 2)\n# free Hamiltonian\nomega = 1.0\nsx = [0. 1.; 1. 0.0im]\nsy = [0. -im; im 0.]\nsz = [1. 0.0im; 0. -1.]\nH0 = 0.5*omega*sz\n# derivative of the free Hamiltonian on omega\ndH = [0.5*sz]\n# dissipation\nsp = [0. 1.; 0. 0.0im]\nsm = [0. 0.; 1. 0.0im]\ndecay = [[sp, 0.0], [sm, 0.1]]\n# time length for the evolution\ntspan = range(0., 50., length=2000)\n# dynamics\nrho, drho = QuanEstimation.expm(tspan, rho0, H0, dH, decay)\n# calculation of the QFI\nF = Float64[]\nfor ti in 2:length(tspan)\n    # QFI\n    F_tp = QuanEstimation.QFIM(rho[ti], drho[ti])\n    append!(F, F_tp)\nend\n</code></pre> <p>If the parameterization process is excuted via the Kraus operators, the QFI (QFIM) can be  calculated by calling the function</p> PythonJulia <pre><code>QFIM_Kraus(rho0, K, dK, LDtype=\"SLD\", exportLD=False, eps=1e-8)\n</code></pre> <pre><code>QFIM_Kraus(rho0, K, dK; LDtype=:SLD, exportLD=false, eps=1e-8)\n</code></pre> <p>where <code>K</code> and <code>dK</code> are the Kraus operators and the derivatives with respect to the unknown  parameters to be estimated.</p> <p>Example 3.2 The Kraus operators for the amplitude damping channel are</p> \\[\\begin{eqnarray} K_1 = \\left(\\begin{array}{cc} 1 &amp; 0  \\\\ 0 &amp; \\sqrt{1-\\gamma} \\end{array}\\right), K_2 = \\left(\\begin{array}{cc} 0 &amp; \\sqrt{\\gamma} \\\\ 0 &amp; 0 \\end{array}\\right), \\nonumber \\end{eqnarray}\\] <p>where \\(\\gamma\\) is unknown parameter to be estimated which represents the decay probability.  In this example, the probe state is taken as \\(|+\\rangle\\langle+|\\) with \\(|+\\rangle:=\\frac{1} {\\sqrt{2}}(|0\\rangle+|1\\rangle)\\). \\(|0\\rangle\\) \\((|1\\rangle)\\) is the eigenstate of \\(\\sigma_3\\)  (Pauli matrix) with respect to the eigenvalue \\(1\\) \\((-1)\\).</p> PythonJulia <pre><code>from quanestimation import *\nimport numpy as np\n\n# initial state\nrho0 = 0.5*np.array([[1., 1.], [1., 1.]])\n# Kraus operators for the amplitude damping channel\ngamma = 0.1\nK1 = np.array([[1., 0.], [0., np.sqrt(1-gamma)]])\nK2 = np.array([[0., np.sqrt(gamma)], [0., 0.]])\nK = [K1, K2]\n# derivatives of Kraus operators on gamma\ndK1 = np.array([[1., 0.], [0., -0.5/np.sqrt(1-gamma)]])\ndK2 = np.array([[0., 0.5/np.sqrt(gamma)], [0., 0.]])\ndK = [[dK1], [dK2]]\nF = QFIM_Kraus(rho0, K, dK)\n</code></pre> <pre><code>using QuanEstimation\n\n# initial state\nrho0 = [0.5+0im 0.5; 0.5 0.5]\n# Kraus operators for the amplitude damping channel\ngamma = 0.1\nK1 = [1. 0.; 0. sqrt(1-gamma)]\nK2 = [0. sqrt(gamma); 0. 0.]\nK = [K1, K2]\n# derivatives of Kraus operators on gamma\ndK1 = [1. 0.; 0. -0.5/sqrt(1-gamma)]\ndK2 = [0. 0.5/sqrt(gamma); 0. 0.]\ndK = [[dK1], [dK2]]\nF = QuanEstimation.QFIM_Kraus(rho0, K, dK)\n</code></pre> <p>The FI (FIM) for a set of the probabilities <code>p</code> can be calculated by</p> PythonJulia <pre><code>FIM(p, dp, eps=1e-8)\n</code></pre> <pre><code>FIM(p, dp; eps=1e-8)\n</code></pre> <p>where <code>dp</code> is a list representing the derivatives of the probabilities <code>p</code> with respect to  the unknown parameters.</p> <p>Example 3.3 </p> PythonJulia <pre><code>from quanestimation import *\n\np = [0.54, 0.46]\ndp = [[0.54], [-0.54]]\nF = FIM(p, dp)\n</code></pre> <pre><code>using QuanEstimation\n\np = [0.54, 0.46]\ndp = [[0.54], [-0.54]]\nF = QuanEstimation.FIM(p, dp)\n</code></pre> <p>The FI can also be calculated based on the experiment data</p> PythonJulia <pre><code>FI_Expt(y1, y2, dx, ftype=\"norm\")\n</code></pre> <pre><code>FI_Expt(y1, y2, dx; ftype=:norm)\n</code></pre> <p><code>y1</code> and <code>y2</code> are two arrays representing the experimental data obtained at \\(x\\) and \\(x+\\delta x\\), respectively.  \\(\\delta x\\) is a known small drift corresponds to <code>dx</code>.  <code>ftype</code> represents the distribution that the data follows, which can be choosen in \"norm\",  \"gamma\", \"rayleigh\", and \"poisson\".  <code>ftype=\"norm\"</code> represents the normal (Gaussian) distribution with the probability density function \\begin{align} f(x)=\\frac{1}{\\sigma\\sqrt{2\\pi}}e^{-(x-\\mu)^2/2\\sigma^2} \\end{align} for distribution fitting, where \\(\\mu\\) and \\(\\sigma\\) are the mean and variance of the distribution,  respectively. </p> <p><code>ftype=\"gamma\"</code> represents the gamma distribution of the form \\begin{align} f(x)=\\frac{x^{\\alpha-1}e^{-\\beta x}\\beta^\\alpha}{\\Gamma(\\alpha)} \\end{align} with \\(\\alpha\\) the shape and \\(\\beta\\) the rate of the distribution. \\(\\Gamma(\\alpha)\\) is the gamma function.</p> <p>If the data follows a rayleigh distribution, the data can be fit through setting  <code>ftype=\"rayleigh\"</code>. The probability density function of the rayleigh distribution is \\begin{align} f(x)=\\frac{x-\\mu}{\\sigma^2}e^{-(x-\\mu)^2/2\\sigma^2} \\end{align} with \\(\\mu\\) and \\(\\sigma\\) the mean and variance of the distribution.</p> <p><code>ftype=\"poisson\"</code> represents a discrete Poisson distribution with the probability mass function \\begin{align} f(k)=\\frac{\\lambda^k e^{-\\lambda}}{k!}, \\end{align} where \\(k=0,1,2,\\cdots\\) represents the number of occurrences, \\(\\lambda\\) represents the variance of the data, \\(!\\) is the factorial function. </p> <p>In quantum metrology, the CFI (CFIM) are solved by</p> PythonJulia <p><pre><code>CFIM(rho, drho, M=[], eps=1e-8)\n</code></pre> Here <code>M</code> represents a set of positive operator-valued measure (POVM) with default value <code>[]</code>.  In this function, a set of rank-one symmetric informationally complete POVM (SIC-POVM) is used  when <code>M=[]</code>. SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state  which can be downloaded from here. </p> <p><pre><code>CFIM(rho, drho; M=missing, eps=1e-8)\n</code></pre> Here <code>M</code> represents a set of positive operator-valued measure (POVM) with default value <code>missing</code>.  In this function, a set of rank-one symmetric informationally complete POVM (SIC-POVM) is used  when <code>M=missing</code>. SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state  which can be downloaded from here. </p> <p>Example 3.4  The Hamiltonian of a single qubit system is \\(H=\\frac{1}{2}\\omega \\sigma_3\\) with \\(\\omega\\)  the frequency and \\(\\sigma_3\\) a Pauli matrix. The dynamics of the system is governed by \\begin{align} \\partial_t\\rho=-i[H, \\rho]+ \\gamma_{+}\\left(\\sigma_{+}\\rho\\sigma_{-}-\\frac{1}{2}{\\sigma_{-} \\sigma_{+}, \\rho}\\right)+ \\gamma_{-}\\left(\\sigma_{-}\\rho\\sigma_{+}-\\frac{1}{2}{\\sigma_{+} \\sigma_{-},\\rho}\\right), \\end{align}</p> <p>where \\(\\sigma_{\\pm}=\\frac{1}{2}(\\sigma_1 \\pm \\sigma_2)\\) with \\(\\sigma_{1}\\), \\(\\sigma_{2}\\) Pauli  matrices and \\(\\gamma_{+}\\), \\(\\gamma_{-}\\) are decay rates. The probe state is taken as \\(|+\\rangle\\)  and the measurement for CFI is \\(\\{|+\\rangle\\langle+|, |-\\rangle\\langle-|\\}\\) with \\(|\\pm\\rangle=\\frac{1}{\\sqrt{2}}(|0\\rangle\\pm|1\\rangle)\\). Here \\(|0\\rangle\\) and \\(|1\\rangle\\) are  the eigenstates of \\(\\sigma_3\\) with respect to the eigenvalues \\(1\\) and \\(-1\\).</p> PythonJulia <pre><code>from quanestimation import *\nimport numpy as np\n\n# initial state\nrho0 = 0.5*np.array([[1., 1.], [1., 1.]])\n# free Hamiltonian\nomega = 1.0\nsz = np.array([[1., 0.], [0., -1.]])\nH0 = 0.5*omega*sz\n# derivative of the free Hamiltonian on omega\ndH = [0.5*sz]\n# dissipation\nsp = np.array([[0., 1.], [0., 0.]])  \nsm = np.array([[0., 0.], [1., 0.]]) \ndecay = [[sp, 0.0], [sm, 0.1]]\n# measurement\nM1 = 0.5*np.array([[1., 1.], [1., 1.]])\nM2 = 0.5*np.array([[1., -1.], [-1., 1.]])\nM = [M1, M2]\n# time length for the evolution\ntspan = np.linspace(0., 50., 2000)\n# dynamics\ndynamics = Lindblad(tspan, rho0, H0, dH, decay)\nrho, drho = dynamics.expm()\n# calculation of the CFI\nI = []\nfor ti in range(1,2000):\n    # CFI\n    I_tp = CFIM(rho[ti], drho[ti], M=M)\n    I.append(I_tp)\n</code></pre> <pre><code>using QuanEstimation\n\n# initial state\nrho0 = 0.5*ones(2, 2)\n# free Hamiltonian\nomega = 1.0\nsx = [0. 1.; 1. 0.0im]\nsy = [0. -im; im 0.]\nsz = [1. 0.0im; 0. -1.]\nH0 = 0.5*omega*sz\n# derivative of the free Hamiltonian on omega\ndH = [0.5*sz]\n# dissipation\nsp = [0. 1.; 0. 0.0im]\nsm = [0. 0.; 1. 0.0im]\ndecay = [[sp, 0.0], [sm, 0.1]]\n# measurement\nM1 = 0.5*[1.0+0.0im  1.; 1.  1.]\nM2 = 0.5*[1.0+0.0im -1.; -1.  1.]\nM = [M1, M2]\n# time length for the evolution\ntspan = range(0., 50., length=2000)\n# dynamics\nrho, drho = QuanEstimation.expm(tspan, rho0, H0, dH, decay)\n# calculation of the CFI\nIm = Float64[]\nfor ti in 2:length(tspan)\n    # CFI\n    I_tp = QuanEstimation.CFIM(rho[ti], drho[ti], M)\n    append!(Im, I_tp)\nend\n</code></pre> <p>In Bloch representation, the SLD based QFI (QFIM) is calculated by</p> PythonJulia <pre><code>QFIM_Bloch(r, dr, eps=1e-8)\n</code></pre> <pre><code>QFIM_Bloch(r, dr; eps=1e-8)\n</code></pre> <p><code>r</code> and <code>dr</code> are the parameterized Bloch vector and its derivatives of with respect to the  unknown parameters to be estimated.</p> <p>Example 3.5 The arbitrary single-qubit state can be written as  \\begin{align} |\\psi\\rangle=\\cos\\frac{\\theta}{2}|0\\rangle+e^{i\\phi}\\sin\\frac{\\theta}{2}|1\\rangle \\end{align}</p> <p>with \\(\\theta\\) and \\(\\phi\\) the parameters to be estimated. The Bloch vector for this state is \\(r=(\\sin\\theta\\cos\\phi, \\sin\\theta\\sin\\phi, \\cos\\theta)^{\\mathrm{T}}\\) and the derivatives  with respect to \\(\\theta\\) and \\(\\phi\\) are  \\(\\partial_\\theta r=(\\cos\\theta\\cos\\phi, \\cos\\theta\\sin\\phi, -\\sin\\theta)^{\\mathrm{T}}\\) and  \\(\\partial_\\phi r=(-\\sin\\theta\\sin\\phi, \\sin\\theta\\cos\\phi, 0)^{\\mathrm{T}}\\)</p> PythonJulia <pre><code>from quanestimation import *\nimport numpy as np\n\ntheta, phi = 0.25*np.pi, 0.25*np.pi\nr = np.array([np.sin(theta)*np.cos(phi), \\\n              np.sin(theta)*np.sin(phi), \\\n              np.cos(theta)])\ndr_theta = np.array([np.cos(theta)*np.cos(phi), \\\n                     np.cos(theta)*np.sin(phi), \\\n                     -np.sin(theta)])\ndr_phi = np.array([-np.sin(theta)*np.sin(phi), \\\n                   np.sin(theta)*np.cos(phi), \\\n                   0.])\ndr = [dr_theta, dr_phi]\nF = QFIM_Bloch(r, dr)\n</code></pre> <pre><code>using QuanEstimation\nusing LinearAlgebra\n\ntheta, phi = 0.25*pi, 0.25*pi\nr = [sin(theta)*cos(phi), sin(theta)*sin(phi), cos(theta)]\ndr_theta = [cos(theta)*cos(phi), cos(theta)*sin(phi), -sin(theta)]\ndr_phi = [-sin(theta)*sin(phi), sin(theta)*cos(phi), 0.]\ndr = [dr_theta, dr_phi]\nF = QuanEstimation.QFIM_Bloch(r, dr)\n</code></pre> <p>The package can also calculte the SLD based QFI (QFIM) with Gaussian states. </p> PythonJulia <pre><code>QFIM_Gauss(R, dR, D, dD)\n</code></pre> <pre><code>QFIM_Gauss(R, dR, D, dD)\n</code></pre> <p>The variable <code>R</code> is the expected value \\(\\left(\\langle[\\textbf{R}]_i\\rangle\\right)\\) of  \\(\\textbf{R}\\) with respect to \\(\\rho\\), it is an array representing the first-order moment.  Here \\(\\textbf{R}=(q_1,p_1,q_2,p_2,\\dots)^{\\mathrm{T}}\\) with \\(q_i=\\frac{1}{\\sqrt{2}} (a_i+a^{\\dagger}_i)\\) and \\(p_i=\\frac{1}{i\\sqrt{2}}(a_i-a^{\\dagger}_i)\\) represents a vector  of quadrature operators. <code>dR</code> is a list of derivatives of <code>R</code> with respect to the unknown  parameters. The \\(i\\)th entry of <code>dR</code> is \\(\\partial_{\\textbf{x}} \\langle[\\textbf{R}]_i\\rangle\\).  <code>D</code> and <code>dD</code> represent the second-order moment matrix with the \\(ij\\)th entry \\(D_{ij}=\\langle  [\\textbf{R}]_i [\\textbf{R}]_j+[\\textbf{R}]_j [\\textbf{R}]_i\\rangle/2\\) and its derivatives with  respect tp the unknown parameters.</p> <p>Example 3.6 The first and second moments [13] are</p> \\[\\begin{eqnarray} \\langle[\\textbf{R}]_i\\rangle = \\left(\\begin{array}{cc} 0   \\\\ 0   \\end{array}\\right), D = \\lambda\\left(\\begin{array}{cc} \\cosh 2r &amp; -\\sinh 2r \\\\ -\\sinh 2r &amp; -\\sinh 2r \\end{array}\\right), \\nonumber \\end{eqnarray}\\] <p>where \\(\\lambda=\\coth\\frac{\\beta}{2}\\).  \\(r\\) and \\(\\beta\\) are the parameters to be estimated.</p> PythonJulia <pre><code>from quanestimation import *\nimport numpy as np\n\ndim = 2\nr, beta = 0.2, 1.0\nLambda = np.cosh(0.5*beta)/np.sinh(0.5*beta)\n# the first-order moment\nR = np.zeros(dim)\ndR = [np.zeros(dim), np.zeros(dim)]\n# the second-order moment\nD = Lambda*np.array([[np.cosh(2*r), -np.sinh(2*r)], \\\n                     [-np.sinh(2*r), np.cosh(2*r)]])\ndD_r = 2*Lambda*np.array([[np.sinh(2*r), -np.cosh(2*r)], \\\n                          [-np.cosh(2*r), np.sinh(2*r)]])\ndD_Lambda = 0.5*(Lambda**2-1)*np.array([[-np.cosh(2*r), np.sinh(2*r)], \\\n                                        [np.sinh(2*r), -np.cosh(2*r)]])\ndD = np.array([dD_r, dD_Lambda])\nF = QFIM_Gauss(R, dR, D, dD)\n</code></pre> <pre><code>using QuanEstimation\n\ndim = 2\nr, beta = 0.2, 1.0\nLambda = coth(0.5*beta)\n# the first-order moment\nR = zeros(dim)\ndR = [zeros(dim), zeros(dim)]\nD = Lambda*[cosh(2*r) -sinh(2*r); -sinh(2*r) cosh(2*r)]\ndD_r = 2*Lambda*[sinh(2*r) -cosh(2*r); -cosh(2*r) sinh(2*r)]\ndD_Lambda = 0.5*(Lambda^2-1)*[-cosh(2*r) sinh(2*r); sinh(2*r) -cosh(2*r)]\ndD = [dD_r, dD_Lambda]\nF = QuanEstimation.QFIM_Gauss(R, dR, D, dD)\n</code></pre>"},{"location":"guide/guide_bounds/#holevo-cramer-rao-bound","title":"Holevo Cram\u00e9r-Rao bound","text":"<p>Holevo Cram\u00e9r-Rao bound (HCRB) is of the form [4,5] \\begin{align} \\mathrm{Tr}(W\\mathrm{cov}(\\hat{\\textbf{x}},{\\Pi_y}))\\geq \\min_{\\textbf{X},V} \\mathrm{Tr}(WV), \\end{align} where \\(W\\) is the weight matrix and \\(V\\geq Z(\\textbf{X})\\) with \\([Z(\\textbf{X})]_{ab}=\\mathrm{Tr} (\\rho X_a X_b)\\). \\(\\textbf{X}=[X_0,X_1,\\cdots]\\) with \\(X_i:=\\sum_y (\\hat{x}_i(y)-x_i)\\Pi_y\\).  The HCRB can be calculated via semidefinite programming as </p> \\[\\begin{align} &amp; \\min_{\\textbf{X},V}~\\mathrm{Tr}(WV),  \\nonumber \\\\ &amp; \\mathrm{subject}~\\mathrm{to} \\begin{cases} \\left(\\begin{array}{cc} V &amp; \\Lambda^{\\mathrm{T}}R^{\\dagger} \\\\ R\\Lambda &amp; I\\\\ \\end{array}\\right)\\geq 0, \\\\ \\sum_i[\\Lambda]_{ai}\\mathrm{Tr}(\\lambda_i\\partial_b\\rho)=\\delta_{ab}. \\end{cases} \\end{align}\\] <p>Here \\(X_i\\) is expanded in a specific basis \\(\\{\\lambda_i\\}\\) as \\(X_i=\\sum_j [\\Lambda]_{ij}\\lambda_j\\),  the Hermitian matrix \\(Z(\\textbf{X})\\) satisfies \\(Z(\\textbf{X})=\\Lambda^{\\mathrm{T}}R^{\\dagger} R\\Lambda\\). In QuanEstimation, the HCRB can be solved by</p> PythonJulia <pre><code>HCRB(rho, drho, W, eps=1e-8)\n</code></pre> <pre><code>HCRB(rho, drho, W; eps=1e-8) \n</code></pre> <p>where <code>rho</code> and <code>drho</code> are the density matrix of the state and its derivatives with respect to the unknown parameters to be estimated, respectively. <code>W</code> represents the weight matrix defaults  to identity matrix and <code>eps</code> is the machine epsilon with default value \\(10^{-8}\\).</p>"},{"location":"guide/guide_bounds/#nagaoka-hayashi-bound","title":"Nagaoka-Hayashi bound","text":"<p>Nagaoka-Hayashi bound (NHB) is another available bound in quantum parameter estimation and  it is tighter than HCRB in general. The NHB can be expressed as [6-8] \\begin{equation} \\mathrm{Tr}(W\\mathrm{cov}(\\hat{\\textbf{x}},{\\Pi_y}))\\geq \\min_{\\textbf{X},\\mathcal{Q}} \\mathrm{Tr}\\left((W\\otimes\\rho)\\mathcal{Q}\\right) \\end{equation}</p> <p>with \\(W\\) the weight matrix and \\(\\mathcal{Q}\\) a matrix satisfying \\(\\mathcal{Q}\\geq\\textbf{X}^{\\mathrm{T}}\\textbf{X}\\).  The NHB can be solved by the semidefinite programming as</p> \\[\\begin{align} &amp; \\min_{\\textbf{X},\\mathcal{Q}}~\\mathrm{Tr}\\left((W\\otimes\\rho)\\mathcal{Q}\\right),  \\nonumber \\\\ &amp; \\mathrm{subject}~\\mathrm{to}~ \\begin{cases} \\left(\\begin{array}{cc} \\mathcal{Q} &amp; \\textbf{X}^{\\mathrm{T}} \\\\ \\textbf{X} &amp; I\\\\ \\end{array}\\right)\\geq 0, \\\\ \\mathrm{Tr}(\\rho X_a)=0,\\,\\forall a, \\\\ \\mathrm{Tr}(X_a\\partial_b\\rho)=\\delta_{ab},\\,\\forall a, b.\\\\ \\end{cases} \\end{align}\\] <p>In QuanEstimation, the NHB can be solved by</p> PythonJulia <pre><code>NHB(rho, drho, W)\n</code></pre> <pre><code>NHB(rho, drho, W) \n</code></pre> <p>Example 3.7  The Hamiltonian of a two-qubit system with \\(XX\\) coupling is  \\begin{align} H=\\omega_1\\sigma_3^{(1)}+\\omega_2\\sigma_3^{(2)}+g\\sigma_1^{(1)}\\sigma_1^{(2)}, \\end{align}</p> <p>where \\(\\omega_1\\), \\(\\omega_2\\) are the frequencies of the first and second qubit, \\(\\sigma_i^{(1)} =\\sigma_i\\otimes I\\) and \\(\\sigma_i^{(2)}=I\\otimes\\sigma_i\\) for \\(i=1,2,3\\). \\(\\sigma_1\\),  \\(\\sigma_2\\), \\(\\sigma_3\\) are Pauli matrices and \\(I\\) denotes the identity matrix. The dynamics  is described by the master equation  \\begin{align} \\partial_t\\rho=-i[H, \\rho]+\\sum_{i=1,2}\\gamma_i\\left(\\sigma_3^{(i)}\\rho\\sigma_3^{(i)}-\\rho\\right) \\end{align}</p> <p>with \\(\\gamma_i\\) the decay rate for the \\(i\\)th qubit.</p> <p>The probe state is taken as \\(\\frac{1}{\\sqrt{2}}(|00\\rangle+|11\\rangle)\\) and the weight matrix  is set to be identity. The measurement for \\(\\mathrm{Tr}(W\\mathcal{I^{-1}})\\) is \\(\\{\\Pi_1\\),  \\(\\Pi_2\\), \\(I-\\Pi_1-\\Pi_2\\}\\) with \\(\\Pi_1=0.85|00\\rangle\\langle 00|\\) and \\(\\Pi_2=0.4|\\!+ \\!+\\rangle\\langle+\\!+\\!|\\). Here \\(|\\pm\\rangle:=\\frac{1}{\\sqrt{2}}(|0\\rangle\\pm|1\\rangle)\\) with  \\(|0\\rangle\\) \\((|1\\rangle)\\) the eigenstate of \\(\\sigma_3\\) with respect to the eigenvalue \\(1\\) (\\(-1\\)).</p> PythonJulia <pre><code>from quanestimation import *\nimport numpy as np\n\n# initial state\npsi0 = np.array([1., 0., 0., 1.])/np.sqrt(2)\nrho0 = np.dot(psi0.reshape(-1,1), psi0.reshape(1,-1).conj())\n# free Hamiltonian\nomega1, omega2, g = 1.0, 1.0, 0.1\nsx = np.array([[0., 1.], [1., 0.]])\nsy = np.array([[0., -1.j], [1.j, 0.]]) \nsz = np.array([[1., 0.], [0., -1.]])\nide = np.array([[1., 0.], [0., 1.]])   \nH0 = omega1*np.kron(sz, ide)+omega2*np.kron(ide, sz)+g*np.kron(sx, sx)\n# derivatives of the free Hamiltonian on omega2 and g\ndH = [np.kron(ide, sz), np.kron(sx, sx)] \n# dissipation\ndecay = [[np.kron(sz,ide), 0.05], [np.kron(ide,sz), 0.05]]\n# measurement\nm1 = np.array([1., 0., 0., 0.])\nM1 = 0.85*np.dot(m1.reshape(-1,1), m1.reshape(1,-1).conj())\nM2 = 0.1*np.ones((4, 4))\nM = [M1, M2, np.identity(4)-M1-M2]\n# weight matrix\nW = np.identity(2)\n# time length for the evolution\ntspan = np.linspace(0., 5., 200)\n# dynamics\ndynamics = Lindblad(tspan, rho0, H0, dH, decay)\nrho, drho = dynamics.expm()\n# calculation of the HCRB and NHB\nf_HCRB, f_NHB = [], []\nfor ti in range(len(tspan)):\n    # HCRB\n    f_tp1 = HCRB(rho[ti], drho[ti], W, eps=1e-7)\n    f_HCRB.append(f_tp1)\n    # NHB\n    f_tp2 = NHB(rho[ti], drho[ti], W)\n    f_NHB.append(f_tp2)\n</code></pre> <pre><code>using QuanEstimation\nusing LinearAlgebra\n\n# initial state\npsi0 = [1., 0., 0., 1.]/sqrt(2)\nrho0 = psi0*psi0'\n# free Hamiltonian\nomega1, omega2, g = 1.0, 1.0, 0.1\nsx = [0. 1.; 1. 0.0im]\nsy = [0. -im; im 0.]\nsz = [1. 0.0im; 0. -1.]\nH0 = omega1*kron(sz, I(2)) + omega2*kron(I(2), sz) + g*kron(sx, sx)\n# derivatives of the free Hamiltonian with respect to omega2 and g\ndH = [kron(I(2), sz), kron(sx, sx)]\n# dissipation\ndecay = [[kron(sz, I(2)), 0.05], [kron(I(2), sz), 0.05]]\n# measurement\nm1 = [1., 0., 0., 0.]\nM1 = 0.85*m1*m1'\nM2 = 0.1*ones(4, 4)\nM = [M1, M2, I(4)-M1-M2]\n# time length for the evolution\ntspan = range(0., 5., length=200)\n# dynamics\nrho, drho = QuanEstimation.expm(tspan, rho0, H0, dH, decay)\n# weight matrix\nW = one(zeros(2, 2))\n# calculation of the HCRB and NHB\nf_HCRB, f_NHB = [], []\nfor ti in 2:length(tspan)\n    # HCRB\n    f_tp1 = QuanEstimation.HCRB(rho[ti], drho[ti], W)\n    append!(f_HCRB, f_tp1)\n    # NHB\n    f_tp2 = QuanEstimation.NHB(rho[ti], drho[ti], W)\n    append!(f_NHB, f_tp2)\nend\n</code></pre>"},{"location":"guide/guide_bounds/#bayesian-cramer-rao-bounds","title":"Bayesian Cram\u00e9r-Rao bounds","text":"<p>The Bayesion version of the classical Fisher information (matrix) and quantum Fisher information  (matrix) can be calculated by </p>  $\\mathcal{I}_{\\mathrm{Bayes}}=\\int p(\\textbf{x})\\mathcal{I}\\mathrm{d}\\textbf{x}$  <p> and </p>  $\\mathcal{F}_{\\mathrm{Bayes}}=\\int p(\\textbf{x})\\mathcal{F}\\mathrm{d}\\textbf{x},$ <p> where \\(p(\\textbf{x})\\) is the prior distribution, \\(\\mathcal{I}\\) and \\(\\mathcal{F}\\) are CFI (CFIM)  and QFI (QFIM) of all types, respectively.</p> <p>In QuanEstimation, BCFI (BCFIM) and BQFI (BQFIM) can be solved via</p> PythonJulia <p><pre><code>BCFIM(x, p, rho, drho, M=[], eps=1e-8)\n</code></pre> <pre><code>BQFIM(x, p, rho, drho, LDtype=\"SLD\", eps=1e-8)\n</code></pre> where <code>x</code> represents the regimes of the parameters for the integral, it should be input as a  list of arrays. <code>p</code> is an array representing the prior distribution. The input varibles <code>rho</code>  and <code>drho</code> are two multidimensional lists with the dimensions as <code>x</code>. For example, for three  parameter (\\(x_0, x_1, x_2\\)) estimation, the \\(ijk\\)th entry of <code>rho</code> and <code>drho</code> are \\(\\rho\\) and  \\([\\partial_0\\rho, \\partial_1\\rho, \\partial_2\\rho]\\) with respect to the values \\([x_0]_i\\),  \\([x_1]_j\\) and \\([x_2]_k\\), respectively.<code>LDtype</code> represents the types of QFI (QFIM) can be set, options are <code>LDtype=SLD</code> (default), <code>LDtype=RLD</code> and <code>LDtype=LLD</code>. <code>M</code> represents a set of  positive operator-valued measure (POVM) with default value <code>[]</code>. In QuanEstimation, a set of  rank-one symmetric informationally complete POVM (SIC-POVM) is load when <code>M=[]</code>. SIC-POVM is  calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded  from here.</p> <p><pre><code>BCFIM(x, p, rho, drho; M=missing, eps=1e-8)\n</code></pre> <pre><code>BQFIM(x, p, rho, drho; LDtype=:SLD, eps=1e-8)\n</code></pre> where <code>x</code> represents the regimes of the parameters for the integral, it should be input as a  list of arrays. <code>p</code> is an array representing the prior distribution. The input varibles <code>rho</code>  and <code>drho</code> are two multidimensional lists with the dimensions as <code>x</code>. For example, for three  parameter (\\(x_0, x_1, x_2\\)) estimation, the \\(ijk\\)th entry of <code>rho</code> and <code>drho</code> are \\(\\rho\\) and  \\([\\partial_0\\rho, \\partial_1\\rho, \\partial_2\\rho]\\) with respect to the values \\([x_0]_i\\),  \\([x_1]_j\\) and \\([x_2]_k\\), respectively.<code>LDtype</code> represents the types of QFI (QFIM) can be set, options are <code>LDtype=SLD</code> (default), <code>LDtype=RLD</code> and <code>LDtype=LLD</code>. <code>M</code> represents a set of  positive operator-valued measure (POVM) with default value <code>missing</code>. In QuanEstimation, a set of  rank-one symmetric informationally complete POVM (SIC-POVM) is load when <code>M=missing</code>. SIC-POVM is  calculated by the Weyl-Heisenberg covariant SIC-POVM fiducial state which can be downloaded  from here.</p> <p>In the Bayesian scenarios, the covariance matrix with a prior distribution \\(p(\\textbf{x})\\) is  defined as \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},{\\Pi_y})=\\int p(\\textbf{x})\\sum_y\\mathrm{Tr}(\\rho\\Pi_y) (\\hat{\\textbf{x}}-\\textbf{x})(\\hat{\\textbf{x}}-\\textbf{x})^{\\mathrm{T}}\\mathrm{d}\\textbf{x}, \\end{align}</p> <p>where \\(\\textbf{x}=(x_0,x_1,\\dots)^{\\mathrm{T}}\\) are the unknown parameters to be estimated and  the integral \\(\\int\\mathrm{d}\\textbf{x}:=\\int\\mathrm{d}x_0\\int\\mathrm{d}x_1\\cdots\\). \\(\\{\\Pi_y\\}\\) is  a set of POVM and \\(\\rho\\) represents the parameterized density matrix. Two types of Bayesian  Cram\u00e9r-Rao bound (BCRB) are calculated in this package, the first one is  \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},{\\Pi_y})\\geq \\int p(\\textbf{x})\\left(B\\mathcal{I}^{-1}B +\\textbf{b}\\textbf{b}^{\\mathrm{T}}\\right)\\mathrm{d}\\textbf{x}, \\end{align}</p> <p>where \\(\\textbf{b}\\) and \\(\\textbf{b}'\\) are the vectors of biase and its derivatives with respect to  \\(\\textbf{x}\\). \\(B\\) is a diagonal matrix with the \\(i\\)th entry \\(B_{ii}=1+[\\textbf{b}']_{i}\\) and  \\(\\mathcal{I}\\) is the CFIM. The second one is \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},{\\Pi_y})\\geq \\mathcal{B}\\,\\mathcal{I}_{\\mathrm{Bayes}}^{-1}\\, \\mathcal{B}+\\int p(\\textbf{x})\\textbf{b}\\textbf{b}^{\\mathrm{T}}\\mathrm{d}\\textbf{x}, \\end{align}</p> <p>where \\(\\mathcal{B}=\\int p(\\textbf{x})B\\mathrm{d}\\textbf{x}\\) is the average of \\(B\\) and  \\(\\mathcal{I}_{\\mathrm{Bayes}}\\) is the average of the CFIM.</p> <p>The third one is  \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},{\\Pi_y})\\geq \\int p(\\textbf{x}) \\mathcal{G}\\left(\\mathcal{I}_p+\\mathcal{I}\\right)^{-1}\\mathcal{G}^{\\mathrm{T}}\\mathrm{d}\\textbf{x} \\end{align}</p> <p>with \\([\\mathcal{I}_{p}]_{ab}:=[\\partial_a \\ln p(\\textbf{x})][\\partial_b \\ln p(\\textbf{x})]\\) and \\(\\mathcal{G}_{ab}:=[\\partial_b\\ln p(\\textbf{x})][\\textbf{b}]_a+B_{aa}\\delta_{ab}\\).</p> <p>Three types of Bayesian Quantum Cram\u00e9r-Rao bound (BCRB) are calculated, the first one is  \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},{\\Pi_y})\\geq\\int p(\\textbf{x})\\left(B\\mathcal{F}^{-1}B +\\textbf{b}\\textbf{b}^{\\mathrm{T}}\\right)\\mathrm{d}\\textbf{x} \\end{align}</p> <p>with \\(\\mathcal{F}\\) the QFIM for all types. The second one is \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},{\\Pi_y})\\geq \\mathcal{B}\\,\\mathcal{F}_{\\mathrm{Bayes}}^{-1}\\, \\mathcal{B}+\\int p(\\textbf{x})\\textbf{b}\\textbf{b}^{\\mathrm{T}}\\mathrm{d}\\textbf{x} \\end{align}</p> <p>with \\(\\mathcal{F}_{\\mathrm{Bayes}}\\) the average of the QFIM.</p> <p>The third one is  \\begin{align} \\mathrm{cov}(\\hat{\\textbf{x}},{\\Pi_y})\\geq \\int p(\\textbf{x}) \\mathcal{G}\\left(\\mathcal{I}_p+\\mathcal{F}\\right)^{-1}\\mathcal{G}^{\\mathrm{T}}\\mathrm{d}\\textbf{x}. \\end{align}</p> <p>In QuanEstimation, the BCRB and BQCRB are calculated via</p> PythonJulia <p><pre><code>BCRB(x, p, dp, rho, drho, M=[], b=[], db=[], btype=1, eps=1e-8)\n</code></pre> <pre><code>BQCRB(x, p, dp, rho, drho, b=[], db=[], btype=1, LDtype=\"SLD\", eps=1e-8)\n</code></pre> where <code>b</code> and <code>db</code> are the vectors of biases and its derivatives on the unknown parameters.  For unbiased estimates, <code>b=[]</code> and <code>db=[]</code>. In QuanEstimation, the users can set the types of  BCRB and BQCRB via the variable <code>btype</code>. </p> <p><pre><code>BCRB(x, p, dp, rho, drho; M=missing, b=missing, db=missing, \n     btype=1, eps=1e-8)\n</code></pre> <pre><code>BQCRB(x, p, dp, rho, drho; b=missing, db=missing, btype=1, \n      LDtype=:SLD, eps=1e-8)\n</code></pre> where <code>b</code> and <code>db</code> are the vectors of biases and its derivatives on the unknown parameters.  For unbiased estimates, <code>b=missing</code> and <code>db=missing</code>. In QuanEstimation, the users can set  the types of BCRB and BQCRB via the variable <code>btype</code>. </p> <p>For single parameter estimation, Ref [9] calculates the optimal biased bound based  on the first type of the BQCRB, it can be realized numerically via</p> PythonJulia <pre><code>OBB(x, p, dp, rho, drho, d2rho, LDtype=\"SLD\", eps=1e-8)\n</code></pre> <pre><code>OBB(x, p, dp, rho, drho, d2rho; LDtype=:SLD, eps=1e-8)\n</code></pre> <p><code>d2rho</code> is a list representing the second order derivatives of <code>rho</code> on <code>x</code>.</p> <p>Van Trees in 1968 [10] provides a well used Bayesian version of Cram\u00e9r-Rao  bound known as Van Trees bound (VTB). </p>  $\\mathrm{cov}(\\hat{\\textbf{x}},\\{\\Pi_y\\})\\geq \\left(\\mathcal{I}_{\\mathrm{prior}} +\\mathcal{I}_{\\mathrm{Bayes}}\\right)^{-1},$  <p>where \\(\\mathcal{I}_{\\mathrm{prior}}=\\int p(\\textbf{x})\\mathcal{I}_{p}\\mathrm{d}\\textbf{x}\\)  is the CFIM for \\(p(\\textbf{x})\\) and \\(\\mathcal{I}_{\\mathrm{Bayes}}\\) is the average of the CFIM.</p> <p>The quantum version (QVTB) provided by Tsang, Wiseman  and Caves [12]. </p>  $\\mathrm{cov}(\\hat{\\textbf{x}},\\{\\Pi_y\\})\\geq \\left(\\mathcal{I}_{\\mathrm{prior}} +\\mathcal{F}_{\\mathrm{Bayes}}\\right)^{-1}$  <p>with \\(\\mathcal{F}_{\\mathrm{Bayes}}\\) the average of the QFIM of all types.</p> <p>The functions to calculate the VTB and QVTB are</p> PythonJulia <p><pre><code>VTB(x, p, dp, rho, drho, M=[], eps=1e-8)\n</code></pre> <pre><code>QVTB(x, p, dp, rho, drho, LDtype=\"SLD\", eps=1e-8)\n</code></pre></p> <p><pre><code>VTB(x, p, dp, rho, drho; M=missing,eps=1e-8)\n</code></pre> <pre><code>QVTB(x, p, dp, rho, drho; LDtype=:SLD, eps=1e-8)\n</code></pre></p> <p>Here the variables in the codes are the same with <code>BCRB</code> and <code>BQCRB</code>.</p>"},{"location":"guide/guide_bounds/#quantum-ziv-zakai-bound","title":"Quantum Ziv-Zakai bound","text":"<p>The expression of Quantum Ziv-Zakai bound (QZZB) with a prior distribution \\(p(x)\\) in a finite  regime \\([\\alpha,\\beta]\\) is</p> \\[\\begin{eqnarray} \\mathrm{var}(\\hat{x},\\{\\Pi_y\\}) &amp;\\geq &amp; \\frac{1}{2}\\int_0^\\infty \\mathrm{d}\\tau\\tau \\mathcal{V}\\int_{-\\infty}^{\\infty} \\mathrm{d}x\\min\\!\\left\\{p(x), p(x+\\tau)\\right\\} \\nonumber \\\\ &amp; &amp; \\times\\left(1-\\frac{1}{2}||\\rho(x)-\\rho(x+\\tau)||\\right), \\end{eqnarray}\\] <p>where \\(||\\cdot||\\) represents the trace norm and \\(\\mathcal{V}\\) is the \"valley-filling\"  operator satisfying \\(\\mathcal{V}f(\\tau)=\\max_{h\\geq 0}f(\\tau+h)\\). \\(\\rho(x)\\) is the  parameterized density matrix. </p> <p>In QuanEstimation, the QZZB can be calculated via the function:</p> PythonJulia <pre><code>QZZB(x, p, rho, eps=1e-8)\n</code></pre> <pre><code>QZZB(x, p, rho; eps=1e-8)\n</code></pre> <p>where <code>x</code> is a list of array representing the regime of the parameter for the integral, <code>p</code> is  an array representing the prior distribution and <code>rho</code> is a multidimensional list representing  the density matrix. <code>eps</code> is the machine epsilon with default value \\(10^{-8}\\).</p> <p>Example 3.8  The Hamiltonian of a qubit system under a magnetic field \\(B\\) in the XZ plane is \\begin{align} H=\\frac{B\\omega_0}{2}(\\sigma_1\\cos{x}+\\sigma_3\\sin{x}) \\end{align}</p> <p>with \\(x\\) the unknown parameter and \\(\\sigma_{1}\\), \\(\\sigma_{3}\\) Pauli matrices. The probe state  is taken as \\(\\frac{1}{\\sqrt{2}}(|0\\rangle+|1\\rangle)\\) with \\(|0\\rangle\\) (\\(|1\\rangle\\)) the  eigenvstates of \\(\\sigma_3\\) with respect to the eigenvalues \\(1\\) (\\(-1\\)). The measurement  for classical bounds is a set of rank-one symmetric informationally complete positive  operator-valued measure (SIC-POVM).</p> <p>Take the Gaussian prior distribution \\(p(x)=\\frac{1}{c\\eta\\sqrt{2\\pi}}\\exp\\left({-\\frac{(x-\\mu)^2} {2\\eta^2}}\\right)\\) on \\([-\\pi/2, \\pi/2]\\) with \\(\\mu\\) and \\(\\eta\\) the expectation and standard  deviation, respectively. Here \\(c=\\frac{1}{2}\\big[\\mathrm{erf}(\\frac{\\pi-2\\mu}{2\\sqrt{2}\\eta}) +\\mathrm{erf}(\\frac{\\pi+2\\mu}{2\\sqrt{2}\\eta})\\big]\\) is the normalized coefficient with  \\(\\mathrm{erf}(x):=\\frac{2}{\\sqrt{\\pi}}\\int^x_0 e^{-t^2}\\mathrm{d}t\\) the error function.</p> PythonJulia <p><pre><code>from quanestimation import *\nimport numpy as np\nfrom scipy.integrate import simps\n\n# initial state\nrho0 = 0.5*np.array([[1., 1.], [1., 1.]])\n# free Hamiltonian\nB, omega0 = 0.5*np.pi, 1.0\nsx = np.array([[0., 1.], [1., 0.]])\nsy = np.array([[0., -1.j], [1.j, 0.]]) \nsz = np.array([[1., 0.], [0., -1.]])\nH0_func = lambda x: 0.5*B*omega0*(sx*np.cos(x)+sz*np.sin(x))\n# derivative of the free Hamiltonian on x\ndH_func = lambda x: [0.5*B*omega0*(-sx*np.sin(x)+sz*np.cos(x))]\n# prior distribution\nx = np.linspace(-0.5*np.pi, 0.5*np.pi, 100)\nmu, eta = 0.0, 0.2\np_func = lambda x, mu, eta: np.exp(-(x-mu)**2/(2*eta**2)) \\\n                            /(eta*np.sqrt(2*np.pi))\ndp_func = lambda x, mu, eta: -(x-mu)*np.exp(-(x-mu)**2/(2*eta**2)) \\\n                              /(eta**3*np.sqrt(2*np.pi))\np_tp = [p_func(x[i], mu, eta) for i in range(len(x))]\ndp_tp = [dp_func(x[i], mu, eta) for i in range(len(x))]\n# normalization of the distribution\nc = simps(p_tp, x)\np, dp = p_tp/c, dp_tp/c\n# time length for the evolution\ntspan = np.linspace(0., 1., 1000)\n# dynamics\nrho = [np.zeros((len(rho0), len(rho0)), dtype=np.complex128) \\\n       for i in range(len(x))]\ndrho = [[np.zeros((len(rho0), len(rho0)), dtype=np.complex128)] \\\n         for i in range(len(x))]\nfor i in range(len(x)):\n    H0_tp = H0_func(x[i])\n    dH_tp = dH_func(x[i])\n    dynamics = Lindblad(tspan, rho0, H0_tp, dH_tp)\n    rho_tp, drho_tp = dynamics.expm()\n    rho[i] = rho_tp[-1]\n    drho[i] = drho_tp[-1]\n</code></pre> <pre><code># Classical Bayesian bounds\nf_BCRB1 = BCRB([x], p, [], rho, drho, M=[], btype=1)\nf_BCRB2 = BCRB([x], p, [], rho, drho, M=[], btype=2)\nf_BCRB3 = BCRB([x], p, dp, rho, drho, M=[], btype=3)\nf_VTB = VTB([x], p, dp, rho, drho, M=[])\n</code></pre> <pre><code># Quantum Bayesian bounds\nf_BQCRB1 = BQCRB([x], p, [], rho, drho, btype=1)\nf_BQCRB2 = BQCRB([x], p, [], rho, drho, btype=2)\nf_BQCRB3 = BQCRB([x], p, dp, rho, drho, btype=3)\nf_QVTB = QVTB([x], p, dp, rho, drho)\nf_QZZB = QZZB([x], p, rho)\n</code></pre></p> <p><pre><code>using QuanEstimation\nusing Trapz\n\n# free Hamiltonian\nfunction H0_func(x)\n    return 0.5*B*omega0*(sx*cos(x)+sz*sin(x))\nend\n# derivative of the free Hamiltonian on x\nfunction dH_func(x)\n    return [0.5*B*omega0*(-sx*sin(x)+sz*cos(x))]\nend\n# prior distribution\nfunction p_func(x, mu, eta)\n    return exp(-(x-mu)^2/(2*eta^2))/(eta*sqrt(2*pi))\nend\nfunction dp_func(x, mu, eta)\n    return -(x-mu)*exp(-(x-mu)^2/(2*eta^2))/(eta^3*sqrt(2*pi))\nend\n\nB, omega0 = 0.5*pi, 1.0\nsx = [0. 1.; 1. 0.0im]\nsy = [0. -im; im 0.]\nsz = [1. 0.0im; 0. -1.]\n# initial state\nrho0 = 0.5*ones(2, 2)\n# prior distribution\nx = range(-0.5*pi, stop=0.5*pi, length=100) |&gt;Vector\nmu, eta = 0.0, 0.2\np_tp = [p_func(x[i], mu, eta) for i in 1:length(x)]\ndp_tp = [dp_func(x[i], mu, eta) for i in 1:length(x)]\n# normalization of the distribution\nc = trapz(x, p_tp)\np = p_tp/c\ndp = dp_tp/c\n# time length for the evolution\ntspan = range(0., stop=1., length=1000)\n# dynamics\nrho = Vector{Matrix{ComplexF64}}(undef, length(x))\ndrho = Vector{Vector{Matrix{ComplexF64}}}(undef, length(x))\nfor i = 1:length(x) \n    H0_tp = H0_func(x[i])\n    dH_tp = dH_func(x[i])\n    rho_tp, drho_tp = QuanEstimation.expm(tspan, rho0, H0_tp, dH_tp)\n    rho[i], drho[i] = rho_tp[end], drho_tp[end]\nend\n</code></pre> <pre><code># Classical Bayesian bounds\nf_BCRB1 = QuanEstimation.BCRB([x], p, dp, rho, drho; btype=1)\nf_BCRB2 = QuanEstimation.BCRB([x], p, dp, rho, drho; btype=2)\nf_BCRB3 = QuanEstimation.BCRB([x], p, dp, rho, drho; btype=3)\nf_VTB = QuanEstimation.VTB([x], p, dp, rho, drho)\n</code></pre> <pre><code># Quantum Bayesian bounds\nf_BQCRB1 = QuanEstimation.BQCRB([x], p, dp, rho, drho, btype=1)\nf_BQCRB2 = QuanEstimation.BQCRB([x], p, dp, rho, drho, btype=2)\nf_BQCRB3 = QuanEstimation.BQCRB([x], p, dp, rho, drho, btype=3)\nf_QVTB = QuanEstimation.QVTB([x], p, dp, rho, drho)\nf_QZZB = QuanEstimation.QZZB([x], p, rho)\n</code></pre></p>"},{"location":"guide/guide_bounds/#bayesian-estimation","title":"Bayesian estimation","text":"<p>In QuanEstimation, two types of Bayesian estimation are considered including maximum a  posteriori estimation (MAP) and maximum likelihood estimation (MLE). In Bayesian estimation,  the prior distribution  is updated as \\begin{align} p(\\textbf{x}|y)=\\frac{p(y|\\textbf{x})p(\\textbf{x})}{\\int p(y|\\textbf{x})p(\\textbf{x}) \\mathrm{d}\\textbf{x}} \\end{align}</p> <p>with \\(p(\\textbf{x})\\) the current prior distribution and \\(y\\) the outcome of the experiment.  In practice, the prior distribution is replaced with \\(p(\\textbf{x}|y)\\) and the estimated  value of \\(\\textbf{x}\\) can be evaluated by</p> PythonJulia <p><pre><code>Bayes(x, p, rho, y, M=[], estimator=\"mean\", savefile=False)\n</code></pre> <pre><code>MLE(x, rho, y, M=[], savefile=False)\n</code></pre> where <code>x</code> is a list of arrays representing the regimes of the parameters for the integral and  <code>p</code> is an array representing the prior distribution. For multiparameter estimation, <code>p</code> is  multidimensional. The input varible <code>rho</code> is a multidimensional list with the dimensions as <code>x</code>  representing the parameterized density matrix. <code>M</code> contains a set of positive operator-valued  measure (POVM). In QuanEstimation, a set of rank-one symmetric informationally complete POVM  (SIC-POVM) is used when <code>M=[]</code>. SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM  fiducial state which can be downloaded from here.      <code>eatimator</code> in <code>Bayes()</code> representing the estimators which is defaulted by the mean value of the  paramters. Also, it can be set as <code>MAP</code>. The posterior distributions (likelihood function) in the  final iteration and the estimated values in all iterations will be saved in \"pout.npy\" (\"Lout.npy\")  and \"xout.npy\" if <code>savefile=False</code>. However, if the users want to save all the posterior  distributions (likelihood function) and the estimated values in all iterations, the variable  <code>savefile</code> needs to be set to <code>True</code>.</p> <p><pre><code>Bayes(x, p, rho, y; M=missing, estimator=\"mean\", savefile=false)\n</code></pre> <pre><code>MLE(x, rho, y; M=missing, savefile=false)\n</code></pre> where <code>x</code> is a list of arrays representing the regimes of the parameters for the integral and  <code>p</code> is an array representing the prior distribution. For multiparameter estimation, <code>p</code> is  multidimensional. The input varible <code>rho</code> is a multidimensional list with the dimensions as <code>x</code>  representing the parameterized density matrix. <code>M</code> contains a set of positive operator-valued  measure (POVM). In QuanEstimation, a set of rank-one symmetric informationally complete POVM  (SIC-POVM) is used when <code>M=missing</code>. SIC-POVM is calculated by the Weyl-Heisenberg covariant SIC-POVM  fiducial state which can be downloaded from here.      <code>eatimator</code> in <code>Bayes()</code> representing the estimators which is defaulted by the mean value of the  paramters. Also, it can be set as <code>MAP</code>. The posterior distributions (likelihood function) in the  final iteration and the estimated values in all iterations will be saved in \"pout.csv\" (\"Lout.csv\")  and \"xout.csv\" if <code>savefile=false</code>. However, if the users want to save all the posterior  distributions (likelihood function) and the estimated values in all iterations, the variable  <code>savefile</code> needs to be set to <code>true</code>.</p> <p>Example 3.9  The Hamiltonian of a qubit system is  \\begin{align} H=\\frac{B\\omega_0}{2}(\\sigma_1\\cos{x}+\\sigma_3\\sin{x}), \\end{align}</p> <p>where \\(B\\) is the magnetic field in the XZ plane, \\(x\\) is the unknown parameter and \\(\\sigma_{1}\\),  \\(\\sigma_{3}\\) are the Pauli matrices. The probe state is taken as \\(|\\pm\\rangle\\). The measurement  is \\(\\{|\\!+\\rangle\\langle+\\!|,|\\!-\\rangle\\langle-\\!|\\}\\). Here \\(|\\pm\\rangle:=\\frac{1}{\\sqrt{2}} (|0\\rangle\\pm|1\\rangle)\\) with \\(|0\\rangle\\) \\((|1\\rangle)\\) the eigenstate of \\(\\sigma_3\\) with respect  to the eigenvalue \\(1\\) \\((-1)\\). In this example, the prior distribution \\(p(x)\\) is uniform on  \\([0, \\pi/2]\\).</p> PythonJulia <p><pre><code>from quanestimation import *\nimport numpy as np\nimport random\n\n# initial state\nrho0 = 0.5*np.array([[1., 1.], [1., 1.]])\n# free Hamiltonian\nB, omega0 = np.pi/2.0, 1.0\nsx = np.array([[0., 1.], [1., 0.]])\nsy = np.array([[0., -1.j], [1.j, 0.]]) \nsz = np.array([[1., 0.], [0., -1.]])\nH0_func = lambda x: 0.5*B*omega0*(sx*np.cos(x)+sz*np.sin(x))\n# derivative of the free Hamiltonian on x\ndH_func = lambda x: [0.5*B*omega0*(-sx*np.sin(x)+sz*np.cos(x))]\n# measurement\nM1 = 0.5*np.array([[1., 1.], [1., 1.]])\nM2 = 0.5*np.array([[1.,-1.], [-1., 1.]])\nM = [M1, M2]\n# prior distribution\nx = np.linspace(0., 0.5*np.pi, 1000)\np = (1.0/(x[-1]-x[0]))*np.ones(len(x))\n# time length for the evolution\ntspan = np.linspace(0., 1., 1000)\n# dynamics\nrho = [np.zeros((len(rho0), len(rho0)), dtype=np.complex128) \\\n       for i in range(len(x))]\nfor i in range(len(x)):\n    H0 = H0_func(x[i])\n    dH = dH_func(x[i])\n    dynamics = Lindblad(tspan, rho0, H0, dH)\n    rho_tp, drho_tp = dynamics.expm()\n    rho[i] = rho_tp[-1]\n</code></pre> <pre><code># Generation of the experimental results\ny = [0 for i in range(500)]\nres_rand = random.sample(range(0, len(y)), 125)\nfor i in range(len(res_rand)):\n    y[res_rand[i]] = 1\n</code></pre> <pre><code># Maximum a posteriori estimation\npout, xout = Bayes([x], p, rho, y, M=M, estimator=\"MAP\", \\\n                   savefile=False)\n</code></pre> <pre><code># Maximum likelihood estimation\nLout, xout = MLE([x], rho, y, M=M, savefile=False)\n</code></pre></p> <p><pre><code>using QuanEstimation\nusing Random\nusing StatsBase\n\n# free Hamiltonian\nfunction H0_func(x)\n    return 0.5*B*omega0*(sx*cos(x)+sz*sin(x))\nend\n# derivative of the free Hamiltonian on x\nfunction dH_func(x)\n    return [0.5*B*omega0*(-sx*sin(x)+sz*cos(x))]\nend\n\nB, omega0 = pi/2.0, 1.0\nsx = [0. 1.; 1. 0.0im]\nsy = [0. -im; im 0.]\nsz = [1. 0.0im; 0. -1.]\n# initial state\nrho0 = 0.5*ones(2, 2)\n# measurement \nM1 = 0.5*[1.0+0.0im  1.; 1.  1.]\nM2 = 0.5*[1.0+0.0im -1.; -1.  1.]\nM = [M1, M2]\n# prior distribution\nx = range(0., stop=0.5*pi, length=100) |&gt;Vector\np = (1.0/(x[end]-x[1]))*ones(length(x))\n# time length for the evolution\ntspan = range(0., stop=1., length=1000)\n# dynamics\nrho = Vector{Matrix{ComplexF64}}(undef, length(x))\nfor i = 1:length(x) \n    H0_tp = H0_func(x[i])\n    dH_tp = dH_func(x[i])\n    rho_tp, drho_tp = QuanEstimation.expm(tspan, rho0, H0_tp, dH_tp)\n    rho[i] = rho_tp[end]\nend\n</code></pre> <pre><code># Generation of the experimental results\nRandom.seed!(1234)\ny = [0 for i in 1:500]\nres_rand = sample(1:length(y), 125, replace=false)\nfor i in 1:length(res_rand)\n    y[res_rand[i]] = 1\nend\n</code></pre> <pre><code># Maximum a posteriori estimation\npout, xout = QuanEstimation.Bayes([x], p, rho, y; M=M, estimator=\"MAP\",\n                                  savefile=false)\n</code></pre> <pre><code># Maximum likelihood estimation\nLout, xout = QuanEstimation.MLE([x], rho, y, M=M; savefile=false)\n</code></pre></p> <p>The average Bayesian cost [14] for a quadratic cost function can be  calculated via \\begin{equation} \\bar{C}:=\\int p(\\textbf{x})\\sum_y p(y|\\textbf{x})(\\textbf{x}-\\hat{\\textbf{x}})^{\\mathrm{T}} W(\\textbf{x}-\\hat{\\textbf{x}})\\,\\mathrm{d}\\textbf{x} \\end{equation}</p> <p>In QuanEstimation, this can be realized by calling</p> PythonJulia <pre><code>BayesCost(x, p, xest, rho, y, M, W=[], eps=1e-8)\n</code></pre> <pre><code>BayesCost(x, p, xest, rho, y, M; W=missing, eps=1e-8)\n</code></pre> <p><code>xest</code> represents the estimators for the parameters.</p> <p>Besides, the average Bayesian cost bounded by [5]  \\begin{equation} \\bar{C}\\geq\\int p(\\textbf{x})\\left(\\textbf{x}^{\\mathrm{T}}W\\textbf{x}\\right)\\mathrm{d}\\textbf{x} -\\sum_{ab}W_{ab}\\mathrm{Tr}\\left(\\bar{\\rho}\\bar{L}_a \\bar{L}_b\\right), \\label{eq:BCB} \\end{equation}</p> <p>and for single-parameter scenario, this inequality reduces to \\begin{equation} \\bar{C}\\geq \\int p(x) x^2\\,\\mathrm{d}x-\\mathrm{Tr}(\\bar{\\rho}\\bar{L}^2).  \\end{equation}</p> <p>The function for calculating the Bayesian cost bound (BCB) is</p> PythonJulia <pre><code>BCB(x, p, rho, W=[], eps=1e-8)\n</code></pre> <pre><code>BCB(x, p, rho; W=missing, eps=1e-8)\n</code></pre> <p>Example 3.10  The Hamiltonian of a qubit system is  \\begin{align} H=\\frac{B\\omega_0}{2}(\\sigma_1\\cos{x}+\\sigma_3\\sin{x}), \\end{align}</p> <p>where \\(B\\) is the magnetic field in the XZ plane, \\(x\\) is the unknown parameter and \\(\\sigma_{1}\\),  \\(\\sigma_{3}\\) are the Pauli matrices. The probe state is taken as \\(|\\pm\\rangle\\). The measurement  is \\(\\{|\\!+\\rangle\\langle+\\!|,|\\!-\\rangle\\langle-\\!|\\}\\). Here \\(|\\pm\\rangle:=\\frac{1}{\\sqrt{2}} (|0\\rangle\\pm|1\\rangle)\\) with \\(|0\\rangle\\) \\((|1\\rangle)\\) the eigenstate of \\(\\sigma_3\\) with respect  to the eigenvalue \\(1\\) \\((-1)\\). In this example, the prior distribution \\(p(x)\\) is uniform on  \\([0, \\pi/2]\\).</p> PythonJulia <p><pre><code>from quanestimation import *\nimport numpy as np\nimport random\n\n# initial state\nrho0 = 0.5*np.array([[1., 1.], [1., 1.]])\n# free Hamiltonian\nB, omega0 = np.pi/2.0, 1.0\nsx = np.array([[0., 1.], [1., 0.]])\nsy = np.array([[0., -1.j], [1.j, 0.]]) \nsz = np.array([[1., 0.], [0., -1.]])\nH0_func = lambda x: 0.5*B*omega0*(sx*np.cos(x)+sz*np.sin(x))\n# derivative of the free Hamiltonian on x\ndH_func = lambda x: [0.5*B*omega0*(-sx*np.sin(x)+sz*np.cos(x))]\n# measurement\nM1 = 0.5*np.array([[1., 1.], [1., 1.]])\nM2 = 0.5*np.array([[1.,-1.], [-1., 1.]])\nM = [M1, M2]\n# prior distribution\nx = np.linspace(0., 0.5*np.pi, 1000)\np = (1.0/(x[-1]-x[0]))*np.ones(len(x))\n# time length for the evolution\ntspan = np.linspace(0., 1., 1000)\n# dynamics\nrho = [np.zeros((len(rho0), len(rho0)), dtype=np.complex128) \\\n       for i in range(len(x))]\nfor i in range(len(x)):\n    H0 = H0_func(x[i])\n    dH = dH_func(x[i])\n    dynamics = Lindblad(tspan, rho0, H0, dH)\n    rho_tp, drho_tp = dynamics.expm()\n    rho[i] = rho_tp[-1]\n</code></pre> <pre><code># average Bayesian cost\nM = SIC(2)\nxest = [np.array([0.8]), np.array([0.9]),np.array([1.0]),np.array([1.2])]\nC = BayesCost([x], p, xest, rho, M, eps=1e-8)\n</code></pre> <pre><code># Bayesian cost Bound\nC = BCB([x], p, rho, eps=1e-8)\n</code></pre></p> <p><pre><code>using QuanEstimation\nusing Random\nusing StatsBase\n\n# free Hamiltonian\nfunction H0_func(x)\n    return 0.5*B*omega0*(sx*cos(x)+sz*sin(x))\nend\n# derivative of the free Hamiltonian on x\nfunction dH_func(x)\n    return [0.5*B*omega0*(-sx*sin(x)+sz*cos(x))]\nend\n\nB, omega0 = pi/2.0, 1.0\nsx = [0. 1.; 1. 0.0im]\nsy = [0. -im; im 0.]\nsz = [1. 0.0im; 0. -1.]\n# initial state\nrho0 = 0.5*ones(2, 2)\n# measurement \nM1 = 0.5*[1.0+0.0im  1.; 1.  1.]\nM2 = 0.5*[1.0+0.0im -1.; -1.  1.]\nM = [M1, M2]\n# prior distribution\nx = range(0., stop=0.5*pi, length=100) |&gt;Vector\np = (1.0/(x[end]-x[1]))*ones(length(x))\n# time length for the evolution\ntspan = range(0., stop=1., length=1000)\n# dynamics\nrho = Vector{Matrix{ComplexF64}}(undef, length(x))\nfor i = 1:length(x) \n    H0_tp = H0_func(x[i])\n    dH_tp = dH_func(x[i])\n    rho_tp, drho_tp = QuanEstimation.expm(tspan, rho0, H0_tp, dH_tp)\n    rho[i] = rho_tp[end]\nend\n</code></pre> <pre><code># average Bayesian cost\nM = QuanEstimation.SIC(2)\nxest = [[0.8], [0.9], [1.0], [1.2]]\nC = QuanEstimation.BayesCost([x], p, xest, rho, M, eps=1e-8)\n</code></pre> <pre><code># Bayesian cost Bound\nC = QuanEstimation.BCB([x], p, rho, eps=1e-8)\n</code></pre></p>"},{"location":"guide/guide_bounds/#bibliography","title":"Bibliography","text":"<p>[1] C. W. Helstrom,  Quantum Detection and Estimation Theory (New York: Academic, 1976).</p> <p>[2]  A. S. Holevo,  Probabilistic and Statistical Aspects of Quantum Theory (Amsterdam: North-Holland, 1982).</p> <p>[3]  J. Liu, H. Yuan, X.-M. Lu, and X. Wang, Quantum Fisher information matrix and multiparameter estimation, J. Phys. A: Math. Theor. 53, 023001 (2020).</p> <p>[4]  A. S Holevo, Statistical decision theory for quantum systems, J. Multivariate Anal. 3, 337-394 (1973).</p> <p>[5]  R. Demkowicz-Dobrza\u0144ski, W. G\u00f3recki, and M. Gu\u0163\u0103, Multi-parameter estimation beyond Quantum Fisher Information, J. Phys. A: Math. Theor. 53, 363001 (2020).</p> <p>[6]  H. Nagaoka, A New Approach to Cra \u00b4 mer\u2013Rao Bounds for Quantum State Estimation, Tech. Rep. IT89-42, 9 (1989).</p> <p>[7]  M. Hayashi, On simultaneous measurement of noncommutative observables. In Development of  Infinite-Dimensional Non-Commutative Anaysis, 96\u2013188 (Kyoto Univ., 1999).</p> <p>[8]  L. O. Conlon, J. Suzuki, P. K. Lam, and S. M. Assad, Efficient computation of the Nagaoka\u2013Hayashi bound for multiparameter estimation with separable measurements, npj Quantum Inf.  7, 110 (2021).</p> <p>[9] J. Liu and H. Yuan,  Valid lower bound for all estimators in quantum parameter estimation,  New J. Phys. 18, 093009 (2016).</p> <p>[10]  H. L. Van Trees,  Detection, estimation, and modulation theory: Part I (Wiley, New York, 1968).</p> <p>[11]  W. Zhong, Z. Sun, J. Ma, X. Wang, and F. Nori, Fisher information under decoherence in Bloch representation,  Phys. Rev. A 87, 022337 (2013).</p> <p>[12]  M. Tsang, H. M. Wiseman, and C. M. Caves,  Fundamental quantum limit to waveform estimation,  Phys. Rev. Lett. 106, 090401 (2011).</p> <p>[13]  D. \u0160afr\u00e1nek, Estimation of Gaussian quantum states, J. Phys. A: Math. Theor. 52, 035304 (2019).</p> <p>[14]  C. P. Robert, The Bayesian Choice (Berlin: Springer, 2007).</p>"},{"location":"guide/guide_dynamics/","title":"Parameterization process","text":"<p>In QuanEstimation, two types of parameterization processes are considered. The first one is  the master equation of the form</p> \\[\\begin{align} \\partial_t\\rho &amp;=\\mathcal{L}\\rho \\nonumber \\\\ &amp;=-i[H,\\rho]+\\sum_i \\gamma_i\\left(\\Gamma_i\\rho\\Gamma^{\\dagger}_i-\\frac{1}{2} \\left\\{\\rho,\\Gamma^{\\dagger}_i \\Gamma_i \\right\\}\\right), \\end{align}\\] <p>where \\(\\rho\\) is the evolved density matrix, \\(H\\) is the Hamiltonian of the system, \\(\\Gamma_i\\)  and \\(\\gamma_i\\) are the \\(i\\mathrm{th}\\) decay operator and the corresponding decay rate.  Numerically, the evolved state at \\(j\\)th time interval is obtained by \\(\\rho_j=e^{\\Delta t\\mathcal{L}} \\rho_{j-1}\\) with \\(\\Delta t\\) the time interval. The derivatives of \\(\\rho_j\\) on \\(\\textbf{x}\\)  is calculated via</p>  $\\partial_{\\textbf{x}}\\rho_j =\\Delta t(\\partial_{\\textbf{x}}\\mathcal{L})\\rho_j +e^{\\Delta t \\mathcal{L}}(\\partial_{\\textbf{x}}\\rho_{j-1}),$  <p> where \\(\\rho_{j-1}\\) is the evolved density matrix at \\((j-1)\\)th time interval.</p> <p>The dynamics can also be solved by the ordinary differential equation (ODE) solvers, thus  \\(\\rho\\) and \\(\\partial_{\\textbf{x}}\\rho\\) are obtained via directly solving the differential equations. Here, \\(\\partial_{\\textbf{x}}\\rho\\) satisfies</p> \\[\\begin{align} \\partial_t(\\partial_{\\textbf{x}}\\rho) =-i[\\partial_{\\textbf{x}}H,\\rho] + \\mathcal{L}(\\partial_{\\textbf{x}}\\rho). \\end{align}\\] <p>The evolved density matrix \\(\\rho\\) and its derivatives (\\(\\partial_{\\textbf{x}}\\rho\\)) with  respect to \\(\\textbf{x}\\) can be calculata the codes</p> PythonJulia <pre><code>dynamics = Lindblad(tspan, rho0, H0, dH, decay=[], Hc=[], ctrl=[])\n</code></pre> expmode <pre><code>rho, drho = dynamics.expm()\n</code></pre> <pre><code>rho, drho = dynamics.ode()\n</code></pre> <p>Here <code>tspan</code> is the time length for the evolution, <code>rho0</code> represents the density matrix of  the probe state, <code>H0</code> and <code>dH</code> are the free Hamiltonian and its derivatives with respect to  the unknown parameters to be estimated. The variable <code>H0</code> is a matrix when the free Hamiltonian  is time-independent and a list of matrices with the length equal to <code>tspan</code> when it is time-dependent.  <code>dH</code> should be input as \\([\\partial_a{H_0}, \\partial_b{H_0}, \\cdots]\\). <code>decay</code> contains decay  operators \\((\\Gamma_1, \\Gamma_2, \\cdots)\\) and the corresponding decay rates \\((\\gamma_1, \\gamma_2,  \\cdots)\\) with the input rule decay=[[\\(\\Gamma_1\\), \\(\\gamma_1\\)], [\\(\\Gamma_2\\), \\(\\gamma_2\\)],...].  For time-dependent decay rate, the input rule is the decay=[[\\(\\Gamma_1\\), \\(\\gamma_1(t)\\)],  [\\(\\Gamma_2\\), \\(\\gamma_2(t)\\)],...], where \\(\\gamma_1(t)\\) [\\(\\gamma_2(t)\\cdots\\)] is an array with  the length equal to <code>tspan</code>. <code>Hc</code> and <code>ctrl</code> are two lists represent the control Hamiltonians and the corresponding control  coefficients. The default values for <code>decay</code>, <code>Hc</code>, and <code>ctrl</code> are <code>[]</code> which means the  dynamics is unitary and only governed by the free Hamiltonian.</p> <p>The output (<code>rho</code> and <code>drho</code>) of this class by calling <code>dynamics.expm()</code> (<code>dynamics.ode()</code>) are  two lists with the length equal to <code>tspan</code>. Here <code>rho</code> represents the parameterized density  matrix and <code>drho</code> is the corresponding derivatives with respect to all the parameters, the \\(i\\)th  entry of <code>drho</code> is \\([\\partial_a{\\rho},\\partial_b{\\rho},\\cdots].\\)</p> expmode <pre><code>rho, drho = expm(tspan, rho0, H0, dH, decay=missing, Hc=missing, \n                 ctrl=missing)\n</code></pre> <pre><code>rho, drho = ode(tspan, rho0, H0, dH, decay=missing, Hc=missing, \n                ctrl=missing)\n</code></pre> <p>Here <code>tspan</code> is the time length for the evolution, <code>rho0</code> represents the density matrix of  the probe state, <code>H0</code> and <code>dH</code> are the free Hamiltonian and its derivatives with respect to  the unknown parameters to be estimated. The variable <code>H0</code> is a matrix when the free Hamiltonian  is time-independent and a list of matrices with the length equal to <code>tspan</code> when it is time-dependent.  <code>dH</code> should be input as \\([\\partial_a{H_0}, \\partial_b{H_0}, \\cdots]\\). <code>decay</code> contains decay  operators \\((\\Gamma_1, \\Gamma_2, \\cdots)\\) and the corresponding decay rates \\((\\gamma_1, \\gamma_2,  \\cdots)\\) with the input rule decay=[[\\(\\Gamma_1\\), \\(\\gamma_1\\)], [\\(\\Gamma_2\\), \\(\\gamma_2\\)],...].  For time-dependent decay rate, the input rule is the decay=[[\\(\\Gamma_1\\), \\(\\gamma_1(t)\\)],  [\\(\\Gamma_2\\), \\(\\gamma_2(t)\\)],...], where \\(\\gamma_1(t)\\) [\\(\\gamma_2(t)\\cdots\\)] is an array with  the length equal to <code>tspan</code>. <code>Hc</code> and <code>ctrl</code> are two lists represent the control Hamiltonians  and the corresponding control coefficients. The default values for <code>decay</code>, <code>Hc</code>, and <code>ctrl</code>  are <code>missing</code> which means the dynamics is unitary and only governed by the free Hamiltonian.</p> <p>The output (<code>rho</code> and <code>drho</code>) of this function by calling <code>expm()</code> (<code>ode()</code>) are two lists with  the length equal to <code>tspan</code>. Here <code>rho</code> represents the parameterized density matrix and <code>drho</code>  is the corresponding derivatives with respect to all the parameters, the \\(i\\)th entry of <code>drho</code>  is \\([\\partial_a{\\rho},\\partial_b{\\rho},\\cdots].\\)</p> <p>Example 2.1 In this example, the free evolution Hamiltonian of a single qubit system is \\(H_0=\\frac{1}{2} \\omega \\sigma_3\\) with \\(\\omega\\) the frequency and \\(\\sigma_3\\) a Pauli matrix.  The dynamics of the system is governed by \\begin{align} \\partial_t\\rho=-i[H_0, \\rho], \\end{align}</p> <p>where \\(\\rho\\) is the parameterized density matrix. The probe state is taken as \\(|+\\rangle\\langle+|\\)  with \\(|+\\rangle=\\frac{1}{\\sqrt{2}}(|0\\rangle+|1\\rangle)\\). Here \\(|0\\rangle\\) \\((|1\\rangle)\\) is the  eigenstate of \\(\\sigma_3\\) with respect to the eigenvalue \\(1\\) \\((-1)\\).</p> PythonJulia <pre><code>from quanestimation import *\nimport numpy as np\n\n# initial state\nrho0 = 0.5*np.array([[1., 1.], [1., 1.]])\n# free Hamiltonian\nomega = 1.0\nsz = np.array([[1., 0.], [0., -1.]])\nH0 = 0.5*omega*sz\n# derivative of the free Hamiltonian on omega\ndH = [0.5*sz]\n# time length for the evolution\ntspan = np.linspace(0., 10., 2500)\n# dynamics\ndynamics = Lindblad(tspan, rho0, H0, dH)\nrho, drho = dynamics.expm()\n</code></pre> <pre><code>using QuanEstimation\n\n# initial state\nrho0 = 0.5*ones(2, 2)\n# free Hamiltonian\nomega = 1.0\nsz = [1. 0.0im; 0. -1.]\nH0 = 0.5*omega*sz\n# derivative of the free Hamiltonian on omega\ndH = [0.5*sz]\n# time length for the evolution\ntspan = range(0., 10., length=2500)\n# dynamics\nrho, drho = QuanEstimation.expm(tspan, rho0, H0, dH)\n</code></pre> <p>The parameterization process can also be implemented with the Kraus operators. In this case, the parameterized density matrix and its derivatives with respect to the unknown parameters  can be calculated via \\begin{align} \\rho=\\sum_i K_i\\rho_0K_i^{\\dagger}, \\end{align}</p> \\[\\begin{align} \\partial_{\\textbf{x}}\\rho=\\sum_i \\partial_{\\textbf{x}}K_i\\rho_0K_i^{\\dagger} + K_i\\rho_0\\partial_{\\textbf{x}}K_i^{\\dagger}, \\end{align}\\] <p>where \\(K_i\\) is a Kraus operator satisfying \\(\\sum_{i}K^{\\dagger}_i K_i=I\\) and \\(\\partial_{\\textbf{x}}K_i\\)  represents its derivatives with respect to \\(\\textbf{x}\\). Here \\(I\\) is the identity  operator and \\(\\rho_0\\) is the probe state.</p> <p>In QuanEstimation, \\(\\rho\\) and \\(\\partial_{\\textbf{x}}\\rho\\) can be solved by</p> PythonJulia <pre><code>rho, drho = Kraus(rho0, K, dK)\n</code></pre> <pre><code>Kraus = Kraus(rho0, K, dK)\nrho, drho = evolve(Kraus)\n</code></pre> <p>where <code>K</code> and <code>dK</code> are the Kraus operators and its derivatives with respect to the unknown parameters.</p> <p>Example 2.2 The Kraus operators for the amplitude damping channel are</p> \\[\\begin{eqnarray} K_1 = \\left(\\begin{array}{cc} 1 &amp; 0  \\\\ 0 &amp; \\sqrt{1-\\gamma} \\end{array}\\right), K_2 = \\left(\\begin{array}{cc} 0 &amp; \\sqrt{\\gamma} \\\\ 0 &amp; 0 \\end{array}\\right), \\nonumber \\end{eqnarray}\\] <p>where \\(\\gamma\\) is the decay probability. In this example, the probe state is taken as \\(|+\\rangle\\langle+|\\) with \\(|+\\rangle=\\frac{1}{\\sqrt{2}}(|0\\rangle+ |1\\rangle)\\). Here \\(|0\\rangle\\) \\((|1\\rangle)\\) is the eigenstate of \\(\\sigma_3\\) with respect to the  eigenvalue \\(1\\) \\((-1)\\).</p> PythonJulia <pre><code>from quanestimation import *\nimport numpy as np\n\n# initial state\nrho0 = 0.5*np.array([[1., 1.], [1., 1.]])\n# Kraus operators for the amplitude damping channel\ngamma = 0.1\nK1 = np.array([[1., 0.], [0., np.sqrt(1-gamma)]])\nK2 = np.array([[0., np.sqrt(gamma)], [0., 0.]])\nK = [K1, K2]\n# derivatives of Kraus operators on gamma\ndK1 = np.array([[1., 0.], [0., -0.5/np.sqrt(1-gamma)]])\ndK2 = np.array([[0., 0.5/np.sqrt(gamma)], [0., 0.]])\ndK = [[dK1], [dK2]]\n# parameterization process\nrho, drho = Kraus(rho0, K, dK)\n</code></pre> <pre><code>using QuanEstimation\n\n# initial state\nrho0 = 0.5*ones(2, 2)\n# Kraus operators for the amplitude damping channel\ngamma = 0.1\nK1 = [1. 0.; 0. sqrt(1-gamma)]\nK2 = [0. sqrt(gamma); 0. 0.]\nK = [K1, K2]\n# derivatives of Kraus operators on gamma\ndK1 = [1. 0.; 0. -0.5/sqrt(1-gamma)]\ndK2 = [0. 0.5/sqrt(gamma); 0. 0.]\ndK = [[dK1], [dK2]]\n# parameterization process\nKraus = QuanEstimation.Kraus(rho0, K, dK)\nrho, drho = QuanEstimation.evolve(Kraus)\n</code></pre>"},{"location":"guide/guide_import/","title":"Getting started","text":"<p>To load QuanEstimation, start with the statement: </p> PythonJulia <pre><code>from quanestimation import *\n</code></pre> <pre><code>using quanestimation\n</code></pre>"},{"location":"guide/guide_resources/","title":"Metrological resources","text":"<p>The metrological resources that QuanEstimation can calculate are spin squeezing and the  minimum time to reach the given target. The spin squeezing can be calculated via the function: </p> PythonJulia <pre><code>SpinSqueezing(rho, basis=\"Dicke\", output=\"KU\")\n</code></pre> <pre><code>SpinSqueezing(rho; basis=\"Dicke\", output=\"KU\")\n</code></pre> <p><code>rho</code> represents the density matrix of the state. In this function, the basis of the state can  be Dicke basis or the original basis of each spin, which can be adjusted by setting  <code>basis=\"Dicke\"</code> or <code>basis=\"Pauli\"</code>. The variable <code>output</code> represents the type of spin squeezing  calculation. <code>output=\"KU\"</code> represents the spin squeezing defined by Kitagawa and Ueda  [1] and <code>output=\"WBIMH\"</code> calculates the spin squeezing defined by Wineland  et al. [2].</p> <p>Example 4.1 In this example, QuTip [3,4] is used to generate spin coherent state.</p> PythonJulia <pre><code>from quanestimation import *\nimport numpy as np\nfrom qutip import spin_coherent\n\n# generation of spin coherent state with QuTip\nj = 2\ntheta = 0.5*np.pi\nphi = 0.5*np.pi\nrho_CSS = spin_coherent(j, theta, phi, type='dm').full()\nxi = SpinSqueezing(rho_CSS, basis=\"Dicke\", output=\"KU\")\n</code></pre> <pre><code>using QuanEstimation\nusing SparseArrays\n\n# generation of the coherent spin state\nj, theta, phi = 2, 0.5pi, 0.5pi\nJp = Matrix(spdiagm(1=&gt;[sqrt(j*(j+1)-m*(m+1)) for m in j:-1:-j][2:end]))\nJm = Jp'\npsi0 = exp(0.5*theta*exp(im*phi)*Jm - 0.5*theta*exp(-im*phi)*Jp)*\n       QuanEstimation.basis(Int(2*j+1), 1)\nrho = psi0*psi0'\nxi = QuanEstimation.SpinSqueezing(rho; basis=\"Dicke\", output=\"KU\")\n</code></pre> <p>Calculation of the minimum time to reach a given precision limit with</p> PythonJulia <p><pre><code>TargetTime(f, tspan, func, *args, **kwargs)\n</code></pre> where <code>f</code> is the given value of the objective function and <code>tspan</code> is the time length for the  evolution. <code>func</code> represents the function for calculating the objective function, <code>*args</code> and  <code>**kwargs</code> are the corresponding input parameters and the keyword arguments.</p> <p><pre><code>TargetTime(f, tspan, func, args...; kwargs...)\n</code></pre> where <code>f</code> is the given value of the objective function and <code>tspan</code> is the time length for the  evolution. <code>func</code> represents the function for calculating the objective function, <code>args...</code>  and <code>kwargs...</code> are the corresponding input parameters and the keyword arguments.</p> <p>Example 4.2 In this example, the free evolution Hamiltonian of a single qubit system is \\(H_0=\\frac{1}{2} \\omega \\sigma_3\\) with \\(\\omega\\) the frequency and \\(\\sigma_3\\) a Pauli matrix.  The dynamics of the system is governed by \\begin{align} \\partial_t\\rho=-i[H_0, \\rho], \\end{align}</p> <p>where \\(\\rho\\) is the parameterized density matrix. The probe state is taken as \\(|+\\rangle\\langle+|\\)  with \\(|+\\rangle=\\frac{1}{\\sqrt{2}}(|0\\rangle+|1\\rangle)\\). Here \\(|0\\rangle\\) \\((|1\\rangle)\\) is the  eigenstate of \\(\\sigma_3\\) with respect to the eigenvalue \\(1\\) \\((-1)\\).</p> PythonJulia <pre><code>from quanestimation import *\nimport numpy as np\n\n# initial state\nrho0 = 0.5*np.array([[1., 1.], [1., 1.]])\n# free Hamiltonian\nomega = 1.0\nsz = np.array([[1., 0.], [0., -1.]])\nH0 = 0.5*omega*sz\n# derivative of the free Hamiltonian on omega\ndH = [0.5*sz]\n# time length for the evolution\ntspan = np.linspace(0., 50., 2000)\n# dynamics\ndynamics = Lindblad(tspan, rho0, H0, dH)\nrho, drho = dynamics.expm()\n# the value of the objective function\nf = 20.0\nt = TargetTime(f, tspan, QFIM, rho, drho)\n</code></pre> <pre><code>using QuanEstimation\n\n# initial state\nrho0 = 0.5*ones(2, 2)\n# free Hamiltonian\nomega = 1.0\nsx = [0. 1.; 1. 0.0im]\nsy = [0. -im; im 0.]\nsz = [1. 0.0im; 0. -1.]\nH0 = 0.5*omega*sz\n# derivative of the free Hamiltonian on omega\ndH = [0.5*sz]\n# time length for the evolution\ntspan = range(0., 50., length=2000)\n# dynamics\nrho, drho = QuanEstimation.expm(tspan, rho0, H0, dH)\ndrho = [drho[i][1] for i in 1:2000]\n# the value of the objective function\nf = 20\nt = QuanEstimation.TargetTime(f, tspan, QuanEstimation.QFIM, rho, drho)\n</code></pre>"},{"location":"guide/guide_resources/#bibliography","title":"Bibliography","text":"<p>[1]  M. Kitagawa and M. Ueda, Squeezed spin states,  Phys. Rev. A 47, 5138 (1993).</p> <p>[2] D. J. Wineland, J. J. Bollinger, W. M. Itano, F. L. Moore, and D. J. Heinzen,  Spin squeezing and reduced quantum noise in spectroscopy,  Phys. Rev. A 46, R6797(R) (1992).</p> <p>[3] J. R. Johansson, P. D. Nation, and F. Nori, QuTiP: An open-source Python framework for the dynamics of open quantum systems, Comp. Phys. Comm. 183, 1760 (2012).</p> <p>[4] J. R. Johansson, P. D. Nation, and F. Nori, QuTiP 2: A Python framework for the dynamics of open quantum systems, Comp. Phys. Comm. 184, 1234 (2013).</p>"},{"location":"guide/output_files/","title":"Output files","text":"<p>In QuanEstimation, the output data will be saved into files during or after the optimization process. There are currently two types of them: the values of the objective function and the values of variables from corresponding scheme (optimizations for controls, states, or measurements).  </p> <p>For the objective fucntion, the optimized variables at each optimization step will be used to evaluate the objective function, and then the obtained values will be saved sequentially, each line a value, into a CSV file named <code>f.csv</code>. However, for the optimized variables, depending on the choice of algorithm and optimization scenario, the storage format of output data varies accordingly. This guide is intended to help users to understand how the optimized data is saved and how to extract and manipulate them for further research. </p>"},{"location":"guide/output_files/#control-optimization","title":"Control optimization","text":"<p>The control optimization results will be saved into a <code>.npy</code> file named <code>controls.npy</code>. If the argument <code>savefile</code> is set to <code>False</code>, the control coefficients after the final round of optimization will be saved, with the first dimension corresponding to the number of control, and the second dimension corresponding to the number of time intervals. Otherwise, all the control coefficients after each round of optimization will be saved. The saved control optimization results can be load with  <pre><code># load the controls\ncontrols = np.load(\"controls.npy\")\n</code></pre></p>"},{"location":"guide/output_files/#state-optimization","title":"State optimization","text":"<p>The state optimization results will be saved into a <code>.npy</code> file named <code>states.npy</code>. If the argument <code>savefile</code> is set to <code>False</code>, the final optimized state vectors will be saved. Otherwise, all the state vectors after each round of optimization will be saved. The saved state optimization results can be load with  <pre><code># load the states\nstates = np.load(\"states.npy\")\n</code></pre></p>"},{"location":"guide/output_files/#measurement-optimization","title":"Measurement optimization","text":"<p>The measurement optimization results will be saved into a <code>.npy</code> file named <code>measurements.npy</code>. If the argument <code>savefile</code> is set to <code>False</code>, the final optimized POVMs will be saved. Otherwise, all the lists of POVMs after each round of optimization will be saved. The saved measurement optimization results can be load with  <pre><code># load the measurements\nM = np.load(\"measurements.npy\")\n</code></pre></p>"}]}